input {

@ADDITIONAL_INPUTS@
  
  file {
    path => "/francelabs/localhost_access_log_datafari.txt"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "access"
    codec => multiline {
      patterns_dir => "./patterns"
      pattern => "%{LOCALHOST_ACCESS_START}"
      negate => "true"
      what => "previous"
    }
  }

  file {
    path => "/francelabs/datafari-monitoring.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "exploit"
    codec => multiline {
      patterns_dir => "./patterns"
      pattern => "%{STAT_LINE_START}"
      negate => "true"
      what => "previous"
      }
  }
  
  file {
    path => "/opt/datafari/logs/datafari-stats.log*"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    type => "queriesstats"
    codec => multiline {
      patterns_dir => "./patterns"
      pattern => "%{STAT_LINE_START}"
      negate => "true"
      what => "previous"
      }
  }

  
}

filter {

  if [type] == "exploit" {

    grok {
      patterns_dir => "./patterns"
      match => { "message" => "%{LOG4J_TIMESTAMP:logDate} %{WORD:level}" }
    }
  
    if [level] == "MONITORING" {
      grok {
        patterns_dir => "./patterns"
        match => { "message" => ".* - %{CUSTOM_DATA:id}\|%{CUSTOM_DATA:timestamp}\|%{INT:numDocs}\|%{CUSTOM_DATA:facet}\|%{GREEDYDATA:facetType}" }
      }
  
      mutate {
        add_tag => ["monitoring"]
      }
  
    }
  
    # Remove unused fields
    mutate {
      remove_field => [ "logDate", "level" ]
    }
  
  }
  
  if [type] == "access" {
    
    if "/Datafari/rest/v2.0/search/select?" not in [message] {
        drop {}
    }
  
    grok {
      patterns_dir => "./patterns"
      match => { "message" => "%{IP:client_ip} %{LOG4J_TIMESTAMP:date} \"%{GREEDYDATA:access_request}\" %{INT:access_request_code} %{INT:access_request_time}" }
    }
    
    # Add index_date field
    mutate {
      add_field => ["index_date", "%{year}.%{month}.%{day}"]
    }
    
  }
  
  # === Stats Queries / clicks ===
  if [type] == "queriesstats" {

    # 1) Queries
    grok {
      match => {
        "message" => [
          '^%{TIMESTAMP_ISO8601:date}\s+%{WORD:level}\s+%{DATA:class}\s-\s(?<id>[^|]+)\|\|(?<q>[^|]*)\|(?<noHits>[^|]*)\|(?<numFound>\d+)\|\|(?<QTime>\d+)\|*(?<username>[^|]*)$',
          '^%{TIMESTAMP_ISO8601:date}\s+%{WORD:level}\s+%{DATA:class}\s-\s(?<id>[^|]+)\|\|(?<q>[^|]*)\|(?<noHits>[^|]*)\|(?<numFound>\d+)\|\|(?<QTime>\d+)\|*$'
        ]
      }
      tag_on_failure => ["_grokparsefailure_queries"]
    }

    if "_grokparsefailure_queries" not in [tags] {
      mutate {
        convert   => { "numFound" => "integer" "QTime" => "integer" }
        add_tag   => ["grok_queries_ok"]
        add_field => { "[@metadata][doc_type]" => "query" }
      }
      ruby {
        code => '
          doc = {
            "id"       => event.get("id"),
            "q"        => event.get("q"),
            "numFound" => event.get("numFound"),
            "QTime"    => event.get("QTime"),
            "noHits"   => event.get("noHits"),
            "click"    => "No Click",
            "date"     => event.get("date"),
            "username" => event.get("username")
          }
          event.set("[@metadata][solr_doc_query]", LogStash::Json.dump({ "add" => { "doc" => doc } }))
        '
      }
    }

    # 2) Clicks
    if "_grokparsefailure_queries" in [tags] {
      grok {
        match => {
          "message" => [
            '^%{TIMESTAMP_ISO8601:date}\s+%{WORD:level}\s+%{DATA:class}\s-\s(?<id>[^|]+)\|\|\|\|\|{\s*(?<numClicks>[^}]*)\s*}\|\|(?<position>\d+)\|(?<click>\w+)\|\|(?<url>[^|]+)\|(?<username>[^|]*)$',
            '^%{TIMESTAMP_ISO8601:date}\s+%{WORD:level}\s+%{DATA:class}\s-\s(?<id>[^|]+)\|\|\|\|\|{\s*(?<numClicks>[^}]*)\s*}\|\|(?<position>\d+)\|(?<click>\w+)\|\|(?<url>[^|]+)\|$'
          ]
        }
        tag_on_failure => ["_grokparsefailure_clicks"]
      }

      if "_grokparsefailure_clicks" not in [tags] {
        mutate {
          replace   => { "numClicks" => "1" }
          convert   => { "numClicks" => "integer" "position" => "integer" }
          add_tag   => ["grok_clicks_ok"]
          remove_tag => ["_grokparsefailure_queries"]
          add_field => { "[@metadata][doc_type]" => "click" }
        }
        ruby {
          code => '
            m = {
              "add" => {
                "doc" => {
                  "id"        => event.get("id"),
                  "numClicks" => { "inc" => 1 },
                  "click"     => { "set" => "Clicked" }
                }
              }
            }
            event.set("[@metadata][solr_doc_click]", LogStash::Json.dump(m))
          '
        }
      } else {
        drop { }
      }
    }

    mutate { remove_field => ["host","path","@version","class","level"] }
  }
  
  
  
@ADDITIONAL_FILTERS@
  
  #generate a finderprint of the message that can provide a unique id for the document if needed
  fingerprint {
    source => ["message"]
    target => "fingerprint"
  }
  
  # Remove unused fields
  mutate {
    remove_field => [ "day", "month", "year", "@timestamp", "message", "@version", "event", "log" ]
  }
  
  # ignore parse failure
  if "_grokparsefailure" in [tags] {
      drop { }
  }
}


output {

  if [type] == "exploit" {
    
    if "monitoring" in [tags] {
      solr_http {
        solr_url => "http://@SOLR_HOST@:8983/solr/Monitoring"
        document_id => "%{id}"    
        idle_flush_time => 100
        flush_size => 10 
      }
    }
  }
  
  if [type] == "access" {
    solr_http {
      solr_url => "http://@SOLR_HOST@:8983/solr/Access"
      document_id => "%{fingerprint}"
      idle_flush_time => 100
      flush_size => 10
    }
  }
  
  # ---- Stats: HTTP output for atomic update
  if [@metadata][doc_type] == "query" {
    http {
      url => "http://@SOLR_HOST@:8983/solr/Statistics/update"
      http_method  => "post"
      content_type => "application/json"
      format       => "message"
      message      => "%{[@metadata][solr_doc_query]}"
    }
  }

  if [@metadata][doc_type] == "click" {
    http {
      url => "http://@SOLR_HOST@:8983/solr/Statistics/update"
      http_method  => "post"
      content_type => "application/json"
      format       => "message"
      message      => "%{[@metadata][solr_doc_click]}"
    }
  }
  
  
  

@ADDITIONAL_OUTPUTS@
}
