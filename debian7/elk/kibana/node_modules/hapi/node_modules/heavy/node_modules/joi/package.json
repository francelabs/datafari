{
  "name": "joi",
  "description": "Object schema validation",
  "version": "5.1.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/hapijs/joi.git"
  },
  "main": "index",
  "keywords": [
    "schema",
    "validation"
  ],
  "engines": {
    "node": ">=0.10.30"
  },
  "dependencies": {
    "hoek": "^2.2.x",
    "topo": "1.x.x",
    "isemail": "1.x.x",
    "moment": "2.x.x"
  },
  "devDependencies": {
    "code": "1.x.x",
    "lab": "5.x.x"
  },
  "scripts": {
    "test": "lab -t 100 -a code",
    "test-cov-html": "lab -r html -o coverage.html -a code"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/hapijs/joi/raw/master/LICENSE"
    }
  ],
  "readme": "![joi Logo](https://raw.github.com/hapijs/joi/master/images/joi.png)\n\nObject schema description language and validator for JavaScript objects.\n\n[![npm version](https://badge.fury.io/js/joi.svg)](http://badge.fury.io/js/joi)\n[![Build Status](https://secure.travis-ci.org/hapijs/joi.svg)](http://travis-ci.org/hapijs/joi)\n[![Dependencies Status](https://david-dm.org/hapijs/joi.svg)](https://david-dm.org/hapijs/joi)\n[![DevDependencies Status](https://david-dm.org/hapijs/joi/dev-status.svg)](https://david-dm.org/hapijs/joi#info=devDependencies)\n\nLead Maintainer: [Nicolas Morel](https://github.com/marsup)\n\n## Table of Contents\n\n<img src=\"https://raw.github.com/hapijs/joi/master/images/validation.png\" align=\"right\" />\n- [Example](#example)\n- [Usage](#usage)\n    - [`validate(value, schema, [options], [callback])`](#validatevalue-schema-options-callback)\n    - [`compile(schema)`](#compileschema)\n    - [`assert(value, schema, [message])`](#assertvalue-schema-message)\n    - [`any`](#any)\n        - [`any.allow(value)`](#anyallowvalue)\n        - [`any.valid(value)`](#anyvalidvalue)\n        - [`any.invalid(value)`](#anyinvalidvalue)\n        - [`any.required()`](#anyrequired)\n        - [`any.optional()`](#anyoptional)\n        - [`any.forbidden()`](#anyforbidden)\n        - [`any.description(desc)`](#anydescriptiondesc)\n        - [`any.notes(notes)`](#anynotesnotes)\n        - [`any.tags(tags)`](#anytagstags)\n        - [`any.meta(meta)`](#anymetameta)\n        - [`any.example(value)`](#anyexamplevalue)\n        - [`any.unit(name)`](#anyunitname)\n        - [`any.options(options)`](#anyoptionsoptions)\n        - [`any.strict()`](#anystrict)\n        - [`any.default(value)`](#anydefaultvalue)\n        - [`any.concat(schema)`](#anyconcatschema)\n        - [`any.when(ref, options)`](#anywhenref-options)\n        - [`any.label(name)`](#anylabelname)\n        - [`any.raw(isRaw)`](#anyrawisraw)\n    - [`array`](#array)\n        - [`array.sparse(enabled)`](#arraysparseenabled)\n        - [`array.includes(type)`](#arrayincludestype)\n        - [`array.excludes(type)`](#arrayexcludestype)\n        - [`array.min(limit)`](#arrayminlimit)\n        - [`array.max(limit)`](#arraymaxlimit)\n        - [`array.length(limit)`](#arraylengthlimit)\n        - [`array.unique()`](#arrayunique)\n    - [`binary`](#binary)\n      - [`binary.encoding(encoding)`](#binaryencodingencoding)\n      - [`binary.min(limit)`](#binaryminlimit)\n      - [`binary.max(limit)`](#binarymaxlimit)\n      - [`binary.length(limit)`](#binarylengthlimit)\n    - [`boolean()`](#boolean)\n    - [`date`](#date)\n        - [`date.min(date)`](#datemindate)\n        - [`date.max(date)`](#datemaxdate)\n        - [`date.format(format)`](#dateformatformat)\n        - [`date.iso()`](#dateiso)\n    - [`func`](#func)\n    - [`number`](#number)\n        - [`number.min(limit)`](#numberminlimit)\n        - [`number.max(limit)`](#numbermaxlimit)\n        - [`number.greater(limit)`](#numbergreaterlimit)\n        - [`number.less(limit)`](#numberlesslimit)\n        - [`number.integer()`](#numberinteger)\n        - [`number.precision(limit)`](#numberprecisionlimit)\n    - [`object`](#object)\n        - [`object.keys([schema])`](#objectkeysschema)\n        - [`object.min(limit)`](#objectminlimit)\n        - [`object.max(limit)`](#objectmaxlimit)\n        - [`object.length(limit)`](#objectlengthlimit)\n        - [`object.pattern(regex, schema)`](#objectpatternregex-schema)\n        - [`object.and(peers)`](#objectandpeers)\n        - [`object.nand(peers)`](#objectnandpeers)\n        - [`object.or(peers)`](#objectorpeers)\n        - [`object.xor(peers)`](#objectxorpeers)\n        - [`object.with(key, peers)`](#objectwithkey-peers)\n        - [`object.without(key, peers)`](#objectwithoutkey-peers)\n        - [`object.rename(from, to, [options])`](#objectrenamefrom-to-options)\n        - [`object.assert(ref, schema, [message])`](#objectassertref-schema-message)\n        - [`object.unknown([allow])`](#objectunknownallow)\n        - [`object.type(constructor, [name])`](#objecttypeconstructorname)\n        - [`object.requiredKeys(children)`](#objectrequiredkeyschildren)\n        - [`object.optionalKeys(children)`](#objectoptionalkeyschildren)\n    - [`string`](#string)\n        - [`string.insensitive()`](#stringinsensitive)\n        - [`string.min(limit, [encoding])`](#stringminlimit-encoding)\n        - [`string.max(limit, [encoding])`](#stringmaxlimit-encoding)\n        - [`string.creditCard()`](#stringcreditCard)\n        - [`string.length(limit, [encoding])`](#stringlengthlimit-encoding)\n        - [`string.regex(pattern, [name])`](#stringregexpattern-name)\n        - [`string.alphanum()`](#stringalphanum)\n        - [`string.token()`](#stringtoken)\n        - [`string.email()`](#stringemail)\n        - [`string.guid()`](#stringguid)\n        - [`string.hostname()`](#stringhostname)\n        - [`string.lowercase()`](#stringlowercase)\n        - [`string.uppercase()`](#stringuppercase)\n        - [`string.trim()`](#stringtrim)\n    - [`alternatives`](#alternatives)\n        - [`alternatives.try(schemas)`](#alternativestryschemas)\n        - [`alternatives.when(ref, options)`](#alternativeswhenref-options)\n    - [`ref(key, [options])`](#refkey-options)\n\n# Example\n\n```javascript\nvar Joi = require('joi');\n\nvar schema = Joi.object().keys({\n    username: Joi.string().alphanum().min(3).max(30).required(),\n    password: Joi.string().regex(/[a-zA-Z0-9]{3,30}/),\n    access_token: [Joi.string(), Joi.number()],\n    birthyear: Joi.number().integer().min(1900).max(2013),\n    email: Joi.string().email()\n}).with('username', 'birthyear').without('password', 'access_token');\n\nJoi.validate({ username: 'abc', birthyear: 1994 }, schema, function (err, value) { });  // err === null -> valid\n```\n\nThe above schema defines the following constraints:\n* `username`\n    * a required string\n    * must contain only alphanumeric characters\n    * at least 3 characters long but no more than 30\n    * must be accompanied by `birthyear`\n* `password`\n    * an optional string\n    * must satisfy the custom regex\n    * cannot appear together with `access_token`\n* `access_token`\n    * an optional, unconstrained string or number\n* `birthyear`\n    * an integer between 1900 and 2013\n* `email`\n    * a valid email address string\n\n# Usage\n\nUsage is a two steps process. First, a schema is constructed using the provided types and constraints:\n\n```javascript\nvar schema = {\n    a: Joi.string()\n};\n```\n\nNote that **joi** schema objects are immutable which means every additional rule added (e.g. `.min(5)`) will return a\nnew schema object.\n\nThen the value is validated against the schema:\n\n```javascript\nJoi.validate({ a: 'a string' }, schema, function (err, value) { });\n```\n\nIf the value is valid, `null` is returned, otherwise an `Error` object.\n\nThe schema can be a plain JavaScript object where every key is assigned a **joi** type, or it can be a **joi** type directly:\n\n```javascript\nvar schema = Joi.string().min(10);\n```\n\nIf the schema is a **joi** type, the `schema.validate(value, callback)` can be called directly on the type. When passing a non-type schema object,\nthe module converts it internally to an object() type equivalent to:\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.string()\n});\n```\n\nWhen validating a schema:\n* Keys are optional by default.\n* Strings are utf-8 encoded by default.\n* Rules are defined in an additive fashion and evaluated in order after whitelist and blacklist checks.\n\n### `validate(value, schema, [options], [callback])`\n\nValidates a value using the given schema and options where:\n- `value` - the value being validated.\n- `schema` - the validation schema. Can be a **joi** type object or a plain object where every key is assigned a **joi** type object.\n- `options` - an optional object with the following optional keys:\n  - `abortEarly` - when `true`, stops validation on the first error, otherwise returns all the errors found. Defaults to `true`.\n  - `convert` - when `true`, attempts to cast values to the required types (e.g. a string to a number). Defaults to `true`.\n  - `allowUnknown` - when `true`, allows object to contain unknown keys which are ignored. Defaults to `false`.\n  - `skipFunctions` - when `true`, ignores unknown keys with a function value. Defaults to `false`.\n  - `stripUnknown` - when `true`, unknown keys are deleted (only when value is an object). Defaults to `false`.\n  - `language` - overrides individual error messages, when `'label'` is set, it overrides the key name in the error message. Defaults to no override (`{}`).\n  - `presence` - sets the default presence requirements. Supported modes: `'optional'`, `'required'`, and `'forbidden'`.\n    Defaults to `'optional'`.\n  - `context` - provides an external data set to be used in [references](#refkey-options). Can only be set as an external option to\n    `validate()` and not using `any.options()`.\n- `callback` - the optional synchronous callback method using the signature `function(err, value)` where:\n  - `err` - if validation failed, the error reason, otherwise `null`.\n  - `value` - the validated value with any type conversions and other modifiers applied (the input is left unchanged). `value` can be\n    incomplete if validation failed and `abortEarly` is `true`. If callback is not provided, then returns an object with error\n    and value properties.\n\n```javascript\nvar schema = {\n    a: Joi.number()\n};\n\nvar value = {\n    a: '123'\n};\n\nJoi.validate(value, schema, function (err, value) { });\n// err -> null\n// value.a -> 123 (number, not string)\n\n// or\nvar result = Joi.validate(value, schema);\n// result.error -> null\n// result.value -> { \"a\" : 123 }\n```\n\n### `compile(schema)`\n\nConverts literal schema definition to **joi** schema object (or returns the same back if already a **joi** schema object) where:\n- `schema` - the schema definition to compile.\n\n```javascript\nvar definition = ['key', 5, { a: true, b: [/^a/, 'boom'] }];\nvar schema = Joi.compile(definition);\n\n// Same as:\n\nvar schema = Joi.alternatives().try([\n    Joi.string().valid('key'),\n    Joi.number().valid(5),\n    Joi.object().keys({\n        a: Joi.boolean().valid(true),\n        b: Joi.alternatives().try([\n            Joi.string().regex(/^a/),\n            Joi.string().valid('boom')\n        ])\n    })\n]);\n```\n\n### `assert(value, schema, [message])`\n\nValidates a value against a schema and throws if validation fails where:\n- `value` - the value to validate.\n- `schema` - the schema object.\n- `message` - optional message sting prefix added in front of the error message.\n\n```javascript\nJoi.assert('x', Joi.number());\n```\n\n### `any`\n\nGenerates a schema object that matches any data type.\n\n```javascript\nvar any = Joi.any();\nany.validate('a', function (err, value) { });\n```\n\n#### `any.allow(value)`\n\nWhitelists a value where:\n- `value` - the allowed value which can be of any type and will be matched against the validated value before applying any other rules.\n  `value` can be an array of values, or multiple values can be passed as individual arguments. `value` supports [references](#refkey-options).\n\n```javascript\nvar schema = {\n    a: Joi.any().allow('a'),\n    b: Joi.any().allow('b', 'B'),\n    c: Joi.any().allow(['c', 'C'])\n};\n```\n\n#### `any.valid(value)`\n\nAdds the provided values into the allowed whitelist and marks them as the only valid values allowed where:\n- `value` - the allowed value which can be of any type and will be matched against the validated value before applying any other rules.\n  `value` can be an array of values, or multiple values can be passed as individual arguments. `value` supports [references](#refkey-options).\n\n```javascript\nvar schema = {\n    a: Joi.any().valid('a'),\n    b: Joi.any().valid('b', 'B'),\n    c: Joi.any().valid(['c', 'C'])\n};\n```\n\n#### `any.invalid(value)`\n\nBlacklists a value where:\n- `value` - the forbidden value which can be of any type and will be matched against the validated value before applying any other rules.\n  `value` can be an array of values, or multiple values can be passed as individual arguments. `value` supports [references](#refkey-options).\n\n```javascript\nvar schema = {\n    a: Joi.any().invalid('a'),\n    b: Joi.any().invalid('b', 'B'),\n    c: Joi.any().invalid(['c', 'C'])\n};\n```\n\n#### `any.required()`\n\nMarks a key as required which will not allow `undefined` as value. All keys are optional by default.\n\n```javascript\nvar schema = Joi.any().required();\n```\n\n#### `any.optional()`\n\nMarks a key as optional which will allow `undefined` as values. Used to annotate the schema for readability as all keys are optional by default.\n\n```javascript\nvar schema = Joi.any().optional();\n```\n\n#### `any.forbidden()`\n\nMarks a key as forbidden which will not allow any value except `undefined`. Used to explicitly forbid keys.\n\n```javascript\nvar schema = {\n    a: Joi.any().forbidden()\n};\n```\n\n#### `any.description(desc)`\n\nAnnotates the key where:\n- `desc` - the description string.\n\n```javascript\nvar schema = Joi.any().description('this key will match anything you give it');\n```\n\n#### `any.notes(notes)`\n\nAnnotates the key where:\n- `notes` - the notes string or array of strings.\n\n```javascript\nvar schema = Joi.any().notes(['this is special', 'this is important']);\n```\n\n#### `any.tags(tags)`\n\nAnnotates the key where:\n- `tags` - the tag string or array of strings.\n\n```javascript\nvar schema = Joi.any().tags(['api', 'user']);\n```\n\n#### `any.meta(meta)`\n\nAttaches metadata to the key where:\n- `meta` - the meta object to attach.\n\n```javascript\nvar schema = Joi.any().meta({ index: true });\n```\n\n#### `any.example(value)`\n\nAnnotates the key where:\n- `value` - an example value.\n\nIf the example fails to pass validation, the function will throw.\n\n```javascript\nvar schema = Joi.string().min(4).example('abcd');\n```\n\n#### `any.unit(name)`\n\nAnnotates the key where:\n- `name` - the unit name of the value.\n\n```javascript\nvar schema = Joi.number().unit('milliseconds');\n```\n\n#### `any.options(options)`\n\nOverrides the global `validate()` options for the current key and any sub-key where:\n- `options` - an object with the same optional keys as [`Joi.validate(value, schema, options, callback)`](#joivalidatevalue-schema-options-callback).\n\n```javascript\nvar schema = Joi.any().options({ convert: false });\n```\n\n#### `any.strict()`\n\nSets the `options.convert` options to `false` which prevent type casting for the current key and any child keys.\n\n```javascript\nvar schema = Joi.any().strict();\n```\n\n#### `any.default(value)`\n\nSets a default value if the original value is undefined where:\n- `value` - the value. `value` supports [references](#refkey-options).\n\nNote that if `value` is an object, any changes to the object after `default()` is called will change the reference\nand any future assignment.\n\n```javascript\nvar schema = {\n    username: Joi.string().default('new_user')\n};\nJoi.validate({}, schema, function (err, value) { });\n// value === { username: \"new_user\" }\n```\n\n#### `any.concat(schema)`\n\nReturns a new type that is the result of adding the rules of one type to another where:\n- `schema` - a **joi** type to merge into the current schema. Can only be of the same type as the context type or `any`.\n\n```javascript\nvar a = Joi.string().valid('a');\nvar b = Joi.string().valid('b');\nvar ab = a.concat(b);\n```\n\n#### `any.when(ref, options)`\n\nConverts the type into an [`alternatives`](#alternatives) type where the conditions are merged into the type definition where:\n- `ref` - the key name or [reference](#refkey-options).\n- `options` - an object with:\n    - `is` - the required condition **joi** type.\n    - `then` - the alternative schema type if the condition is true. Required if `otherwise` is missing.\n    - `otherwise` - the alternative schema type if the condition is false. Required if `then` is missing.\n\n```javascript\nvar schema = {\n    a: Joi.any().valid('x').when('b', { is: 5, then: Joi.valid('y'), otherwise: Joi.valid('z') }),\n    b: Joi.any()\n};\n```\n\nAlternatively, if you want to specify a specific type such as `string`, `array`, etc, you can do so like this:\n\n```javascript\nvar schema = {\n    a: Joi.valid('a', 'b', 'other'),\n    other: Joi.string()\n        .when('a', { is: 'other', then: Joi.required() }),\n};\n```\n\n#### `any.label(name)`\n\nOverrides the key name in error messages.\n- `name` - the name of the key.\n\n```javascript\nvar schema = {\n    first_name: Joi.string().label('First Name')\n};\n```\n\n#### `any.raw(isRaw)`\n\nOutputs the original untouched value instead of the casted value.\n- `isRaw` - whether to enable raw mode or not. Defaults to true.\n\n```javascript\nvar schema = {\n    timestamp: Joi.date().format('YYYYMMDD').raw()\n};\n```\n\n### `array`\n\nGenerates a schema object that matches an array data type. Note that undefined values inside arrays are not allowed by default but can be by using `sparse()`.\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar array = Joi.array().includes(Joi.string().valid('a', 'b'));\narray.validate(['a', 'b', 'a'], function (err, value) { });\n```\n\n#### `array.sparse(enabled)`\n\nAllow this array to be sparse. `enabled` can be used with a falsy value to go back to the default behavior.\n\n```javascript\nvar schema = Joi.array().sparse(); // undefined values are now allowed\nschema = schema.sparse(false); // undefined values are now denied\n```\n\n#### `array.single(enabled)`\n\nAllow single values to be checked against rules as if it were provided as an array.\n\n`enabled` can be used with a falsy value to go back to the default behavior.\n\n```javascript\nvar schema = Joi.array().includes(Joi.number()).single();\nschema.validate([4]); // returns `{ error: null, value: [ 4 ] }`\nschema.validate(4); // returns `{ error: null, value: [ 4 ] }`\n```\n\n#### `array.includes(type)`\n\nList the types allowed for the array values where:\n- `type` - a **joi** schema object to validate each array item against. `type` can be an array of values, or multiple values can be passed as individual arguments.\n\n```javascript\nvar schema = Joi.array().includes(Joi.string(), Joi.number());\n```\n\n#### `array.excludes(type)`\n\nList the types forbidden for the array values where:\n- `type` - a **joi** schema object to validate each array item against. `type` can be an array of values, or multiple values can be passed as individual arguments.\n\n```javascript\nvar schema = Joi.array().excludes(Joi.object());\n```\n\n#### `array.min(limit)`\n\nSpecifies the minimum number of items in the array where:\n- `limit` - the lowest number of array items allowed.\n\n```javascript\nvar schema = Joi.array().min(2);\n```\n\n#### `array.max(limit)`\n\nSpecifies the maximum number of items in the array where:\n- `limit` - the highest number of array items allowed.\n\n```javascript\nvar schema = Joi.array().max(10);\n```\n\n#### `array.length(limit)`\n\nSpecifies the exact number of items in the array where:\n- `limit` - the number of array items allowed.\n\n```javascript\nvar schema = Joi.array().length(5);\n```\n\n#### `array.unique()`\n\nRequires the array values to be unique.\n\nBe aware that a deep equality is performed on elements of the array having a type of `object`, a performance penalty is to be expected for this kind of operation.\n\n```javascript\nvar schema = Joi.array().unique();\n```\n\n### `boolean`\n\nGenerates a schema object that matches a boolean data type (as well as the strings 'true', 'false', 'yes', and 'no'). Can also be called via `bool()`.\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar boolean = Joi.boolean();\nboolean.validate(true, function (err, value) { });\n```\n\n### `binary`\n\nGenerates a schema object that matches a Buffer data type (as well as the strings which will be converted to Buffers).\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar schema = Joi.binary();\n```\n\n#### `binary.encoding(encoding)`\n\nSets the string encoding format if a string input is converted to a buffer where:\n- `encoding` - the encoding scheme.\n\n```javascript\nvar schema = Joi.binary().encoding('base64');\n```\n\n#### `binary.min(limit)`\n\nSpecifies the minimum length of the buffer where:\n- `limit` - the lowest size of the buffer.\n\n```javascript\nvar schema = Joi.binary().min(2);\n```\n\n#### `binary.max(limit)`\n\nSpecifies the maximum length of the buffer where:\n- `limit` - the highest size of the buffer.\n\n```javascript\nvar schema = Joi.binary().max(10);\n```\n\n#### `binary.length(limit)`\n\nSpecifies the exact length of the buffer:\n- `limit` - the size of buffer allowed.\n\n```javascript\nvar schema = Joi.binary().length(5);\n```\n\n### `date`\n\nGenerates a schema object that matches a date type (as well as a JavaScript date string or number of milliseconds).\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar date = Joi.date();\ndate.validate('12-21-2012', function (err, value) { });\n```\n\n#### `date.min(date)`\n\nSpecifies the oldest date allowed where:\n- `date` - the oldest date allowed.\n\n```javascript\nvar schema = Joi.date().min('1-1-1974');\n```\n\nNotes: `'now'` can be passed in lieu of `date` so as to always compare relatively to the current date, allowing to explicitly ensure a date is either in the past or in the future.\n\n```javascript\nvar schema = Joi.date().min('now');\n```\n\nIt can also be a reference to another field.\n\n```javascript\nvar schema = Joi.object({\n  from: Joi.date().required(),\n  to: Joi.date().min(Joi.ref('from')).required()\n});\n```\n\n#### `date.max(date)`\n\nSpecifies the latest date allowed where:\n- `date` - the latest date allowed.\n\n```javascript\nvar schema = Joi.date().max('12-31-2020');\n```\n\nNotes: `'now'` can be passed in lieu of `date` so as to always compare relatively to the current date, allowing to explicitly ensure a date is either in the past or in the future.\n\n```javascript\nvar schema = Joi.date().max('now');\n```\n\nIt can also be a reference to another field.\n\n```javascript\nvar schema = Joi.object({\n  from: Joi.date().max(Joi.ref('to')).required(),\n  to: Joi.date().required()\n});\n```\n\n#### `date.format(format)`\n\nSpecifies the allowed date format:\n- `format` - string or array of strings that follow the `moment.js` [format](http://momentjs.com/docs/#/parsing/string-format/).\n\n```javascript\nvar schema = Joi.date().format('YYYY/MM/DD');\n```\n\n#### `date.iso()`\n\nRequires the string value to be in valid ISO 8601 date format.\n\n```javascript\nvar schema = Joi.date().iso();\n```\n\n### `func`\n\nGenerates a schema object that matches a function type.\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar func = Joi.func();\nfunc.validate(function () {}, function (err, value) { });\n```\n\n### `number`\n\nGenerates a schema object that matches a number data type (as well as strings that can be converted to numbers).\n\n`Infinity` and `-Infinity` are invalid by default, you can change that behavior by calling `allow(Infinity, -Infinity)`.\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar number = Joi.number();\nnumber.validate(5, function (err, value) { });\n```\n\n#### `number.min(limit)`\n\nSpecifies the minimum value where:\n- `limit` - the minimum value allowed.\n\n```javascript\nvar schema = Joi.number().min(2);\n```\n\n#### `number.max(limit)`\n\nSpecifies the maximum value where:\n- `limit` - the maximum value allowed.\n\n```javascript\nvar schema = Joi.number().max(10);\n```\n\n#### `number.greater(limit)`\n\nSpecifies that the value must be greater than `limit`.\n\n```javascript\nvar schema = Joi.number().greater(5);\n```\n\n#### `number.less(limit)`\n\nSpecifies that the value must be less than `limit`.\n\n```javascript\nvar schema = Joi.number().less(10);\n```\n\n#### `number.integer()`\n\nRequires the number to be an integer (no floating point).\n\n```javascript\nvar schema = Joi.number().integer();\n```\n\n#### `number.precision(limit)`\n\nSpecifies the maximum number of decimal places where:\n- `limit` - the maximum number of decimal places allowed.\n\n```javascript\nvar schema = Joi.number().precision(2);\n```\n\n### `object`\n\nGenerates a schema object that matches an object data type (as well as JSON strings that parsed into objects). Defaults\nto allowing any child key.\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar object = Joi.object().keys({\n    a: Joi.number().min(1).max(10).integer(),\n    b: 'some string'\n});\n\nobject.validate({ a: 5 }, function (err, value) { });\n```\n\n#### `object.keys([schema])`\n\nSets or extends the allowed object keys where:\n- `schema` - optional object where each key is assigned a **joi** type object. If `schema` is `{}` no keys allowed.\n  If `schema` is `null` or `undefined`, any key allowed. If `schema` is an object with keys, the keys are added to any\n  previously defined keys (but narrows the selection if all keys previously allowed). Defaults to 'undefined' which\n  allows any child key.\n\n```javascript\nvar base = Joi.object().keys({\n    a: Joi.number(),\n    b: Joi.string()\n});\n// Validate keys a, b and c.\nvar extended = base.keys({\n    c: Joi.boolean()\n});\n```\n\n#### `object.min(limit)`\n\nSpecifies the minimum number of keys in the object where:\n- `limit` - the lowest number of keys allowed.\n\n```javascript\nvar schema = Joi.object().min(2);\n```\n\n#### `object.max(limit)`\n\nSpecifies the maximum number of keys in the object where:\n- `limit` - the highest number of object keys allowed.\n\n```javascript\nvar schema = Joi.object().max(10);\n```\n\n#### `object.length(limit)`\n\nSpecifies the exact number of keys in the object where:\n- `limit` - the number of object keys allowed.\n\n```javascript\nvar schema = Joi.object().length(5);\n```\n\n#### `object.pattern(regex, schema)`\n\nSpecify validation rules for unknown keys matching a pattern where:\n- `regex` - a regular expression tested against the unknown key names.\n- `schema` - the schema object matching keys much validate against.\n\n```javascrip\nvar schema = Joi.object({\n    a: Joi.string()\n}).pattern(/\\w\\d/, Joi.boolean());\n```\n\n#### `object.and(peers)`\n\nDefines an all-or-nothing relationship between keys where if one of the peers is present, all of them are required as\nwell where:\n- `peers` - the key names of which if one present, all are required. `peers` can be a single string value, an\n  array of string values, or each peer provided as an argument.\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.any(),\n    b: Joi.any()\n}).and('a', 'b');\n```\n\n#### `object.nand(peers)`\n\nDefines a relationship between keys where not all peers can be present at the\nsame time where:\n- `peers` - the key names of which if one present, the others may not all be present. `peers` can be a single string value, an\n  array of string values, or each peer provided as an argument.\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.any(),\n    b: Joi.any()\n}).nand('a', 'b');\n```\n\n#### `object.or(peers)`\n\nDefines a relationship between keys where one of the peers is required (and more than one is allowed) where:\n- `peers` - the key names of which at least one must appear. `peers` can be a single string value, an\n  array of string values, or each peer provided as an argument.\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.any(),\n    b: Joi.any()\n}).or('a', 'b');\n```\n\n#### `object.xor(peers)`\n\nDefines an exclusive relationship between a set of keys where one of them is required but not at the same time where:\n- `peers` - the exclusive key names that must not appear together but where one of them is required. `peers` can be a single string value, an\n  array of string values, or each peer provided as an argument.\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.any(),\n    b: Joi.any()\n}).xor('a', 'b');\n```\n\n#### `object.with(key, peers)`\n\nRequires the presence of other keys whenever the specified key is present where:\n- `key` - the reference key.\n- `peers` - the required peer key names that must appear together with `key`. `peers` can be a single string value or an array of string values.\n\nNote that unlike [`object.and()`](#objectandpeers), `with()` creates a dependency only between the `key` and each of the `peers`, not\nbetween the `peers` themselves.\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.any(),\n    b: Joi.any()\n}).with('a', 'b');\n```\n\n#### `object.without(key, peers)`\n\nForbids the presence of other keys whenever the specified is present where:\n- `key` - the reference key.\n- `peers` - the forbidden peer key names that must not appear together with `key`. `peers` can be a single string value or an array of string values.\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.any(),\n    b: Joi.any()\n}).without('a', ['b']);\n```\n\n#### `object.rename(from, to, [options])`\n\nRenames a key to another name (deletes the renamed key) where:\n- `from` - the original key name.\n- `to` - the new key name.\n- `options` - an optional object with the following optional keys:\n    - `alias` - if `true`, does not delete the old key name, keeping both the new and old keys in place. Defaults to `false`.\n    - `multiple` - if `true`, allows renaming multiple keys to the same destination where the last rename wins. Defaults to `false`.\n    - `override` - if `true`, allows renaming a key over an existing key. Defaults to `false`.\n\nKeys are renamed before any other validation rules are applied.\n\n```javascript\nvar object = Joi.object().keys({\n    a: Joi.number()\n}).rename('b', 'a');\n\nobject.validate({ b: 5 }, function (err, value) { });\n```\n\n#### `object.assert(ref, schema, [message])`\n\nVerifies an assertion where:\n- `ref` - the key name or [reference](#refkey-options).\n- `schema` - the validation rules required to satisfy the assertion. If the `schema` includes references, they are resolved against\n  the object value, not the value of the `ref` target.\n- `message` - optional human-readable message used when the assertion fails. Defaults to 'failed to pass the assertion test'.\n\n```javascript\nvar schema = Joi.object().keys({\n    a: {\n        b: Joi.string(),\n        c: Joi.number()\n    },\n    d: {\n        e: Joi.any()\n    }\n}).assert('d.e', Joi.ref('a.c'), 'equal to a.c');\n```\n\n#### `object.unknown([allow])`\n\nOverrides the handling of unknown keys for the scope of the current object only (does not apply to children) where:\n- `allow` - if `false`, unknown keys are not allowed, otherwise unknown keys are ignored.\n\n```javascript\nvar schema = Joi.object({ a: Joi.any() }).unknown();\n```\n\n#### `object.type(constructor, [name])`\n\nRequires the object to be an instance of a given constructor where:\n- `constructor` - the constructor function that the object must be an instance of.\n- `name` - an alternate name to use in validation errors. This is useful when the constructor function does not have a name.\n\n```javascript\nvar schema = Joi.object().type(RegExp);\n```\n\n#### `object.requiredKeys(children)`\n\nSets the specified children to required.\n- `children` - can be a single string value, an array of string values, or each child provided as an argument.\n\n```javascript\nvar schema = Joi.object().keys({ a: { b: Joi.number() }, c: { d: Joi.string() } });\nvar requiredSchema = schema.requiredKeys('', 'a.b', 'c', 'c.d');\n```\n\nNote that in this example `''` means the current object, `a` is not required but `b` is, as well as `c` and `d`.\n\n#### `object.optionalKeys(children)`\n\nSets the specified children to optional.\n- `children` - can be a single string value, an array of string values, or each child provided as an argument.\n\n```javascript\nvar schema = Joi.object().keys({ a: { b: Joi.number().required() }, c: { d: Joi.string().required() } });\nvar requiredSchema = schema.optionalKeys('a.b', 'c.d');\n```\n\nThe behavior is exactly the same as `requiredKeys`.\n\n### `string`\n\nGenerates a schema object that matches a string data type. Note that empty strings are not allowed by default and must be enabled with `allow('')`.\n\nSupports the same methods of the [`any()`](#any) type.\n\n```javascript\nvar schema = Joi.string().min(1).max(10);\nschema.validate('12345', function (err, value) { });\n```\n\n#### `string.insensitive()`\n\nAllows the value to match any whitelist of blacklist item in a case insensitive comparison.\n\n```javascript\nvar schema = Joi.string().valid('a').insensitive();\n```\n\n#### `string.min(limit, [encoding])`\n\nSpecifies the minimum number string characters where:\n- `limit` - the minimum number of string characters required.\n- `encoding` - is specified, the string length is calculated in bytes using the provided encoding.\n\n```javascript\nvar schema = Joi.string().min(2);\n```\n\n#### `string.max(limit, [encoding])`\n\nSpecifies the maximum number of string characters where:\n- `limit` - the maximum number of string characters allowed.\n- `encoding` - is specified, the string length is calculated in bytes using the provided encoding.\n\n```javascript\nvar schema = Joi.string().max(10);\n```\n\n#### `string.creditCard()`\n\nRequires the number to be a credit card number (Using [Lunh\nAlgorithm](http://en.wikipedia.org/wiki/Luhn_algorithm)).\n\n```javascript\nvar schema = Joi.string().creditCard();\n```\n\n#### `string.length(limit, [encoding])`\n\nSpecifies the exact string length required where:\n- `limit` - the required string length.\n- `encoding` - is specified, the string length is calculated in bytes using the provided encoding.\n\n```javascript\nvar schema = Joi.string().length(5);\n```\n\n#### `string.regex(pattern, [name])`\n\nDefines a regular expression rule where:\n- `pattern` - a regular expression object the string value must match against.\n- `name` - optional name for patterns (useful with multiple patterns). Defaults to 'required'.\n\n```javascript\nvar schema = Joi.string().regex(/^[abc]+$/);\n```\n\n#### `string.alphanum()`\n\nRequires the string value to only contain a-z, A-Z, and 0-9.\n\n```javascript\nvar schema = Joi.string().alphanum();\n```\n\n#### `string.token()`\n\nRequires the string value to only contain a-z, A-Z, 0-9, and underscore _.\n\n```javascript\nvar schema = Joi.string().token();\n```\n\n#### `string.email()`\n\nRequires the string value to be a valid email address.\n\n```javascript\nvar schema = Joi.string().email();\n```\n\n#### `string.guid()`\n\nRequires the string value to be a valid GUID.\n\n```javascript\nvar schema = Joi.string().guid();\n```\n\n#### `string.hostname()`\n\nRequires the string value to be a valid hostname as per [RFC1123](http://tools.ietf.org/html/rfc1123).\n\n```javascript\nvar schema = Joi.string().hostname();\n```\n\n#### `string.lowercase()`\n\nRequires the string value to be all lowercase. If the validation `convert` option is on (enabled by default), the string\nwill be forced to lowercase.\n\n```javascript\nvar schema = Joi.string().lowercase();\n```\n\n#### `string.uppercase()`\n\nRequires the string value to be all uppercase. If the validation `convert` option is on (enabled by default), the string\nwill be forced to uppercase.\n\n```javascript\nvar schema = Joi.string().uppercase();\n```\n\n#### `string.trim()`\n\nRequires the string value to contain no whitespace before or after. If the validation `convert` option is on (enabled by\ndefault), the string will be trimmed.\n\n```javascript\nvar schema = Joi.string().trim();\n```\n\n### `alternatives`\n\nGenerates a type that will match one of the provided alternative schemas via the [`try()`](#alternativestryschemas)\nmethod. If no schemas are added, the type will not match any value except for `undefined`.\n\nSupports the same methods of the [`any()`](#any) type.\n\nAlternatives can be expressed using the shorter `[]` notation.\n\n```javascript\nvar alt = Joi.alternatives().try(Joi.number(), Joi.string());\n// Same as [Joi.number(), Joi.string()]\n```\n\n#### `alternatives.try(schemas)`\n\nAdds an alternative schema type for attempting to match against the validated value where:\n- `schema` - an array of alternative **joi** types. Also supports providing each type as a separate argument.\n\n```javascript\nvar alt = Joi.alternatives().try(Joi.number(), Joi.string());\nalt.validate('a', function (err, value) { });\n```\n\n#### `alternatives.when(ref, options)`\n\nAdds a conditional alternative schema type based on another key (not the same as `any.when()`) value where:\n- `ref` - the key name or [reference](#refkey-options).\n- `options` - an object with:\n    - `is` - the required condition **joi** type.\n    - `then` - the alternative schema type to **try** if the condition is true. Required if `otherwise` is missing.\n    - `otherwise` - the alternative schema type to **try** if the condition is false. Required if `then` is missing.\n\n```javascript\nvar schema = {\n    a: Joi.alternatives().when('b', { is: 5, then: Joi.string(), otherwise: Joi.number() }),\n    b: Joi.any()\n};\n```\n\nNote that `when()` only adds additional alternatives to try and does not impact the overall type. Setting\na `required()` rule on a single alternative will not apply to the overall key. For example,\nthis definition of `a`:\n\n```javascript\nvar schema = {\n    a: Joi.alternatives().when('b', { is: true, then: Joi.required() }),\n    b: Joi.boolean()\n};\n```\n\nDoes not turn `a` into a required key when `b` is `true`. Instead, it tells the validator to try and match the\nvalue to anything that's not `undefined`. However, since `Joi.alternatives()` by itself allows `undefined`, the rule\ndoes not accomplish turning `a` to a required value. This rule is the same as `Joi.alternatives([Joi.required()])`\nwhen `b` is `true` which will allow any value including `undefined`.\n\nTo accomplish the desired result above use:\n\n```javascript\nvar schema = {\n    a: Joi.when('b', { is: true, then: Joi.required() }),\n    b: Joi.boolean()\n};\n```\n\n### `ref(key, [options])`\n\nGenerates a reference to the value of the named key. References are resolved at validation time and in order of dependency\nso that if one key validation depends on another, the dependent key is validated second after the reference is validated.\nReferences support the following arguments:\n- `key` - the reference target. References cannot point up the object tree, only to sibling keys, but they can point to\n  their siblings' children (e.g. 'a.b.c') using the `.` separator. If a `key` starts with `$` is signifies a context reference\n  which is looked up in the `context` option object.\n- `options` - optional settings:\n    - `separator` - overrides the default `.` hierarchy separator.\n    - `contextPrefix` - overrides the default `$` context prefix signifier.\n\nNote that references can only be used where explicitly supported such as in `valid()` or `invalid()` rules. If upwards\n(parents) references are needed, use [`object.assert()`](#objectassertref-schema-message).\n\n```javascript\nvar schema = Joi.object().keys({\n    a: Joi.ref('b.c'),\n    b: {\n        c: Joi.any()\n    },\n    c: Joi.ref('$x')\n});\n\nJoi.validate({ a: 5, b: { c: 5 } }, schema, { context: { x: 5 } }, function (err, value) {});\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/hapijs/joi/issues"
  },
  "homepage": "https://github.com/hapijs/joi#readme",
  "_id": "joi@5.1.0",
  "_shasum": "152ad07db8ee9c6401997ff5fd2c12896070bf58",
  "_resolved": "http://registry.npmjs.org/joi/-/joi-5.1.0.tgz",
  "_from": "joi@>=5.0.0 <6.0.0"
}
