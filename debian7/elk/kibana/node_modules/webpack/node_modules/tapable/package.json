{
  "name": "tapable",
  "version": "0.1.9",
  "author": {
    "name": "Tobias Koppers @sokra"
  },
  "description": "Just a little module for plugins.",
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "devDependencies": {
    "mocha": "^2.2.4",
    "should": "^5.2.0"
  },
  "engines": {
    "node": ">=0.6"
  },
  "homepage": "https://github.com/webpack/tapable",
  "main": "lib/Tapable.js",
  "scripts": {
    "test": "mocha --reporter spec"
  },
  "readme": "# Tapable\r\n\r\n``` javascript\r\nvar Tapable = require(\"tapable\");\r\n```\r\n\r\n`Tapable` is a class for plugin binding and applying.\r\n\r\nJust extend it.\r\n\r\n``` javascript\r\nfunction MyClass() {\r\n\tTapable.call(this);\r\n}\r\n\r\nMyClass.prototype = Object.create(Tapable.prototype);\r\n\r\nMyClass.prototype.method = function() {};\r\n```\r\n\r\nOr mix it in.\r\n\r\n``` javascript\r\nfunction MyClass2() {\r\n\tEventEmitter.call(this);\r\n\tTapable.call(this);\r\n}\r\n\r\nMyClass2.prototype = Object.create(EventEmitter.prototype);\r\nTapable.mixin(MyClass2.prototype);\r\n\r\nMyClass2.prototype.method = function() {};\r\n```\r\n\r\n## Public functions\r\n\r\n### apply\r\n\r\n``` javascript\r\nvoid apply(plugins: Plugin...)\r\n```\r\n\r\nAttaches all plugins passed as arguments to the instance, by calling `apply` on them.\r\n\r\n### plugin\r\n\r\n``` javascript\r\nvoid plugin(names: string|string[], handler: Function)\r\n```\r\n\r\n`names` are the names (or a single name) of the plugin interfaces the class provides.\r\n\r\n`handler` is a callback function. The signature depends on the class. `this` is the instance of the class.\r\n\r\n### restartApplyPlugins\r\n\r\n``` javascript\r\nvoid restartApplyPlugins()\r\n```\r\n\r\nShould only be called from a handler function.\r\n\r\nIt restarts the process of applying handers.\r\n\r\n## Protected functions\r\n\r\n### applyPlugins\r\n\r\n``` javascript\r\nvoid applyPlugins(name: string, args: any...)\r\n```\r\n\r\nSynchronous applies all registered handers for `name`. The handler functions are called with all args.\r\n\r\n### applyPluginsWaterfall\r\n\r\n``` javascript\r\nany applyPluginsWaterfall(name: string, init: any, args: any...)\r\n```\r\n\r\nSynchronous applies all registered handers for `name`. The handler functions are called with the return value of the previous handler and all args. For the first handler `init` is used and the return value of the last handler is return by `applyPluginsWaterfall`\r\n\r\n### applyPluginsAsync\r\n\r\n``` javascript\r\nvoid applyPluginsAsync(\r\n\tname: string,\r\n\targs: any...,\r\n\tcallback: (err?: Error) -> void\r\n)\r\n```\r\n\r\nAsynchronously applies all registered handers for `name`. The handler functions are called with all args and a callback function with the signature `(err?: Error) -> void`. The hander functions are called in order of registration.\r\n\r\n`callback` is called after all handlers are called.\r\n\r\n### applyPluginsBailResult\r\n\r\n``` javascript\r\nany applyPluginsBailResult(name: string, args: any...)\r\n```\r\n\r\nSynchronous applies all registered handers for `name`. The handler function are called with all args. If a handler function returns something `!== undefined`, the value is returned and no more handers are applied.\r\n\r\n### applyPluginsAsyncWaterfall\r\n\r\n``` javascript\r\napplyPluginsAsyncWaterfall(\r\n\tname: string,\r\n\tinit: any,\r\n\tcallback: (err: Error, result: any) -> void\r\n)\r\n```\r\n\r\nAsynchronously applies all registered handers for `name`. The hander functions are called with the current value and a callback function with the signature `(err: Error, nextValue: any) -> void`. When called `nextValue` is the current value for the next handler. The current value for the first handler is `init`. After all handlers are applied, `callback` is called with the last value. If any handler passes a value for `err`, the `callback` is called with this error and no more handlers are called.\r\n\r\n### applyPluginsAsyncSeries\r\n\r\n``` javascript\r\napplyPluginsAsyncSeries(\r\n\tname: string,\r\n\targs: any...,\r\n\tcallback: (err: Error, result: any) -> void\r\n)\r\n```\r\n\r\nAsynchronously applies all registered handers for `name`. The hander functions are called with all `args` and a callback function with the signature `(err: Error) -> void`. The handers are called in series, one at a time. After all handlers are applied, `callback` is called. If any handler passes a value for `err`, the `callback` is called with this error and no more handlers are called.\r\n\r\n### applyPluginsParallel\r\n\r\n``` javascript\r\napplyPluginsParallel(\r\n\tname: string,\r\n\targs: any...,\r\n\tcallback: (err?: Error) -> void\r\n)\r\n```\r\n\r\nApplies all registered handlers for `name` parallel. The handler functions are called with all args and a callback function with the signature `(err?: Error) -> void`. The `callback` function is called when all handlers called the callback without `err`. If any handler calls the callback with `err`, `callback` is invoked with this error and the other handlers are ignored.\r\n\r\n`restartApplyPlugins` cannot be used.\r\n\r\n### applyPluginsParallelBailResult\r\n\r\n``` javascript\r\napplyPluginsParallelBailResult(\r\n\tname: string,\r\n\targs: any...,\r\n\tcallback: (err: Error, result: any) -> void\r\n)\r\n```\r\n\r\nApplies all registered handlers for `name` parallel. The handler functions are called with all args and a callback function with the signature `(err?: Error) -> void`. Handler functions must call the callback. They can either pass an error, or pass undefined, or pass an value. The first result (either error or value) with is not undefined is passed to the `callback`. The order is defined by registeration not by speed of the handler function. This function compentate this.\r\n\r\n`restartApplyPlugins` cannot be used.\r\n",
  "readmeFilename": "README.md",
  "_id": "tapable@0.1.9",
  "_shasum": "1003d9499c344ba238cb32329c8d2c8babc92e54",
  "_resolved": "http://registry.npmjs.org/tapable/-/tapable-0.1.9.tgz",
  "_from": "tapable@>=0.1.8 <0.2.0"
}
