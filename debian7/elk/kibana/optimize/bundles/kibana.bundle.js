webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Test entry file
	 *
	 * This is programatically created and updated, do not modify
	 *
	 * context: {"env":"production","sourceMaps":false,"kbnVersion":"4.2.0","buildNum":8809}
	 * includes code from:
	 *  - elasticsearch@1.0.0
	 *  - kbn_vislib_vis_types@1.0.0
	 *  - kibana@1.0.0
	 *  - markdown_vis@1.0.0
	 *  - metric_vis@1.0.0
	 *  - spyModes@1.0.0
	 *  - statusPage@1.0.0
	 *  - table_vis@1.0.0
	 *
	 */

	'use strict';

	__webpack_require__(1);
	__webpack_require__(326);
	__webpack_require__(747);
	__webpack_require__(810);
	__webpack_require__(305);
	__webpack_require__(798);
	__webpack_require__(426);
	__webpack_require__(427);
	__webpack_require__(797);
	__webpack_require__(484);
	__webpack_require__(453);
	__webpack_require__(811);
	__webpack_require__(483);
	__webpack_require__(306);
	__webpack_require__(594);
	__webpack_require__(813);
	__webpack_require__(815);
	__webpack_require__(816);
	__webpack_require__(705);
	__webpack_require__(818);
	__webpack_require__(452);
	__webpack_require__(627);
	__webpack_require__(621);
	__webpack_require__(746);
	__webpack_require__(625);
	__webpack_require__(489);
	__webpack_require__(819);
	__webpack_require__(595);
	__webpack_require__(555);
	__webpack_require__(687);
	__webpack_require__(495);
	__webpack_require__(767);
	__webpack_require__(428);
	__webpack_require__(803);
	__webpack_require__(468);
	__webpack_require__(429);
	__webpack_require__(766);
	__webpack_require__(820);
	__webpack_require__(821);
	__webpack_require__(822);
	__webpack_require__(823);
	__webpack_require__(824);
	__webpack_require__(825);
	__webpack_require__(826);
	__webpack_require__(827);
	__webpack_require__(828);
	__webpack_require__(829);
	__webpack_require__(830);
	__webpack_require__(831);
	__webpack_require__(832);
	__webpack_require__(833);
	__webpack_require__(834);
	__webpack_require__(835);
	__webpack_require__(820);
	__webpack_require__(836);
	__webpack_require__(837);
	__webpack_require__(209);
	__webpack_require__(1);
	__webpack_require__(838);
	__webpack_require__(841);
	__webpack_require__(842);
	__webpack_require__(712);
	__webpack_require__(496);
	__webpack_require__(491);
	__webpack_require__(649);
	__webpack_require__(788);
	__webpack_require__(497);
	__webpack_require__(238);
	__webpack_require__(843);
	__webpack_require__(846);
	__webpack_require__(670);
	__webpack_require__(500);
	__webpack_require__(853);
	__webpack_require__(308);
	__webpack_require__(854);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(499);
	__webpack_require__(547);
	__webpack_require__(252);
	__webpack_require__(855);
	__webpack_require__(856);
	__webpack_require__(878);
	__webpack_require__(215);
	__webpack_require__(481);
	__webpack_require__(880);
	__webpack_require__(716);
	__webpack_require__(765);
	__webpack_require__(597);
	__webpack_require__(490);
	__webpack_require__(884);
	__webpack_require__(327);
	__webpack_require__(676);
	__webpack_require__(711);
	__webpack_require__(742);
	__webpack_require__(743);
	__webpack_require__(806);
	__webpack_require__(332);
	__webpack_require__(885);
	__webpack_require__(550);
	__webpack_require__(396);
	__webpack_require__(918);
	__webpack_require__(942);
	__webpack_require__(950);
	__webpack_require__(955);
	__webpack_require__(967);
	__webpack_require__(969);
	__webpack_require__(1).bootstrap();
	/* xoxo */

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(327);
	__webpack_require__(676);
	__webpack_require__(711);
	__webpack_require__(742);
	__webpack_require__(806);

	var chrome = __webpack_require__(1);
	var routes = __webpack_require__(216);
	var modules = __webpack_require__(214);

	var kibanaLogoUrl = __webpack_require__(809);

	routes.otherwise({
	  redirectTo: '/discover'
	});

	chrome.setBrand({
	  'logo': 'url(' + kibanaLogoUrl + ') left no-repeat',
	  'smallLogo': 'url(' + kibanaLogoUrl + ') left no-repeat'
	}).setNavBackground('#222222').setTabDefaults({
	  resetWhenActive: true,
	  lastUrlStore: window.sessionStore,
	  activeIndicatorColor: '#656a76'
	}).setTabs([{
	  id: 'discover',
	  title: 'Discover'
	}, {
	  id: 'visualize',
	  title: 'Visualize',
	  activeIndicatorColor: function activeIndicatorColor() {
	    return String(this.lastUrl).indexOf('/visualize/step/') === 0 ? 'white' : '#656a76';
	  }
	}, {
	  id: 'dashboard',
	  title: 'Dashboard'
	}, {
	  id: 'settings',
	  title: 'Settings'
	}]).setRootController('kibana', function ($scope, $rootScope, courier, config) {
	  // wait for the application to finish loading
	  $scope.$on('application.load', function () {
	    courier.start();
	  });
	});

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(328);
	__webpack_require__(331);
	__webpack_require__(423);
	__webpack_require__(425);
	__webpack_require__(447);
	__webpack_require__(673);
	__webpack_require__(456);
	__webpack_require__(674);
	__webpack_require__(675);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, module, exports) {
	  __webpack_require__(328);
	  __webpack_require__(331);
	  __webpack_require__(423);
	  __webpack_require__(425);
	  __webpack_require__(447);
	  __webpack_require__(673);

	  // preload
	  __webpack_require__(456);

	  __webpack_require__(674).register(__webpack_require__(675));
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(329);
	__webpack_require__(308);
	__webpack_require__(214);
	__webpack_require__(330);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(329);
	  __webpack_require__(308);

	  var module = __webpack_require__(214).get('discover/saved_searches', ['kibana/notify']);

	  // Register this service with the saved object registry so it can be
	  // edited by the object editor.
	  __webpack_require__(330).register({
	    service: 'savedSearches',
	    title: 'searches'
	  });

	  module.service('savedSearches', function (Promise, config, kbnIndex, es, createNotifier, SavedSearch, kbnUrl) {

	    var notify = createNotifier({
	      location: 'Saved Searches'
	    });

	    this.type = SavedSearch.type;
	    this.Class = SavedSearch;

	    this.loaderProperties = {
	      name: 'searches',
	      noun: 'Saved Search',
	      nouns: 'saved searches'
	    };

	    this.get = function (id) {
	      return new SavedSearch(id).init();
	    };

	    this.urlFor = function (id) {
	      return kbnUrl.eval('#/discover/{{id}}', { id: id });
	    };

	    this['delete'] = function (ids) {
	      ids = !_.isArray(ids) ? [ids] : ids;
	      return Promise.map(ids, function (id) {
	        return new SavedSearch(id)['delete']();
	      });
	    };

	    this.find = function (searchString) {
	      var size = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];

	      var self = this;
	      var body;
	      if (searchString) {
	        body = {
	          query: {
	            simple_query_string: {
	              query: searchString + '*',
	              fields: ['title^3', 'description'],
	              default_operator: 'AND'
	            }
	          }
	        };
	      } else {
	        body = { query: { match_all: {} } };
	      }

	      return es.search({
	        index: kbnIndex,
	        type: 'search',
	        body: body,
	        size: size
	      }).then(function (resp) {
	        return {
	          total: resp.hits.total,
	          hits: resp.hits.hits.map(function (hit) {
	            var source = hit._source;
	            source.id = hit._id;
	            source.url = self.urlFor(hit._id);
	            return source;
	          })
	        };
	      });
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(308);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(308);

	  var module = __webpack_require__(214).get('discover/saved_searches', ['kibana/notify', 'kibana/courier']);

	  module.factory('SavedSearch', function (courier) {
	    _['class'](SavedSearch).inherits(courier.SavedObject);
	    function SavedSearch(id) {
	      courier.SavedObject.call(this, {
	        type: SavedSearch.type,
	        mapping: SavedSearch.mapping,
	        searchSource: SavedSearch.searchSource,

	        id: id,
	        defaults: {
	          title: 'New Saved Search',
	          description: '',
	          columns: [],
	          hits: 0,
	          sort: [],
	          version: 1
	        }
	      });
	    }

	    SavedSearch.type = 'search';

	    SavedSearch.mapping = {
	      title: 'string',
	      description: 'string',
	      hits: 'integer',
	      columns: 'string',
	      sort: 'string',
	      version: 'integer'
	    };

	    SavedSearch.searchSource = true;

	    return SavedSearch;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var registry = [];
	  return {
	    register: function register(service) {
	      registry.push(service);
	    },
	    all: function all() {
	      return registry;
	    },
	    get: function get(id) {
	      return _.find(registry, { service: id });
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(214).get('apps/discover').directive('discoverTimechart', function (Private, $compile) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var vislib = Private(__webpack_require__(332));

	  return {
	    restrict: 'E',
	    scope: {
	      data: '='
	    },
	    link: function link($scope, elem) {

	      var init = function init() {
	        // This elem should already have a height/width
	        var myChart = new vislib.Chart(elem[0], {});

	        $scope.$watch('data', function (data) {
	          if (data != null) {
	            myChart.render(data);
	          }
	        });
	      };

	      // Start the directive
	      init();
	    }
	  };
	});

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	// prefetched for faster optimization runs
	'use strict';

	__webpack_require__(333);
	__webpack_require__(388);
	__webpack_require__(393);
	__webpack_require__(394);
	__webpack_require__(369);
	__webpack_require__(337);
	__webpack_require__(395);
	__webpack_require__(408);
	// end prefetching

	/**
	 * Provides the Kibana4 Visualization Library
	 *
	 * @module vislib
	 * @main vislib
	 * @return {Object} Contains the version number and the Vis Class for creating visualizations
	 */
	module.exports = function VislibProvider(Private) {
	  __webpack_require__(418);

	  return {
	    version: '0.0.0',
	    Vis: Private(__webpack_require__(419))
	  };
	};

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(334);
	__webpack_require__(337);
	__webpack_require__(380);
	__webpack_require__(386);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PieHandler(Private) {
	    var Handler = Private(__webpack_require__(334));
	    var Data = Private(__webpack_require__(337));
	    var Legend = Private(__webpack_require__(380));
	    var ChartTitle = Private(__webpack_require__(386));

	    /*
	     * Handler for Pie visualizations.
	     */

	    return function (vis) {
	      return new Handler(vis, {
	        legend: new Legend(vis),
	        chartTitle: new ChartTitle(vis.el)
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(220);
	__webpack_require__(336);
	__webpack_require__(337);
	__webpack_require__(368);
	__webpack_require__(380);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HandlerBaseClass(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var errors = __webpack_require__(220);
	    var Binder = __webpack_require__(336);

	    var Data = Private(__webpack_require__(337));
	    var Layout = Private(__webpack_require__(368));
	    var Legend = Private(__webpack_require__(380));

	    /**
	     * Handles building all the components of the visualization
	     *
	     * @class Handler
	     * @constructor
	     * @param vis {Object} Reference to the Vis Class Constructor
	     * @param opts {Object} Reference to Visualization constructors needed to
	     * create the visualization
	     */
	    function Handler(vis, opts) {
	      if (!(this instanceof Handler)) {
	        return new Handler(vis, opts);
	      }

	      this.data = opts.data || new Data(vis.data, vis._attr);
	      this.vis = vis;
	      this.el = vis.el;
	      this.ChartClass = vis.ChartClass;
	      this.charts = [];

	      this._attr = _.defaults(vis._attr || {}, {
	        'margin': { top: 10, right: 3, bottom: 5, left: 3 }
	      });

	      this.xAxis = opts.xAxis;
	      this.yAxis = opts.yAxis;
	      this.chartTitle = opts.chartTitle;
	      this.axisTitle = opts.axisTitle;
	      this.alerts = opts.alerts;

	      if (this._attr.addLegend) {
	        this.legend = opts.legend;
	      }

	      this.layout = new Layout(vis.el, vis.data, vis._attr.type, opts);
	      this.binder = new Binder();
	      this.renderArray = _.filter([this.layout, this.legend, this.axisTitle, this.chartTitle, this.alerts, this.xAxis, this.yAxis], Boolean);

	      // memoize so that the same function is returned every time,
	      // allowing us to remove/re-add the same function
	      this.getProxyHandler = _.memoize(function (event) {
	        var self = this;
	        return function (e) {
	          self.vis.emit(event, e);
	        };
	      });
	    }

	    /**
	     * Validates whether data is actually present in the data object
	     * used to render the Vis. Throws a no results error if data is not
	     * present.
	     *
	     * @private
	     */
	    Handler.prototype._validateData = function () {
	      var dataType = this.data.type;

	      if (!dataType) {
	        throw new errors.NoResults();
	      }
	    };

	    /**
	     * Renders the constructors that create the visualization,
	     * including the chart constructor
	     *
	     * @method render
	     * @returns {HTMLElement} With the visualization child element
	     */
	    Handler.prototype.render = function () {
	      var self = this;
	      var charts = this.charts = [];
	      var selection = d3.select(this.el);

	      selection.selectAll('*').remove();

	      this._validateData();
	      this.renderArray.forEach(function (property) {
	        if (property instanceof Legend) {
	          self.vis.activeEvents().forEach(function (event) {
	            self.enable(event, property);
	          });
	        }

	        if (typeof property.render === 'function') {
	          property.render();
	        }
	      });

	      // render the chart(s)
	      selection.selectAll('.chart').each(function (chartData) {
	        var chart = new self.ChartClass(self, this, chartData);

	        self.vis.activeEvents().forEach(function (event) {
	          self.enable(event, chart);
	        });

	        charts.push(chart);
	        chart.render();
	      });
	    };

	    /**
	     * Enables events, i.e. binds specific events to the chart
	     * object(s) `on` method. For example, `click` or `mousedown` events.
	     *
	     * @method enable
	     * @param event {String} Event type
	     * @param chart {Object} Chart
	     * @returns {*}
	     */
	    Handler.prototype.enable = chartEventProxyToggle('on');

	    /**
	     * Disables events for all charts
	     *
	     * @method disable
	     * @param event {String} Event type
	     * @param chart {Object} Chart
	     * @returns {*}
	     */
	    Handler.prototype.disable = chartEventProxyToggle('off');

	    function chartEventProxyToggle(method) {
	      return function (event, chart) {
	        var proxyHandler = this.getProxyHandler(event);

	        _.each(chart ? [chart] : this.charts, function (chart) {
	          chart.events[method](event, proxyHandler);
	        });
	      };
	    }

	    /**
	     * Removes all DOM elements from the HTML element provided
	     *
	     * @method removeAll
	     * @param el {HTMLElement} Reference to the HTML Element that
	     * contains the chart
	     * @returns {D3.Selection|D3.Transition.Transition} With the chart
	     * child element removed
	     */
	    Handler.prototype.removeAll = function (el) {
	      return d3.select(el).selectAll('*').remove();
	    };

	    /**
	     * Displays an error message in the DOM
	     *
	     * @method error
	     * @param message {String} Error message to display
	     * @returns {HTMLElement} Displays the input message
	     */
	    Handler.prototype.error = function (message) {
	      this.removeAll(this.el);

	      var div = d3.select(this.el).append('div')
	      // class name needs `chart` in it for the polling checkSize function
	      // to continuously call render on resize
	      .attr('class', 'visualize-error chart error');

	      if (message === 'No results found') {
	        div.append('div').attr('class', 'text-center visualize-error visualize-chart ng-scope').append('div').attr('class', 'item top').append('div').attr('class', 'item').append('h2').html('<i class="fa fa-meh-o"></i>').append('h4').text(message);

	        div.append('div').attr('class', 'item bottom');
	        return div;
	      }

	      return div.append('h4').text(message);
	    };

	    /**
	     * Destroys all the charts in the visualization
	     *
	     * @method destroy
	     */
	    Handler.prototype.destroy = function () {
	      this.binder.destroy();

	      this.renderArray.forEach(function (renderable) {
	        if (_.isFunction(renderable.destroy)) {
	          renderable.destroy();
	        }
	      });

	      this.charts.splice(0).forEach(function (chart) {
	        if (_.isFunction(chart.destroy)) {
	          chart.destroy();
	        }
	      });
	    };

	    return Handler;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 335 */,
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var $ = __webpack_require__(206);
	var d3 = __webpack_require__(335);
	var callEach = __webpack_require__(192).callEach;
	var bindKey = __webpack_require__(192).bindKey;
	var rest = __webpack_require__(192).rest;

	function Binder($scope) {
	  this.disposal = [];
	  if ($scope) {
	    $scope.$on('$destroy', bindKey(this, 'destroy'));
	  }
	}

	Binder.prototype._bind = function (on, off, emitter, args) {
	  on.apply(emitter, args);
	  this.disposal.push(function () {
	    off.apply(emitter, args);
	  });
	};

	Binder.prototype.on = function (emitter /*, ...args */) {
	  this._bind(emitter.on, emitter.off || emitter.removeListener, emitter, rest(arguments));
	};

	Binder.prototype.jqOn = function (el /*, ...args */) {
	  var $el = $(el);
	  this._bind($el.on, $el.off, $el, rest(arguments));
	};

	Binder.prototype.fakeD3Bind = function (el, event, handler) {
	  this.jqOn(el, event, function (e) {
	    // mimick https://github.com/mbostock/d3/blob/3abb00113662463e5c19eb87cd33f6d0ddc23bc0/src/selection/on.js#L87-L94
	    var o = d3.event; // Events can be reentrant (e.g., focus).
	    d3.event = e;
	    try {
	      handler.apply(this, [this.__data__]);
	    } finally {
	      d3.event = o;
	    }
	  });
	};

	Binder.prototype.destroy = function () {
	  var destroyers = this.disposal;
	  this.disposal = [];
	  callEach(destroyers);
	};

	module.exports = Binder;

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(338);
	__webpack_require__(339);
	__webpack_require__(356);
	__webpack_require__(364);
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DataFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);

	    var injectZeros = Private(__webpack_require__(338));
	    var orderKeys = Private(__webpack_require__(339));
	    var getLabels = Private(__webpack_require__(356));
	    var color = Private(__webpack_require__(364));
	    var errors = __webpack_require__(220);

	    /**
	     * Provides an API for pulling values off the data
	     * and calculating values using the data
	     *
	     * @class Data
	     * @constructor
	     * @param data {Object} Elasticsearch query results
	     * @param attr {Object|*} Visualization options
	     */
	    function Data(data, attr) {
	      if (!(this instanceof Data)) {
	        return new Data(data, attr);
	      }

	      var self = this;
	      var offset;

	      if (attr.mode === 'stacked') {
	        offset = 'zero';
	      } else if (attr.mode === 'percentage') {
	        offset = 'expand';
	      } else if (attr.mode === 'grouped') {
	        offset = 'group';
	      } else {
	        offset = attr.mode;
	      }

	      this.data = data;
	      this.type = this.getDataType();

	      this.labels = this._getLabels(this.data);
	      this.color = this.labels ? color(this.labels) : undefined;
	      this._normalizeOrdered();

	      this._attr = _.defaults(attr || {}, {
	        stack: d3.layout.stack().x(function (d) {
	          return d.x;
	        }).y(function (d) {
	          if (offset === 'expand') {
	            return Math.abs(d.y);
	          }
	          return d.y;
	        }).offset(offset || 'zero')
	      });

	      if (attr.mode === 'stacked' && attr.type === 'histogram') {
	        this._attr.stack.out(function (d, y0, y) {
	          return self._stackNegAndPosVals(d, y0, y);
	        });
	      }
	    }

	    Data.prototype._updateData = function () {
	      if (this.data.rows) {
	        _.map(this.data.rows, this._updateDataSeriesLabel, this);
	      } else if (this.data.columns) {
	        _.map(this.data.columns, this._updateDataSeriesLabel, this);
	      } else {
	        this._updateDataSeriesLabel(this.data);
	      }
	    };

	    Data.prototype._updateDataSeriesLabel = function (eachData) {
	      if (eachData.series) {
	        eachData.series[0].label = this.get('yAxisLabel');
	      }
	    };

	    Data.prototype._getLabels = function (data) {
	      if (this.type === 'series') {
	        var noLabel = getLabels(data).length === 1 && getLabels(data)[0] === '';
	        if (noLabel) {
	          this._updateData();
	          return [this.get('yAxisLabel')];
	        }
	        return getLabels(data);
	      }
	      return this.pieNames();
	    };

	    /**
	     * Returns true for positive numbers
	     */
	    Data.prototype._isPositive = function (num) {
	      return num >= 0;
	    };

	    /**
	     * Returns true for negative numbers
	     */
	    Data.prototype._isNegative = function (num) {
	      return num < 0;
	    };

	    /**
	     * Adds two input values
	     */
	    Data.prototype._addVals = function (a, b) {
	      return a + b;
	    };

	    /**
	     * Returns the results of the addition of numbers in a filtered array.
	     */
	    Data.prototype._sumYs = function (arr, callback) {
	      var filteredArray = arr.filter(callback);

	      return filteredArray.length ? filteredArray.reduce(this._addVals) : 0;
	    };

	    /**
	     * Calculates the d.y0 value for stacked data in D3.
	     */
	    Data.prototype._calcYZero = function (y, arr) {
	      if (y >= 0) return this._sumYs(arr, this._isPositive);
	      return this._sumYs(arr, this._isNegative);
	    };

	    /**
	     *
	     */
	    Data.prototype._getCounts = function (i, j) {
	      var data = this.chartData();
	      var dataLengths = {};

	      dataLengths.charts = data.length;
	      dataLengths.stacks = dataLengths.charts ? data[i].series.length : 0;
	      dataLengths.values = dataLengths.stacks ? data[i].series[j].values.length : 0;

	      return dataLengths;
	    };

	    /**
	     *
	     */
	    Data.prototype._createCache = function () {
	      var cache = {
	        index: {
	          chart: 0,
	          stack: 0,
	          value: 0
	        },
	        yValsArr: []
	      };

	      cache.count = this._getCounts(cache.index.chart, cache.index.stack);

	      return cache;
	    };

	    /**
	     * Stacking function passed to the D3 Stack Layout `.out` API.
	     * See: https://github.com/mbostock/d3/wiki/Stack-Layout
	     * It is responsible for calculating the correct d.y0 value for
	     * mixed datasets containing both positive and negative values.
	     */
	    Data.prototype._stackNegAndPosVals = function (d, y0, y) {
	      var data = this.chartData();

	      // Storing counters and data characteristics needed to stack values properly
	      if (!this._cache) {
	        this._cache = this._createCache();
	      }

	      d.y0 = this._calcYZero(y, this._cache.yValsArr);
	      ++this._cache.index.stack;

	      // last stack, or last value, reset the stack count and y value array
	      var lastStack = this._cache.index.stack >= this._cache.count.stacks;
	      if (lastStack) {
	        this._cache.index.stack = 0;
	        ++this._cache.index.value;
	        this._cache.yValsArr = [];
	        // still building the stack collection, push v value to array
	      } else if (y !== 0) {
	          this._cache.yValsArr.push(y);
	        }

	      // last value, prepare for the next chart, if one exists
	      var lastValue = this._cache.index.value >= this._cache.count.values;
	      if (lastValue) {
	        this._cache.index.value = 0;
	        ++this._cache.index.chart;

	        // no more charts, reset the queue and finish
	        if (this._cache.index.chart >= this._cache.count.charts) {
	          this._cache = this._createCache();
	          return;
	        }

	        // get stack and value count for next chart
	        var chartSeries = data[this._cache.index.chart].series;
	        this._cache.count.stacks = chartSeries.length;
	        this._cache.count.values = chartSeries.length ? chartSeries[this._cache.index.stack].values.length : 0;
	      }
	    };

	    Data.prototype.getDataType = function () {
	      var data = this.getVisData();
	      var type;

	      data.forEach(function (obj) {
	        if (obj.series) {
	          type = 'series';
	        } else if (obj.slices) {
	          type = 'slices';
	        } else if (obj.geoJson) {
	          type = 'geoJson';
	        }
	      });

	      return type;
	    };

	    /**
	     * Returns an array of the actual x and y data value objects
	     * from data with series keys
	     *
	     * @method chartData
	     * @returns {*} Array of data objects
	     */
	    Data.prototype.chartData = function () {
	      if (!this.data.series) {
	        var arr = this.data.rows ? this.data.rows : this.data.columns;
	        return _.toArray(arr);
	      }
	      return [this.data];
	    };

	    /**
	     * Returns an array of chart data objects
	     *
	     * @method getVisData
	     * @returns {*} Array of chart data objects
	     */
	    Data.prototype.getVisData = function () {
	      var visData;

	      if (this.data.rows) {
	        visData = this.data.rows;
	      } else if (this.data.columns) {
	        visData = this.data.columns;
	      } else {
	        visData = [this.data];
	      }

	      return visData;
	    };

	    /**
	     * get min and max for all cols, rows of data
	     *
	     * @method getMaxMin
	     * @return {Object}
	     */
	    Data.prototype.getGeoExtents = function () {
	      var visData = this.getVisData();

	      return _.reduce(_.pluck(visData, 'geoJson.properties'), function (minMax, props) {
	        return {
	          min: Math.min(props.min, minMax.min),
	          max: Math.max(props.max, minMax.max)
	        };
	      }, { min: Infinity, max: -Infinity });
	    };

	    /**
	     * Returns array of chart data objects for pie data objects
	     *
	     * @method pieData
	     * @returns {*} Array of chart data objects
	     */
	    Data.prototype.pieData = function () {
	      if (!this.data.slices) {
	        return this.data.rows ? this.data.rows : this.data.columns;
	      }
	      return [this.data];
	    };

	    /**
	     * Get attributes off the data, e.g. `tooltipFormatter` or `xAxisFormatter`
	     * pulls the value off the first item in the array
	     * these values are typically the same between data objects of the same chart
	     * TODO: May need to verify this or refactor
	     *
	     * @method get
	     * @param thing {String} Data object key
	     * @returns {*} Data object value
	     */
	    Data.prototype.get = function (thing, def) {
	      var source = (this.data.rows || this.data.columns || [this.data])[0];
	      return _.get(source, thing, def);
	    };

	    /**
	     * Returns true if null values are present
	     * @returns {*}
	     */
	    Data.prototype.hasNullValues = function () {
	      var chartData = this.chartData();

	      return chartData.some(function (chart) {
	        return chart.series.some(function (obj) {
	          return obj.values.some(function (d) {
	            return d.y === null;
	          });
	        });
	      });
	    };

	    /**
	     * Return an array of all value objects
	     * Pluck the data.series array from each data object
	     * Create an array of all the value objects from the series array
	     *
	     * @method flatten
	     * @returns {Array} Value objects
	     */
	    Data.prototype.flatten = function () {
	      return _(this.chartData()).pluck('series').flattenDeep().pluck('values').flattenDeep().value();
	    };

	    /**
	     * Determines whether histogram charts should be stacked
	     * TODO: need to make this more generic
	     *
	     * @method shouldBeStacked
	     * @returns {boolean}
	     */
	    Data.prototype.shouldBeStacked = function () {
	      var isHistogram = this._attr.type === 'histogram';
	      var isArea = this._attr.type === 'area';
	      var isOverlapping = this._attr.mode === 'overlap';
	      var grouped = this._attr.mode === 'grouped';

	      var stackedHisto = isHistogram && !grouped;
	      var stackedArea = isArea && !isOverlapping;

	      return stackedHisto || stackedArea;
	    };

	    /**
	     * Validates that the Y axis min value defined by user input
	     * is a number.
	     *
	     * @param val {Number} Y axis min value
	     * @returns {Number} Y axis min value
	     */
	    Data.prototype.validateUserDefinedYMin = function (val) {
	      if (!_.isNumber(val)) {
	        throw new Error('validateUserDefinedYMin expects a number');
	      }
	      return val;
	    };

	    /**
	     * Calculates the lowest Y value across all charts, taking
	     * stacking into consideration.
	     *
	     * @method getYMin
	     * @param {function} [getValue] - optional getter that will receive a
	     *                              point and should return the value that should
	     *                              be considered
	     * @returns {Number} Min y axis value
	     */
	    Data.prototype.getYMin = function (getValue) {
	      var self = this;
	      var arr = [];

	      if (this._attr.mode === 'percentage' || this._attr.mode === 'wiggle' || this._attr.mode === 'silhouette') {
	        return 0;
	      }

	      var flat = this.flatten();
	      // if there is only one data point and its less than zero,
	      // return 0 as the yMax value.
	      if (!flat.length || flat.length === 1 && flat[0].y > 0) {
	        return 0;
	      }

	      var min = Infinity;

	      // for each object in the dataArray,
	      // push the calculated y value to the initialized array (arr)
	      _.each(this.chartData(), function (chart) {
	        var calculatedMin = self._getYExtent(chart, 'min', getValue);
	        if (!_.isUndefined(calculatedMin)) {
	          min = Math.min(min, calculatedMin);
	        }
	      });

	      return min;
	    };

	    /**
	     * Calculates the highest Y value across all charts, taking
	     * stacking into consideration.
	     *
	     * @method getYMax
	     * @param {function} [getValue] - optional getter that will receive a
	     *                              point and should return the value that should
	     *                              be considered
	     * @returns {Number} Max y axis value
	     */
	    Data.prototype.getYMax = function (getValue) {
	      var self = this;
	      var arr = [];

	      if (self._attr.mode === 'percentage') {
	        return 1;
	      }

	      var flat = this.flatten();
	      // if there is only one data point and its less than zero,
	      // return 0 as the yMax value.
	      if (!flat.length || flat.length === 1 && flat[0].y < 0) {
	        return 0;
	      }

	      var max = -Infinity;

	      // for each object in the dataArray,
	      // push the calculated y value to the initialized array (arr)
	      _.each(this.chartData(), function (chart) {
	        var calculatedMax = self._getYExtent(chart, 'max', getValue);
	        if (!_.isUndefined(calculatedMax)) {
	          max = Math.max(max, calculatedMax);
	        }
	      });

	      return max;
	    };

	    /**
	     * Calculates the stacked values for each data object
	     *
	     * @method stackData
	     * @param series {Array} Array of data objects
	     * @returns {*} Array of data objects with x, y, y0 keys
	     */
	    Data.prototype.stackData = function (series) {
	      // Should not stack values on line chart
	      if (this._attr.type === 'line') return series;
	      return this._attr.stack(series);
	    };

	    /**
	     * Returns the max Y axis value for a `series` array based on
	     * a specified callback function (calculation).
	     * @param {function} [getValue] - Optional getter that will be used to read
	     *                              values from points when calculating the extent.
	     *                              default is either this._getYStack or this.getY
	     *                              based on this.shouldBeStacked().
	     */
	    Data.prototype._getYExtent = function (chart, extent, getValue) {
	      if (this.shouldBeStacked()) {
	        this.stackData(_.pluck(chart.series, 'values'));
	        getValue = getValue || this._getYStack;
	      } else {
	        getValue = getValue || this._getY;
	      }

	      var points = chart.series.reduce(function (points, series) {
	        return points.concat(series.values);
	      }, []).map(getValue);

	      return d3[extent](points);
	    };

	    /**
	     * Calculates the y stack value for each data object
	     */
	    Data.prototype._getYStack = function (d) {
	      return d.y0 + d.y;
	    };

	    /**
	     * Calculates the Y max value
	     */
	    Data.prototype._getY = function (d) {
	      return d.y;
	    };

	    /**
	     * Helper function for getNames
	     * Returns an array of objects with a name (key) value and an index value.
	     * The index value allows us to sort the names in the correct nested order.
	     *
	     * @method returnNames
	     * @param array {Array} Array of data objects
	     * @param index {Number} Number of times the object is nested
	     * @param columns {Object} Contains name formatter information
	     * @returns {Array} Array of labels (strings)
	     */
	    Data.prototype.returnNames = function (array, index, columns) {
	      var names = [];
	      var self = this;

	      _.forEach(array, function (obj, i) {
	        names.push({
	          label: obj.name,
	          values: obj,
	          index: index
	        });

	        if (obj.children) {
	          var plusIndex = index + 1;

	          _.forEach(self.returnNames(obj.children, plusIndex, columns), function (namedObj) {
	            names.push(namedObj);
	          });
	        }
	      });

	      return names;
	    };

	    /**
	     * Flattens hierarchical data into an array of objects with a name and index value.
	     * The indexed value determines the order of nesting in the data.
	     * Returns an array with names sorted by the index value.
	     *
	     * @method getNames
	     * @param data {Object} Chart data object
	     * @param columns {Object} Contains formatter information
	     * @returns {Array} Array of names (strings)
	     */
	    Data.prototype.getNames = function (data, columns) {
	      var slices = data.slices;

	      if (slices.children) {
	        var namedObj = this.returnNames(slices.children, 0, columns);

	        return _(namedObj).sortBy(function (obj) {
	          return obj.index;
	        }).unique(function (d) {
	          return d.label;
	        }).value();
	      }
	    };

	    /**
	     * Removes zeros from pie chart data
	     * @param slices
	     * @returns {*}
	     */
	    Data.prototype._removeZeroSlices = function (slices) {
	      var self = this;

	      if (!slices.children) return slices;

	      slices = _.clone(slices);
	      slices.children = slices.children.reduce(function (children, child) {
	        if (child.size !== 0) {
	          children.push(self._removeZeroSlices(child));
	        }
	        return children;
	      }, []);

	      return slices;
	    };

	    /**
	     * Returns an array of names ordered by appearance in the nested array
	     * of objects
	     *
	     * @method pieNames
	     * @returns {Array} Array of unique names (strings)
	     */
	    Data.prototype.pieNames = function (data) {
	      var self = this;
	      var names = [];

	      _.forEach(data, function (obj) {
	        var columns = obj.raw ? obj.raw.columns : undefined;
	        obj.slices = self._removeZeroSlices(obj.slices);

	        _.forEach(self.getNames(obj, columns), function (name) {
	          names.push(name);
	        });
	      });

	      return _.uniq(names, 'label');
	    };

	    /**
	     * Inject zeros into the data
	     *
	     * @method injectZeros
	     * @returns {Object} Data object with zeros injected
	     */
	    Data.prototype.injectZeros = function () {
	      return injectZeros(this.data);
	    };

	    /**
	     * Returns an array of all x axis values from the data
	     *
	     * @method xValues
	     * @returns {Array} Array of x axis values
	     */
	    Data.prototype.xValues = function () {
	      return orderKeys(this.data);
	    };

	    /**
	     * Return an array of unique labels
	     * Curently, only used for vertical bar and line charts,
	     * or any data object with series values
	     *
	     * @method getLabels
	     * @returns {Array} Array of labels (strings)
	     */
	    Data.prototype.getLabels = function () {
	      return getLabels(this.data);
	    };

	    /**
	     * Returns a function that does color lookup on labels
	     *
	     * @method getColorFunc
	     * @returns {Function} Performs lookup on string and returns hex color
	     */
	    Data.prototype.getColorFunc = function () {
	      return color(this.getLabels());
	    };

	    /**
	     * Returns a function that does color lookup on names for pie charts
	     *
	     * @method getPieColorFunc
	     * @returns {Function} Performs lookup on string and returns hex color
	     */
	    Data.prototype.getPieColorFunc = function () {
	      return color(this.pieNames(this.getVisData()).map(function (d) {
	        return d.label;
	      }));
	    };

	    /**
	     * ensure that the datas ordered property has a min and max
	     * if the data represents an ordered date range.
	     *
	     * @return {undefined}
	     */
	    Data.prototype._normalizeOrdered = function () {
	      if (!this.data.ordered || !this.data.ordered.date) return;

	      var missingMin = this.data.ordered.min == null;
	      var missingMax = this.data.ordered.max == null;

	      if (missingMax || missingMin) {
	        var extent = d3.extent(this.xValues());
	        if (missingMin) this.data.ordered.min = extent[0];
	        if (missingMax) this.data.ordered.max = extent[1];
	      }
	    };

	    /**
	     * Calculates min and max values for all map data
	     * series.rows is an array of arrays
	     * each row is an array of values
	     * last value in row array is bucket count
	     *
	     * @method mapDataExtents
	     * @param series {Array} Array of data objects
	     * @returns {Array} min and max values
	     */
	    Data.prototype.mapDataExtents = function (series) {
	      var values;
	      values = _.map(series.rows, function (row) {
	        return row[row.length - 1];
	      });
	      var extents = [_.min(values), _.max(values)];
	      return extents;
	    };

	    /**
	     * Get the maximum number of series, considering each chart
	     * individually.
	     *
	     * @return {number} - the largest number of series from all charts
	     */
	    Data.prototype.maxNumberOfSeries = function () {
	      return this.chartData().reduce(function (max, chart) {
	        return Math.max(max, chart.series.length);
	      }, 0);
	    };

	    return Data;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(339);
	__webpack_require__(354);
	__webpack_require__(355);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ZeroInjectionUtilService(Private) {
	    var _ = __webpack_require__(192);

	    var orderXValues = Private(__webpack_require__(339));
	    var createZeroFilledArray = Private(__webpack_require__(354));
	    var zeroFillDataArray = Private(__webpack_require__(355));

	    /*
	     * A Kibana data object may have multiple series with different array lengths.
	     * This proves an impediment to stacking in the visualization library.
	     * Therefore, zero values must be injected wherever these arrays do not line up.
	     * That is, each array must have the same x values with zeros filled in where the
	     * x values were added.
	     *
	     * This function and its helper functions accepts a Kibana data object
	     * and injects zeros where needed.
	     */

	    function getDataArray(obj) {
	      if (obj.rows) {
	        return obj.rows;
	      } else if (obj.columns) {
	        return obj.columns;
	      } else if (obj.series) {
	        return [obj];
	      }
	    }

	    return function (obj) {
	      if (!_.isObject(obj) || !obj.rows && !obj.columns && !obj.series) {
	        throw new TypeError('ZeroInjectionUtilService expects an object with a series, rows, or columns key');
	      }

	      var keys = orderXValues(obj);
	      var arr = getDataArray(obj);

	      arr.forEach(function (object) {
	        object.series.forEach(function (series) {
	          var zeroArray = createZeroFilledArray(keys);

	          series.values = zeroFillDataArray(zeroArray, series.values);
	        });
	      });

	      return obj;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(316);
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(340);

	'use strict';

	var _toConsumableArray = __webpack_require__(316)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function OrderedXKeysUtilService(Private) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);
	    var getUniqKeys = Private(__webpack_require__(340));

	    /*
	     * Accepts a Kibana data object and returns
	     * an array of x axis values.
	     * values sorted by timestamp if isDate and Date Histogram agg
	     * else values sorted by index
	     */

	    return function (obj) {
	      if (!_.isObject(obj)) {
	        throw new Error('OrderedXKeysUtilService expects an object');
	      }

	      var uniqKeys = getUniqKeys(obj);
	      var uniqKeysPairs = [].concat(_toConsumableArray(uniqKeys.entries()));

	      var interval = _.get(obj, 'ordered.interval');
	      var dateInterval = moment.isDuration(interval) ? interval : false;

	      return _(uniqKeysPairs).sortBy(function (d) {
	        if (d[1].isDate || d[1].isOrdered) {
	          return +d[0];
	        }
	        return d[1].index;
	      }).map(function (d, i, list) {
	        if (!d[1].isNumber) return d[0];

	        var val = +d[0];
	        if (interval == null) return val;

	        var gapEdge = parseFloat(_.get(list, [i + 1, 0]));
	        if (isNaN(gapEdge)) return val;

	        var vals = [];
	        var next = val;

	        if (dateInterval) {
	          next = moment(val);
	          while (next < gapEdge) {
	            vals.push(next.valueOf());
	            next.add(dateInterval);
	          }
	        } else {
	          while (next < gapEdge) {
	            vals.push(next);
	            next += interval;
	          }
	        }

	        return vals;
	      }).flatten().value();
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(341);
	__webpack_require__(192);
	__webpack_require__(353);

	'use strict';

	var _Map = __webpack_require__(341)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function UniqueXValuesUtilService(Private) {
	    var _ = __webpack_require__(192);

	    var flattenDataArray = Private(__webpack_require__(353));

	    /*
	     * Accepts a Kibana data object.
	     * Returns an object with unique x axis values as keys with an object of
	     * their index numbers and an isNumber boolean as their values.
	     * e.g. { 'xAxisValue': { index: 1, isNumber: false }}, ...
	     */

	    return function (obj) {
	      if (!_.isObject(obj)) {
	        throw new TypeError('UniqueXValuesUtilService expects an object');
	      }

	      var flattenedData = flattenDataArray(obj);
	      var uniqueXValues = new _Map();

	      var charts;
	      if (!obj.series) {
	        charts = obj.rows ? obj.rows : obj.columns;
	      } else {
	        charts = [obj];
	      }

	      var isDate = charts.every(function (chart) {
	        return chart.ordered && chart.ordered.date;
	      });

	      var isOrdered = charts.every(function (chart) {
	        return chart.ordered;
	      });

	      flattenedData.forEach(function (d, i) {
	        var key = d.x;
	        var prev = uniqueXValues.get(key);

	        if (d.xi != null) {
	          i = d.xi;
	        }

	        if (prev) {
	          i = Math.min(i, prev.index);
	        }

	        uniqueXValues.set(key, {
	          index: i,
	          isDate: isDate,
	          isOrdered: isOrdered,
	          isNumber: _.isNumber(key)
	        });
	      });

	      return uniqueXValues;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(342), __esModule: true };

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(343);
	__webpack_require__(292);
	__webpack_require__(272);
	__webpack_require__(344);
	__webpack_require__(351);
	module.exports = __webpack_require__(236).Map;

/***/ },
/* 343 */
/***/ function(module, exports) {

	

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(345);

	// 23.1 Map Objects
	__webpack_require__(350)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(203)
	  , hide         = __webpack_require__(283)
	  , ctx          = __webpack_require__(320)
	  , species      = __webpack_require__(346)
	  , strictNew    = __webpack_require__(347)
	  , defined      = __webpack_require__(245)
	  , forOf        = __webpack_require__(348)
	  , step         = __webpack_require__(275)
	  , ID           = __webpack_require__(289)('id')
	  , $has         = __webpack_require__(286)
	  , isObject     = __webpack_require__(232)
	  , isExtensible = Object.isExtensible || isObject
	  , SUPPORT_DESC = __webpack_require__(285)
	  , SIZE         = SUPPORT_DESC ? '_s' : 'size'
	  , id           = 0;

	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!$has(it, ID)){
	    // can't set id to frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add id
	    if(!create)return 'E';
	    // add missing object id
	    hide(it, ID, ++id);
	  // return object id with prefix
	  } return 'O' + it[ID];
	};

	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = $.create(null); // index
	      that._f = undefined;      // first entry
	      that._l = undefined;      // last entry
	      that[SIZE] = 0;           // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    __webpack_require__(349)(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(SUPPORT_DESC)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    __webpack_require__(280)(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    species(C);
	    species(__webpack_require__(236)[NAME]); // for wrapper
	  }
	};

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $       = __webpack_require__(203)
	  , SPECIES = __webpack_require__(287)('species');
	module.exports = function(C){
	  if(__webpack_require__(285) && !(SPECIES in C))$.setDesc(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 347 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name){
	  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
	  return it;
	};

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(320)
	  , call        = __webpack_require__(322)
	  , isArrayIter = __webpack_require__(323)
	  , anObject    = __webpack_require__(296)
	  , toLength    = __webpack_require__(324)
	  , getIterFn   = __webpack_require__(297);
	module.exports = function(iterable, entries, fn, that){
	  var iterFn = getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    call(iterator, f, step.value, entries);
	  }
	};

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var $redef = __webpack_require__(282);
	module.exports = function(target, src){
	  for(var key in src)$redef(target, key, src[key]);
	  return target;
	};

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $          = __webpack_require__(203)
	  , $def       = __webpack_require__(234)
	  , hide       = __webpack_require__(283)
	  , forOf      = __webpack_require__(348)
	  , strictNew  = __webpack_require__(347);

	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = __webpack_require__(235)[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!__webpack_require__(285) || typeof C != 'function'
	    || !(IS_WEAK || proto.forEach && !__webpack_require__(237)(function(){ new C().entries().next(); }))
	  ){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    __webpack_require__(349)(C.prototype, methods);
	  } else {
	    C = wrapper(function(target, iterable){
	      strictNew(target, C, NAME);
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
	      var chain = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return chain ? this : result;
	      });
	    });
	    if('size' in proto)$.setDesc(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }

	  __webpack_require__(291)(C, NAME);

	  O[NAME] = C;
	  $def($def.G + $def.W + $def.F, O);

	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

	  return C;
	};

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $def  = __webpack_require__(234);

	$def($def.P, 'Map', {toJSON: __webpack_require__(352)('Map')});

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var forOf   = __webpack_require__(348)
	  , classof = __webpack_require__(298);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    var arr = [];
	    forOf(this, false, arr.push, arr);
	    return arr;
	  };
	};

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FlattenDataObjectUtilService() {
	    var _ = __webpack_require__(192);

	    /*
	     * Accepts a Kibana data object, flattens the data.series values array,
	     * and returns an array of values objects.
	     */

	    return function (obj) {
	      var charts;

	      if (!_.isObject(obj) || !obj.rows && !obj.columns && !obj.series) {
	        throw new TypeError('FlattenDataObjUtilService expects an object with a series, rows, or columns key');
	      }

	      if (!obj.series) {
	        charts = obj.rows ? obj.rows : obj.columns;
	      }

	      return _(charts ? charts : [obj]).pluck('series').flattenDeep().pluck('values').flattenDeep().filter(Boolean).value();
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function ZeroFilledArrayUtilService() {
	    var _ = __webpack_require__(192);

	    /*
	     * Accepts an array of x axis values (strings or numbers).
	     * Returns a zero filled array.
	    */

	    return function (arr) {
	      if (!_.isArray(arr)) {
	        throw new Error('ZeroFilledArrayUtilService expects an array of strings or numbers');
	      }

	      var zeroFilledArray = [];

	      arr.forEach(function (val) {
	        zeroFilledArray.push({
	          x: val,
	          xi: Infinity,
	          y: 0
	        });
	      });

	      return zeroFilledArray;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ZeroFillDataArrayUtilService(Private) {
	    var _ = __webpack_require__(192);

	    /*
	     * Accepts an array of zero-filled y value objects (arr1)
	     * and a kibana data.series[i].values array of objects (arr2).
	     * Return a zero-filled array of objects (arr1).
	     */

	    return function (arr1, arr2) {
	      if (!_.isArray(arr1) || !_.isArray(arr2)) {
	        throw new TypeError('ZeroFillDataArrayUtilService expects 2 arrays');
	      }

	      var i;
	      var val;
	      var index;
	      var max = arr2.length;

	      var getX = function getX(d) {
	        return d.x === val.x;
	      };

	      for (i = 0; i < max; i++) {
	        val = arr2[i];
	        index = _.findIndex(arr1, getX);
	        arr1.splice(index, 1, val);
	      }

	      return arr1;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(357);
	__webpack_require__(359);
	__webpack_require__(360);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function LabelUtilService(Private) {
	    var _ = __webpack_require__(192);

	    var createArr = Private(__webpack_require__(357));
	    var getArrOfUniqLabels = Private(__webpack_require__(359));
	    var getPieLabels = Private(__webpack_require__(360));

	    /*
	     * Accepts a Kibana data object and returns an array of unique labels (strings).
	     * Extracts the field formatter from the raw object and passes it to the
	     * getArrOfUniqLabels function.
	     *
	     * Currently, this service is only used for vertical bar charts and line charts.
	     */
	    return function (obj, chartType) {
	      if (!_.isObject(obj)) {
	        throw new TypeError('LabelUtil expects an object');
	      }
	      if (chartType === 'pie') {
	        return getPieLabels(obj);
	      }
	      return getArrOfUniqLabels(createArr(obj));
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(358);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function GetArrayUtilService(Private) {
	    var _ = __webpack_require__(192);
	    var flattenSeries = Private(__webpack_require__(358));

	    /*
	     * Accepts a Kibana data object and returns an array of values objects.
	    */
	    return function (obj) {
	      if (!_.isObject(obj) || !obj.rows && !obj.columns && !obj.series) {
	        throw new TypeError('GetArrayUtilService expects an object with a series, rows, or columns key');
	      }

	      if (!obj.series) return flattenSeries(obj);
	      return obj.series;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function GetSeriesUtilService() {
	    var _ = __webpack_require__(192);

	    /*
	     * Accepts a Kibana data object with a rows or columns key
	     * and returns an array of flattened series values.
	     */
	    return function (obj) {
	      if (!_.isObject(obj) || !obj.rows && !obj.columns) {
	        throw new TypeError('GetSeriesUtilService expects an object with either a rows or columns key');
	      }

	      obj = obj.rows ? obj.rows : obj.columns;

	      return _.chain(obj).pluck('series').flattenDeep().value();
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function UniqLabelUtilService() {
	    var _ = __webpack_require__(192);

	    /*
	     * Accepts an array of data objects and a formatter function.
	     * Returns a unique list of formatted labels (strings).
	     */
	    return function (arr) {
	      if (!_.isArray(arr)) {
	        throw new TypeError('UniqLabelUtil expects an array of objects');
	      }

	      return _(arr).pluck('label').unique().value();
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(361);
	__webpack_require__(362);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function PieLabels(Private) {
	    var removeZeroSlices = Private(__webpack_require__(361));
	    var getNames = Private(__webpack_require__(362));

	    return function (obj) {
	      if (!_.isObject(obj)) {
	        throw new TypeError('PieLabel expects an object');
	      }

	      var data = obj.columns || obj.rows || [obj];
	      var names = [];

	      data.forEach(function (obj) {
	        var columns = obj.raw ? obj.raw.columns : undefined;
	        obj.slices = removeZeroSlices(obj.slices);

	        getNames(obj, columns).forEach(function (name) {
	          names.push(name);
	        });
	      });

	      return _.uniq(names);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function RemoveZeroSlices() {
	    return function removeZeroSlices(slices) {
	      if (!slices.children) return slices;

	      slices = _.clone(slices);
	      slices.children = slices.children.reduce(function (children, child) {
	        if (child.size !== 0) {
	          children.push(removeZeroSlices(child));
	        }
	        return children;
	      }, []);

	      return slices;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(363);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function GetPieNames(Private) {
	    var returnNames = Private(__webpack_require__(363));

	    return function (data, columns) {
	      var slices = data.slices;

	      if (slices.children) {
	        return _(returnNames(slices.children, 0, columns)).sortBy(function (obj) {
	          return obj.index;
	        }).pluck('key').unique().value();
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function ReturnPieNames() {
	    return function returnNames(array, index, columns) {
	      var names = [];

	      array.forEach(function (obj) {
	        names.push({ key: obj.name, index: index });

	        if (obj.children) {
	          returnNames(obj.children, index + 1, columns).forEach(function (namedObj) {
	            names.push(namedObj);
	          });
	        }
	      });

	      return names;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(365);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ColorUtilService(Private) {
	    var _ = __webpack_require__(192);
	    var mappedColors = Private(__webpack_require__(365));

	    /*
	     * Accepts an array of strings or numbers that are used to create a
	     * a lookup table that associates the values (key) with a hex color (value).
	     * Returns a function that accepts a value (i.e. a string or number)
	     * and returns a hex color associated with that value.
	     */

	    return function (arrayOfStringsOrNumbers) {
	      if (!_.isArray(arrayOfStringsOrNumbers)) {
	        throw new Error('ColorUtil expects an array');
	      }

	      arrayOfStringsOrNumbers.forEach(function (val) {
	        if (!_.isString(val) && !_.isNumber(val) && !_.isUndefined(val)) {
	          throw new TypeError('ColorUtil expects an array of strings, numbers, or undefined values');
	        }
	      });

	      mappedColors.mapKeys(arrayOfStringsOrNumbers);

	      return function (value) {
	        return mappedColors.get(value);
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(222);
	__webpack_require__(225);
	__webpack_require__(192);
	__webpack_require__(335);
	__webpack_require__(366);

	'use strict';

	var _createClass = __webpack_require__(222)['default'];

	var _classCallCheck = __webpack_require__(225)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function (Private, config) {
	    var _ = __webpack_require__(192);
	    var d3 = __webpack_require__(335);
	    var createColorPalette = Private(__webpack_require__(366));

	    var standardizeColor = function standardizeColor(color) {
	      return d3.rgb(color).toString();
	    };
	    function getConfigColorMapping() {
	      return _.mapValues(config.get('visualization:colorMapping'), standardizeColor);
	    }

	    /*
	     * Maintains a lookup table that associates the value (key) with a hex color (value)
	     * across the visualizations.
	     * Provides functions to interact with the lookup table
	     */

	    var MappedColors = (function () {
	      function MappedColors() {
	        _classCallCheck(this, MappedColors);

	        this.mapping = {};
	      }

	      _createClass(MappedColors, [{
	        key: 'get',
	        value: function get(key) {
	          return getConfigColorMapping()[key] || this.mapping[key];
	        }
	      }, {
	        key: 'mapKeys',
	        value: function mapKeys(keys) {
	          var _this = this;

	          var configMapping = getConfigColorMapping();
	          var configColors = _.values(configMapping);

	          var keysToMap = [];
	          _.each(keys, function (key) {
	            // If this key is mapped in the config, it's unnecessary to have it mapped here
	            if (configMapping[key]) delete _this.mapping[key];

	            // If this key is mapped to a color used by the config color mapping, we need to remap it
	            if (_.contains(configColors, _this.mapping[key])) keysToMap.push(key);

	            // If this key isn't mapped, we need to map it
	            if (_this.get(key) == null) keysToMap.push(key);
	          });

	          // Generate a color palette big enough that all new keys can have unique color values
	          var allColors = _(this.mapping).values().union(configColors).value();
	          var colorPalette = createColorPalette(allColors.length + keysToMap.length);
	          var newColors = _.difference(colorPalette, allColors);
	          _.merge(this.mapping, _.zipObject(keysToMap, newColors));
	        }
	      }]);

	      return MappedColors;
	    })();

	    return new MappedColors();
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(367);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ColorPaletteUtilService(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);

	    var seedColors = Private(__webpack_require__(367));

	    /*
	     * Generates an array of hex colors the length of the input number.
	     * If the number is greater than the length of seed colors available,
	     * new colors are generated up to the value of the input number.
	     */

	    var offset = 300; // Hue offset to start at

	    var fraction = function fraction(goal) {
	      var walkTree = function walkTree(_x, _x2, _x3) {
	        var _again = true;

	        _function: while (_again) {
	          var numerator = _x,
	              denominator = _x2,
	              bytes = _x3;
	          _again = false;

	          if (bytes.length) {
	            _x = numerator * 2 + (bytes.pop() ? 1 : -1);
	            _x2 = denominator * 2;
	            _x3 = bytes;
	            _again = true;
	            continue _function;
	          } else {
	            return numerator / denominator;
	          }
	        }
	      };

	      var b = (goal + 2).toString(2).split('').map(function (num) {
	        return parseInt(num, 10);
	      });
	      b.shift();

	      return walkTree(1, 2, b);
	    };

	    return function (num) {
	      if (!_.isNumber(num)) {
	        throw new TypeError('ColorPaletteUtilService expects a number');
	      }

	      var colors = seedColors;

	      var seedLength = seedColors.length;

	      _.times(num - seedLength, function (i) {
	        colors.push(d3.hsl((fraction(i + seedLength + 1) * 360 + offset) % 360, 0.5, 0.5).toString());
	      });

	      return colors;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  /*
	   * Using a random color generator presented awful colors and unpredictable color schemes.
	   * So we needed to come up with a color scheme of our own that creates consistent, pleasing color patterns.
	   * The order allows us to guarantee that 1st, 2nd, 3rd, etc values always get the same color.
	   * Returns an array of 72 colors.
	   */

	  return function SeedColorUtilService() {
	    return ['#57c17b', '#006e8a', '#6f87d8', '#663db8', '#bc52bc', '#9e3533', '#daa05d'];
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(369);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function LayoutFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);

	    var layoutType = Private(__webpack_require__(369));

	    /**
	     * Builds the visualization DOM layout
	     *
	     * The Layout Constructor is responsible for rendering the visualization
	     * layout, which includes all the DOM div elements.
	     * Input:
	     *   1. DOM div - parent element for which the layout is attached
	     *   2. data - data is bound to the div element
	     *   3. chartType (e.g. 'histogram') - specifies the layout type to grab
	     *
	     * @class Layout
	     * @constructor
	     * @param el {HTMLElement} HTML element to which the chart will be appended
	     * @param data {Object} Elasticsearch query results for this specific chart
	     * @param chartType {Object} Reference to chart functions, i.e. Pie
	     */
	    function Layout(el, data, chartType, opts) {
	      if (!(this instanceof Layout)) {
	        return new Layout(el, data, chartType, opts);
	      }

	      this.el = el;
	      this.data = data;
	      this.opts = opts;
	      this.layoutType = layoutType[chartType](this.el, this.data);
	    }

	    // Render the layout
	    /**
	     * Renders visualization HTML layout
	     * Remove all elements from the current visualization and creates the layout
	     *
	     * @method render
	     */
	    Layout.prototype.render = function () {
	      this.removeAll(this.el);
	      this.createLayout(this.layoutType);
	    };

	    /**
	     * Create the layout based on the json array provided
	     * for each object in the layout array, call the layout function
	     *
	     * @method createLayout
	     * @param arr {Array} Json array
	     * @returns {*} Creates the visualization layout
	     */
	    Layout.prototype.createLayout = function (arr) {
	      var self = this;

	      return _.each(arr, function (obj) {
	        self.layout(obj);
	      });
	    };

	    /**
	     * Appends a DOM element based on the object keys
	     * check to see if reference to DOM element is string but not class selector
	     * Create a class selector
	     *
	     * @method layout
	     * @param obj {Object} Instructions for creating the layout of a DOM Element
	     * @returns {*} DOM Element
	     */
	    Layout.prototype.layout = function (obj) {
	      if (!obj.parent) {
	        throw new Error('No parent element provided');
	      }

	      if (!obj.type) {
	        throw new Error('No element type provided');
	      }

	      if (typeof obj.type !== 'string') {
	        throw new Error(obj.type + ' must be a string');
	      }

	      if (typeof obj.parent === 'string' && obj.parent.charAt(0) !== '.') {
	        obj.parent = '.' + obj.parent;
	      }

	      var childEl = this.appendElem(obj.parent, obj.type, obj['class']);

	      if (obj.datum) {
	        childEl.datum(obj.datum);
	      }

	      if (obj.splits) {
	        childEl.call(obj.splits, obj.parent, this.opts);
	      }

	      if (obj.children) {
	        var newParent = childEl[0][0];

	        _.forEach(obj.children, function (obj) {
	          if (!obj.parent) {
	            obj.parent = newParent;
	          }
	        });

	        this.createLayout(obj.children);
	      }

	      return childEl;
	    };

	    /**
	     * Appends a `type` of DOM element to `el` and gives it a class name attribute `className`
	     *
	     * @method appendElem
	     * @param el {HTMLElement} Reference to a DOM Element
	     * @param type {String} DOM element type
	     * @param className {String} CSS class name
	     * @returns {*} Reference to D3 Selection
	     */
	    Layout.prototype.appendElem = function (el, type, className) {
	      if (!el || !type || !className) {
	        throw new Error('Function requires that an el, type, and class be provided');
	      }

	      if (typeof el === 'string') {
	        // Create a DOM reference with a d3 selection
	        // Need to make sure that the `el` is bound to this object
	        // to prevent it from being appended to another Layout
	        el = d3.select(this.el).select(el)[0][0];
	      }

	      return d3.select(el).append(type).attr('class', className);
	    };

	    /**
	     * Removes all DOM elements from DOM element
	     *
	     * @method removeAll
	     * @param el {HTMLElement} Reference to DOM element
	     * @returns {D3.Selection|D3.Transition.Transition} Reference to an empty DOM element
	     */
	    Layout.prototype.removeAll = function (el) {
	      return d3.select(el).selectAll('*').remove();
	    };

	    return Layout;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(370);
	__webpack_require__(375);
	__webpack_require__(378);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function LayoutTypeFactory(Private) {

	    /**
	     * Provides the HTML layouts for each visualization class
	     *
	     * @module vislib
	     * @submodule LayoutTypeFactory
	     * @param Private {Service} Loads any function as an angular module
	     * @return {Function} Returns an Object of HTML layouts for each visualization class
	     */
	    return {
	      histogram: Private(__webpack_require__(370)),
	      line: Private(__webpack_require__(370)),
	      area: Private(__webpack_require__(370)),
	      pie: Private(__webpack_require__(375)),
	      tile_map: Private(__webpack_require__(378))
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(371);
	__webpack_require__(372);
	__webpack_require__(373);
	__webpack_require__(374);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ColumnLayoutFactory(Private) {
	    var d3 = __webpack_require__(335);

	    var chartSplit = Private(__webpack_require__(371));
	    var yAxisSplit = Private(__webpack_require__(372));
	    var xAxisSplit = Private(__webpack_require__(373));
	    var chartTitleSplit = Private(__webpack_require__(374));

	    /**
	     * Specifies the visualization layout for column charts.
	     *
	     * This is done using an array of objects. The first object has
	     * a `parent` DOM element,  a DOM `type` (e.g. div, svg, etc),
	     * and a `class` (required). Each child can omit the parent object,
	     * but must include a type and class.
	     *
	     * Optionally, you can specify `datum` to be bound to the DOM
	     * element, a `splits` function that divides the selected element
	     * into more DOM elements based on a callback function provided, or
	     * a children array which nests other layout objects.
	     *
	     * Objects in children arrays are children of the current object and return
	     * DOM elements which are children of their respective parent element.
	     */

	    return function (el, data) {
	      if (!el || !data) {
	        throw new Error('Both an el and data need to be specified');
	      }

	      return [{
	        parent: el,
	        type: 'div',
	        'class': 'vis-wrapper',
	        datum: data,
	        children: [{
	          type: 'div',
	          'class': 'y-axis-col-wrapper',
	          children: [{
	            type: 'div',
	            'class': 'y-axis-col',
	            children: [{
	              type: 'div',
	              'class': 'y-axis-title'
	            }, {
	              type: 'div',
	              'class': 'y-axis-chart-title',
	              splits: chartTitleSplit
	            }, {
	              type: 'div',
	              'class': 'y-axis-div-wrapper',
	              splits: yAxisSplit
	            }]
	          }, {
	            type: 'div',
	            'class': 'y-axis-spacer-block'
	          }]
	        }, {
	          type: 'div',
	          'class': 'vis-col-wrapper',
	          children: [{
	            type: 'div',
	            'class': 'chart-wrapper',
	            splits: chartSplit
	          }, {
	            type: 'div',
	            'class': 'vis-alerts'
	          }, {
	            type: 'div',
	            'class': 'x-axis-wrapper',
	            children: [{
	              type: 'div',
	              'class': 'x-axis-div-wrapper',
	              splits: xAxisSplit
	            }, {
	              type: 'div',
	              'class': 'x-axis-chart-title',
	              splits: chartTitleSplit
	            }, {
	              type: 'div',
	              'class': 'x-axis-title'
	            }]
	          }]
	        }, {
	          type: 'div',
	          'class': 'legend-col-wrapper'
	        }]
	      }];
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function ChartSplitFactory() {
	    var d3 = __webpack_require__(335);

	    /*
	     * Adds div DOM elements to the `.chart-wrapper` element based on the data layout.
	     * For example, if the data has rows, it returns the same number of
	     * `.chart` elements as row objects.
	     */
	    return function split(selection) {
	      selection.each(function (data) {
	        var div = d3.select(this).attr('class', function () {
	          if (data.rows) {
	            return 'chart-wrapper-row';
	          } else if (data.columns) {
	            return 'chart-wrapper-column';
	          } else {
	            return 'chart-wrapper';
	          }
	        });
	        var divClass;

	        var charts = div.selectAll('charts').append('div').data(function (d) {
	          if (d.rows) {
	            divClass = 'chart-row';
	            return d.rows;
	          } else if (d.columns) {
	            divClass = 'chart-column';
	            return d.columns;
	          } else {
	            divClass = 'chart';
	            return [d];
	          }
	        }).enter().append('div').attr('class', function () {
	          return divClass;
	        });

	        if (!data.series) {
	          charts.call(split);
	        }
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function YAxisSplitFactory() {
	    var d3 = __webpack_require__(335);

	    /*
	     * Adds div DOM elements to the `.y-axis-div-wrapper` element based on the data layout.
	     * For example, if the data has rows, it returns the same number of
	     * `.y-axis-div` elements as row objects.
	     */

	    // render and get bounding box width
	    return function (selection, parent, opts) {
	      var yAxis = opts && opts.yAxis;

	      selection.each(function () {
	        var div = d3.select(this);

	        div.call(setWidth, yAxis);

	        div.selectAll('.y-axis-div').append('div').data(function (d) {
	          return d.rows ? d.rows : [d];
	        }).enter().append('div').attr('class', 'y-axis-div');
	      });
	    };

	    function setWidth(el, yAxis) {
	      if (!yAxis) return;

	      var padding = 5;
	      var height = parseInt(el.node().clientHeight, 10);

	      // render svg and get the width of the bounding box
	      var svg = d3.select('body').append('svg').attr('style', 'position:absolute; top:-10000; left:-10000');
	      var width = svg.append('g').call(yAxis.getYAxis(height)).node().getBBox().width + padding;
	      svg.remove();

	      el.style('width', width + padding + 'px');
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function XAxisSplitFactory() {
	    var d3 = __webpack_require__(335);

	    /*
	     * Adds div DOM elements to the `.x-axis-div-wrapper` element based on the data layout.
	     * For example, if the data has rows, it returns the same number of
	     * `.x-axis-div` elements as row objects.
	     */

	    return function (selection) {
	      selection.each(function () {
	        var div = d3.select(this);

	        div.selectAll('.x-axis-div').append('div').data(function (d) {
	          return d.columns ? d.columns : [d];
	        }).enter().append('div').attr('class', 'x-axis-div');
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function ChartTitleSplitFactory() {
	    var d3 = __webpack_require__(335);

	    /*
	     * Adds div DOM elements to either the `.y-axis-chart-title` element or the
	     * `.x-axis-chart-title` element based on the data layout.
	     * For example, if the data has rows, it returns the same number of
	     * `.chart-title` elements as row objects.
	     * if not data.rows or data.columns, return no chart titles
	     */
	    return function (selection) {
	      selection.each(function (data) {
	        var div = d3.select(this);

	        if (!data.series) {
	          div.selectAll('.chart-title').append('div').data(function (d) {
	            return d.rows ? d.rows : d.columns;
	          }).enter().append('div').attr('class', 'chart-title');

	          if (data.rows) {
	            d3.select('.x-axis-chart-title').remove();
	          } else {
	            d3.select('.y-axis-chart-title').remove();
	          }

	          return div;
	        }

	        return d3.select(this).remove();
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(376);
	__webpack_require__(377);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ColumnLayoutFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var chartSplit = Private(__webpack_require__(376));
	    var chartTitleSplit = Private(__webpack_require__(377));

	    /**
	     * Specifies the visualization layout for column charts.
	     *
	     * This is done using an array of objects. The first object has
	     * a `parent` DOM element,  a DOM `type` (e.g. div, svg, etc),
	     * and a `class` (required). Each child can omit the parent object,
	     * but must include a type and class.
	     *
	     * Optionally, you can specify `datum` to be bound to the DOM
	     * element, a `splits` function that divides the selected element
	     * into more DOM elements based on a callback function provided, or
	     * a children array which nests other layout objects.
	     *
	     * Objects in children arrays are children of the current object and return
	     * DOM elements which are children of their respective parent element.
	     */

	    return function (el, data) {
	      if (!el || !data) {
	        throw new Error('Both an el and data need to be specified');
	      }

	      return [{
	        parent: el,
	        type: 'div',
	        'class': 'vis-wrapper',
	        datum: data,
	        children: [{
	          type: 'div',
	          'class': 'y-axis-chart-title',
	          splits: chartTitleSplit
	        }, {
	          type: 'div',
	          'class': 'vis-col-wrapper',
	          children: [{
	            type: 'div',
	            'class': 'chart-wrapper',
	            splits: chartSplit
	          }, {
	            type: 'div',
	            'class': 'x-axis-chart-title',
	            splits: chartTitleSplit
	          }]
	        }, {
	          type: 'div',
	          'class': 'legend-col-wrapper'
	        }]
	      }];
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function ChartSplitFactory() {
	    var d3 = __webpack_require__(335);

	    /*
	     * Adds div DOM elements to the `.chart-wrapper` element based on the data layout.
	     * For example, if the data has rows, it returns the same number of
	     * `.chart` elements as row objects.
	     */

	    return function split(selection) {
	      selection.each(function (data) {
	        var div = d3.select(this).attr('class', function () {
	          if (data.rows) {
	            return 'chart-wrapper-row';
	          } else if (data.columns) {
	            return 'chart-wrapper-column';
	          } else {
	            return 'chart-wrapper';
	          }
	        });
	        var divClass;

	        var charts = div.selectAll('charts').append('div').data(function (d) {
	          if (d.rows) {
	            divClass = 'chart-row';
	            return d.rows;
	          } else if (d.columns) {
	            divClass = 'chart-column';
	            return d.columns;
	          } else {
	            divClass = 'chart';
	            return [d];
	          }
	        }).enter().append('div').attr('class', function () {
	          return divClass;
	        });

	        if (!data.slices) {
	          charts.call(split);
	        }
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function ChartTitleSplitFactory() {
	    var d3 = __webpack_require__(335);

	    /*
	     * Adds div DOM elements to either the `.y-axis-chart-title` element or the
	     * `.x-axis-chart-title` element based on the data layout.
	     * For example, if the data has rows, it returns the same number of
	     * `.chart-title` elements as row objects.
	     * if not data.rows or data.columns, return no chart titles
	     */

	    return function (selection, parent) {
	      selection.each(function (data) {
	        var div = d3.select(this);

	        if (!data.slices) {
	          div.selectAll('.chart-title').append('div').data(function (d) {
	            return d.rows ? d.rows : d.columns;
	          }).enter().append('div').attr('class', 'chart-title');

	          if (data.rows) {
	            d3.select(parent).select('.x-axis-chart-title').remove();
	          } else {
	            d3.select(parent).select('.y-axis-chart-title').remove();
	          }

	          return div;
	        }

	        return d3.select(this).remove();
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(379);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ColumnLayoutFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var mapSplit = Private(__webpack_require__(379));

	    /*
	     * Specifies the visualization layout for tile maps.
	     *
	     * This is done using an array of objects. The first object has
	     * a `parent` DOM element,  a DOM `type` (e.g. div, svg, etc),
	     * and a `class` (required). Each child can omit the parent object,
	     * but must include a type and class.
	     *
	     * Optionally, you can specify `datum` to be bound to the DOM
	     * element, a `splits` function that divides the selected element
	     * into more DOM elements based on a callback function provided, or
	     * a children array which nests other layout objects.
	     *
	     * Objects in children arrays are children of the current object and return
	     * DOM elements which are children of their respective parent element.
	     */

	    return function (el, data) {
	      if (!el || !data) {
	        throw new Error('Both an el and data need to be specified');
	      }

	      return [{
	        parent: el,
	        type: 'div',
	        'class': 'vis-wrapper',
	        datum: data,
	        children: [{
	          type: 'div',
	          'class': 'vis-col-wrapper',
	          children: [{
	            type: 'div',
	            'class': 'chart-wrapper',
	            splits: mapSplit
	          }]
	        }]
	      }];
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function ChartSplitFactory() {
	    var d3 = __webpack_require__(335);

	    /*
	     * Adds div DOM elements to the `.chart-wrapper` element based on the data layout.
	     * For example, if the data has rows, it returns the same number of
	     * `.chart` elements as row objects.
	     */
	    return function split(selection) {
	      selection.each(function (data) {
	        var div = d3.select(this).attr('class', function () {
	          // Determine the parent class
	          if (data.rows) {
	            return 'chart-wrapper-row';
	          } else if (data.columns) {
	            return 'chart-wrapper-column';
	          } else {
	            return 'chart-wrapper';
	          }
	        });
	        var divClass;

	        var charts = div.selectAll('charts').append('div').data(function (d) {
	          // Determine the child class
	          if (d.rows) {
	            divClass = 'chart-row';
	            return d.rows;
	          } else if (d.columns) {
	            divClass = 'chart-column';
	            return d.columns;
	          } else {
	            divClass = 'chart';
	            return [d];
	          }
	        }).enter().append('div').attr('class', function () {
	          return divClass;
	        });

	        if (!data.geoJson) {
	          charts.call(split);
	        }
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(381);
	__webpack_require__(337);
	__webpack_require__(384);
	__webpack_require__(385);
	__webpack_require__(364);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function LegendFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var Dispatch = Private(__webpack_require__(381));
	    var Data = Private(__webpack_require__(337));
	    var legendHeaderTemplate = _.template(__webpack_require__(384));
	    var dataLabel = __webpack_require__(385);
	    var color = Private(__webpack_require__(364));

	    /**
	     * Appends legend to the visualization
	     *
	     * @class Legend
	     * @constructor
	     * @param vis {Object} Reference to Vis Constructor
	     */
	    function Legend(vis) {
	      if (!(this instanceof Legend)) {
	        return new Legend(vis);
	      }

	      var data = vis.data.columns || vis.data.rows || [vis.data];
	      var type = vis._attr.type;
	      var labels = this.labels = this._getLabels(data, type);
	      var labelsArray = labels.map(function (obj) {
	        return obj.label;
	      });

	      this.events = new Dispatch();
	      this.vis = vis;
	      this.el = vis.el;
	      this.color = color(labelsArray);
	      this._attr = _.defaults({}, vis._attr || {}, {
	        'legendClass': 'legend-col-wrapper',
	        'blurredOpacity': 0.3,
	        'focusOpacity': 1,
	        'defaultOpacity': 1,
	        'legendDefaultOpacity': 1
	      });
	    }

	    Legend.prototype._getPieLabels = function (data) {
	      return Data.prototype.pieNames(data);
	    };

	    Legend.prototype._getSeriesLabels = function (data) {
	      var isOneSeries = data.every(function (chart) {
	        return chart.series.length === 1;
	      });

	      var values = data.map(function (chart) {
	        var yLabel = isOneSeries ? chart.yAxisLabel : undefined;

	        return chart.series.map(function (series) {
	          if (yLabel) series.label = yLabel;
	          return series;
	        });
	      }).reduce(function (a, b) {
	        return a.concat(b);
	      }, []);

	      return _.uniq(values, 'label');
	    };

	    Legend.prototype._getLabels = function (data, type) {
	      if (type === 'pie') return this._getPieLabels(data);
	      return this._getSeriesLabels(data);
	    };

	    /**
	     * Adds legend header
	     *
	     * @method header
	     * @param el {HTMLElement} Reference to DOM element
	     * @param args {Object|*} Legend options
	     * @returns {*} HTML element
	     */
	    Legend.prototype._header = function (el, args) {
	      var self = this;
	      return el.append('div').attr('class', 'header').append('div').attr('class', 'column-labels').html(function () {
	        return legendHeaderTemplate({ isOpen: self.vis.get('legendOpen') });
	      });
	    };

	    /**
	     * Adds list to legend
	     *
	     * @method list
	     * @param el {HTMLElement} Reference to DOM element
	     * @param arrOfLabels {Array} Array of labels
	     * @param args {Object|*} Legend options
	     * @returns {D3.Selection} HTML element with list of labels attached
	     */
	    Legend.prototype._list = function (el, data, args) {
	      var self = this;

	      return el.append('ul').attr('class', function () {
	        var className = 'legend-ul';
	        if (self.vis && !self.vis.get('legendOpen')) className += ' hidden';
	        return className;
	      }).selectAll('li').data(data).enter().append('li').attr('class', 'color').each(function (d) {
	        var li = d3.select(this);
	        self._addIdentifier.call(this, d);

	        li.append('i').attr('class', 'fa fa-circle dots').attr('style', 'color:' + args.color(d.label));

	        li.append('span').text(d.label);
	      });
	    };

	    /**
	     * Append the data label to the element
	     *
	     * @method _addIdentifier
	     * @param label {string} label to use
	     */
	    Legend.prototype._addIdentifier = function (d) {
	      dataLabel(this, d.label);
	    };

	    /**
	     * Renders legend
	     *
	     * @method render
	     * @return {HTMLElement} Legend
	     */
	    Legend.prototype.render = function () {
	      var self = this;
	      var visEl = d3.select(this.el);
	      var legendDiv = visEl.select('.' + this._attr.legendClass);
	      var items = this.labels;
	      this._header(legendDiv, this);
	      this._list(legendDiv, items, this);

	      var headerIcon = visEl.select('.legend-toggle');

	      // toggle legend open and closed
	      headerIcon.on('click', function legendClick() {
	        var legendOpen = !self.vis.get('legendOpen');
	        self.vis.set('legendOpen', legendOpen);

	        visEl.select('ul.legend-ul').classed('hidden', legendOpen);
	        self.vis.resize();
	      });

	      legendDiv.select('.legend-ul').selectAll('li').on('mouseover', function (d) {
	        var label = d.label;
	        var charts = visEl.selectAll('.chart');

	        function filterLabel() {
	          var pointLabel = this.getAttribute('data-label');
	          return pointLabel !== label.toString();
	        }

	        if (label && label !== 'Count') {
	          d3.select(this).style('cursor', 'pointer');
	        }

	        // legend
	        legendDiv.selectAll('li').filter(filterLabel).classed('blur_shape', true);

	        // all data-label attribute
	        charts.selectAll('[data-label]').filter(filterLabel).classed('blur_shape', true);

	        var eventEl = d3.select(this);
	        eventEl.style('white-space', 'inherit');
	        eventEl.style('word-break', 'break-all');
	      }).on('mouseout', function () {
	        /*
	         * The default opacity of elements in charts may be modified by the
	         * chart constructor, and so may differ from that of the legend
	         */

	        var charts = visEl.selectAll('.chart');

	        // legend
	        legendDiv.selectAll('li').classed('blur_shape', false);

	        // all data-label attribute
	        charts.selectAll('[data-label]').classed('blur_shape', false);

	        var eventEl = d3.select(this);
	        eventEl.style('white-space', 'nowrap');
	        eventEl.style('word-break', 'inherit');
	      });

	      legendDiv.selectAll('li.color').each(function (d) {
	        var label = d.label;
	        if (label !== undefined && label !== 'Count') {
	          d3.select(this).call(self.events.addClickEvent());
	        }
	      });
	    };

	    return Legend;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(382);
	__webpack_require__(248);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DispatchClass(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var Tooltip = Private(__webpack_require__(382));
	    var SimpleEmitter = __webpack_require__(248);

	    /**
	     * Handles event responses
	     *
	     * @class Dispatch
	     * @constructor
	     * @param handler {Object} Reference to Handler Class Object
	     */

	    _['class'](Dispatch).inherits(SimpleEmitter);
	    function Dispatch(handler) {
	      if (!(this instanceof Dispatch)) {
	        return new Dispatch(handler);
	      }

	      Dispatch.Super.call(this);
	      this.handler = handler;
	      this._listeners = {};
	    }

	    /**
	     * Response to click and hover events
	     *
	     * @param d {Object} Data point
	     * @param i {Number} Index number of data point
	     * @returns {{value: *, point: *, label: *, color: *, pointIndex: *,
	      * series: *, config: *, data: (Object|*),
	     * e: (d3.event|*), handler: (Object|*)}} Event response object
	     */
	    Dispatch.prototype.eventResponse = function (d, i) {
	      var datum = d._input || d;
	      var data = d3.event.target.nearestViewportElement ? d3.event.target.nearestViewportElement.__data__ : d3.event.target.__data__;
	      var label = d.label ? d.label : d.name;
	      var isSeries = !!(data && data.series);
	      var isSlices = !!(data && data.slices);
	      var series = isSeries ? data.series : undefined;
	      var slices = isSlices ? data.slices : undefined;
	      var handler = this.handler;
	      var color = _.get(handler, 'data.color');
	      var isPercentage = handler && handler._attr.mode === 'percentage';

	      var eventData = {
	        value: d.y,
	        point: datum,
	        datum: datum,
	        label: label,
	        color: color ? color(label) : undefined,
	        pointIndex: i,
	        series: series,
	        slices: slices,
	        config: handler && handler._attr,
	        data: data,
	        e: d3.event,
	        handler: handler
	      };

	      if (isSeries) {
	        // Find object with the actual d value and add it to the point object
	        var object = _.find(series, { 'label': d.label });
	        eventData.value = +object.values[i].y;

	        if (isPercentage) {
	          // Add the formatted percentage to the point object
	          eventData.percent = (100 * d.y).toFixed(1) + '%';
	        }
	      }

	      return eventData;
	    };

	    /**
	     * Returns a function that adds events and listeners to a D3 selection
	     *
	     * @method addEvent
	     * @param event {String}
	     * @param callback {Function}
	     * @returns {Function}
	     */
	    Dispatch.prototype.addEvent = function (event, callback) {
	      return function (selection) {
	        selection.each(function () {
	          var element = d3.select(this);

	          if (typeof callback === 'function') {
	            return element.on(event, callback);
	          }
	        });
	      };
	    };

	    /**
	     *
	     * @method addHoverEvent
	     * @returns {Function}
	     */
	    Dispatch.prototype.addHoverEvent = function () {
	      var self = this;
	      var isClickable = this.listenerCount('click') > 0;
	      var addEvent = this.addEvent;
	      var $el = this.handler.el;

	      function hover(d, i) {
	        // Add pointer if item is clickable
	        if (isClickable) {
	          self.addMousePointer.call(this, arguments);
	        }

	        self.highlightLegend.call(this, $el);
	        self.emit('hover', self.eventResponse(d, i));
	      }

	      return addEvent('mouseover', hover);
	    };

	    /**
	     *
	     * @method addMouseoutEvent
	     * @returns {Function}
	     */
	    Dispatch.prototype.addMouseoutEvent = function () {
	      var self = this;
	      var addEvent = this.addEvent;
	      var $el = this.handler.el;

	      function mouseout() {
	        self.unHighlightLegend.call(this, $el);
	      }

	      return addEvent('mouseout', mouseout);
	    };

	    /**
	     *
	     * @method addClickEvent
	     * @returns {Function}
	     */
	    Dispatch.prototype.addClickEvent = function () {
	      var self = this;
	      var addEvent = this.addEvent;

	      function click(d, i) {
	        self.emit('click', self.eventResponse(d, i));
	      }

	      return addEvent('click', click);
	    };

	    /**
	     * Determine if we will allow brushing
	     *
	     * @method allowBrushing
	     * @returns {Boolean}
	     */
	    Dispatch.prototype.allowBrushing = function () {
	      var xAxis = this.handler.xAxis;
	      return Boolean(xAxis.ordered && xAxis.xScale && _.isFunction(xAxis.xScale.invert));
	    };

	    /**
	     * Determine if brushing is currently enabled
	     *
	     * @method isBrushable
	     * @returns {Boolean}
	     */
	    Dispatch.prototype.isBrushable = function () {
	      return this.allowBrushing() && this.listenerCount('brush') > 0;
	    };

	    /**
	     *
	     * @param svg
	     * @returns {Function}
	     */
	    Dispatch.prototype.addBrushEvent = function (svg) {
	      if (!this.isBrushable()) return;

	      var xScale = this.handler.xAxis.xScale;
	      var yScale = this.handler.xAxis.yScale;
	      var brush = this.createBrush(xScale, svg);

	      function brushEnd() {
	        if (!validBrushClick(d3.event)) return;

	        var bar = d3.select(this);
	        var startX = d3.mouse(svg.node());
	        var startXInv = xScale.invert(startX[0]);

	        // Reset the brush value
	        brush.extent([startXInv, startXInv]);

	        // Magic!
	        // Need to call brush on svg to see brush when brushing
	        // while on top of bars.
	        // Need to call brush on bar to allow the click event to be registered
	        svg.call(brush);
	        bar.call(brush);
	      }

	      return this.addEvent('mousedown', brushEnd);
	    };

	    /**
	     * Mouseover Behavior
	     *
	     * @method addMousePointer
	     * @returns {D3.Selection}
	     */
	    Dispatch.prototype.addMousePointer = function () {
	      return d3.select(this).style('cursor', 'pointer');
	    };

	    /**
	     * Mouseover Behavior
	     *
	     * @param element {D3.Selection}
	     * @method highlightLegend
	     */
	    Dispatch.prototype.highlightLegend = function (element) {
	      var label = this.getAttribute('data-label');

	      if (!label) return;

	      d3.select(element).select('.legend-ul').selectAll('li.color').filter(function (d, i) {
	        return String(d.label) !== label;
	      }).classed('blur_shape', true);
	    };

	    /**
	     * Mouseout Behavior
	     *
	     * @param element {D3.Selection}
	     * @method unHighlightLegend
	     */
	    Dispatch.prototype.unHighlightLegend = function (element) {
	      d3.select(element).select('.legend-ul').selectAll('li.color').classed('blur_shape', false);
	    };

	    /**
	     * Adds D3 brush to SVG and returns the brush function
	     *
	     * @param xScale {Function} D3 xScale function
	     * @param svg {HTMLElement} Reference to SVG
	     * @returns {*} Returns a D3 brush function and a SVG with a brush group attached
	     */
	    Dispatch.prototype.createBrush = function (xScale, svg) {
	      var self = this;
	      var attr = self.handler._attr;
	      var height = attr.height;
	      var margin = attr.margin;

	      // Brush scale
	      var brush = d3.svg.brush().x(xScale).on('brushend', function brushEnd() {

	        // Assumes data is selected at the chart level
	        // In this case, the number of data objects should always be 1
	        var data = d3.select(this).data()[0];
	        var isTimeSeries = data.ordered && data.ordered.date;

	        // Allows for brushing on d3.scale.ordinal()
	        var selected = xScale.domain().filter(function (d) {
	          return brush.extent()[0] <= xScale(d) && xScale(d) <= brush.extent()[1];
	        });
	        var range = isTimeSeries ? brush.extent() : selected;

	        return self.emit('brush', {
	          range: range,
	          config: attr,
	          e: d3.event,
	          data: data
	        });
	      });

	      // if `addBrushing` is true, add brush canvas
	      if (self.listenerCount('brush')) {
	        svg.insert('g', 'g').attr('class', 'brush').call(brush).call(function (brushG) {
	          // hijack the brush start event to filter out right/middle clicks
	          var brushHandler = brushG.on('mousedown.brush');
	          if (!brushHandler) return; // touch events in use
	          brushG.on('mousedown.brush', function () {
	            if (validBrushClick(d3.event)) brushHandler.apply(this, arguments);
	          });
	        }).selectAll('rect').attr('height', height - margin.top - margin.bottom);

	        return brush;
	      }
	    };

	    function validBrushClick(event) {
	      return event.button === 0;
	    }

	    return Dispatch;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var d3 = __webpack_require__(335);
	var _ = __webpack_require__(192);
	var $ = __webpack_require__(206);
	var Binder = __webpack_require__(336);
	var positionTooltip = __webpack_require__(383);

	var allContents = [];

	/**
	 * Add tooltip and listeners to visualization elements
	 *
	 * @class Tooltip
	 * @constructor
	 * @param el {HTMLElement} Reference to DOM element
	 * @param formatter {Function} Tooltip formatter
	 * @param events {Constructor} Allows tooltip to return event response data
	 */
	function Tooltip(id, el, formatter, events) {
	  if (!(this instanceof Tooltip)) {
	    return new Tooltip(id, el, formatter, events);
	  }

	  this.id = id; // unique id for this tooltip type
	  this.el = el;
	  this.order = 100; // higher ordered contents are rendered below the others
	  this.formatter = formatter;
	  this.events = events;
	  this.containerClass = 'vis-wrapper';
	  this.tooltipClass = 'vis-tooltip';
	  this.tooltipSizerClass = 'vis-tooltip-sizing-clone';
	  this.showCondition = _.constant(true);

	  this.binder = new Binder();
	}

	/**
	 * Get jquery reference to the tooltip node
	 *
	 * @return {Object} jQuery node object
	 */
	Tooltip.prototype.$get = _.once(function () {
	  return $('<div>').addClass(this.tooltipClass).appendTo(document.body);
	});

	/**
	 * Get jquery reference to the tooltip sizer node
	 *
	 * @return {Object} jQuery node object
	 */
	Tooltip.prototype.$getSizer = _.once(function () {
	  return this.$get().clone().removeClass(this.tooltipClass).addClass(this.tooltipSizerClass).appendTo(document.body);
	});

	/**
	 * Show the tooltip, positioning it based on the content and chart container
	 */
	Tooltip.prototype.show = function () {
	  var $tooltip = this.$get();
	  var $chart = this.$getChart();
	  var html = $tooltip.html();

	  if (!$chart) return;

	  var placement = positionTooltip({
	    $window: $(window),
	    $chart: $chart,
	    $el: $tooltip,
	    $sizer: this.$getSizer(),
	    event: d3.event
	  }, html);

	  $tooltip.css({
	    visibility: 'visible',
	    left: placement.left,
	    top: placement.top
	  });
	};

	/**
	 * Hide the tooltip, clearing its contents
	 */
	Tooltip.prototype.hide = function () {
	  var $tooltip = this.$get();
	  allContents = [];
	  $tooltip.css({
	    visibility: 'hidden',
	    left: '-500px',
	    top: '-500px'
	  });
	};

	/**
	 * Get the jQuery chart node, based on the container object
	 * NOTE: the container is a d3 selection
	 *
	 * @return {Object} jQuery node for the chart
	 */
	Tooltip.prototype.$getChart = function () {
	  var chart = $(this.container && this.container.node());
	  return chart.size() ? chart : false;
	};

	/**
	 * Renders tooltip
	 *
	 * @method render
	 * @return {Function} Renders tooltip on a D3 selection
	 */
	Tooltip.prototype.render = function () {
	  var self = this;

	  /**
	   * Calculates values for the tooltip placement
	   *
	   * @param {Object} selection D3 selection object
	   */
	  return function (selection) {
	    var $tooltip = self.$get();
	    var id = self.id;
	    var order = self.order;

	    var tooltipSelection = d3.select($tooltip.get(0));

	    if (self.container === undefined || self.container !== d3.select(self.el).select('.' + self.containerClass)) {
	      self.container = d3.select(self.el).select('.' + self.containerClass);
	    }

	    var $chart = self.$getChart();
	    if ($chart) {
	      self.binder.jqOn($chart, 'mouseleave', function (event) {
	        // only clear when we leave the chart, so that
	        // moving between points doesn't make it reposition
	        $chart.removeData('previousPlacement');
	      });
	    }

	    selection.each(function (d, i) {
	      var element = d3.select(this);

	      function render(html) {
	        allContents = _.filter(allContents, function (content) {
	          return content.id !== id;
	        });

	        if (html) allContents.push({ id: id, html: html, order: order });

	        var allHtml = _(allContents).sortBy('order').pluck('html').compact().join('\n');

	        if (allHtml) {
	          $tooltip.html(allHtml);
	          self.show();
	        } else {
	          self.hide();
	        }
	      }

	      self.binder.fakeD3Bind(this, 'mousemove', function () {
	        if (!self.showCondition.call(element, d, i)) {
	          return render();
	        }

	        var events = self.events ? self.events.eventResponse(d, i) : d;
	        return render(self.formatter(events));
	      });

	      self.binder.fakeD3Bind(this, 'mouseleave', function () {
	        render();
	      });
	    });
	  };
	};

	Tooltip.prototype.destroy = function () {
	  this.binder.destroy();
	};

	module.exports = function TooltipFactoryProvider() {
	  return Tooltip;
	};

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(192);
	var $ = __webpack_require__(206);

	var OFFSET = 10;
	var $clone;

	// translate css properties into their basic direction
	var propDirs = {
	  top: 'north',
	  left: 'west'
	};

	function positionTooltip(opts, html) {
	  if (!opts) return;
	  var $chart = $(opts.$chart);
	  var $el = $(opts.$el);
	  var $window = $(opts.$window || window);
	  var $sizer = $(opts.$sizer);
	  var prev = $chart.data('previousPlacement') || {};
	  var event = opts.event;

	  if (!$chart.size() || !$el.size()) return;

	  var size = getTtSize(html || $el.html(), $sizer);
	  var pos = getBasePosition(size, event);
	  var overflow = getOverflow(size, pos, [$chart, $window]);

	  var placement = placeToAvoidOverflow(pos, prev, overflow);
	  $chart.data('previousPlacement', placement);
	  return placement;
	}

	function getTtSize(ttHtml, $sizer) {
	  if ($sizer.html() !== ttHtml) {
	    $sizer.html(ttHtml);
	  }

	  var size = {
	    width: $sizer.outerWidth(),
	    height: $sizer.outerHeight()
	  };

	  return size;
	}

	function getBasePosition(size, event) {
	  return {
	    east: event.clientX + OFFSET,
	    west: event.clientX - size.width - OFFSET,
	    south: event.clientY + OFFSET,
	    north: event.clientY - size.height - OFFSET
	  };
	}

	function getBounds($el) {
	  // in testing, $window is not actually a window, so we need to add
	  // the offsets to make it work right.
	  var bounds = $el.offset() || { top: 0, left: 0 };
	  bounds.top += $el.scrollTop();
	  bounds.left += $el.scrollLeft();
	  bounds.bottom = bounds.top + $el.outerHeight();
	  bounds.right = bounds.left + $el.outerWidth();
	  return bounds;
	}

	function getOverflow(size, pos, containers) {
	  var overflow = {};

	  containers.map(getBounds).forEach(function (bounds) {
	    // number of pixels that the toolip would overflow it's far
	    // side, if we placed it that way. (negative === no overflow)
	    mergeOverflows(overflow, {
	      north: bounds.top - pos.north,
	      east: pos.east + size.width - bounds.right,
	      south: pos.south + size.height - bounds.bottom,
	      west: bounds.left - pos.west
	    });
	  });

	  (window.overflows || (window.overflows = [])).push(overflow);
	  return overflow;
	}

	function mergeOverflows(dest, src) {
	  return _.merge(dest, src, function (a, b) {
	    if (a == null || b == null) return a || b;
	    if (a < 0 && b < 0) return Math.min(a, b);
	    return Math.max(a, b);
	  });
	}

	function pickPlacement(prop, pos, overflow, prev, pref, fallback, placement) {
	  var stash = '_' + prop;

	  // list of directions in order of preference
	  var dirs = _.unique([prev[stash], pref, fallback].filter(Boolean));

	  var dir;
	  var value;

	  // find the first direction that doesn't overflow
	  for (var i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (overflow[dir] > 0) continue;
	    value = pos[dir];
	    break;
	  }

	  // if we don't find one that doesn't overflow, use
	  // the first choice and offset based on overflo
	  if (value == null) {
	    dir = dirs[0];

	    var offset = overflow[dir];
	    if (propDirs[prop] === dir) {
	      // when the property represents the same direction
	      // as dir, we flip the overflow
	      offset = offset * -1;
	    }

	    value = pos[dir] - offset;
	  }

	  placement[prop] = value;
	  placement[stash] = dir;
	}

	function placeToAvoidOverflow(pos, prev, overflow) {
	  var placement = {};
	  pickPlacement('top', pos, overflow, prev, 'south', 'north', placement);
	  pickPlacement('left', pos, overflow, prev, 'east', 'west', placement);
	  return placement;
	}

	// expose units/helpers for testing
	positionTooltip.getTtSize = getTtSize;
	positionTooltip.getBasePosition = getBasePosition;
	positionTooltip.getOverflow = getOverflow;
	positionTooltip.getBounds = getBounds;
	positionTooltip.placeToAvoidOverflow = placeToAvoidOverflow;
	positionTooltip.removeClone = function () {
	  $clone && $clone.remove();
	  $clone = null;
	};

	module.exports = positionTooltip;

/***/ },
/* 384 */
/***/ function(module, exports) {

	module.exports = "<div class=\"legend-toggle\">\n  <strong>\n    <%= (isOpen) ?\n      '<span class=\"legend-open\">Legend <i class=\"fa fa-arrow-circle-right\"></i></span>' :\n      '<span class=\"legend-closed\"><i class=\"fa fa-arrow-circle-left\"></i></span>'\n    %>\n  </strong>\n</div>"

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var d3 = __webpack_require__(335);
	  /**
	   * Creates a string based on the hex color passed in
	   *
	   * @method dataLabel
	   * @param d {Object} object to wrap in d3.select
	   * @returns {string} label value
	   */
	  function dataLabel(selection, label) {
	    d3.select(selection).attr('data-label', label);
	  }

	  return dataLabel;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(387);
	__webpack_require__(382);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ChartTitleFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);

	    var ErrorHandler = Private(__webpack_require__(387));
	    var Tooltip = Private(__webpack_require__(382));

	    /**
	     * Appends chart titles to the visualization
	     *
	     * @class ChartTitle
	     * @constructor
	     * @param el {HTMLElement} Reference to DOM element
	     */
	    _['class'](ChartTitle).inherits(ErrorHandler);
	    function ChartTitle(el) {
	      if (!(this instanceof ChartTitle)) {
	        return new ChartTitle(el);
	      }

	      this.el = el;
	      this.tooltip = new Tooltip('chart-title', el, function (d) {
	        return '<p>' + _.escape(d.label) + '</p>';
	      });
	    }

	    /**
	     * Renders chart titles
	     *
	     * @method render
	     * @returns {D3.Selection|D3.Transition.Transition} DOM element with chart titles
	     */
	    ChartTitle.prototype.render = function () {
	      var el = d3.select(this.el).select('.chart-title').node();
	      var width = el ? el.clientWidth : 0;
	      var height = el ? el.clientHeight : 0;

	      return d3.select(this.el).selectAll('.chart-title').call(this.draw(width, height));
	    };

	    /**
	     * Truncates chart title text
	     *
	     * @method truncate
	     * @param size {Number} Height or width of the HTML Element
	     * @returns {Function} Truncates text
	     */
	    ChartTitle.prototype.truncate = function (size) {
	      var self = this;

	      return function (selection) {
	        selection.each(function () {
	          var text = d3.select(this);
	          var n = text[0].length;
	          var maxWidth = size / n * 0.9;
	          var length = this.getComputedTextLength();
	          var str;
	          var avg;
	          var end;

	          if (length > maxWidth) {
	            str = text.text();
	            avg = length / str.length;
	            end = Math.floor(maxWidth / avg) - 5;
	            str = str.substr(0, end) + '...';
	            self.addMouseEvents(text);

	            return text.text(str);
	          }

	          return text.text();
	        });
	      };
	    };

	    /**
	     * Adds tooltip events on truncated chart titles
	     *
	     * @method addMouseEvents
	     * @param target {HTMLElement} DOM element to attach event listeners
	     * @returns {*} DOM element with event listeners attached
	     */
	    ChartTitle.prototype.addMouseEvents = function (target) {
	      if (this.tooltip) {
	        return target.call(this.tooltip.render());
	      }
	    };

	    /**
	     * Appends chart titles to the visualization
	     *
	     * @method draw
	     * @returns {Function} Appends chart titles to a D3 selection
	     */
	    ChartTitle.prototype.draw = function (width, height) {
	      var self = this;

	      return function (selection) {
	        selection.each(function () {
	          var div = d3.select(this);
	          var dataType = this.parentNode.__data__.rows ? 'rows' : 'columns';
	          var size = dataType === 'rows' ? height : width;
	          var txtHtOffset = 11;

	          self.validateWidthandHeight(width, height);

	          div.append('svg').attr('width', width).attr('height', height).append('text').attr('transform', function () {
	            if (dataType === 'rows') {
	              return 'translate(' + txtHtOffset + ',' + height / 2 + ')rotate(270)';
	            }
	            return 'translate(' + width / 2 + ',' + txtHtOffset + ')';
	          }).attr('text-anchor', 'middle').text(function (d) {
	            return d.label;
	          });

	          // truncate long chart titles
	          div.selectAll('text').call(self.truncate(size));
	        });
	      };
	    };

	    return ChartTitle;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var errors = __webpack_require__(220);

	  return function ErrorHandlerFactory() {

	    /**
	     * Common errors shared between constructors
	     *
	     * @class ErrorHandler
	     * @constructor
	     */
	    function ErrorHandler() {}

	    /**
	     * Validates the height and width are > 0
	     * min size must be at least 1 px
	     *
	     * @method validateWidthandHeight
	     * @param width {Number} HTMLElement width
	     * @param height {Number} HTMLElement height
	     * @returns {HTMLElement} HTML div with an error message
	     */
	    ErrorHandler.prototype.validateWidthandHeight = function (width, height) {
	      var badWidth = _.isNaN(width) || width <= 0;
	      var badHeight = _.isNaN(height) || height <= 0;

	      if (badWidth || badHeight) {
	        throw new errors.ContainerTooSmall();
	      }
	    };

	    return ErrorHandler;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(338);
	__webpack_require__(334);
	__webpack_require__(337);
	__webpack_require__(380);
	__webpack_require__(389);
	__webpack_require__(390);
	__webpack_require__(391);
	__webpack_require__(386);
	__webpack_require__(392);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ColumnHandler(Private) {
	    var injectZeros = Private(__webpack_require__(338));
	    var Handler = Private(__webpack_require__(334));
	    var Data = Private(__webpack_require__(337));
	    var Legend = Private(__webpack_require__(380));
	    var XAxis = Private(__webpack_require__(389));
	    var YAxis = Private(__webpack_require__(390));
	    var AxisTitle = Private(__webpack_require__(391));
	    var ChartTitle = Private(__webpack_require__(386));
	    var Alerts = Private(__webpack_require__(392));

	    /*
	     * Create handlers for Area, Column, and Line charts which
	     * are all nearly the same minus a few details
	     */
	    function create(opts) {
	      opts = opts || {};

	      return function (vis) {
	        var isUserDefinedYAxis = vis._attr.setYExtents;
	        var data;

	        if (opts.zeroFill) {
	          data = new Data(injectZeros(vis.data), vis._attr);
	        } else {
	          data = new Data(vis.data, vis._attr);
	        }

	        return new Handler(vis, {
	          data: data,
	          legend: new Legend(vis, vis.data),
	          axisTitle: new AxisTitle(vis.el, data.get('xAxisLabel'), data.get('yAxisLabel')),
	          chartTitle: new ChartTitle(vis.el),
	          xAxis: new XAxis({
	            el: vis.el,
	            xValues: data.xValues(),
	            ordered: data.get('ordered'),
	            xAxisFormatter: data.get('xAxisFormatter'),
	            expandLastBucket: opts.expandLastBucket,
	            _attr: vis._attr
	          }),
	          alerts: new Alerts(vis, data, opts.alerts),
	          yAxis: new YAxis({
	            el: vis.el,
	            yMin: isUserDefinedYAxis ? vis._attr.yAxis.min : data.getYMin(),
	            yMax: isUserDefinedYAxis ? vis._attr.yAxis.max : data.getYMax(),
	            yAxisFormatter: data.get('yAxisFormatter'),
	            _attr: vis._attr
	          })
	        });
	      };
	    }

	    return {
	      line: create(),

	      column: create({
	        zeroFill: true,
	        expandLastBucket: true
	      }),

	      area: create({
	        zeroFill: true,
	        alerts: [{
	          type: 'warning',
	          msg: 'Positive and negative values are not accurately represented by stacked ' + 'area charts. Either changing the chart mode to "overlap" or using a ' + 'bar chart is recommended.',
	          test: function test(vis, data) {
	            if (!data.shouldBeStacked() || data.maxNumberOfSeries() < 2) return;

	            var hasPos = data.getYMax(data._getY) > 0;
	            var hasNeg = data.getYMin(data._getY) < 0;
	            return hasPos && hasNeg;
	          }
	        }, {
	          type: 'warning',
	          msg: 'Parts of or the entire area chart might not be displayed due to null ' + 'values in the data. A line chart is recommended when displaying data ' + 'with null values.',
	          test: function test(vis, data) {
	            return data.hasNullValues();
	          }
	        }]
	      })
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(387);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function XAxisFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);

	    var ErrorHandler = Private(__webpack_require__(387));

	    /**
	     * Adds an x axis to the visualization
	     *
	     * @class XAxis
	     * @constructor
	     * @param args {{el: (HTMLElement), xValues: (Array), ordered: (Object|*),
	     * xAxisFormatter: (Function), _attr: (Object|*)}}
	     */
	    _['class'](XAxis).inherits(ErrorHandler);
	    function XAxis(args) {
	      if (!(this instanceof XAxis)) {
	        return new XAxis(args);
	      }

	      this.el = args.el;
	      this.xValues = args.xValues;
	      this.ordered = args.ordered;
	      this.xAxisFormatter = args.xAxisFormatter;
	      this.expandLastBucket = args.expandLastBucket == null ? true : args.expandLastBucket;
	      this._attr = _.defaults(args._attr || {});
	    }

	    /**
	     * Renders the x axis
	     *
	     * @method render
	     * @returns {D3.UpdateSelection} Appends x axis to visualization
	     */
	    XAxis.prototype.render = function () {
	      d3.select(this.el).selectAll('.x-axis-div').call(this.draw());
	    };

	    /**
	     * Returns d3 x axis scale function.
	     * If time, return time scale, else return d3 ordinal scale for nominal data
	     *
	     * @method getScale
	     * @returns {*} D3 scale function
	     */
	    XAxis.prototype.getScale = function () {
	      var ordered = this.ordered;

	      if (ordered && ordered.date) {
	        return d3.time.scale.utc();
	      }
	      return d3.scale.ordinal();
	    };

	    /**
	     * Add domain to the x axis scale.
	     * if time, return a time domain, and calculate the min date, max date, and time interval
	     * else, return a nominal (d3.scale.ordinal) domain, i.e. array of x axis values
	     *
	     * @method getDomain
	     * @param scale {Function} D3 scale
	     * @returns {*} D3 scale function
	     */
	    XAxis.prototype.getDomain = function (scale) {
	      var ordered = this.ordered;

	      if (ordered && ordered.date) {
	        return this.getTimeDomain(scale, this.xValues);
	      }
	      return this.getOrdinalDomain(scale, this.xValues);
	    };

	    /**
	     * Returns D3 time domain
	     *
	     * @method getTimeDomain
	     * @param scale {Function} D3 scale function
	     * @param data {Array}
	     * @returns {*} D3 scale function
	     */
	    XAxis.prototype.getTimeDomain = function (scale, data) {
	      return scale.domain([this.minExtent(data), this.maxExtent(data)]);
	    };

	    XAxis.prototype.minExtent = function (data) {
	      return this._calculateExtent(data || this.xValues, 'min');
	    };

	    XAxis.prototype.maxExtent = function (data) {
	      return this._calculateExtent(data || this.xValues, 'max');
	    };

	    /**
	     *
	     * @param data
	     * @param extent
	     */
	    XAxis.prototype._calculateExtent = function (data, extent) {
	      var ordered = this.ordered;
	      var opts = [ordered[extent]];

	      var point = d3[extent](data);
	      if (this.expandLastBucket && extent === 'max') {
	        point = this.addInterval(point);
	      }
	      opts.push(point);

	      return d3[extent](opts.reduce(function (opts, v) {
	        if (!_.isNumber(v)) v = +v;
	        if (!isNaN(v)) opts.push(v);
	        return opts;
	      }, []));
	    };

	    /**
	     * Add the interval to a point on the x axis,
	     * this properly adds dates if needed.
	     *
	     * @param {number} x - a value on the x-axis
	     * @returns {number} - x + the ordered interval
	     */
	    XAxis.prototype.addInterval = function (x) {
	      return this.modByInterval(x, +1);
	    };

	    /**
	     * Subtract the interval to a point on the x axis,
	     * this properly subtracts dates if needed.
	     *
	     * @param {number} x - a value on the x-axis
	     * @returns {number} - x - the ordered interval
	     */
	    XAxis.prototype.subtractInterval = function (x) {
	      return this.modByInterval(x, -1);
	    };

	    /**
	     * Modify the x value by n intervals, properly
	     * handling dates if needed.
	     *
	     * @param {number} x - a value on the x-axis
	     * @param {number} n - the number of intervals
	     * @returns {number} - x + n intervals
	     */
	    XAxis.prototype.modByInterval = function (x, n) {
	      var ordered = this.ordered;
	      if (!ordered) return x;
	      var interval = ordered.interval;
	      if (!interval) return x;

	      if (!ordered.date) {
	        return x += ordered.interval * n;
	      }

	      var y = moment(x);
	      var method = n > 0 ? 'add' : 'subtract';

	      _.times(Math.abs(n), function () {
	        y[method](interval);
	      });

	      return y.valueOf();
	    };

	    /**
	     * Return a nominal(d3 ordinal) domain
	     *
	     * @method getOrdinalDomain
	     * @param scale {Function} D3 scale function
	     * @param xValues {Array} Array of x axis values
	     * @returns {*} D3 scale function
	     */
	    XAxis.prototype.getOrdinalDomain = function (scale, xValues) {
	      return scale.domain(xValues);
	    };

	    /**
	     * Return the range for the x axis scale
	     * if time, return a normal range, else if nominal, return rangeBands with a default (0.1) spacer specified
	     *
	     * @method getRange
	     * @param scale {Function} D3 scale function
	     * @param width {Number} HTML Element width
	     * @returns {*} D3 scale function
	     */
	    XAxis.prototype.getRange = function (domain, width) {
	      var ordered = this.ordered;

	      if (ordered && ordered.date) {
	        return domain.range([0, width]);
	      }
	      return domain.rangeBands([0, width], 0.1);
	    };

	    /**
	     * Return the x axis scale
	     *
	     * @method getXScale
	     * @param width {Number} HTML Element width
	     * @returns {*} D3 x scale function
	     */
	    XAxis.prototype.getXScale = function (width) {
	      var domain = this.getDomain(this.getScale());

	      return this.getRange(domain, width);
	    };

	    /**
	     * Creates d3 xAxis function
	     *
	     * @method getXAxis
	     * @param width {Number} HTML Element width
	     */
	    XAxis.prototype.getXAxis = function (width) {
	      this.xScale = this.getXScale(width);

	      if (!this.xScale || _.isNaN(this.xScale)) {
	        throw new Error('xScale is ' + this.xScale);
	      }

	      this.xAxis = d3.svg.axis().scale(this.xScale).ticks(10).tickFormat(this.xAxisFormatter).orient('bottom');
	    };

	    /**
	     * Renders the x axis
	     *
	     * @method draw
	     * @returns {Function} Renders the x axis to a D3 selection
	     */
	    XAxis.prototype.draw = function () {
	      var self = this;
	      var div;
	      var width;
	      var height;
	      var svg;
	      var parentWidth;
	      var n;
	      this._attr.isRotated = false;

	      return function (selection) {
	        n = selection[0].length;
	        parentWidth = $(self.el).find('.x-axis-div-wrapper').width();

	        selection.each(function () {

	          div = d3.select(this);
	          width = parentWidth / n;
	          height = $(this.parentElement).height();

	          self.validateWidthandHeight(width, height);

	          self.getXAxis(width);

	          svg = div.append('svg').attr('width', width).attr('height', height);

	          svg.append('g').attr('class', 'x axis').attr('transform', 'translate(0,0)').call(self.xAxis);
	        });

	        selection.call(self.filterOrRotate());
	      };
	    };

	    /**
	     * Returns a function that evaluates scale type and
	     * applies filter to tick labels on time scales
	     * rotates and truncates tick labels on nominal/ordinal scales
	     *
	     * @method filterOrRotate
	     * @returns {Function} Filters or rotates x axis tick labels
	     */
	    XAxis.prototype.filterOrRotate = function () {
	      var self = this;
	      var ordered = self.ordered;
	      var axis;
	      var labels;

	      return function (selection) {
	        selection.each(function () {
	          axis = d3.select(this);
	          labels = axis.selectAll('.tick text');
	          if (ordered && ordered.date) {
	            axis.call(self.filterAxisLabels());
	          } else {
	            axis.call(self.rotateAxisLabels());
	          }
	        });

	        self.updateXaxisHeight();

	        selection.call(self.fitTitles());
	      };
	    };

	    /**
	     * Rotate the axis tick labels within selection
	     *
	     * @returns {Function} Rotates x axis tick labels of a D3 selection
	     */
	    XAxis.prototype.rotateAxisLabels = function () {
	      var self = this;
	      var text;
	      var barWidth = self.xScale.rangeBand();
	      var maxRotatedLength = 180;
	      var xAxisPadding = 15;
	      var svg;
	      var lengths = [];
	      var length;
	      self._attr.isRotated = false;

	      return function (selection) {
	        text = selection.selectAll('.tick text');

	        text.each(function textWidths() {
	          lengths.push(d3.select(this).node().getBBox().width);
	        });
	        length = _.max(lengths);
	        self._attr.xAxisLabelHt = length + xAxisPadding;

	        // if longer than bar width, rotate
	        if (length > barWidth) {
	          self._attr.isRotated = true;
	        }

	        // if longer than maxRotatedLength, truncate
	        if (length > maxRotatedLength) {
	          self._attr.xAxisLabelHt = maxRotatedLength;
	        }

	        if (self._attr.isRotated) {
	          text.text(function truncate() {
	            return self.truncateLabel(this, self._attr.xAxisLabelHt);
	          }).style('text-anchor', 'end').attr('dx', '-.8em').attr('dy', '-.60em').attr('transform', function rotate() {
	            return 'rotate(-90)';
	          });
	          selection.select('svg').attr('height', self._attr.xAxisLabelHt);
	        }
	      };
	    };

	    /**
	     * Returns a string that is truncated to fit size
	     *
	     * @method truncateLabel
	     * @param text {HTMLElement}
	     * @param size {Number}
	     * @returns {*|jQuery}
	     */
	    XAxis.prototype.truncateLabel = function (text, size) {
	      var node = d3.select(text).node();
	      var str = $(node).text();
	      var width = node.getBBox().width;
	      var chars = str.length;
	      var pxPerChar = width / chars;
	      var endChar = 0;
	      var ellipsesPad = 4;

	      if (width > size) {
	        endChar = Math.floor(size / pxPerChar - ellipsesPad);
	        while (str[endChar - 1] === ' ' || str[endChar - 1] === '-' || str[endChar - 1] === ',') {
	          endChar = endChar - 1;
	        }
	        str = str.substr(0, endChar) + '...';
	      }
	      return str;
	    };

	    /**
	     * Filter out text labels by width and position on axis
	     * trims labels that would overlap each other
	     * or extend past left or right edges
	     * if prev label pos (or 0) + half of label width is < label pos
	     * and label pos + half width  is not > width of axis
	     *
	     * @method filterAxisLabels
	     * @returns {Function}
	     */
	    XAxis.prototype.filterAxisLabels = function () {
	      var self = this;
	      var startX = 0;
	      var maxW;
	      var par;
	      var myX;
	      var myWidth;
	      var halfWidth;
	      var padding = 1.1;

	      return function (selection) {
	        selection.selectAll('.tick text').text(function (d) {
	          par = d3.select(this.parentNode).node();
	          myX = self.xScale(d);
	          myWidth = par.getBBox().width * padding;
	          halfWidth = myWidth / 2;
	          maxW = $(self.el).find('.x-axis-div').width();

	          if (startX + halfWidth < myX && maxW > myX + halfWidth) {
	            startX = myX + halfWidth;
	            return self.xAxisFormatter(d);
	          } else {
	            d3.select(this.parentNode).remove();
	          }
	        });
	      };
	    };

	    /**
	     * Returns a function that adjusts axis titles and
	     * chart title transforms to fit axis label divs.
	     * Sets transform of x-axis-title to fit .x-axis-title div width
	     * if x-axis-chart-titles, set transform of x-axis-chart-titles
	     * to fit .chart-title div width
	     *
	     * @method fitTitles
	     * @returns {Function}
	     */
	    XAxis.prototype.fitTitles = function () {
	      var visEls = $('.vis-wrapper');
	      var xAxisChartTitle;
	      var yAxisChartTitle;
	      var text;
	      var titles;

	      return function () {

	        visEls.each(function () {
	          var visEl = d3.select(this);
	          var $visEl = $(this);
	          var xAxisTitle = $visEl.find('.x-axis-title');
	          var yAxisTitle = $visEl.find('.y-axis-title');
	          var titleWidth = xAxisTitle.width();
	          var titleHeight = yAxisTitle.height();

	          text = visEl.select('.x-axis-title').select('svg').attr('width', titleWidth).select('text').attr('transform', 'translate(' + titleWidth / 2 + ',11)');

	          text = visEl.select('.y-axis-title').select('svg').attr('height', titleHeight).select('text').attr('transform', 'translate(11,' + titleHeight / 2 + ')rotate(-90)');

	          if ($visEl.find('.x-axis-chart-title').length) {
	            xAxisChartTitle = $visEl.find('.x-axis-chart-title');
	            titleWidth = xAxisChartTitle.find('.chart-title').width();

	            titles = visEl.select('.x-axis-chart-title').selectAll('.chart-title');
	            titles.each(function () {
	              text = d3.select(this).select('svg').attr('width', titleWidth).select('text').attr('transform', 'translate(' + titleWidth / 2 + ',11)');
	            });
	          }

	          if ($visEl.find('.y-axis-chart-title').length) {
	            yAxisChartTitle = $visEl.find('.y-axis-chart-title');
	            titleHeight = yAxisChartTitle.find('.chart-title').height();

	            titles = visEl.select('.y-axis-chart-title').selectAll('.chart-title');
	            titles.each(function () {
	              text = d3.select(this).select('svg').attr('height', titleHeight).select('text').attr('transform', 'translate(11,' + titleHeight / 2 + ')rotate(-90)');
	            });
	          }
	        });
	      };
	    };

	    /**
	     * Appends div to make .y-axis-spacer-block
	     * match height of .x-axis-wrapper
	     *
	     * @method updateXaxisHeight
	     */
	    XAxis.prototype.updateXaxisHeight = function () {
	      var selection = d3.select(this.el).selectAll('.vis-wrapper');

	      selection.each(function () {
	        var visEl = d3.select(this);

	        if (visEl.select('.inner-spacer-block').node() === null) {
	          visEl.select('.y-axis-spacer-block').append('div').attr('class', 'inner-spacer-block');
	        }
	        var xAxisHt = visEl.select('.x-axis-wrapper').style('height');

	        visEl.select('.inner-spacer-block').style('height', xAxisHt);
	      });
	    };

	    return XAxis;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(220);
	__webpack_require__(387);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function YAxisFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var errors = __webpack_require__(220);

	    var ErrorHandler = Private(__webpack_require__(387));

	    /**
	     * Appends y axis to the visualization
	     *
	     * @class YAxis
	     * @constructor
	     * @param args {{el: (HTMLElement), yMax: (Number), _attr: (Object|*)}}
	     */
	    _['class'](YAxis).inherits(ErrorHandler);
	    function YAxis(args) {
	      this.el = args.el;
	      this.scale = null;
	      this.domain = [args.yMin, args.yMax];
	      this.yAxisFormatter = args.yAxisFormatter;
	      this._attr = args._attr || {};
	    }

	    /**
	     * Renders the y axis
	     *
	     * @method render
	     * @return {D3.UpdateSelection} Renders y axis to visualization
	     */
	    YAxis.prototype.render = function () {
	      d3.select(this.el).selectAll('.y-axis-div').call(this.draw());
	    };

	    YAxis.prototype._isPercentage = function () {
	      return this._attr.mode === 'percentage';
	    };

	    YAxis.prototype._isUserDefined = function () {
	      return this._attr.setYExtents;
	    };

	    YAxis.prototype._isYExtents = function () {
	      return this._attr.defaultYExtents;
	    };

	    YAxis.prototype._validateUserExtents = function (domain) {
	      var self = this;

	      return domain.map(function (val) {
	        val = parseInt(val, 10);

	        if (isNaN(val)) throw new Error(val + ' is not a valid number');
	        if (self._isPercentage() && self._attr.setYExtents) return val / 100;
	        return val;
	      });
	    };

	    YAxis.prototype._getExtents = function (domain) {
	      var min = domain[0];
	      var max = domain[1];

	      if (this._isUserDefined()) return this._validateUserExtents(domain);
	      if (this._isYExtents()) return domain;
	      if (this._attr.scale === 'log') return this._logDomain(min, max); // Negative values cannot be displayed with a log scale.
	      if (!this._isYExtents() && !this._isUserDefined()) return [Math.min(0, min), Math.max(0, max)];
	      return domain;
	    };

	    YAxis.prototype._throwCustomError = function (message) {
	      throw new Error(message);
	    };

	    YAxis.prototype._throwLogScaleValuesError = function () {
	      throw new errors.InvalidLogScaleValues();
	    };

	    /**
	     * Returns the appropriate D3 scale
	     *
	     * @param fnName {String} D3 scale
	     * @returns {*}
	     */
	    YAxis.prototype._getScaleType = function (fnName) {
	      if (fnName === 'square root') fnName = 'sqrt'; // Rename 'square root' to 'sqrt'
	      fnName = fnName || 'linear';

	      if (typeof d3.scale[fnName] !== 'function') return this._throwCustomError('YAxis.getScaleType: ' + fnName + ' is not a function');

	      return d3.scale[fnName]();
	    };

	    /**
	     * Return the domain for log scale, i.e. the extent of the log scale.
	     * Log scales must begin at 1 since the log(0) = -Infinity
	     *
	     * @param scale
	     * @param yMin
	     * @param yMax
	     * @returns {*[]}
	     */
	    YAxis.prototype._logDomain = function (min, max) {
	      if (min < 0 || max < 0) return this._throwLogScaleValuesError();
	      return [1, max];
	    };

	    /**
	     * Creates the d3 y scale function
	     *
	     * @method getYScale
	     * @param height {Number} DOM Element height
	     * @returns {D3.Scale.QuantitiveScale|*} D3 yScale function
	     */
	    YAxis.prototype.getYScale = function (height) {
	      var scale = this._getScaleType(this._attr.scale);
	      var domain = this._getExtents(this.domain);

	      this.yScale = scale.domain(domain).range([height, 0]);

	      if (!this._isUserDefined()) this.yScale.nice(); // round extents when not user defined
	      // Prevents bars from going off the chart when the y extents are within the domain range
	      if (this._attr.type === 'histogram') this.yScale.clamp(true);
	      return this.yScale;
	    };

	    YAxis.prototype.getScaleType = function () {
	      return this._attr.scale;
	    };

	    YAxis.prototype.tickFormat = function () {
	      var isPercentage = this._attr.mode === 'percentage';
	      if (isPercentage) return d3.format('%');
	      if (this.yAxisFormatter) return this.yAxisFormatter;
	      return d3.format('n');
	    };

	    YAxis.prototype._validateYScale = function (yScale) {
	      if (!yScale || _.isNaN(yScale)) throw new Error('yScale is ' + yScale);
	    };

	    /**
	     * Creates the d3 y axis function
	     *
	     * @method getYAxis
	     * @param height {Number} DOM Element height
	     * @returns {D3.Svg.Axis|*} D3 yAxis function
	     */
	    YAxis.prototype.getYAxis = function (height) {
	      var yScale = this.getYScale(height);
	      this._validateYScale(yScale);

	      // Create the d3 yAxis function
	      this.yAxis = d3.svg.axis().scale(yScale).tickFormat(this.tickFormat(this.domain)).ticks(this.tickScale(height)).orient('left');

	      return this.yAxis;
	    };

	    /**
	     * Create a tick scale for the y axis that modifies the number of ticks
	     * based on the height of the wrapping DOM element
	     * Avoid using even numbers in the yTickScale.range
	     * Causes the top most tickValue in the chart to be missing
	     *
	     * @method tickScale
	     * @param height {Number} DOM element height
	     * @returns {number} Number of y axis ticks
	     */
	    YAxis.prototype.tickScale = function (height) {
	      var yTickScale = d3.scale.linear().clamp(true).domain([20, 40, 1000]).range([0, 3, 11]);

	      return Math.ceil(yTickScale(height));
	    };

	    /**
	     * Renders the y axis to the visualization
	     *
	     * @method draw
	     * @returns {Function} Renders y axis to visualization
	     */
	    YAxis.prototype.draw = function () {
	      var self = this;
	      var margin = this._attr.margin;
	      var mode = this._attr.mode;
	      var isWiggleOrSilhouette = mode === 'wiggle' || mode === 'silhouette';

	      return function (selection) {
	        selection.each(function () {
	          var el = this;

	          var div = d3.select(el);
	          var width = $(el).parent().width();
	          var height = $(el).height();
	          var adjustedHeight = height - margin.top - margin.bottom;

	          // Validate whether width and height are not 0 or `NaN`
	          self.validateWidthandHeight(width, adjustedHeight);

	          var yAxis = self.getYAxis(adjustedHeight);

	          // The yAxis should not appear if mode is set to 'wiggle' or 'silhouette'
	          if (!isWiggleOrSilhouette) {
	            // Append svg and y axis
	            var svg = div.append('svg').attr('width', width).attr('height', height);

	            svg.append('g').attr('class', 'y axis').attr('transform', 'translate(' + (width - 2) + ',' + margin.top + ')').call(yAxis);

	            var container = svg.select('g.y.axis').node();
	            if (container) {
	              var cWidth = Math.max(width, container.getBBox().width);
	              svg.attr('width', cWidth);
	              svg.select('g').attr('transform', 'translate(' + (cWidth - 2) + ',' + margin.top + ')');
	            }
	          }
	        });
	      };
	    };

	    return YAxis;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(387);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AxisTitleFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);

	    var ErrorHandler = Private(__webpack_require__(387));

	    /**
	     * Appends axis title(s) to the visualization
	     *
	     * @class AxisTitle
	     * @constructor
	     * @param el {HTMLElement} DOM element
	     * @param xTitle {String} X-axis title
	     * @param yTitle {String} Y-axis title
	     */
	    _['class'](AxisTitle).inherits(ErrorHandler);
	    function AxisTitle(el, xTitle, yTitle) {
	      if (!(this instanceof AxisTitle)) {
	        return new AxisTitle(el, xTitle, yTitle);
	      }

	      this.el = el;
	      this.xTitle = xTitle;
	      this.yTitle = yTitle;
	    }

	    /**
	     * Renders both x and y axis titles
	     *
	     * @method render
	     * @returns {HTMLElement} DOM Element with axis titles
	     */
	    AxisTitle.prototype.render = function () {
	      d3.select(this.el).select('.x-axis-title').call(this.draw(this.xTitle));
	      d3.select(this.el).select('.y-axis-title').call(this.draw(this.yTitle));
	    };

	    /**
	     * Appends an SVG with title text
	     *
	     * @method draw
	     * @param title {String} Axis title
	     * @returns {Function} Appends axis title to a D3 selection
	     */
	    AxisTitle.prototype.draw = function (title) {
	      var self = this;

	      return function (selection) {
	        selection.each(function () {
	          var el = this;
	          var div = d3.select(el);
	          var width = $(el).width();
	          var height = $(el).height();

	          self.validateWidthandHeight(width, height);

	          div.append('svg').attr('width', width).attr('height', height).append('text').attr('transform', function () {
	            if (div.attr('class') === 'x-axis-title') {
	              return 'translate(' + width / 2 + ',11)';
	            }
	            return 'translate(11,' + height / 2 + ')rotate(270)';
	          }).attr('text-anchor', 'middle').text(title);
	        });
	      };
	    };

	    return AxisTitle;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(336);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AlertsFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);
	    var Binder = __webpack_require__(336);

	    /**
	     * Adds allerts that float in front of a visualization
	     *
	     * @class Alerts
	     * @constructor
	     * @param el {HTMLElement} Reference to DOM element
	     */
	    function Alerts(vis, data, alertDefs) {
	      if (!(this instanceof Alerts)) {
	        return new Alerts(vis, data, alertDefs);
	      }

	      this.vis = vis;
	      this.data = data;
	      this.binder = new Binder();
	      this.alertDefs = alertDefs || [];

	      this.binder.jqOn(vis.el, 'mouseenter', '.vis-alerts-tray', function () {
	        var $tray = $(this);
	        hide();
	        $(vis.el).on('mousemove', checkForExit);

	        function hide() {
	          $tray.css({
	            'pointer-events': 'none',
	            opacity: 0.3
	          });
	        }

	        function show() {
	          $(vis.el).off('mousemove', checkForExit);
	          $tray.css({
	            'pointer-events': 'auto',
	            opacity: 1
	          });
	        }

	        function checkForExit(event) {
	          var pos = $tray.offset();
	          if (pos.top > event.clientY || pos.left > event.clientX) return show();

	          var bottom = pos.top + $tray.height();
	          if (event.clientY > bottom) return show();

	          var right = pos.left + $tray.width();
	          if (event.clientX > right) return show();
	        }
	      });
	    }

	    /**
	     * Renders chart titles
	     *
	     * @method render
	     * @returns {D3.Selection|D3.Transition.Transition} DOM element with chart titles
	     */
	    Alerts.prototype.render = function () {
	      var vis = this.vis;
	      var data = this.data;

	      var alerts = _(this.alertDefs).map(function (alertDef) {
	        if (!alertDef) return;
	        if (alertDef.test && !alertDef.test(vis, data)) return;

	        var type = alertDef.type || 'info';
	        var icon = alertDef.icon || type;
	        var msg = alertDef.msg;

	        // alert container
	        var $icon = $('<i>').addClass('vis-alerts-icon fa fa-' + icon);
	        var $text = $('<p>').addClass('vis-alerts-text').text(msg);

	        return $('<div>').addClass('vis-alert vis-alert-' + type).append([$icon, $text]);
	      }).compact();

	      if (!alerts.size()) return;

	      $(vis.el).find('.vis-alerts').append($('<div>').addClass('vis-alerts-tray').append(alerts.value()));
	    };

	    /**
	     * Tear down the Alerts
	     * @return {undefined}
	     */
	    Alerts.prototype.destroy = function () {
	      this.binder.destroy();
	    };

	    return Alerts;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(334);
	__webpack_require__(337);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function MapHandlerProvider(Private) {
	    var _ = __webpack_require__(192);

	    var Handler = Private(__webpack_require__(334));
	    var Data = Private(__webpack_require__(337));

	    return function (vis) {
	      var data = new Data(vis.data, vis._attr);

	      var MapHandler = new Handler(vis, {
	        data: data
	      });

	      MapHandler.resize = function () {
	        this.charts.forEach(function (chart) {
	          chart.resizeArea();
	        });
	      };

	      return MapHandler;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(388);
	__webpack_require__(333);
	__webpack_require__(393);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HandlerTypeFactory(Private) {
	    var pointSeries = Private(__webpack_require__(388));

	    /**
	     * Handles the building of each visualization
	     *
	     * @return {Function} Returns an Object of Handler types
	     */
	    return {
	      histogram: pointSeries.column,
	      line: pointSeries.line,
	      pie: Private(__webpack_require__(333)),
	      area: pointSeries.area,
	      tile_map: Private(__webpack_require__(393))
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(396);
	__webpack_require__(403);
	__webpack_require__(405);
	__webpack_require__(406);
	__webpack_require__(407);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function MapFactory(Private) {
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var L = __webpack_require__(396);

	    var defaultMapZoom = 2;
	    var defaultMapCenter = [15, 5];
	    var defaultMarkerType = 'Scaled Circle Markers';

	    var mapTiles = {
	      url: 'https://otile{s}-s.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.jpeg',
	      options: {
	        attribution: 'Tiles by <a href="http://www.mapquest.com/">MapQuest</a> &mdash; ' + 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' + '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
	        subdomains: '1234'
	      }
	    };

	    var markerTypes = {
	      'Scaled Circle Markers': Private(__webpack_require__(403)),
	      'Shaded Circle Markers': Private(__webpack_require__(405)),
	      'Shaded Geohash Grid': Private(__webpack_require__(406)),
	      'Heatmap': Private(__webpack_require__(407))
	    };

	    /**
	     * Tile Map Maps
	     *
	     * @class Map
	     * @constructor
	     * @param container {HTML Element} Element to render map into
	     * @param chartData {Object} Elasticsearch query results for this map
	     * @param params {Object} Parameters used to build a map
	     */
	    function TileMapMap(container, chartData, params) {
	      this._container = $(container).get(0);
	      this._chartData = chartData;

	      // keep a reference to all of the optional params
	      this._events = _.get(params, 'events');
	      this._markerType = markerTypes[params.markerType] ? params.markerType : defaultMarkerType;
	      this._valueFormatter = params.valueFormatter || _.identity;
	      this._tooltipFormatter = params.tooltipFormatter || _.identity;
	      this._geoJson = _.get(this._chartData, 'geoJson');
	      this._attr = params.attr || {};

	      var mapOptions = {
	        minZoom: 1,
	        maxZoom: 18,
	        noWrap: true,
	        maxBounds: L.latLngBounds([-90, -220], [90, 220]),
	        scrollWheelZoom: false,
	        fadeAnimation: false
	      };

	      this._createMap(mapOptions);
	    }

	    TileMapMap.prototype.addBoundingControl = function () {
	      if (this._boundingControl) return;

	      var self = this;
	      var drawOptions = { draw: {} };

	      _.each(['polyline', 'polygon', 'circle', 'marker', 'rectangle'], function (drawShape) {
	        if (self._events && !self._events.listenerCount(drawShape)) {
	          drawOptions.draw[drawShape] = false;
	        } else {
	          drawOptions.draw[drawShape] = {
	            shapeOptions: {
	              stroke: false,
	              color: '#000'
	            }
	          };
	        }
	      });

	      this._boundingControl = new L.Control.Draw(drawOptions);
	      this.map.addControl(this._boundingControl);
	    };

	    TileMapMap.prototype.addFitControl = function () {
	      if (this._fitControl) return;

	      var self = this;
	      var fitContainer = L.DomUtil.create('div', 'leaflet-control leaflet-bar leaflet-control-fit');

	      // Add button to fit container to points
	      var FitControl = L.Control.extend({
	        options: {
	          position: 'topleft'
	        },
	        onAdd: function onAdd(map) {
	          $(fitContainer).html('<a class="fa fa-crop" href="#" title="Fit Data Bounds"></a>').on('click', function (e) {
	            e.preventDefault();
	            self._fitBounds();
	          });

	          return fitContainer;
	        },
	        onRemove: function onRemove(map) {
	          $(fitContainer).off('click');
	        }
	      });

	      this._fitControl = new FitControl();
	      this.map.addControl(this._fitControl);
	    };

	    /**
	     * Adds label div to each map when data is split
	     *
	     * @method addTitle
	     * @param mapLabel {String}
	     * @return {undefined}
	     */
	    TileMapMap.prototype.addTitle = function (mapLabel) {
	      if (this._label) return;

	      var label = this._label = L.control();

	      label.onAdd = function () {
	        this._div = L.DomUtil.create('div', 'tilemap-info tilemap-label');
	        this.update();
	        return this._div;
	      };
	      label.update = function () {
	        this._div.innerHTML = '<h2>' + _.escape(mapLabel) + '</h2>';
	      };

	      // label.addTo(this.map);
	      this.map.addControl(label);
	    };

	    /**
	     * remove css class for desat filters on map tiles
	     *
	     * @method saturateTiles
	     * @return undefined
	     */
	    TileMapMap.prototype.saturateTiles = function () {
	      if (!this._attr.isDesaturated) {
	        $('img.leaflet-tile-loaded').addClass('filters-off');
	      }
	    };

	    TileMapMap.prototype.updateSize = function () {
	      this.map.invalidateSize({
	        debounceMoveend: true
	      });
	    };

	    TileMapMap.prototype.destroy = function () {
	      if (this._label) this._label.removeFrom(this.map);
	      if (this._fitControl) this._fitControl.removeFrom(this.map);
	      if (this._boundingControl) this._boundingControl.removeFrom(this.map);
	      if (this._markers) this._markers.destroy();
	      this.map.remove();
	      this.map = undefined;
	    };

	    /**
	     * Switch type of data overlay for map:
	     * creates featurelayer from mapData (geoJson)
	     *
	     * @method _addMarkers
	     */
	    TileMapMap.prototype._addMarkers = function () {
	      if (!this._geoJson) return;
	      if (this._markers) this._markers.destroy();

	      this._markers = this._createMarkers({
	        tooltipFormatter: this._tooltipFormatter,
	        valueFormatter: this._valueFormatter,
	        attr: this._attr
	      });

	      if (this._geoJson.features.length > 1) {
	        this._markers.addLegend();
	      }
	    };

	    /**
	     * Create the marker instance using the given options
	     *
	     * @method _createMarkers
	     * @param options {Object} options to give to marker class
	     * @return {Object} marker layer
	     */
	    TileMapMap.prototype._createMarkers = function (options) {
	      var MarkerType = markerTypes[this._markerType];
	      return new MarkerType(this.map, this._geoJson, options);
	    };

	    TileMapMap.prototype._attachEvents = function () {
	      var self = this;
	      var saturateTiles = self.saturateTiles.bind(self);

	      this._tileLayer.on('tileload', saturateTiles);

	      this.map.on('unload', function () {
	        self._tileLayer.off('tileload', saturateTiles);
	      });

	      this.map.on('moveend', function setZoomCenter(ev) {
	        if (!self.map) return;
	        // update internal center and zoom references
	        self._mapCenter = self.map.getCenter();
	        self._mapZoom = self.map.getZoom();
	        self._addMarkers();

	        if (!self._events) return;

	        self._events.emit('mapMoveEnd', {
	          chart: self._chartData,
	          map: self.map,
	          center: self._mapCenter,
	          zoom: self._mapZoom
	        });
	      });

	      this.map.on('draw:created', function (e) {
	        var drawType = e.layerType;
	        if (!self._events || !self._events.listenerCount(drawType)) return;

	        // TODO: Different drawTypes need differ info. Need a switch on the object creation
	        var bounds = e.layer.getBounds();

	        self._events.emit(drawType, {
	          e: e,
	          chart: self._chartData,
	          bounds: {
	            top_left: {
	              lat: bounds.getNorthWest().lat,
	              lon: bounds.getNorthWest().lng
	            },
	            bottom_right: {
	              lat: bounds.getSouthEast().lat,
	              lon: bounds.getSouthEast().lng
	            }
	          }
	        });
	      });

	      this.map.on('zoomend', function () {
	        if (!self.map) return;
	        self._mapZoom = self.map.getZoom();
	        if (!self._events) return;

	        self._events.emit('mapZoomEnd', {
	          chart: self._chartData,
	          map: self.map,
	          zoom: self._mapZoom
	        });
	      });
	    };

	    TileMapMap.prototype._createMap = function (mapOptions) {
	      if (this.map) this.destroy();

	      // get center and zoom from mapdata, or use defaults
	      this._mapCenter = _.get(this._geoJson, 'properties.center') || defaultMapCenter;
	      this._mapZoom = _.get(this._geoJson, 'properties.zoom') || defaultMapZoom;

	      // add map tiles layer, using the mapTiles object settings
	      if (this._attr.wms && this._attr.wms.enabled) {
	        this._tileLayer = L.tileLayer.wms(this._attr.wms.url, this._attr.wms.options);
	      } else {
	        this._tileLayer = L.tileLayer(mapTiles.url, mapTiles.options);
	      }

	      // append tile layers, center and zoom to the map options
	      mapOptions.layers = this._tileLayer;
	      mapOptions.center = this._mapCenter;
	      mapOptions.zoom = this._mapZoom;

	      this.map = L.map(this._container, mapOptions);
	      this._attachEvents();
	      this._addMarkers();
	    };

	    /**
	     * zoom map to fit all features in featureLayer
	     *
	     * @method _fitBounds
	     * @param map {Leaflet Object}
	     * @return {boolean}
	     */
	    TileMapMap.prototype._fitBounds = function () {
	      this.map.fitBounds(this._getDataRectangles());
	    };

	    /**
	     * Get the Rectangles representing the geohash grid
	     *
	     * @return {LatLngRectangles[]}
	     */
	    TileMapMap.prototype._getDataRectangles = function () {
	      if (!this._geoJson) return [];
	      return _.pluck(this._geoJson.features, 'properties.rectangle');
	    };

	    return TileMapMap;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(397);
	window.L = module.exports = __webpack_require__(398);

	__webpack_require__(400);

	__webpack_require__(401);
	__webpack_require__(402);


/***/ },
/* 397 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
	 (c) 2010-2013, Vladimir Agafonkin
	 (c) 2010-2011, CloudMade
	*/
	!function(t,e,i){var n=t.L,o={};o.version="0.7.5","object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"=="function"&&__webpack_require__(399)&&!(__WEBPACK_AMD_DEFINE_FACTORY__ = (o), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)),o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;n>i;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?void(o=!0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),void t.apply(i,a))}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?void e():s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)r={action:e,context:i||this},h=t[n],p?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=m&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u],delete _[c];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n="ActiveXObject"in t,s=n&&!e.addEventListener,a=navigator.userAgent.toLowerCase(),r=-1!==a.indexOf("webkit"),h=-1!==a.indexOf("chrome"),l=-1!==a.indexOf("phantom"),u=-1!==a.indexOf("android"),c=-1!==a.search("android [23]"),d=-1!==a.indexOf("gecko"),p=typeof orientation!=i+"",_=!t.PointerEvent&&t.MSPointerEvent,m=t.PointerEvent&&t.navigator.pointerEnabled&&t.navigator.maxTouchPoints||_,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!c,P="MozPerspective"in g.style,L="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||P||L)&&!l,w=!t.L_NO_TOUCH&&!l&&(m||"ontouchstart"in t||t.DocumentTouch&&e instanceof t.DocumentTouch);o.Browser={ie:n,ielt9:s,webkit:r,gecko:d&&!r&&!t.opera&&!n,android:u,android23:c,chrome:h,ie3d:v,webkit3d:y,gecko3d:P,opera3d:L,any3d:x,mobile:p,mobileWebkit:p&&r,mobileWebkit3d:p&&y,mobileOpera:p&&t.opera,touch:w,msPointer:_,pointer:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var l=o.DomUtil.getStyle(a,"width"),u=o.DomUtil.getStyle(a,"max-width"),c=a.getBoundingClientRect();("none"!==l||"none"!==u)&&(s+=c.left+a.clientLeft),n+=c.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil._getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,a=n.length;a>s;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var r=o.DomUtil._getClass(t);o.DomUtil._setClass(t,(r?r+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil._setClass(t,o.Util.trim((" "+o.DomUtil._getClass(t)+" ").replace(" "+e+" "," ")))},_setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},_getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){if("onselectstart"in e)o.extend(o.DomUtil,{disableTextSelection:function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)}});else{var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(i){var t=e.documentElement.style;this._userSelect=t[i],t[i]="none"}},enableTextSelection:function(){i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)}})}o.extend(o.DomUtil,{disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e,n){if(t=parseFloat(t),e=parseFloat(e),isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=t,this.lng=e,n!==i&&(this.alt=parseFloat(n))},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(t>i||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?"number"==typeof t[0]||"string"==typeof t[0]?new o.LatLng(t[0],t[1],t[2]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):e===i?null:new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){if(!t)return this;var e=o.latLng(t);return t=null!==e?e:o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)},getSize:function(t){var e=this.scale(t);return o.point(e,e)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=this._limitZoom(t),this)},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n));s=e.maxZoom?Math.min(e.maxZoom,s):s;var a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),this.options.maxBounds=t,t?(this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds,this)):this.off("moveend",this._panInsideMaxBounds,this)},panInsideBounds:function(t,e){var i=this.getCenter(),n=this._limitCenter(i,this._zoom,t);return i.equals(n)?this:this.panTo(n,e)},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this):this},hasLayer:function(t){return t?o.stamp(t)in this._layers:!1},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._initialCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),a=n.subtract(s);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){this._loaded&&this.fire("unload"),this._initEvents("off");try{delete this._container._leaflet}catch(t){this._container._leaflet=i}return this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._initialCenter&&!this._moved()?this._initialCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom===i?0:this._layersMinZoom:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&a>=s);return u&&e?null:e?s:s-1},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,this.fire("viewreset",{hard:!i}),a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-(1/0),o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;n>i;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&(this.dragging&&this.dragging.moved()||this.boxZoom&&this.boxZoom.moved())||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),a=new o.Bounds(n.subtract(s),n.add(s)),r=this._getBoundsOffset(a,i,e);return this.unproject(n.add(r),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=this.project(e.getNorthWest(),i).subtract(t.min),s=this.project(e.getSouthEast(),i).subtract(t.max),a=this._rebound(n.x,-s.x),r=this._rebound(n.y,-s.y);return new o.Point(a,r)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;return new o.LatLng(u*i,a)}},o.CRS.EPSG3395=o.extend({},o.CRS,{code:"EPSG:3395",
	projection:o.Projection.Mercator,transformation:function(){var t=o.Projection.Mercator,e=t.R_MAJOR,i=.5/(Math.PI*e);return new o.Transformation(i,.5,-i,.5)}()}),o.TileLayer=o.Class.extend({includes:o.Mixin.Events,options:{minZoom:0,maxZoom:18,tileSize:256,subdomains:"abc",errorTileUrl:"",attribution:"",zoomOffset:0,opacity:1,unloadInvisibleTiles:o.Browser.mobile,updateWhenIdle:o.Browser.mobile},initialize:function(t,e){e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomOffset++,e.minZoom>0&&e.minZoom--,this.options.maxZoom--),e.bounds&&(e.bounds=o.latLngBounds(e.bounds)),this._url=t;var i=this.options.subdomains;"string"==typeof i&&(this.options.subdomains=i.split(""))},onAdd:function(t){this._map=t,this._animated=t._zoomAnimated,this._initContainer(),t.on({viewreset:this._reset,moveend:this._update},this),this._animated&&t.on({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||(this._limitedUpdate=o.Util.limitExecByInterval(this._update,150,this),t.on("move",this._limitedUpdate,this)),this._reset(),this._update()},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this._container.parentNode.removeChild(this._container),t.off({viewreset:this._reset,moveend:this._update},this),this._animated&&t.off({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||t.off("move",this._limitedUpdate,this),this._container=null,this._map=null},bringToFront:function(){var t=this._map._panes.tilePane;return this._container&&(t.appendChild(this._container),this._setAutoZIndex(t,Math.max)),this},bringToBack:function(){var t=this._map._panes.tilePane;return this._container&&(t.insertBefore(this._container,t.firstChild),this._setAutoZIndex(t,Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},redraw:function(){return this._map&&(this._reset({hard:!0}),this._update()),this},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t,e){var i,n,o,s=t.children,a=-e(1/0,-(1/0));for(n=0,o=s.length;o>n;n++)s[n]!==this._container&&(i=parseInt(s[n].style.zIndex,10),isNaN(i)||(a=e(a,i)));this.options.zIndex=this._container.style.zIndex=(isFinite(a)?a:0)+e(1,-1)},_updateOpacity:function(){var t,e=this._tiles;if(o.Browser.ielt9)for(t in e)o.DomUtil.setOpacity(e[t],this.options.opacity);else o.DomUtil.setOpacity(this._container,this.options.opacity)},_initContainer:function(){var t=this._map._panes.tilePane;if(!this._container){if(this._container=o.DomUtil.create("div","leaflet-layer"),this._updateZIndex(),this._animated){var e="leaflet-tile-container";this._bgBuffer=o.DomUtil.create("div",e,this._container),this._tileContainer=o.DomUtil.create("div",e,this._container)}else this._tileContainer=this._container;t.appendChild(this._container),this.options.opacity<1&&this._updateOpacity()}},_reset:function(t){for(var e in this._tiles)this.fire("tileunload",{tile:this._tiles[e]});this._tiles={},this._tilesToLoad=0,this.options.reuseTiles&&(this._unusedTiles=[]),this._tileContainer.innerHTML="",this._animated&&t&&t.hard&&this._clearBgBuffer(),this._initContainer()},_getTileSize:function(){var t=this._map,e=t.getZoom()+this.options.zoomOffset,i=this.options.maxNativeZoom,n=this.options.tileSize;return i&&e>i&&(n=Math.round(t.getZoomScale(e)/t.getZoomScale(i)*n)),n},_update:function(){if(this._map){var t=this._map,e=t.getPixelBounds(),i=t.getZoom(),n=this._getTileSize();if(!(i>this.options.maxZoom||i<this.options.minZoom)){var s=o.bounds(e.min.divideBy(n)._floor(),e.max.divideBy(n)._floor());this._addTilesFromCenterOut(s),(this.options.unloadInvisibleTiles||this.options.reuseTiles)&&this._removeOtherTiles(s)}}},_addTilesFromCenterOut:function(t){var i,n,s,a=[],r=t.getCenter();for(i=t.min.y;i<=t.max.y;i++)for(n=t.min.x;n<=t.max.x;n++)s=new o.Point(n,i),this._tileShouldBeLoaded(s)&&a.push(s);var h=a.length;if(0!==h){a.sort(function(t,e){return t.distanceTo(r)-e.distanceTo(r)});var l=e.createDocumentFragment();for(this._tilesToLoad||this.fire("loading"),this._tilesToLoad+=h,n=0;h>n;n++)this._addTile(a[n],l);this._tileContainer.appendChild(l)}},_tileShouldBeLoaded:function(t){if(t.x+":"+t.y in this._tiles)return!1;var e=this.options;if(!e.continuousWorld){var i=this._getWrapTileNum();if(e.noWrap&&(t.x<0||t.x>=i.x)||t.y<0||t.y>=i.y)return!1}if(e.bounds){var n=this._getTileSize(),o=t.multiplyBy(n),s=o.add([n,n]),a=this._map.unproject(o),r=this._map.unproject(s);if(e.continuousWorld||e.noWrap||(a=a.wrap(),r=r.wrap()),!e.bounds.intersects([a,r]))return!1}return!0},_removeOtherTiles:function(t){var e,i,n,o;for(o in this._tiles)e=o.split(":"),i=parseInt(e[0],10),n=parseInt(e[1],10),(i<t.min.x||i>t.max.x||n<t.min.y||n>t.max.y)&&this._removeTile(o)},_removeTile:function(t){var e=this._tiles[t];this.fire("tileunload",{tile:e,url:e.src}),this.options.reuseTiles?(o.DomUtil.removeClass(e,"leaflet-tile-loaded"),this._unusedTiles.push(e)):e.parentNode===this._tileContainer&&this._tileContainer.removeChild(e),o.Browser.android||(e.onload=null,e.src=o.Util.emptyImageUrl),delete this._tiles[t]},_addTile:function(t,e){var i=this._getTilePos(t),n=this._getTile();o.DomUtil.setPosition(n,i,o.Browser.chrome),this._tiles[t.x+":"+t.y]=n,this._loadTile(n,t),n.parentNode!==this._tileContainer&&e.appendChild(n)},_getZoomForUrl:function(){var t=this.options,e=this._map.getZoom();return t.zoomReverse&&(e=t.maxZoom-e),e+=t.zoomOffset,t.maxNativeZoom?Math.min(e,t.maxNativeZoom):e},_getTilePos:function(t){var e=this._map.getPixelOrigin(),i=this._getTileSize();return t.multiplyBy(i).subtract(e)},getTileUrl:function(t){return o.Util.template(this._url,o.extend({s:this._getSubdomain(t),z:t.z,x:t.x,y:t.y},this.options))},_getWrapTileNum:function(){var t=this._map.options.crs,e=t.getSize(this._map.getZoom());return e.divideBy(this._getTileSize())._floor()},_adjustTilePoint:function(t){var e=this._getWrapTileNum();this.options.continuousWorld||this.options.noWrap||(t.x=(t.x%e.x+e.x)%e.x),this.options.tms&&(t.y=e.y-t.y-1),t.z=this._getZoomForUrl()},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_getTile:function(){if(this.options.reuseTiles&&this._unusedTiles.length>0){var t=this._unusedTiles.pop();return this._resetTile(t),t}return this._createTile()},_resetTile:function(){},_createTile:function(){var t=o.DomUtil.create("img","leaflet-tile");return t.style.width=t.style.height=this._getTileSize()+"px",t.galleryimg="no",t.onselectstart=t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity!==i&&o.DomUtil.setOpacity(t,this.options.opacity),o.Browser.mobileWebkit3d&&(t.style.WebkitBackfaceVisibility="hidden"),t},_loadTile:function(t,e){t._layer=this,t.onload=this._tileOnLoad,t.onerror=this._tileOnError,this._adjustTilePoint(e),t.src=this.getTileUrl(e),this.fire("tileloadstart",{tile:t,url:t.src})},_tileLoaded:function(){this._tilesToLoad--,this._animated&&o.DomUtil.addClass(this._tileContainer,"leaflet-zoom-animated"),this._tilesToLoad||(this.fire("load"),this._animated&&(clearTimeout(this._clearBgBufferTimer),this._clearBgBufferTimer=setTimeout(o.bind(this._clearBgBuffer,this),500)))},_tileOnLoad:function(){var t=this._layer;this.src!==o.Util.emptyImageUrl&&(o.DomUtil.addClass(this,"leaflet-tile-loaded"),t.fire("tileload",{tile:this,url:this.src})),t._tileLoaded()},_tileOnError:function(){var t=this._layer;t.fire("tileerror",{tile:this,url:this.src});var e=t.options.errorTileUrl;e&&(this.src=e),t._tileLoaded()}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",version:"1.1.1",layers:"",styles:"",format:"image/jpeg",transparent:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams),n=e.tileSize||this.options.tileSize;e.detectRetina&&o.Browser.retina?i.width=i.height=2*n:i.width=i.height=n;for(var s in e)this.options.hasOwnProperty(s)||"crs"===s||(i[s]=e[s]);this.wmsParams=i,o.setOptions(this,e)},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._map,i=this.options.tileSize,n=t.multiplyBy(i),s=n.add([i,i]),a=this._crs.project(e.unproject(n,t.z)),r=this._crs.project(e.unproject(s,t.z)),h=this._wmsVersion>=1.3&&this._crs===o.CRS.EPSG4326?[r.y,a.x,a.y,r.x].join(","):[a.x,r.y,r.x,a.y].join(","),l=o.Util.template(this._url,{s:this._getSubdomain(t)});return l+o.Util.getParamString(this.wmsParams,l,!0)+"&BBOX="+h},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.TileLayer.Canvas=o.TileLayer.extend({options:{async:!1},initialize:function(t){o.setOptions(this,t)},redraw:function(){this._map&&(this._reset({hard:!0}),this._update());for(var t in this._tiles)this._redrawTile(this._tiles[t]);return this},_redrawTile:function(t){this.drawTile(t,t._tilePoint,this._map._zoom)},_createTile:function(){var t=o.DomUtil.create("canvas","leaflet-tile");return t.width=t.height=this.options.tileSize,t.onselectstart=t.onmousemove=o.Util.falseFn,t},_loadTile:function(t,e){t._layer=this,t._tilePoint=e,this._redrawTile(t),this.options.async||this.tileDrawn(t)},drawTile:function(){},tileDrawn:function(t){this._tileOnLoad.call(t)}}),o.tileLayer.canvas=function(t){return new o.TileLayer.Canvas(t)},o.ImageOverlay=o.Class.extend({includes:o.Mixin.Events,options:{opacity:1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(t){this._map=t,this._image||this._initImage(),t._panes.overlayPane.appendChild(this._image),t.on("viewreset",this._reset,this),t.options.zoomAnimation&&o.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._image),t.off("viewreset",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},bringToFront:function(){return this._image&&this._map._panes.overlayPane.appendChild(this._image),this},bringToBack:function(){var t=this._map._panes.overlayPane;return this._image&&t.insertBefore(this._image,t.firstChild),this},setUrl:function(t){this._url=t,this._image.src=this._url},getAttribution:function(){return this.options.attribution},_initImage:function(){this._image=o.DomUtil.create("img","leaflet-image-layer"),this._map.options.zoomAnimation&&o.Browser.any3d?o.DomUtil.addClass(this._image,"leaflet-zoom-animated"):o.DomUtil.addClass(this._image,"leaflet-zoom-hide"),this._updateOpacity(),o.extend(this._image,{galleryimg:"no",onselectstart:o.Util.falseFn,onmousemove:o.Util.falseFn,onload:o.bind(this._onImageLoad,this),src:this._url})},_animateZoom:function(t){var e=this._map,i=this._image,n=e.getZoomScale(t.zoom),s=this._bounds.getNorthWest(),a=this._bounds.getSouthEast(),r=e._latLngToNewLayerPoint(s,t.zoom,t.center),h=e._latLngToNewLayerPoint(a,t.zoom,t.center)._subtract(r),l=r._add(h._multiplyBy(.5*(1-1/n)));i.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(l)+" scale("+n+") "},_reset:function(){var t=this._image,e=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),i=this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);o.DomUtil.setPosition(t,e),t.style.width=i.x+"px",t.style.height=i.y+"px"},_onImageLoad:function(){this.fire("load")},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({options:{className:""},initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n;return n=e&&"IMG"===e.tagName?this._createImg(i,e):this._createImg(i),this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i,n=this.options,s=o.point(n[e+"Size"]);i="shadow"===e?o.point(n.shadowAnchor||n.iconAnchor):o.point(n.iconAnchor),!i&&s&&(i=s.divideBy(2,!0)),t.className="leaflet-marker-"+e+" "+n.className,i&&(t.style.marginLeft=-i.x+"px",t.style.marginTop=-i.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return i=i||e.createElement("img"),i.src=t,i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]?this.options[t+"RetinaUrl"]:this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]},_getIconUrl:function(t){var e=t+"Url";if(this.options[e])return this.options[e];o.Browser.retina&&"icon"===t&&(t+="-2x");var i=o.Icon.Default.imagePath;if(!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");return i+"/marker-"+t+".png"}}),o.Icon.Default.imagePath=function(){var t,i,n,o,s,a=e.getElementsByTagName("script"),r=/[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;for(t=0,i=a.length;i>t;t++)if(n=a[t].src,o=n.match(r))return s=n.split(r)[0],(s?s+"/":"")+"images"}(),o.Marker=o.Class.extend({includes:o.Mixin.Events,options:{icon:new o.Icon.Default,title:"",alt:"",clickable:!0,draggable:!1,keyboard:!0,zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._map=t,t.on("viewreset",this.update,this),this._initIcon(),this.update(),this.fire("add"),t.options.zoomAnimation&&t.options.markerZoomAnimation&&t.on("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this.dragging&&this.dragging.disable(),this._removeIcon(),this._removeShadow(),this.fire("remove"),t.off({viewreset:this.update,zoomanim:this._animateZoom},this),this._map=null},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this.update(),this.fire("move",{latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update(),this},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup),this},update:function(){return this._icon&&this._setPos(this._map.latLngToLayerPoint(this._latlng).round()),this},_initIcon:function(){var t=this.options,e=this._map,i=e.options.zoomAnimation&&e.options.markerZoomAnimation,n=i?"leaflet-zoom-animated":"leaflet-zoom-hide",s=t.icon.createIcon(this._icon),a=!1;s!==this._icon&&(this._icon&&this._removeIcon(),a=!0,t.title&&(s.title=t.title),t.alt&&(s.alt=t.alt)),o.DomUtil.addClass(s,n),t.keyboard&&(s.tabIndex="0"),this._icon=s,this._initInteraction(),t.riseOnHover&&o.DomEvent.on(s,"mouseover",this._bringToFront,this).on(s,"mouseout",this._resetZIndex,this);var r=t.icon.createShadow(this._shadow),h=!1;r!==this._shadow&&(this._removeShadow(),h=!0),r&&o.DomUtil.addClass(r,n),this._shadow=r,t.opacity<1&&this._updateOpacity();var l=this._map._panes;a&&l.markerPane.appendChild(this._icon),r&&h&&l.shadowPane.appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&o.DomEvent.off(this._icon,"mouseover",this._bringToFront).off(this._icon,"mouseout",this._resetZIndex),this._map._panes.markerPane.removeChild(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&this._map._panes.shadowPane.removeChild(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(e)},_initInteraction:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];o.DomUtil.addClass(t,"leaflet-clickable"),o.DomEvent.on(t,"click",this._onMouseClick,this),o.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)o.DomEvent.on(t,e[i],this._fireMouseEvent,this);o.Handler.MarkerDrag&&(this.dragging=new o.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_onMouseClick:function(t){var e=this.dragging&&this.dragging.moved();(this.hasEventListeners(t.type)||e)&&o.DomEvent.stopPropagation(t),e||(this.dragging&&this.dragging._enabled||!this._map.dragging||!this._map.dragging.moved())&&this.fire(t.type,{originalEvent:t,latlng:this._latlng})},_onKeyPress:function(t){13===t.keyCode&&this.fire("click",{originalEvent:t,latlng:this._latlng})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t,latlng:this._latlng}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&o.DomEvent.preventDefault(t),"mousedown"!==t.type?o.DomEvent.stopPropagation(t):o.DomEvent.preventDefault(t)},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){o.DomUtil.setOpacity(this._icon,this.options.opacity),this._shadow&&o.DomUtil.setOpacity(this._shadow,this.options.opacity)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],className:"leaflet-div-icon",html:!1},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;return n.html!==!1?i.innerHTML=n.html:i.innerHTML="",n.bgPos&&(i.style.backgroundPosition=-n.bgPos.x+"px "+-n.bgPos.y+"px"),this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Popup=o.Class.extend({includes:o.Mixin.Events,options:{minWidth:50,maxWidth:300,autoPan:!0,closeButton:!0,offset:[0,7],autoPanPadding:[5,5],keepInView:!1,className:"",zoomAnimation:!0},initialize:function(t,e){o.setOptions(this,t),this._source=e,this._animated=o.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._container||this._initLayout();var e=t.options.fadeAnimation;e&&o.DomUtil.setOpacity(this._container,0),t._panes.popupPane.appendChild(this._container),t.on(this._getEvents(),this),this.update(),e&&o.DomUtil.setOpacity(this._container,1),this.fire("open"),t.fire("popupopen",{popup:this}),this._source&&this._source.fire("popupopen",{popup:this})},addTo:function(t){return t.addLayer(this),this},openOn:function(t){return t.openPopup(this),this},onRemove:function(t){t._panes.popupPane.removeChild(this._container),o.Util.falseFn(this._container.offsetWidth),t.off(this._getEvents(),this),t.options.fadeAnimation&&o.DomUtil.setOpacity(this._container,0),this._map=null,this.fire("close"),t.fire("popupclose",{popup:this}),this._source&&this._source.fire("popupclose",{popup:this})},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},_getEvents:function(){var t={viewreset:this._updatePosition};return this._animated&&(t.zoomanim=this._zoomAnimation),("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t,e="leaflet-popup",i=e+" "+this.options.className+" leaflet-zoom-"+(this._animated?"animated":"hide"),n=this._container=o.DomUtil.create("div",i);this.options.closeButton&&(t=this._closeButton=o.DomUtil.create("a",e+"-close-button",n),t.href="#close",t.innerHTML="&#215;",o.DomEvent.disableClickPropagation(t),o.DomEvent.on(t,"click",this._onCloseButtonClick,this));var s=this._wrapper=o.DomUtil.create("div",e+"-content-wrapper",n);o.DomEvent.disableClickPropagation(s),this._contentNode=o.DomUtil.create("div",e+"-content",s),o.DomEvent.disableScrollPropagation(this._contentNode),o.DomEvent.on(s,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",e+"-tip-container",n),this._tip=o.DomUtil.create("div",e+"-tip",this._tipContainer)},_updateContent:function(){if(this._content){if("string"==typeof this._content)this._contentNode.innerHTML=this._content;else{for(;this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);this._contentNode.appendChild(this._content)}this.fire("contentupdate")}},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,a="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,a)):o.DomUtil.removeClass(t,a),this._containerWidth=this._container.offsetWidth},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=this._animated,i=o.point(this.options.offset);e&&o.DomUtil.setPosition(this._container,t),this._containerBottom=-i.y-(e?0:t.y),this._containerLeft=-Math.round(this._containerWidth/2)+i.x+(e?0:t.x),this._container.style.bottom=this._containerBottom+"px",this._container.style.left=this._containerLeft+"px"}},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);o.DomUtil.setPosition(this._container,e)},_adjustPan:function(){if(this.options.autoPan){var t=this._map,e=this._container.offsetHeight,i=this._containerWidth,n=new o.Point(this._containerLeft,-e-this._containerBottom);this._animated&&n._add(o.DomUtil.getPosition(this._container));var s=t.layerPointToContainerPoint(n),a=o.point(this.options.autoPanPadding),r=o.point(this.options.autoPanPaddingTopLeft||a),h=o.point(this.options.autoPanPaddingBottomRight||a),l=t.getSize(),u=0,c=0;s.x+i+h.x>l.x&&(u=s.x+i-l.x+h.x),s.x-u-r.x<0&&(u=s.x-r.x),s.y+e+h.y>l.y&&(c=s.y+e-l.y+h.y),s.y-c-r.y<0&&(c=s.y-r.y),(u||c)&&t.fire("autopanstart").panBy([u,c])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.include({openPopup:function(t,e,i){if(this.closePopup(),!(t instanceof o.Popup)){var n=t;t=new o.Popup(i).setLatLng(e).setContent(n)}return t._isOpen=!0,this._popup=t,this.addLayer(t)},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&(this.removeLayer(t),t._isOpen=!1),this}}),o.Marker.include({openPopup:function(){return this._popup&&this._map&&!this._map.hasLayer(this._popup)&&(this._popup.setLatLng(this._latlng),this._map.openPopup(this._popup)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(){return this._popup&&(this._popup._isOpen?this.closePopup():this.openPopup()),this},bindPopup:function(t,e){var i=o.point(this.options.icon.options.popupAnchor||[0,0]);return i=i.add(o.Popup.prototype.options.offset),e&&e.offset&&(i=i.add(e.offset)),e=o.extend({offset:i},e),this._popupHandlersAdded||(this.on("click",this.togglePopup,this).on("remove",this.closePopup,this).on("move",this._movePopup,this),this._popupHandlersAdded=!0),t instanceof o.Popup?(o.setOptions(t,e),this._popup=t,t._source=this):this._popup=new o.Popup(e,this).setContent(t),this},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this.togglePopup,this).off("remove",this.closePopup,this).off("move",this._movePopup,this),this._popupHandlersAdded=!1),this},getPopup:function(){return this._popup},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.LayerGroup=o.Class.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;i>e;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return t?t in this._layers||this.getLayerId(t)in this._layers:!1},clearLayers:function(){return this.eachLayer(this.removeLayer,this),this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){this._map=t,this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t),this._map=null},addTo:function(t){return t.addLayer(this),this},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({includes:o.Mixin.Events,statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},addLayer:function(t){return this.hasLayer(t)?this:("on"in t&&t.on(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.addLayer.call(this,t),this._popupContent&&t.bindPopup&&t.bindPopup(this._popupContent,this._popupOptions),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.off(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.removeLayer.call(this,t),this._popupContent&&this.invoke("unbindPopup"),this.fire("layerremove",{layer:t})):this},bindPopup:function(t,e){return this._popupContent=t,this._popupOptions=e,this.invoke("bindPopup",t,e)},openPopup:function(t){for(var e in this._layers){this._layers[e].openPopup(t);break}return this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;return this.eachLayer(function(e){t.extend(e instanceof o.Marker?e.getLatLng():e.getBounds())}),t},_propagateEvent:function(t){t=o.extend({layer:t.target,target:this},t),this.fire(t.type,t)}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Path=o.Class.extend({includes:[o.Mixin.Events],statics:{CLIP_PADDING:function(){var e=o.Browser.mobile?1280:2e3,i=(e/Math.max(t.outerWidth,t.outerHeight)-1)/2;return Math.max(0,Math.min(.5,i))}()},options:{stroke:!0,color:"#0033ff",dashArray:null,lineCap:null,lineJoin:null,weight:5,opacity:.5,fill:!1,fillColor:null,fillOpacity:.2,clickable:!0},initialize:function(t){o.setOptions(this,t)},onAdd:function(t){this._map=t,this._container||(this._initElements(),this._initEvents()),this.projectLatlngs(),this._updatePath(),this._container&&this._map._pathRoot.appendChild(this._container),this.fire("add"),t.on({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){t._pathRoot.removeChild(this._container),this.fire("remove"),this._map=null,o.Browser.vml&&(this._container=null,this._stroke=null,this._fill=null),t.off({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},projectLatlngs:function(){},setStyle:function(t){return o.setOptions(this,t),this._container&&this._updateStyle(),this},redraw:function(){return this._map&&(this.projectLatlngs(),this._updatePath()),this}}),o.Map.include({_updatePathViewport:function(){var t=o.Path.CLIP_PADDING,e=this.getSize(),i=o.DomUtil.getPosition(this._mapPane),n=i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),s=n.add(e.multiplyBy(1+2*t)._round());this._pathViewport=new o.Bounds(n,s)}}),o.Path.SVG_NS="http://www.w3.org/2000/svg",o.Browser.svg=!(!e.createElementNS||!e.createElementNS(o.Path.SVG_NS,"svg").createSVGRect),o.Path=o.Path.extend({statics:{SVG:o.Browser.svg},bringToFront:function(){var t=this._map._pathRoot,e=this._container;return e&&t.lastChild!==e&&t.appendChild(e),this},bringToBack:function(){var t=this._map._pathRoot,e=this._container,i=t.firstChild;return e&&i!==e&&t.insertBefore(e,i),this},getPathString:function(){},_createElement:function(t){return e.createElementNS(o.Path.SVG_NS,t)},_initElements:function(){this._map._initPathRoot(),this._initPath(),this._initStyle()},_initPath:function(){this._container=this._createElement("g"),this._path=this._createElement("path"),this.options.className&&o.DomUtil.addClass(this._path,this.options.className),this._container.appendChild(this._path)},_initStyle:function(){this.options.stroke&&(this._path.setAttribute("stroke-linejoin","round"),this._path.setAttribute("stroke-linecap","round")),this.options.fill&&this._path.setAttribute("fill-rule","evenodd"),this.options.pointerEvents&&this._path.setAttribute("pointer-events",this.options.pointerEvents),this.options.clickable||this.options.pointerEvents||this._path.setAttribute("pointer-events","none"),this._updateStyle()},_updateStyle:function(){this.options.stroke?(this._path.setAttribute("stroke",this.options.color),this._path.setAttribute("stroke-opacity",this.options.opacity),this._path.setAttribute("stroke-width",this.options.weight),this.options.dashArray?this._path.setAttribute("stroke-dasharray",this.options.dashArray):this._path.removeAttribute("stroke-dasharray"),this.options.lineCap&&this._path.setAttribute("stroke-linecap",this.options.lineCap),this.options.lineJoin&&this._path.setAttribute("stroke-linejoin",this.options.lineJoin)):this._path.setAttribute("stroke","none"),this.options.fill?(this._path.setAttribute("fill",this.options.fillColor||this.options.color),this._path.setAttribute("fill-opacity",this.options.fillOpacity)):this._path.setAttribute("fill","none")},_updatePath:function(){var t=this.getPathString();t||(t="M0 0"),this._path.setAttribute("d",t)},_initEvents:function(){if(this.options.clickable){(o.Browser.svg||!o.Browser.vml)&&o.DomUtil.addClass(this._path,"leaflet-clickable"),o.DomEvent.on(this._container,"click",this._onMouseClick,this);for(var t=["dblclick","mousedown","mouseover","mouseout","mousemove","contextmenu"],e=0;e<t.length;e++)o.DomEvent.on(this._container,t[e],this._fireMouseEvent,this)}},_onMouseClick:function(t){this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)},_fireMouseEvent:function(t){if(this.hasEventListeners(t.type)){var e=this._map,i=e.mouseEventToContainerPoint(t),n=e.containerPointToLayerPoint(i),s=e.layerPointToLatLng(n);this.fire(t.type,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t}),"contextmenu"===t.type&&o.DomEvent.preventDefault(t),"mousemove"!==t.type&&o.DomEvent.stopPropagation(t)}}}),o.Map.include({_initPathRoot:function(){this._pathRoot||(this._pathRoot=o.Path.prototype._createElement("svg"),this._panes.overlayPane.appendChild(this._pathRoot),this.options.zoomAnimation&&o.Browser.any3d?(o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-animated"),
	this.on({zoomanim:this._animatePathZoom,zoomend:this._endPathZoom})):o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-hide"),this.on("moveend",this._updateSvgViewport),this._updateSvgViewport())},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:((!this._popup||e)&&(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");o.DomUtil.addClass(t,"leaflet-vml-shape"+(this.options.className?" "+this.options.className:"")),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,i.dashArray?t.dashStyle=o.Util.isArray(i.dashArray)?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):t.dashStyle="",i.lineCap&&(t.endcap=i.lineCap.replace("butt","flat")),i.lineJoin&&(t.joinstyle=i.lineJoin)):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this.fire("remove"),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color),t.lineCap&&(this._ctx.lineCap=t.lineCap),t.lineJoin&&(this._ctx.lineJoin=t.lineJoin)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;i>t;t++){for(e=0,n=this._parts[t].length;n>e;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill(e.fillRule||"evenodd")),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click dblclick contextmenu",this._fireMouseEvent,this))},_fireMouseEvent:function(t){this._containsPoint(t.layerPoint)&&this.fire(t.type,t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;n>a;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;o-1>=a;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;e>t;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";e>t;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;h>r;r++)for(var l=s[r],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);n>d&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;n>i;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";s>n;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return void(this._parts=[n]);this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;s-1>t;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),(i[1]!==n[t+1]||t===s-2)&&(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;n>i;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;l>n;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;4>a;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;l>n;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){o.Polyline.prototype.initialize.call(this,t,e),this._initWithHoles(t)},_initWithHoles:function(t){var e,i,n;if(t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),e=0,i=this._holes.length;i>e;e++)n=this._holes[e]=this._convertLatLngs(this._holes[e]),n[0].equals(n[n.length-1])&&n.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;i>t;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;n>e;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},setLatLngs:function(t){return t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0]?(this._initWithHoles(t),this.redraw()):o.Polyline.prototype.setLatLngs.call(this,t)},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;n>i;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){n>i?t.setLatLngs(e[i++]):this.removeLayer(t)},this);n>i;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=this._mRadius/40075017*360,i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,23592600")},getRadius:function(){return this._mRadius},_getLatRadius:function(){return this._mRadius/40075017*360},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setLatLng:function(t){return o.Circle.prototype.setLatLng.call(this,t),this._popup&&this._popup._isOpen&&this._popup.setLatLng(t),this},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;a>i;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;r>n;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),u>=h))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;l>a;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng,a);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i,n){var s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return s=i(u),e?e(t,s):new o.Marker(s);case"MultiPoint":for(r=0,h=u.length;h>r;r++)s=i(u[r]),c.push(e?e(t,s):new o.Marker(s));return new o.FeatureGroup(c);case"LineString":return a=this.coordsToLatLngs(u,0,i),new o.Polyline(a,n);case"Polygon":if(2===u.length&&!u[1].length)throw new Error("Invalid GeoJSON object.");return a=this.coordsToLatLngs(u,1,i),new o.Polygon(a,n);case"MultiLineString":return a=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(a,n);case"MultiPolygon":return a=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(a,n);case"GeometryCollection":for(r=0,h=l.geometries.length;h>r;r++)c.push(this.geometryToLayer({geometry:l.geometries[r],type:"Feature",properties:t.properties},e,i,n));return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;s>o;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){var e=[t.lng,t.lat];return t.alt!==i&&e.push(t.alt),e},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;n>i;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;e>t;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t){return function(){var e=[];return this.eachLayer(function(t){e.push(t.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:t,coordinates:e})}}o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}),o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}),o.LayerGroup.include({toGeoJSON:function(){var e,i=this.feature&&this.feature.geometry,n=[];if(i&&"MultiPoint"===i.type)return t("MultiPoint").call(this);var s=i&&"GeometryCollection"===i.type;return this.eachLayer(function(t){t.toGeoJSON&&(e=t.toGeoJSON(),n.push(s?e.geometry:o.GeoJSON.asFeature(e)))}),s?o.GeoJSON.getFeature(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}})}(),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.pointer&&0===e.indexOf("touch")?this.addPointerListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){return o.DomEvent._checkMouse(t,e)?a(e):void 0},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,"mousewheel",e).on(t,"MozMousePixelScroll",e)},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.on(t,o.Draggable.START[i],e);return o.DomEvent.on(t,"click",o.DomEvent._fakeStop).on(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&500>n||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(this._moved=!1,!(t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||(o.DomEvent.stopPropagation(t),o.Draggable._disabled||(o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),this._moving)))){var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(t){if(t.touches&&t.touches.length>1)return void(this._moved=!0);var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.Browser.touch&&Math.abs(s.x)+Math.abs(s.y)<3||(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.DomUtil.addClass(e.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,o.DomUtil.addClass(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget)))},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(){o.DomUtil.removeClass(e.body,"leaflet-dragging"),this._lastTarget&&(o.DomUtil.removeClass(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null);for(var t in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[t],this._onMove).off(e,o.Draggable.END[t],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),t.whenReady(this._onViewReset,this))}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(t){var e=this._map,i=e.options,n=+new Date-this._lastTime,s=!i.inertia||n>i.inertiaThreshold||!this._positions[0];if(e.fire("dragend",t),s)e.fire("moveend");else{var a=this._lastPos.subtract(this._positions[0]),r=(this._lastTime+n-this._times[0])/1e3,h=i.easeLinearity,l=a.multiplyBy(h/r),u=l.distanceTo([0,0]),c=Math.min(i.inertiaMaxSpeed,u),d=l.multiplyBy(c/u),p=c/(i.inertiaDeceleration*h),_=d.multiplyBy(-p/2).round();_.x&&_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:p,easeLinearity:h,noMoveStart:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom()+(t.originalEvent.shiftKey?-1:1);"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&("center"===t.options.scrollWheelZoom?t.setZoom(i+e):t.setZoomAround(this._lastMousePos,i+e))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.pointer?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&u>=n,r=i}}function a(t){if(o.Browser.pointer){var e=_.indexOf(t.pointerId);if(-1===e)return;_.splice(e,1)}if(l){if(o.Browser.pointer){var n,s={};for(var a in h)n=h[a],"function"==typeof n?s[a]=n.bind(h):s[a]=n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.pointer?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.pointer&&m.addEventListener(o.DomEvent.POINTER_CANCEL,a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.pointer?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.pointer&&e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL,t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",_pointers:[],_pointerDocumentListener:!1,addPointerListener:function(t,e,i,n){switch(e){case"touchstart":return this.addPointerListenerStart(t,e,i,n);
	case"touchend":return this.addPointerListenerEnd(t,e,i,n);case"touchmove":return this.addPointerListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addPointerListenerStart:function(t,i,n,s){var a="_leaflet_",r=this._pointers,h=function(t){o.DomEvent.preventDefault(t);for(var e=!1,i=0;i<r.length;i++)if(r[i].pointerId===t.pointerId){e=!0;break}e||r.push(t),t.touches=r.slice(),t.changedTouches=[t],n(t)};if(t[a+"touchstart"+s]=h,t.addEventListener(this.POINTER_DOWN,h,!1),!this._pointerDocumentListener){var l=function(t){for(var e=0;e<r.length;e++)if(r[e].pointerId===t.pointerId){r.splice(e,1);break}};e.documentElement.addEventListener(this.POINTER_UP,l,!1),e.documentElement.addEventListener(this.POINTER_CANCEL,l,!1),this._pointerDocumentListener=!0}return this},addPointerListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._pointers;return t[s+"touchmove"+n]=o,t.addEventListener(this.POINTER_MOVE,o,!1),this},addPointerListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._pointers,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener(this.POINTER_UP,a,!1),t.addEventListener(this.POINTER_CANCEL,a,!1),this},removePointerListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener(this.POINTER_DOWN,o,!1);break;case"touchmove":t.removeEventListener(this.POINTER_MOVE,o,!1);break;case"touchend":t.removeEventListener(this.POINTER_UP,o,!1),t.removeEventListener(this.POINTER_CANCEL,o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(e.options.bounceAtZoomLimits||!(e.getZoom()===e.getMinZoom()&&this._scale<1||e.getZoom()===e.getMaxZoom()&&this._scale>1))&&(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta,!1,!0)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return void(this._zooming=!1);var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._moved=!1},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown),this._moved=!1},moved:function(){return this._moved},_onMouseDown:function(t){return this._moved=!1,!t.shiftKey||1!==t.which&&1!==t.button?!1:(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),void o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this))},_onMouseMove:function(t){this._moved||(this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",this._map.fire("boxzoomstart"));var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),this._moved=!0,i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._moved&&(this._pane.removeChild(this._box),this._container.style.cursor=""),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;-1===t.tabIndex&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable(),o.DomUtil.addClass(this._marker._icon,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable(),o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(t){this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this},_refocusOnMap:function(){this._map&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton(this.options.zoomInText,this.options.zoomInTitle,e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton(this.options.zoomOutText,this.options.zoomOutTitle,e+"-out",i,this._zoomOut,this),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a).on(r,"click",this._refocusOnMap,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):void 0},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):void 0},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=1e3>e?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange,this).off("layerremove",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;o>t;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1,this._refocusOnMap()},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,void this.fire("step")):void this._onTransitionEnd()},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,!0)},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;e>t?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return i.animate===!0||this.getSize().contains(o)?(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0):!1},_animateZoom:function(t,e,i,n,s,a,r){r||(this._animatingZoom=!0),o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),o.Util.requestAnimFrame(function(){this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a}),setTimeout(o.bind(this._onZoomTransitionEnd,this),250)},this)},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1))}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth);var i=this._map.getZoom();(i>this.options.maxZoom||i<this.options.minZoom)&&this._clearBgBuffer(),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&.5>n?(t.style.visibility="hidden",void this._stopLoadingImages(t)):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),void clearTimeout(this._clearBgBufferTimer))},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;i>e;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;i>e;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r,timestamp:t.timestamp};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);

/***/ },
/* 399 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 400 */
/***/ function(module, exports) {

	/*
	 (c) 2014, Vladimir Agafonkin
	 simpleheat, a tiny JavaScript library for drawing heatmaps with Canvas
	 https://github.com/mourner/simpleheat
	*/
	!function(){"use strict";function t(i){return this instanceof t?(this._canvas=i="string"==typeof i?document.getElementById(i):i,this._ctx=i.getContext("2d"),this._width=i.width,this._height=i.height,this._max=1,void this.clear()):new t(i)}t.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(t){return this._data=t,this},max:function(t){return this._max=t,this},add:function(t){return this._data.push(t),this},clear:function(){return this._data=[],this},radius:function(t,i){i=i||15;var a=this._circle=document.createElement("canvas"),s=a.getContext("2d"),e=this._r=t+i;return a.width=a.height=2*e,s.shadowOffsetX=s.shadowOffsetY=200,s.shadowBlur=i,s.shadowColor="black",s.beginPath(),s.arc(e-200,e-200,t,0,2*Math.PI,!0),s.closePath(),s.fill(),this},gradient:function(t){var i=document.createElement("canvas"),a=i.getContext("2d"),s=a.createLinearGradient(0,0,0,256);i.width=1,i.height=256;for(var e in t)s.addColorStop(e,t[e]);return a.fillStyle=s,a.fillRect(0,0,1,256),this._grad=a.getImageData(0,0,1,256).data,this},draw:function(t){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var i=this._ctx;i.clearRect(0,0,this._width,this._height);for(var a,s=0,e=this._data.length;e>s;s++)a=this._data[s],i.globalAlpha=Math.max(a[2]/this._max,t||.05),i.drawImage(this._circle,a[0]-this._r,a[1]-this._r);var n=i.getImageData(0,0,this._width,this._height);return this._colorize(n.data,this._grad),i.putImageData(n,0,0),this},_colorize:function(t,i){for(var a,s=3,e=t.length;e>s;s+=4)a=4*t[s],a&&(t[s-3]=i[a],t[s-2]=i[a+1],t[s-1]=i[a+2])}},window.simpleheat=t}(),/*
	 (c) 2014, Vladimir Agafonkin
	 Leaflet.heat, a tiny and fast heatmap plugin for Leaflet.
	 https://github.com/Leaflet/Leaflet.heat
	*/
	L.HeatLayer=(L.Layer?L.Layer:L.Class).extend({initialize:function(t,i){this._latlngs=t,L.setOptions(this,i)},setLatLngs:function(t){return this._latlngs=t,this.redraw()},addLatLng:function(t){return this._latlngs.push(t),this.redraw()},setOptions:function(t){return L.setOptions(this,t),this._heat&&this._updateOptions(),this.redraw()},redraw:function(){return!this._heat||this._frame||this._map._animating||(this._frame=L.Util.requestAnimFrame(this._redraw,this)),this},onAdd:function(t){this._map=t,this._canvas||this._initCanvas(),t._panes.overlayPane.appendChild(this._canvas),t.on("moveend",this._reset,this),t.options.zoomAnimation&&L.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._canvas),t.off("moveend",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},_initCanvas:function(){var t=this._canvas=L.DomUtil.create("canvas","leaflet-heatmap-layer leaflet-layer"),i=this._map.getSize();t.width=i.x,t.height=i.y;var a=this._map.options.zoomAnimation&&L.Browser.any3d;L.DomUtil.addClass(t,"leaflet-zoom-"+(a?"animated":"hide")),this._heat=simpleheat(t),this._updateOptions()},_updateOptions:function(){this._heat.radius(this.options.radius||this._heat.defaultRadius,this.options.blur),this.options.gradient&&this._heat.gradient(this.options.gradient),this.options.max&&this._heat.max(this.options.max)},_reset:function(){var t=this._map.containerPointToLayerPoint([0,0]);L.DomUtil.setPosition(this._canvas,t);var i=this._map.getSize();this._heat._width!==i.x&&(this._canvas.width=this._heat._width=i.x),this._heat._height!==i.y&&(this._canvas.height=this._heat._height=i.y),this._redraw()},_redraw:function(){var t,i,a,s,e,n,h,o,r,_=[],d=this._heat._r,l=this._map.getSize(),m=new L.LatLngBounds(this._map.containerPointToLatLng(L.point([-d,-d])),this._map.containerPointToLatLng(l.add([d,d]))),c=void 0===this.options.maxZoom?this._map.getMaxZoom():this.options.maxZoom,u=1/Math.pow(2,Math.max(0,Math.min(c-this._map.getZoom(),12))),g=d/2,f=[],p=this._map._getMapPanePos(),v=p.x%g,w=p.y%g;for(t=0,i=this._latlngs.length;i>t;t++)if(m.contains(this._latlngs[t])){a=this._map.latLngToContainerPoint(this._latlngs[t]),e=Math.floor((a.x-v)/g)+2,n=Math.floor((a.y-w)/g)+2;var y=void 0!==this._latlngs[t].alt?this._latlngs[t].alt:void 0!==this._latlngs[t][2]?+this._latlngs[t][2]:1;r=y*u,f[n]=f[n]||[],s=f[n][e],s?(s[0]=(s[0]*s[2]+a.x*r)/(s[2]+r),s[1]=(s[1]*s[2]+a.y*r)/(s[2]+r),s[2]+=r):f[n][e]=[a.x,a.y,r]}for(t=0,i=f.length;i>t;t++)if(f[t])for(h=0,o=f[t].length;o>h;h++)s=f[t][h],s&&_.push([Math.round(s[0]),Math.round(s[1]),Math.min(s[2],1)]);this._heat.data(_).draw(this.options.minOpacity),this._frame=null},_animateZoom:function(t){var i=this._map.getZoomScale(t.zoom),a=this._map._getCenterOffset(t.center)._multiplyBy(-i).subtract(this._map._getMapPanePos());L.DomUtil.setTransform?L.DomUtil.setTransform(this._canvas,a,i):this._canvas.style[L.DomUtil.TRANSFORM]=L.DomUtil.getTranslateString(a)+" scale("+i+")"}}),L.heatLayer=function(t,i){return new L.HeatLayer(t,i)};

/***/ },
/* 401 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 402 */
/***/ function(module, exports) {

	/*
		Leaflet.draw, a plugin that adds drawing and editing tools to Leaflet powered maps.
		(c) 2012-2013, Jacob Toye, Smartrak

		https://github.com/Leaflet/Leaflet.draw
		http://leafletjs.com
		https://github.com/jacobtoye
	*/
	!function(t,e){L.drawVersion="0.2.4-dev",L.drawLocal={draw:{toolbar:{actions:{title:"Cancel drawing",text:"Cancel"},undo:{title:"Delete last point drawn",text:"Delete last point"},buttons:{polyline:"Draw a polyline",polygon:"Draw a polygon",rectangle:"Draw a rectangle",circle:"Draw a circle",marker:"Draw a marker"}},handlers:{circle:{tooltip:{start:"Click and drag to draw circle."},radius:"Radius"},marker:{tooltip:{start:"Click map to place marker."}},polygon:{tooltip:{start:"Click to start drawing shape.",cont:"Click to continue drawing shape.",end:"Click first point to close this shape."}},polyline:{error:"<strong>Error:</strong> shape edges cannot cross!",tooltip:{start:"Click to start drawing line.",cont:"Click to continue drawing line.",end:"Click last point to finish line."}},rectangle:{tooltip:{start:"Click and drag to draw rectangle."}},simpleshape:{tooltip:{end:"Release mouse to finish drawing."}}}},edit:{toolbar:{actions:{save:{title:"Save changes.",text:"Save"},cancel:{title:"Cancel editing, discards all changes.",text:"Cancel"}},buttons:{edit:"Edit layers.",editDisabled:"No layers to edit.",remove:"Delete layers.",removeDisabled:"No layers to delete."}},handlers:{edit:{tooltip:{text:"Drag handles, or marker to edit feature.",subtext:"Click cancel to undo changes."}},remove:{tooltip:{text:"Click on a feature to remove"}}}}},L.Draw={},L.Draw.Feature=L.Handler.extend({includes:L.Mixin.Events,initialize:function(t,e){this._map=t,this._container=t._container,this._overlayPane=t._panes.overlayPane,this._popupPane=t._panes.popupPane,e&&e.shapeOptions&&(e.shapeOptions=L.Util.extend({},this.options.shapeOptions,e.shapeOptions)),L.setOptions(this,e)},enable:function(){this._enabled||(L.Handler.prototype.enable.call(this),this.fire("enabled",{handler:this.type}),this._map.fire("draw:drawstart",{layerType:this.type}))},disable:function(){this._enabled&&(L.Handler.prototype.disable.call(this),this._map.fire("draw:drawstop",{layerType:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(L.DomUtil.disableTextSelection(),t.getContainer().focus(),this._tooltip=new L.Tooltip(this._map),L.DomEvent.on(this._container,"keyup",this._cancelDrawing,this))},removeHooks:function(){this._map&&(L.DomUtil.enableTextSelection(),this._tooltip.dispose(),this._tooltip=null,L.DomEvent.off(this._container,"keyup",this._cancelDrawing,this))},setOptions:function(t){L.setOptions(this,t)},_fireCreatedEvent:function(t){this._map.fire("draw:created",{layer:t,layerType:this.type})},_cancelDrawing:function(t){27===t.keyCode&&this.disable()}}),L.Draw.Polyline=L.Draw.Feature.extend({statics:{TYPE:"polyline"},Poly:L.Polyline,options:{allowIntersection:!0,repeatMode:!1,drawError:{color:"#b00b00",timeout:2500},icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),guidelineDistance:20,maxGuideLineLength:4e3,shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!1,clickable:!0},metric:!0,showLength:!0,zIndexOffset:2e3},initialize:function(t,e){this.options.drawError.message=L.drawLocal.draw.handlers.polyline.error,e&&e.drawError&&(e.drawError=L.Util.extend({},this.options.drawError,e.drawError)),this.type=L.Draw.Polyline.TYPE,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._markers=[],this._markerGroup=new L.LayerGroup,this._map.addLayer(this._markerGroup),this._poly=new L.Polyline([],this.options.shapeOptions),this._tooltip.updateContent(this._getTooltipText()),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("mousedown",this._onMouseDown,this).addTo(this._map),this._map.on("mousemove",this._onMouseMove,this).on("mouseup",this._onMouseUp,this).on("zoomend",this._onZoomEnd,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._clearHideErrorTimeout(),this._cleanUpShape(),this._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers,this._map.removeLayer(this._poly),delete this._poly,this._mouseMarker.off("mousedown",this._onMouseDown,this).off("mouseup",this._onMouseUp,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._clearGuides(),this._map.off("mousemove",this._onMouseMove,this).off("zoomend",this._onZoomEnd,this)},deleteLastVertex:function(){if(!(this._markers.length<=1)){var t=this._markers.pop(),e=this._poly,i=this._poly.spliceLatLngs(e.getLatLngs().length-1,1)[0];this._markerGroup.removeLayer(t),e.getLatLngs().length<2&&this._map.removeLayer(e),this._vertexChanged(i,!1)}},addVertex:function(t){var e=this._markers.length;return e>0&&!this.options.allowIntersection&&this._poly.newLatLngIntersects(t)?(this._showErrorTooltip(),void 0):(this._errorShown&&this._hideErrorTooltip(),this._markers.push(this._createMarker(t)),this._poly.addLatLng(t),2===this._poly.getLatLngs().length&&this._map.addLayer(this._poly),this._vertexChanged(t,!0),void 0)},_finishShape:function(){var t=this._poly.newLatLngIntersects(this._poly.getLatLngs()[0],!0);return!this.options.allowIntersection&&t||!this._shapeIsValid()?(this._showErrorTooltip(),void 0):(this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable(),void 0)},_shapeIsValid:function(){return!0},_onZoomEnd:function(){this._updateGuide()},_onMouseMove:function(t){var e=t.layerPoint,i=t.latlng;this._currentLatLng=i,this._updateTooltip(i),this._updateGuide(e),this._mouseMarker.setLatLng(i),L.DomEvent.preventDefault(t.originalEvent)},_vertexChanged:function(t,e){this._updateFinishHandler(),this._updateRunningMeasure(t,e),this._clearGuides(),this._updateTooltip()},_onMouseDown:function(t){var e=t.originalEvent;this._mouseDownOrigin=L.point(e.clientX,e.clientY)},_onMouseUp:function(e){if(this._mouseDownOrigin){var i=L.point(e.originalEvent.clientX,e.originalEvent.clientY).distanceTo(this._mouseDownOrigin);Math.abs(i)<9*(t.devicePixelRatio||1)&&this.addVertex(e.latlng)}this._mouseDownOrigin=null},_updateFinishHandler:function(){var t=this._markers.length;t>1&&this._markers[t-1].on("click",this._finishShape,this),t>2&&this._markers[t-2].off("click",this._finishShape,this)},_createMarker:function(t){var e=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset});return this._markerGroup.addLayer(e),e},_updateGuide:function(t){var e=this._markers.length;e>0&&(t=t||this._map.latLngToLayerPoint(this._currentLatLng),this._clearGuides(),this._drawGuide(this._map.latLngToLayerPoint(this._markers[e-1].getLatLng()),t))},_updateTooltip:function(t){var e=this._getTooltipText();t&&this._tooltip.updatePosition(t),this._errorShown||this._tooltip.updateContent(e)},_drawGuide:function(t,e){var i,o,a,s=Math.floor(Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))),r=this.options.guidelineDistance,n=this.options.maxGuideLineLength,l=s>n?s-n:r;for(this._guidesContainer||(this._guidesContainer=L.DomUtil.create("div","leaflet-draw-guides",this._overlayPane));s>l;l+=this.options.guidelineDistance)i=l/s,o={x:Math.floor(t.x*(1-i)+i*e.x),y:Math.floor(t.y*(1-i)+i*e.y)},a=L.DomUtil.create("div","leaflet-draw-guide-dash",this._guidesContainer),a.style.backgroundColor=this._errorShown?this.options.drawError.color:this.options.shapeOptions.color,L.DomUtil.setPosition(a,o)},_updateGuideColor:function(t){if(this._guidesContainer)for(var e=0,i=this._guidesContainer.childNodes.length;i>e;e++)this._guidesContainer.childNodes[e].style.backgroundColor=t},_clearGuides:function(){if(this._guidesContainer)for(;this._guidesContainer.firstChild;)this._guidesContainer.removeChild(this._guidesContainer.firstChild)},_getTooltipText:function(){var t,e,i=this.options.showLength;return 0===this._markers.length?t={text:L.drawLocal.draw.handlers.polyline.tooltip.start}:(e=i?this._getMeasurementString():"",t=1===this._markers.length?{text:L.drawLocal.draw.handlers.polyline.tooltip.cont,subtext:e}:{text:L.drawLocal.draw.handlers.polyline.tooltip.end,subtext:e}),t},_updateRunningMeasure:function(t,e){var i,o,a=this._markers.length;1===this._markers.length?this._measurementRunningTotal=0:(i=a-(e?2:1),o=t.distanceTo(this._markers[i].getLatLng()),this._measurementRunningTotal+=o*(e?1:-1))},_getMeasurementString:function(){var t,e=this._currentLatLng,i=this._markers[this._markers.length-1].getLatLng();return t=this._measurementRunningTotal+e.distanceTo(i),L.GeometryUtil.readableDistance(t,this.options.metric)},_showErrorTooltip:function(){this._errorShown=!0,this._tooltip.showAsError().updateContent({text:this.options.drawError.message}),this._updateGuideColor(this.options.drawError.color),this._poly.setStyle({color:this.options.drawError.color}),this._clearHideErrorTimeout(),this._hideErrorTimeout=setTimeout(L.Util.bind(this._hideErrorTooltip,this),this.options.drawError.timeout)},_hideErrorTooltip:function(){this._errorShown=!1,this._clearHideErrorTimeout(),this._tooltip.removeError().updateContent(this._getTooltipText()),this._updateGuideColor(this.options.shapeOptions.color),this._poly.setStyle({color:this.options.shapeOptions.color})},_clearHideErrorTimeout:function(){this._hideErrorTimeout&&(clearTimeout(this._hideErrorTimeout),this._hideErrorTimeout=null)},_cleanUpShape:function(){this._markers.length>1&&this._markers[this._markers.length-1].off("click",this._finishShape,this)},_fireCreatedEvent:function(){var t=new this.Poly(this._poly.getLatLngs(),this.options.shapeOptions);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t)}}),L.Draw.Polygon=L.Draw.Polyline.extend({statics:{TYPE:"polygon"},Poly:L.Polygon,options:{showArea:!1,shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0}},initialize:function(t,e){L.Draw.Polyline.prototype.initialize.call(this,t,e),this.type=L.Draw.Polygon.TYPE},_updateFinishHandler:function(){var t=this._markers.length;1===t&&this._markers[0].on("click",this._finishShape,this),t>2&&(this._markers[t-1].on("dblclick",this._finishShape,this),t>3&&this._markers[t-2].off("dblclick",this._finishShape,this))},_getTooltipText:function(){var t,e;return 0===this._markers.length?t=L.drawLocal.draw.handlers.polygon.tooltip.start:this._markers.length<3?t=L.drawLocal.draw.handlers.polygon.tooltip.cont:(t=L.drawLocal.draw.handlers.polygon.tooltip.end,e=this._getMeasurementString()),{text:t,subtext:e}},_getMeasurementString:function(){var t=this._area;return t?L.GeometryUtil.readableArea(t,this.options.metric):null},_shapeIsValid:function(){return this._markers.length>=3},_vertexChanged:function(t,e){var i;!this.options.allowIntersection&&this.options.showArea&&(i=this._poly.getLatLngs(),this._area=L.GeometryUtil.geodesicArea(i)),L.Draw.Polyline.prototype._vertexChanged.call(this,t,e)},_cleanUpShape:function(){var t=this._markers.length;t>0&&(this._markers[0].off("click",this._finishShape,this),t>2&&this._markers[t-1].off("dblclick",this._finishShape,this))}}),L.SimpleShape={},L.Draw.SimpleShape=L.Draw.Feature.extend({options:{repeatMode:!1},initialize:function(t,e){this._endLabelText=L.drawLocal.draw.handlers.simpleshape.tooltip.end,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._mapDraggable=this._map.dragging.enabled(),this._mapDraggable&&this._map.dragging.disable(),this._container.style.cursor="crosshair",this._tooltip.updateContent({text:this._initialLabelText}),this._map.on("mousedown",this._onMouseDown,this).on("mousemove",this._onMouseMove,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._mapDraggable&&this._map.dragging.enable(),this._container.style.cursor="",this._map.off("mousedown",this._onMouseDown,this).off("mousemove",this._onMouseMove,this),L.DomEvent.off(e,"mouseup",this._onMouseUp,this),this._shape&&(this._map.removeLayer(this._shape),delete this._shape)),this._isDrawing=!1},_getTooltipText:function(){return{text:this._endLabelText}},_onMouseDown:function(t){this._isDrawing=!0,this._startLatLng=t.latlng,L.DomEvent.on(e,"mouseup",this._onMouseUp,this).preventDefault(t.originalEvent)},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._isDrawing&&(this._tooltip.updateContent(this._getTooltipText()),this._drawShape(e))},_onMouseUp:function(){this._shape&&this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable()}}),L.Draw.Rectangle=L.Draw.SimpleShape.extend({statics:{TYPE:"rectangle"},options:{shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},metric:!0},initialize:function(t,e){this.type=L.Draw.Rectangle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.rectangle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e)},_drawShape:function(t){this._shape?this._shape.setBounds(new L.LatLngBounds(this._startLatLng,t)):(this._shape=new L.Rectangle(new L.LatLngBounds(this._startLatLng,t),this.options.shapeOptions),this._map.addLayer(this._shape))},_fireCreatedEvent:function(){var t=new L.Rectangle(this._shape.getBounds(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t)},_getTooltipText:function(){var t,e,i,o=L.Draw.SimpleShape.prototype._getTooltipText.call(this),a=this._shape;return a&&(t=this._shape.getLatLngs(),e=L.GeometryUtil.geodesicArea(t),i=L.GeometryUtil.readableArea(e,this.options.metric)),{text:o.text,subtext:i}}}),L.Draw.Circle=L.Draw.SimpleShape.extend({statics:{TYPE:"circle"},options:{shapeOptions:{stroke:!0,color:"#f06eaa",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},showRadius:!0,metric:!0},initialize:function(t,e){this.type=L.Draw.Circle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e)},_drawShape:function(t){this._shape?this._shape.setRadius(this._startLatLng.distanceTo(t)):(this._shape=new L.Circle(this._startLatLng,this._startLatLng.distanceTo(t),this.options.shapeOptions),this._map.addLayer(this._shape))},_fireCreatedEvent:function(){var t=new L.Circle(this._startLatLng,this._shape.getRadius(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t)},_onMouseMove:function(t){var e,i=t.latlng,o=this.options.showRadius,a=this.options.metric;this._tooltip.updatePosition(i),this._isDrawing&&(this._drawShape(i),e=this._shape.getRadius().toFixed(1),this._tooltip.updateContent({text:this._endLabelText,subtext:o?L.drawLocal.draw.handlers.circle.radius+": "+L.GeometryUtil.readableDistance(e,a):""}))}}),L.Draw.Marker=L.Draw.Feature.extend({statics:{TYPE:"marker"},options:{icon:new L.Icon.Default,repeatMode:!1,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.Marker.TYPE,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._tooltip.updateContent({text:L.drawLocal.draw.handlers.marker.tooltip.start}),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("click",this._onClick,this).addTo(this._map),this._map.on("mousemove",this._onMouseMove,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._marker&&(this._marker.off("click",this._onClick,this),this._map.off("click",this._onClick,this).removeLayer(this._marker),delete this._marker),this._mouseMarker.off("click",this._onClick,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._map.off("mousemove",this._onMouseMove,this))},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._mouseMarker.setLatLng(e),this._marker?(e=this._mouseMarker.getLatLng(),this._marker.setLatLng(e)):(this._marker=new L.Marker(e,{icon:this.options.icon,zIndexOffset:this.options.zIndexOffset}),this._marker.on("click",this._onClick,this),this._map.on("click",this._onClick,this).addLayer(this._marker))},_onClick:function(){this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable()},_fireCreatedEvent:function(){var t=new L.Marker(this._marker.getLatLng(),{icon:this.options.icon});L.Draw.Feature.prototype._fireCreatedEvent.call(this,t)}}),L.Edit=L.Edit||{},L.Edit.Marker=L.Handler.extend({initialize:function(t,e){this._marker=t,L.setOptions(this,e)},addHooks:function(){var t=this._marker;t.dragging.enable(),t.on("dragend",this._onDragEnd,t),this._toggleMarkerHighlight()},removeHooks:function(){var t=this._marker;t.dragging.disable(),t.off("dragend",this._onDragEnd,t),this._toggleMarkerHighlight()},_onDragEnd:function(t){var e=t.target;e.edited=!0},_toggleMarkerHighlight:function(){if(this._icon){var t=this._icon;t.style.display="none",L.DomUtil.hasClass(t,"leaflet-edit-marker-selected")?(L.DomUtil.removeClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,-4)):(L.DomUtil.addClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,4)),t.style.display=""}},_offsetMarker:function(t,e){var i=parseInt(t.style.marginTop,10)-e,o=parseInt(t.style.marginLeft,10)-e;t.style.marginTop=i+"px",t.style.marginLeft=o+"px"}}),L.Marker.addInitHook(function(){L.Edit.Marker&&(this.editing=new L.Edit.Marker(this),this.options.editable&&this.editing.enable())}),L.Edit=L.Edit||{},L.Edit.Poly=L.Handler.extend({options:{icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"})},initialize:function(t,e){this._poly=t,L.setOptions(this,e)},addHooks:function(){var t=this._poly;t instanceof L.Polygon||(t.options.editing.fill=!1),t.setStyle(t.options.editing),this._poly._map&&(this._markerGroup||this._initMarkers(),this._poly._map.addLayer(this._markerGroup))},removeHooks:function(){var t=this._poly;t.setStyle(t.options.original),t._map&&(t._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers)},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers()},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._markers=[];var t,e,i,o,a=this._poly._latlngs;for(t=0,i=a.length;i>t;t++)o=this._createMarker(a[t],t),o.on("click",this._onMarkerClick,this),this._markers.push(o);var s,r;for(t=0,e=i-1;i>t;e=t++)(0!==t||L.Polygon&&this._poly instanceof L.Polygon)&&(s=this._markers[e],r=this._markers[t],this._createMiddleMarker(s,r),this._updatePrevNext(s,r))},_createMarker:function(t,e){var i=new L.Marker(t,{draggable:!0,icon:this.options.icon});return i._origLatLng=t,i._index=e,i.on("drag",this._onMarkerDrag,this),i.on("dragend",this._fireEdit,this),this._markerGroup.addLayer(i),i},_removeMarker:function(t){var e=t._index;this._markerGroup.removeLayer(t),this._markers.splice(e,1),this._poly.spliceLatLngs(e,1),this._updateIndexes(e,-1),t.off("drag",this._onMarkerDrag,this).off("dragend",this._fireEdit,this).off("click",this._onMarkerClick,this)},_fireEdit:function(){this._poly.edited=!0,this._poly.fire("edit")},_onMarkerDrag:function(t){var e=t.target;L.extend(e._origLatLng,e._latlng),e._middleLeft&&e._middleLeft.setLatLng(this._getMiddleLatLng(e._prev,e)),e._middleRight&&e._middleRight.setLatLng(this._getMiddleLatLng(e,e._next)),this._poly.redraw()},_onMarkerClick:function(t){var e=L.Polygon&&this._poly instanceof L.Polygon?4:3,i=t.target;this._poly._latlngs.length<e||(this._removeMarker(i),this._updatePrevNext(i._prev,i._next),i._middleLeft&&this._markerGroup.removeLayer(i._middleLeft),i._middleRight&&this._markerGroup.removeLayer(i._middleRight),i._prev&&i._next?this._createMiddleMarker(i._prev,i._next):i._prev?i._next||(i._prev._middleRight=null):i._next._middleLeft=null,this._fireEdit())},_updateIndexes:function(t,e){this._markerGroup.eachLayer(function(i){i._index>t&&(i._index+=e)})},_createMiddleMarker:function(t,e){var i,o,a,s=this._getMiddleLatLng(t,e),r=this._createMarker(s);r.setOpacity(.6),t._middleRight=e._middleLeft=r,o=function(){var o=e._index;r._index=o,r.off("click",i,this).on("click",this._onMarkerClick,this),s.lat=r.getLatLng().lat,s.lng=r.getLatLng().lng,this._poly.spliceLatLngs(o,0,s),this._markers.splice(o,0,r),r.setOpacity(1),this._updateIndexes(o,1),e._index++,this._updatePrevNext(t,r),this._updatePrevNext(r,e),this._poly.fire("editstart")},a=function(){r.off("dragstart",o,this),r.off("dragend",a,this),this._createMiddleMarker(t,r),this._createMiddleMarker(r,e)},i=function(){o.call(this),a.call(this),this._fireEdit()},r.on("click",i,this).on("dragstart",o,this).on("dragend",a,this),this._markerGroup.addLayer(r)},_updatePrevNext:function(t,e){t&&(t._next=e),e&&(e._prev=t)},_getMiddleLatLng:function(t,e){var i=this._poly._map,o=i.project(t.getLatLng()),a=i.project(e.getLatLng());return i.unproject(o._add(a)._divideBy(2))}}),L.Polyline.addInitHook(function(){this.editing||(L.Edit.Poly&&(this.editing=new L.Edit.Poly(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks()}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks()}))}),L.Edit=L.Edit||{},L.Edit.SimpleShape=L.Handler.extend({options:{moveIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move"}),resizeIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"})},initialize:function(t,e){this._shape=t,L.Util.setOptions(this,e)},addHooks:function(){var t=this._shape;t.setStyle(t.options.editing),t._map&&(this._map=t._map,this._markerGroup||this._initMarkers(),this._map.addLayer(this._markerGroup))},removeHooks:function(){var t=this._shape;if(t.setStyle(t.options.original),t._map){this._unbindMarker(this._moveMarker);for(var e=0,i=this._resizeMarkers.length;i>e;e++)this._unbindMarker(this._resizeMarkers[e]);this._resizeMarkers=null,this._map.removeLayer(this._markerGroup),delete this._markerGroup}this._map=null},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers()},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._createMoveMarker(),this._createResizeMarker()},_createMoveMarker:function(){},_createResizeMarker:function(){},_createMarker:function(t,e){var i=new L.Marker(t,{draggable:!0,icon:e,zIndexOffset:10});return this._bindMarker(i),this._markerGroup.addLayer(i),i},_bindMarker:function(t){t.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._onMarkerDragEnd,this)},_unbindMarker:function(t){t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._onMarkerDragEnd,this)},_onMarkerDragStart:function(t){var e=t.target;e.setOpacity(0),this._shape.fire("editstart")},_fireEdit:function(){this._shape.edited=!0,this._shape.fire("edit")},_onMarkerDrag:function(t){var e=t.target,i=e.getLatLng();e===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw()},_onMarkerDragEnd:function(t){var e=t.target;e.setOpacity(1),this._fireEdit()},_move:function(){},_resize:function(){}}),L.Edit=L.Edit||{},L.Edit.Rectangle=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getBounds(),e=t.getCenter();this._moveMarker=this._createMarker(e,this.options.moveIcon)},_createResizeMarker:function(){var t=this._getCorners();this._resizeMarkers=[];for(var e=0,i=t.length;i>e;e++)this._resizeMarkers.push(this._createMarker(t[e],this.options.resizeIcon)),this._resizeMarkers[e]._cornerIndex=e},_onMarkerDragStart:function(t){L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t);var e=this._getCorners(),i=t.target,o=i._cornerIndex;this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o)},_onMarkerDragEnd:function(t){var e,i,o=t.target;o===this._moveMarker&&(e=this._shape.getBounds(),i=e.getCenter(),o.setLatLng(i)),this._toggleCornerMarkers(1),this._repositionCornerMarkers(),L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this,t)},_move:function(t){for(var e,i=this._shape.getLatLngs(),o=this._shape.getBounds(),a=o.getCenter(),s=[],r=0,n=i.length;n>r;r++)e=[i[r].lat-a.lat,i[r].lng-a.lng],s.push([t.lat+e[0],t.lng+e[1]]);this._shape.setLatLngs(s),this._repositionCornerMarkers()},_resize:function(t){var e;this._shape.setBounds(L.latLngBounds(t,this._oppositeCorner)),e=this._shape.getBounds(),this._moveMarker.setLatLng(e.getCenter())},_getCorners:function(){var t=this._shape.getBounds(),e=t.getNorthWest(),i=t.getNorthEast(),o=t.getSouthEast(),a=t.getSouthWest();return[e,i,o,a]},_toggleCornerMarkers:function(t){for(var e=0,i=this._resizeMarkers.length;i>e;e++)this._resizeMarkers[e].setOpacity(t)},_repositionCornerMarkers:function(){for(var t=this._getCorners(),e=0,i=this._resizeMarkers.length;i>e;e++)this._resizeMarkers[e].setLatLng(t[e])}}),L.Rectangle.addInitHook(function(){L.Edit.Rectangle&&(this.editing=new L.Edit.Rectangle(this),this.options.editable&&this.editing.enable())}),L.Edit=L.Edit||{},L.Edit.Circle=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getLatLng();this._moveMarker=this._createMarker(t,this.options.moveIcon)},_createResizeMarker:function(){var t=this._shape.getLatLng(),e=this._getResizeMarkerPoint(t);this._resizeMarkers=[],this._resizeMarkers.push(this._createMarker(e,this.options.resizeIcon))},_getResizeMarkerPoint:function(t){var e=this._shape._radius*Math.cos(Math.PI/4),i=this._map.project(t);return this._map.unproject([i.x+e,i.y-e])},_move:function(t){var e=this._getResizeMarkerPoint(t);this._resizeMarkers[0].setLatLng(e),this._shape.setLatLng(t)},_resize:function(t){var e=this._moveMarker.getLatLng(),i=e.distanceTo(t);this._shape.setRadius(i)}}),L.Circle.addInitHook(function(){L.Edit.Circle&&(this.editing=new L.Edit.Circle(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks()}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks()})}),L.LatLngUtil={cloneLatLngs:function(t){for(var e=[],i=0,o=t.length;o>i;i++)e.push(this.cloneLatLng(t[i]));return e},cloneLatLng:function(t){return L.latLng(t.lat,t.lng)}},L.GeometryUtil=L.extend(L.GeometryUtil||{},{geodesicArea:function(t){var e,i,o=t.length,a=0,s=L.LatLng.DEG_TO_RAD;if(o>2){for(var r=0;o>r;r++)e=t[r],i=t[(r+1)%o],a+=(i.lng-e.lng)*s*(2+Math.sin(e.lat*s)+Math.sin(i.lat*s));a=6378137*a*6378137/2}return Math.abs(a)},readableArea:function(t,e){var i;return e?i=t>=1e4?(1e-4*t).toFixed(2)+" ha":t.toFixed(2)+" m&sup2;":(t/=.836127,i=t>=3097600?(t/3097600).toFixed(2)+" mi&sup2;":t>=4840?(t/4840).toFixed(2)+" acres":Math.ceil(t)+" yd&sup2;"),i},readableDistance:function(t,e){var i;return e?i=t>1e3?(t/1e3).toFixed(2)+" km":Math.ceil(t)+" m":(t*=1.09361,i=t>1760?(t/1760).toFixed(2)+" miles":Math.ceil(t)+" yd"),i}}),L.Util.extend(L.LineUtil,{segmentsIntersect:function(t,e,i,o){return this._checkCounterclockwise(t,i,o)!==this._checkCounterclockwise(e,i,o)&&this._checkCounterclockwise(t,e,i)!==this._checkCounterclockwise(t,e,o)},_checkCounterclockwise:function(t,e,i){return(i.y-t.y)*(e.x-t.x)>(e.y-t.y)*(i.x-t.x)}}),L.Polyline.include({intersects:function(){var t,e,i,o=this._originalPoints,a=o?o.length:0;if(this._tooFewPointsForIntersection())return!1;for(t=a-1;t>=3;t--)if(e=o[t-1],i=o[t],this._lineSegmentsIntersectsRange(e,i,t-2))return!0;return!1},newLatLngIntersects:function(t,e){return this._map?this.newPointIntersects(this._map.latLngToLayerPoint(t),e):!1},newPointIntersects:function(t,e){var i=this._originalPoints,o=i?i.length:0,a=i?i[o-1]:null,s=o-2;return this._tooFewPointsForIntersection(1)?!1:this._lineSegmentsIntersectsRange(a,t,s,e?1:0)},_tooFewPointsForIntersection:function(t){var e=this._originalPoints,i=e?e.length:0;return i+=t||0,!this._originalPoints||3>=i},_lineSegmentsIntersectsRange:function(t,e,i,o){var a,s,r=this._originalPoints;o=o||0;for(var n=i;n>o;n--)if(a=r[n-1],s=r[n],L.LineUtil.segmentsIntersect(t,e,a,s))return!0;return!1}}),L.Polygon.include({intersects:function(){var t,e,i,o,a,s=this._originalPoints;return this._tooFewPointsForIntersection()?!1:(t=L.Polyline.prototype.intersects.call(this))?!0:(e=s.length,i=s[0],o=s[e-1],a=e-2,this._lineSegmentsIntersectsRange(o,i,a,1))}}),L.Control.Draw=L.Control.extend({options:{position:"topleft",draw:{},edit:!1},initialize:function(t){if(L.version<"0.7")throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/");L.Control.prototype.initialize.call(this,t);var e;this._toolbars={},L.DrawToolbar&&this.options.draw&&(e=new L.DrawToolbar(this.options.draw),this._toolbars[L.DrawToolbar.TYPE]=e,this._toolbars[L.DrawToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.EditToolbar&&this.options.edit&&(e=new L.EditToolbar(this.options.edit),this._toolbars[L.EditToolbar.TYPE]=e,this._toolbars[L.EditToolbar.TYPE].on("enable",this._toolbarEnabled,this))},onAdd:function(t){var e,i=L.DomUtil.create("div","leaflet-draw"),o=!1,a="leaflet-draw-toolbar-top";for(var s in this._toolbars)this._toolbars.hasOwnProperty(s)&&(e=this._toolbars[s].addToolbar(t),e&&(o||(L.DomUtil.hasClass(e,a)||L.DomUtil.addClass(e.childNodes[0],a),o=!0),i.appendChild(e)));return i},onRemove:function(){for(var t in this._toolbars)this._toolbars.hasOwnProperty(t)&&this._toolbars[t].removeToolbar()},setDrawingOptions:function(t){for(var e in this._toolbars)this._toolbars[e]instanceof L.DrawToolbar&&this._toolbars[e].setOptions(t)},_toolbarEnabled:function(t){var e=t.target;for(var i in this._toolbars)this._toolbars[i]!==e&&this._toolbars[i].disable()}}),L.Map.mergeOptions({drawControlTooltips:!0,drawControl:!1}),L.Map.addInitHook(function(){this.options.drawControl&&(this.drawControl=new L.Control.Draw,this.addControl(this.drawControl))}),L.Toolbar=L.Class.extend({includes:[L.Mixin.Events],initialize:function(t){L.setOptions(this,t),this._modes={},this._actionButtons=[],this._activeMode=null},enabled:function(){return null!==this._activeMode},disable:function(){this.enabled()&&this._activeMode.handler.disable()},addToolbar:function(t){var e,i=L.DomUtil.create("div","leaflet-draw-section"),o=0,a=this._toolbarClass||"",s=this.getModeHandlers(t);for(this._toolbarContainer=L.DomUtil.create("div","leaflet-draw-toolbar leaflet-bar"),this._map=t,e=0;e<s.length;e++)s[e].enabled&&this._initModeHandler(s[e].handler,this._toolbarContainer,o++,a,s[e].title);return o?(this._lastButtonIndex=--o,this._actionsContainer=L.DomUtil.create("ul","leaflet-draw-actions"),i.appendChild(this._toolbarContainer),i.appendChild(this._actionsContainer),i):void 0},removeToolbar:function(){for(var t in this._modes)this._modes.hasOwnProperty(t)&&(this._disposeButton(this._modes[t].button,this._modes[t].handler.enable,this._modes[t].handler),this._modes[t].handler.disable(),this._modes[t].handler.off("enabled",this._handlerActivated,this).off("disabled",this._handlerDeactivated,this));this._modes={};for(var e=0,i=this._actionButtons.length;i>e;e++)this._disposeButton(this._actionButtons[e].button,this._actionButtons[e].callback,this);this._actionButtons=[],this._actionsContainer=null},_initModeHandler:function(t,e,i,o,a){var s=t.type;this._modes[s]={},this._modes[s].handler=t,this._modes[s].button=this._createButton({title:a,className:o+"-"+s,container:e,callback:this._modes[s].handler.enable,context:this._modes[s].handler}),this._modes[s].buttonIndex=i,this._modes[s].handler.on("enabled",this._handlerActivated,this).on("disabled",this._handlerDeactivated,this)},_createButton:function(t){var e=L.DomUtil.create("a",t.className||"",t.container);return e.href="#",t.text&&(e.innerHTML=t.text),t.title&&(e.title=t.title),L.DomEvent.on(e,"click",L.DomEvent.stopPropagation).on(e,"mousedown",L.DomEvent.stopPropagation).on(e,"dblclick",L.DomEvent.stopPropagation).on(e,"click",L.DomEvent.preventDefault).on(e,"click",t.callback,t.context),e
	},_disposeButton:function(t,e){L.DomEvent.off(t,"click",L.DomEvent.stopPropagation).off(t,"mousedown",L.DomEvent.stopPropagation).off(t,"dblclick",L.DomEvent.stopPropagation).off(t,"click",L.DomEvent.preventDefault).off(t,"click",e)},_handlerActivated:function(t){this.disable(),this._activeMode=this._modes[t.handler],L.DomUtil.addClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._showActionsToolbar(),this.fire("enable")},_handlerDeactivated:function(){this._hideActionsToolbar(),L.DomUtil.removeClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._activeMode=null,this.fire("disable")},_createActions:function(t){var e,i,o,a,s=this._actionsContainer,r=this.getActions(t),n=r.length;for(i=0,o=this._actionButtons.length;o>i;i++)this._disposeButton(this._actionButtons[i].button,this._actionButtons[i].callback);for(this._actionButtons=[];s.firstChild;)s.removeChild(s.firstChild);for(var l=0;n>l;l++)"enabled"in r[l]&&!r[l].enabled||(e=L.DomUtil.create("li","",s),a=this._createButton({title:r[l].title,text:r[l].text,container:e,callback:r[l].callback,context:r[l].context}),this._actionButtons.push({button:a,callback:r[l].callback}))},_showActionsToolbar:function(){var t=this._activeMode.buttonIndex,e=this._lastButtonIndex,i=this._activeMode.button.offsetTop-1;this._createActions(this._activeMode.handler),this._actionsContainer.style.top=i+"px",0===t&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-top")),t===e&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-bottom")),this._actionsContainer.style.display="block"},_hideActionsToolbar:function(){this._actionsContainer.style.display="none",L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-top"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-bottom")}}),L.Tooltip=L.Class.extend({initialize:function(t){this._map=t,this._popupPane=t._panes.popupPane,this._container=t.options.drawControlTooltips?L.DomUtil.create("div","leaflet-draw-tooltip",this._popupPane):null,this._singleLineLabel=!1},dispose:function(){this._container&&(this._popupPane.removeChild(this._container),this._container=null)},updateContent:function(t){return this._container?(t.subtext=t.subtext||"",0!==t.subtext.length||this._singleLineLabel?t.subtext.length>0&&this._singleLineLabel&&(L.DomUtil.removeClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!1):(L.DomUtil.addClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!0),this._container.innerHTML=(t.subtext.length>0?'<span class="leaflet-draw-tooltip-subtext">'+t.subtext+"</span><br />":"")+"<span>"+t.text+"</span>",this):this},updatePosition:function(t){var e=this._map.latLngToLayerPoint(t),i=this._container;return this._container&&(i.style.visibility="inherit",L.DomUtil.setPosition(i,e)),this},showAsError:function(){return this._container&&L.DomUtil.addClass(this._container,"leaflet-error-draw-tooltip"),this},removeError:function(){return this._container&&L.DomUtil.removeClass(this._container,"leaflet-error-draw-tooltip"),this}}),L.DrawToolbar=L.Toolbar.extend({statics:{TYPE:"draw"},options:{polyline:{},polygon:{},rectangle:{},circle:{},marker:{}},initialize:function(t){for(var e in this.options)this.options.hasOwnProperty(e)&&t[e]&&(t[e]=L.extend({},this.options[e],t[e]));this._toolbarClass="leaflet-draw-draw",L.Toolbar.prototype.initialize.call(this,t)},getModeHandlers:function(t){return[{enabled:this.options.polyline,handler:new L.Draw.Polyline(t,this.options.polyline),title:L.drawLocal.draw.toolbar.buttons.polyline},{enabled:this.options.polygon,handler:new L.Draw.Polygon(t,this.options.polygon),title:L.drawLocal.draw.toolbar.buttons.polygon},{enabled:this.options.rectangle,handler:new L.Draw.Rectangle(t,this.options.rectangle),title:L.drawLocal.draw.toolbar.buttons.rectangle},{enabled:this.options.circle,handler:new L.Draw.Circle(t,this.options.circle),title:L.drawLocal.draw.toolbar.buttons.circle},{enabled:this.options.marker,handler:new L.Draw.Marker(t,this.options.marker),title:L.drawLocal.draw.toolbar.buttons.marker}]},getActions:function(t){return[{enabled:t.deleteLastVertex,title:L.drawLocal.draw.toolbar.undo.title,text:L.drawLocal.draw.toolbar.undo.text,callback:t.deleteLastVertex,context:t},{title:L.drawLocal.draw.toolbar.actions.title,text:L.drawLocal.draw.toolbar.actions.text,callback:this.disable,context:this}]},setOptions:function(t){L.setOptions(this,t);for(var e in this._modes)this._modes.hasOwnProperty(e)&&t.hasOwnProperty(e)&&this._modes[e].handler.setOptions(t[e])}}),L.EditToolbar=L.Toolbar.extend({statics:{TYPE:"edit"},options:{edit:{selectedPathOptions:{color:"#fe57a1",opacity:.6,dashArray:"10, 10",fill:!0,fillColor:"#fe57a1",fillOpacity:.1,maintainColor:!1}},remove:{},featureGroup:null},initialize:function(t){t.edit&&("undefined"==typeof t.edit.selectedPathOptions&&(t.edit.selectedPathOptions=this.options.edit.selectedPathOptions),t.edit.selectedPathOptions=L.extend({},this.options.edit.selectedPathOptions,t.edit.selectedPathOptions)),t.remove&&(t.remove=L.extend({},this.options.remove,t.remove)),this._toolbarClass="leaflet-draw-edit",L.Toolbar.prototype.initialize.call(this,t),this._selectedFeatureCount=0},getModeHandlers:function(t){var e=this.options.featureGroup;return[{enabled:this.options.edit,handler:new L.EditToolbar.Edit(t,{featureGroup:e,selectedPathOptions:this.options.edit.selectedPathOptions}),title:L.drawLocal.edit.toolbar.buttons.edit},{enabled:this.options.remove,handler:new L.EditToolbar.Delete(t,{featureGroup:e}),title:L.drawLocal.edit.toolbar.buttons.remove}]},getActions:function(){return[{title:L.drawLocal.edit.toolbar.actions.save.title,text:L.drawLocal.edit.toolbar.actions.save.text,callback:this._save,context:this},{title:L.drawLocal.edit.toolbar.actions.cancel.title,text:L.drawLocal.edit.toolbar.actions.cancel.text,callback:this.disable,context:this}]},addToolbar:function(t){var e=L.Toolbar.prototype.addToolbar.call(this,t);return this._checkDisabled(),this.options.featureGroup.on("layeradd layerremove",this._checkDisabled,this),e},removeToolbar:function(){this.options.featureGroup.off("layeradd layerremove",this._checkDisabled,this),L.Toolbar.prototype.removeToolbar.call(this)},disable:function(){this.enabled()&&(this._activeMode.handler.revertLayers(),L.Toolbar.prototype.disable.call(this))},_save:function(){this._activeMode.handler.save(),this._activeMode.handler.disable()},_checkDisabled:function(){var t,e=this.options.featureGroup,i=0!==e.getLayers().length;this.options.edit&&(t=this._modes[L.EditToolbar.Edit.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.edit:L.drawLocal.edit.toolbar.buttons.editDisabled)),this.options.remove&&(t=this._modes[L.EditToolbar.Delete.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.remove:L.drawLocal.edit.toolbar.buttons.removeDisabled))}}),L.EditToolbar.Edit=L.Handler.extend({statics:{TYPE:"edit"},includes:L.Mixin.Events,initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.setOptions(this,e),this._featureGroup=e.featureGroup,!(this._featureGroup instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this._uneditedLayerProps={},this.type=L.EditToolbar.Edit.TYPE},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire("draw:editstart",{handler:this.type}),L.Handler.prototype.enable.call(this),this._featureGroup.on("layeradd",this._enableLayerEdit,this).on("layerremove",this._disableLayerEdit,this))},disable:function(){this._enabled&&(this._featureGroup.off("layeradd",this._enableLayerEdit,this).off("layerremove",this._disableLayerEdit,this),L.Handler.prototype.disable.call(this),this._map.fire("draw:editstop",{handler:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._featureGroup.eachLayer(this._enableLayerEdit,this),this._tooltip=new L.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}),this._map.on("mousemove",this._onMouseMove,this))},removeHooks:function(){this._map&&(this._featureGroup.eachLayer(this._disableLayerEdit,this),this._uneditedLayerProps={},this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this))},revertLayers:function(){this._featureGroup.eachLayer(function(t){this._revertLayer(t)},this)},save:function(){var t=new L.LayerGroup;this._featureGroup.eachLayer(function(e){e.edited&&(t.addLayer(e),e.edited=!1)}),this._map.fire("draw:edited",{layers:t})},_backupLayer:function(t){var e=L.Util.stamp(t);this._uneditedLayerProps[e]||(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?this._uneditedLayerProps[e]={latlngs:L.LatLngUtil.cloneLatLngs(t.getLatLngs())}:t instanceof L.Circle?this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng()),radius:t.getRadius()}:t instanceof L.Marker&&(this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng())}))},_revertLayer:function(t){var e=L.Util.stamp(t);t.edited=!1,this._uneditedLayerProps.hasOwnProperty(e)&&(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?t.setLatLngs(this._uneditedLayerProps[e].latlngs):t instanceof L.Circle?(t.setLatLng(this._uneditedLayerProps[e].latlng),t.setRadius(this._uneditedLayerProps[e].radius)):t instanceof L.Marker&&t.setLatLng(this._uneditedLayerProps[e].latlng),t.fire("revert-edited",{layer:t}))},_enableLayerEdit:function(t){var e,i=t.layer||t.target||t;this._backupLayer(i),this.options.selectedPathOptions&&(e=L.Util.extend({},this.options.selectedPathOptions),e.maintainColor&&(e.color=i.options.color,e.fillColor=i.options.fillColor),i.options.original=L.extend({},i.options),i.options.editing=e),i.editing.enable()},_disableLayerEdit:function(t){var e=t.layer||t.target||t;e.edited=!1,e.editing.disable(),delete e.options.editing,delete e.options.original},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng)},_hasAvailableLayers:function(){return 0!==this._featureGroup.getLayers().length}}),L.EditToolbar.Delete=L.Handler.extend({statics:{TYPE:"remove"},includes:L.Mixin.Events,initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.Util.setOptions(this,e),this._deletableLayers=this.options.featureGroup,!(this._deletableLayers instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this.type=L.EditToolbar.Delete.TYPE},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire("draw:deletestart",{handler:this.type}),L.Handler.prototype.enable.call(this),this._deletableLayers.on("layeradd",this._enableLayerDelete,this).on("layerremove",this._disableLayerDelete,this))},disable:function(){this._enabled&&(this._deletableLayers.off("layeradd",this._enableLayerDelete,this).off("layerremove",this._disableLayerDelete,this),L.Handler.prototype.disable.call(this),this._map.fire("draw:deletestop",{handler:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._deletableLayers.eachLayer(this._enableLayerDelete,this),this._deletedLayers=new L.LayerGroup,this._tooltip=new L.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.remove.tooltip.text}),this._map.on("mousemove",this._onMouseMove,this))},removeHooks:function(){this._map&&(this._deletableLayers.eachLayer(this._disableLayerDelete,this),this._deletedLayers=null,this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this))},revertLayers:function(){this._deletedLayers.eachLayer(function(t){this._deletableLayers.addLayer(t),t.fire("revert-deleted",{layer:t})},this)},save:function(){this._map.fire("draw:deleted",{layers:this._deletedLayers})},_enableLayerDelete:function(t){var e=t.layer||t.target||t;e.on("click",this._removeLayer,this)},_disableLayerDelete:function(t){var e=t.layer||t.target||t;e.off("click",this._removeLayer,this),this._deletedLayers.removeLayer(e)},_removeLayer:function(t){var e=t.layer||t.target||t;this._deletableLayers.removeLayer(e),this._deletedLayers.addLayer(e),e.fire("deleted")},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng)},_hasAvailableLayers:function(){return 0!==this._deletableLayers.getLayers().length}})}(window,document);

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(396);
	__webpack_require__(404);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ScaledCircleMarkerFactory(Private) {
	    var _ = __webpack_require__(192);
	    var L = __webpack_require__(396);

	    var BaseMarker = Private(__webpack_require__(404));

	    /**
	     * Map overlay: circle markers that are scaled to illustrate values
	     *
	     * @param map {Leaflet Object}
	     * @param mapData {geoJson Object}
	     * @param params {Object}
	     */
	    _['class'](ScaledCircleMarker).inherits(BaseMarker);
	    function ScaledCircleMarker(map, geoJson, params) {
	      var self = this;
	      ScaledCircleMarker.Super.apply(this, arguments);

	      // multiplier to reduce size of all circles
	      var scaleFactor = 0.6;

	      this._createMarkerGroup({
	        pointToLayer: function pointToLayer(feature, latlng) {
	          var value = feature.properties.value;
	          var scaledRadius = self._radiusScale(value) * scaleFactor;
	          return L.circleMarker(latlng).setRadius(scaledRadius);
	        }
	      });
	    }

	    /**
	     * radiusScale returns a number for scaled circle markers
	     * for relative sizing of markers
	     *
	     * @method _radiusScale
	     * @param value {Number}
	     * @return {Number}
	     */
	    ScaledCircleMarker.prototype._radiusScale = function (value) {
	      var precisionBiasBase = 5;
	      var precisionBiasNumerator = 200;
	      var zoom = this.map.getZoom();
	      var maxValue = this.geoJson.properties.allmax;
	      var precision = _.max(this.geoJson.features.map(function (feature) {
	        return String(feature.properties.geohash).length;
	      }));

	      var pct = Math.abs(value) / Math.abs(maxValue);
	      var zoomRadius = 0.5 * Math.pow(2, zoom);
	      var precisionScale = precisionBiasNumerator / Math.pow(precisionBiasBase, precision);

	      // square root value percentage
	      return Math.pow(pct, 0.5) * zoomRadius * precisionScale;
	    };

	    return ScaledCircleMarker;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(396);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function MarkerFactory() {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var L = __webpack_require__(396);

	    /**
	     * Base map marker overlay, all other markers inherit from this class
	     *
	     * @param map {Leaflet Object}
	     * @param geoJson {geoJson Object}
	     * @param params {Object}
	     */
	    function BaseMarker(map, geoJson, params) {
	      this.map = map;
	      this.geoJson = geoJson;
	      this.popups = [];

	      this._tooltipFormatter = params.tooltipFormatter || _.identity;
	      this._valueFormatter = params.valueFormatter || _.identity;
	      this._attr = params.attr || {};

	      // set up the default legend colors
	      this.quantizeLegendColors();
	    }

	    /**
	     * Adds legend div to each map when data is split
	     * uses d3 scale from BaseMarker.prototype.quantizeLegendColors
	     *
	     * @method addLegend
	     * @return {undefined}
	     */
	    BaseMarker.prototype.addLegend = function () {
	      // ensure we only ever create 1 legend
	      if (this._legend) return;

	      var self = this;

	      // create the legend control, keep a reference
	      self._legend = L.control({ position: 'bottomright' });

	      self._legend.onAdd = function () {
	        // creates all the neccessary DOM elements for the control, adds listeners
	        // on relevant map events, and returns the element containing the control
	        var $div = $('<div>').addClass('tilemap-legend');

	        _.each(self._legendColors, function (color, i) {
	          var labelText = self._legendQuantizer.invertExtent(color).map(self._valueFormatter).join(' ');

	          var label = $('<div>').text(labelText);

	          var icon = $('<i>').css({
	            background: color,
	            'border-color': self.darkerColor(color)
	          });

	          label.append(icon);
	          $div.append(label);
	        });

	        return $div.get(0);
	      };

	      self._legend.addTo(self.map);
	    };

	    /**
	     * Apply style with shading to feature
	     *
	     * @method applyShadingStyle
	     * @param value {Object}
	     * @return {Object}
	     */
	    BaseMarker.prototype.applyShadingStyle = function (value) {
	      var color = this._legendQuantizer(value);

	      return {
	        fillColor: color,
	        color: this.darkerColor(color),
	        weight: 1.5,
	        opacity: 1,
	        fillOpacity: 0.75
	      };
	    };

	    /**
	     * Binds popup and events to each feature on map
	     *
	     * @method bindPopup
	     * @param feature {Object}
	     * @param layer {Object}
	     * return {undefined}
	     */
	    BaseMarker.prototype.bindPopup = function (feature, layer) {
	      var self = this;

	      var popup = layer.on({
	        mouseover: function mouseover(e) {
	          var layer = e.target;
	          // bring layer to front if not older browser
	          if (!L.Browser.ie && !L.Browser.opera) {
	            layer.bringToFront();
	          }
	          self._showTooltip(feature);
	        },
	        mouseout: function mouseout(e) {
	          self._hidePopup();
	        }
	      });

	      self.popups.push(popup);
	    };

	    /**
	     * d3 method returns a darker hex color,
	     * used for marker stroke color
	     *
	     * @method darkerColor
	     * @param color {String} hex color
	     * @param amount? {Number} amount to darken by
	     * @return {String} hex color
	     */
	    BaseMarker.prototype.darkerColor = function (color, amount) {
	      amount = amount || 1.3;
	      return d3.hcl(color).darker(amount).toString();
	    };

	    BaseMarker.prototype.destroy = function () {
	      var self = this;

	      // remove popups
	      self.popups = self.popups.filter(function (popup) {
	        popup.off('mouseover').off('mouseout');
	      });

	      if (self._legend) {
	        self.map.removeControl(self._legend);
	        self._legend = undefined;
	      }

	      // remove marker layer from map
	      if (self._markerGroup) {
	        self.map.removeLayer(self._markerGroup);
	        self._markerGroup = undefined;
	      }
	    };

	    BaseMarker.prototype._addToMap = function () {
	      this.map.addLayer(this._markerGroup);
	    };

	    /**
	     * Creates leaflet marker group, passing options to L.geoJson
	     *
	     * @method _createMarkerGroup
	     * @param options {Object} Options to pass to L.geoJson
	     */
	    BaseMarker.prototype._createMarkerGroup = function (options) {
	      var self = this;
	      var defaultOptions = {
	        onEachFeature: function onEachFeature(feature, layer) {
	          self.bindPopup(feature, layer);
	        },
	        style: function style(feature) {
	          var value = _.get(feature, 'properties.value');
	          return self.applyShadingStyle(value);
	        },
	        filter: self._filterToMapBounds()
	      };

	      this._markerGroup = L.geoJson(this.geoJson, _.defaults(defaultOptions, options));
	      this._addToMap();
	    };

	    /**
	     * return whether feature is within map bounds
	     *
	     * @method _filterToMapBounds
	     * @param map {Leaflet Object}
	     * @return {boolean}
	     */
	    BaseMarker.prototype._filterToMapBounds = function () {
	      var self = this;
	      return function (feature) {
	        var mapBounds = self.map.getBounds();
	        var bucketRectBounds = _.get(feature, 'properties.rectangle');
	        return mapBounds.intersects(bucketRectBounds);
	      };
	    };

	    /**
	     * Checks if event latlng is within bounds of mapData
	     * features and shows tooltip for that feature
	     *
	     * @method _showTooltip
	     * @param feature {LeafletFeature}
	     * @param latLng? {Leaflet latLng}
	     * @return undefined
	     */
	    BaseMarker.prototype._showTooltip = function (feature, latLng) {
	      if (!this.map) return;
	      var lat = _.get(feature, 'geometry.coordinates.1');
	      var lng = _.get(feature, 'geometry.coordinates.0');
	      latLng = latLng || L.latLng(lat, lng);

	      var content = this._tooltipFormatter(feature);

	      if (!content) return;
	      this._createTooltip(content, latLng);
	    };

	    BaseMarker.prototype._createTooltip = function (content, latLng) {
	      L.popup({ autoPan: false }).setLatLng(latLng).setContent(content).openOn(this.map);
	    };

	    /**
	     * Closes the tooltip on the map
	     *
	     * @method _hidePopup
	     * @return undefined
	     */
	    BaseMarker.prototype._hidePopup = function () {
	      if (!this.map) return;

	      this.map.closePopup();
	    };

	    /**
	     * d3 quantize scale returns a hex color, used for marker fill color
	     *
	     * @method quantizeLegendColors
	     * return {undefined}
	     */
	    BaseMarker.prototype.quantizeLegendColors = function () {
	      var min = _.get(this.geoJson, 'properties.allmin', 0);
	      var max = _.get(this.geoJson, 'properties.allmax', 1);
	      var quantizeDomain = min !== max ? [min, max] : d3.scale.quantize().domain();

	      var reds1 = ['#ff6128'];
	      var reds3 = ['#fecc5c', '#fd8d3c', '#e31a1c'];
	      var reds5 = ['#fed976', '#feb24c', '#fd8d3c', '#f03b20', '#bd0026'];
	      var bottomCutoff = 2;
	      var middleCutoff = 24;

	      if (max - min <= bottomCutoff) {
	        this._legendColors = reds1;
	      } else if (max - min <= middleCutoff) {
	        this._legendColors = reds3;
	      } else {
	        this._legendColors = reds5;
	      }

	      this._legendQuantizer = d3.scale.quantize().domain(quantizeDomain).range(this._legendColors);
	    };

	    return BaseMarker;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(396);
	__webpack_require__(404);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ShadedCircleMarkerFactory(Private) {
	    var _ = __webpack_require__(192);
	    var L = __webpack_require__(396);

	    var BaseMarker = Private(__webpack_require__(404));

	    /**
	     * Map overlay: circle markers that are shaded to illustrate values
	     *
	     * @param map {Leaflet Object}
	     * @param mapData {geoJson Object}
	     * @return {Leaflet object} featureLayer
	     */
	    _['class'](ShadedCircleMarker).inherits(BaseMarker);
	    function ShadedCircleMarker(map, geoJson, params) {
	      var self = this;
	      ShadedCircleMarker.Super.apply(this, arguments);

	      // super min and max from all chart data
	      var min = this.geoJson.properties.allmin;
	      var max = this.geoJson.properties.allmax;

	      // multiplier to reduce size of all circles
	      var scaleFactor = 0.8;

	      this._createMarkerGroup({
	        pointToLayer: function pointToLayer(feature, latlng) {
	          var radius = self._geohashMinDistance(feature) * scaleFactor;
	          return L.circle(latlng, radius);
	        }
	      });
	    }

	    /**
	     * _geohashMinDistance returns a min distance in meters for sizing
	     * circle markers to fit within geohash grid rectangle
	     *
	     * @method _geohashMinDistance
	     * @param feature {Object}
	     * @return {Number}
	     */
	    ShadedCircleMarker.prototype._geohashMinDistance = function (feature) {
	      var centerPoint = _.get(feature, 'properties.center');
	      var geohashRect = _.get(feature, 'properties.rectangle');

	      // centerPoint is an array of [lat, lng]
	      // geohashRect is the 4 corners of the geoHash rectangle
	      //   an array that starts at the southwest corner and proceeds
	      //   clockwise, each value being an array of [lat, lng]

	      // center lat and southeast lng
	      var east = L.latLng([centerPoint[0], geohashRect[2][1]]);
	      // southwest lat and center lng
	      var north = L.latLng([geohashRect[3][0], centerPoint[1]]);

	      // get latLng of geohash center point
	      var center = L.latLng([centerPoint[0], centerPoint[1]]);

	      // get smallest radius at center of geohash grid rectangle
	      var eastRadius = Math.floor(center.distanceTo(east));
	      var northRadius = Math.floor(center.distanceTo(north));
	      return _.min([eastRadius, northRadius]);
	    };

	    return ShadedCircleMarker;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(396);
	__webpack_require__(404);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function GeohashGridMarkerFactory(Private) {
	    var _ = __webpack_require__(192);
	    var L = __webpack_require__(396);

	    var BaseMarker = Private(__webpack_require__(404));

	    /**
	     * Map overlay: rectangles that show the geohash grid bounds
	     *
	     * @param map {Leaflet Object}
	     * @param geoJson {geoJson Object}
	     * @param params {Object}
	     */
	    _['class'](GeohashGridMarker).inherits(BaseMarker);
	    function GeohashGridMarker(map, geoJson, params) {
	      var self = this;
	      GeohashGridMarker.Super.apply(this, arguments);

	      // super min and max from all chart data
	      var min = this.geoJson.properties.allmin;
	      var max = this.geoJson.properties.allmax;

	      this._createMarkerGroup({
	        pointToLayer: function pointToLayer(feature, latlng) {
	          var geohashRect = feature.properties.rectangle;
	          // get bounds from northEast[3] and southWest[1]
	          // corners in geohash rectangle
	          var corners = [[geohashRect[3][0], geohashRect[3][1]], [geohashRect[1][0], geohashRect[1][1]]];
	          return L.rectangle(corners);
	        }
	      });
	    }

	    return GeohashGridMarker;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(396);
	__webpack_require__(404);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HeatmapMarkerFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var L = __webpack_require__(396);

	    var BaseMarker = Private(__webpack_require__(404));

	    /**
	     * Map overlay: canvas layer with leaflet.heat plugin
	     *
	     * @param map {Leaflet Object}
	     * @param geoJson {geoJson Object}
	     * @param params {Object}
	     */
	    _['class'](HeatmapMarker).inherits(BaseMarker);
	    function HeatmapMarker(map, geoJson, params) {
	      var self = this;
	      this._disableTooltips = false;
	      HeatmapMarker.Super.apply(this, arguments);

	      this._createMarkerGroup({
	        radius: +this._attr.heatRadius,
	        blur: +this._attr.heatBlur,
	        maxZoom: +this._attr.heatMaxZoom,
	        minOpacity: +this._attr.heatMinOpacity
	      });
	    }

	    /**
	     * Does nothing, heatmaps don't have a legend
	     *
	     * @method addLegend
	     * @return {undefined}
	     */
	    HeatmapMarker.prototype.addLegend = _.noop;

	    HeatmapMarker.prototype._createMarkerGroup = function (options) {
	      var max = _.get(this.geoJson, 'properties.allmax');
	      var points = this._dataToHeatArray(max);

	      this._markerGroup = L.heatLayer(points, options);
	      this._fixTooltips();
	      this._addToMap();
	    };

	    HeatmapMarker.prototype._fixTooltips = function () {
	      var self = this;
	      var debouncedMouseMoveLocation = _.debounce(mouseMoveLocation.bind(this), 15, {
	        'leading': true,
	        'trailing': false
	      });

	      if (!this._disableTooltips && this._attr.addTooltip) {
	        this.map.on('mousemove', debouncedMouseMoveLocation);
	        this.map.on('mouseout', function () {
	          self.map.closePopup();
	        });
	        this.map.on('mousedown', function () {
	          self._disableTooltips = true;
	          self.map.closePopup();
	        });
	        this.map.on('mouseup', function () {
	          self._disableTooltips = false;
	        });
	      }

	      function mouseMoveLocation(e) {
	        var latlng = e.latlng;

	        this.map.closePopup();

	        // unhighlight all svgs
	        d3.selectAll('path.geohash', this.chartEl).classed('geohash-hover', false);

	        if (!this.geoJson.features.length || this._disableTooltips) {
	          return;
	        }

	        // find nearest feature to event latlng
	        var feature = this._nearestFeature(latlng);

	        // show tooltip if close enough to event latlng
	        if (this._tooltipProximity(latlng, feature)) {
	          this._showTooltip(feature, latlng);
	        }
	      }
	    };

	    /**
	     * returns a memoized Leaflet latLng for given geoJson feature
	     *
	     * @method addLatLng
	     * @param feature {geoJson Object}
	     * @return {Leaflet latLng Object}
	     */
	    HeatmapMarker.prototype._getLatLng = _.memoize(function (feature) {
	      return L.latLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
	    }, function (feature) {
	      // turn coords into a string for the memoize cache
	      return [feature.geometry.coordinates[1], feature.geometry.coordinates[0]].join(',');
	    });

	    /**
	     * Finds nearest feature in mapData to event latlng
	     *
	     * @method _nearestFeature
	     * @param latLng {Leaflet latLng}
	     * @return nearestPoint {Leaflet latLng}
	     */
	    HeatmapMarker.prototype._nearestFeature = function (latLng) {
	      var self = this;
	      var nearest;

	      if (latLng.lng < -180 || latLng.lng > 180) {
	        return;
	      }

	      _.reduce(this.geoJson.features, function (distance, feature) {
	        var featureLatLng = self._getLatLng(feature);
	        var dist = latLng.distanceTo(featureLatLng);

	        if (dist < distance) {
	          nearest = feature;
	          return dist;
	        }

	        return distance;
	      }, Infinity);

	      return nearest;
	    };

	    /**
	     * display tooltip if feature is close enough to event latlng
	     *
	     * @method _tooltipProximity
	     * @param latlng {Leaflet latLng  Object}
	     * @param feature {geoJson Object}
	     * @return {Boolean}
	     */
	    HeatmapMarker.prototype._tooltipProximity = function (latlng, feature) {
	      if (!feature) return;

	      var showTip = false;
	      var featureLatLng = this._getLatLng(feature);

	      // zoomScale takes map zoom and returns proximity value for tooltip display
	      // domain (input values) is map zoom (min 1 and max 18)
	      // range (output values) is distance in meters
	      // used to compare proximity of event latlng to feature latlng
	      var zoomScale = d3.scale.linear().domain([1, 4, 7, 10, 13, 16, 18]).range([1000000, 300000, 100000, 15000, 2000, 150, 50]);

	      var proximity = zoomScale(this.map.getZoom());
	      var distance = latlng.distanceTo(featureLatLng);

	      // maxLngDif is max difference in longitudes
	      // to prevent feature tooltip from appearing 360
	      // away from event latlng
	      var maxLngDif = 40;
	      var lngDif = Math.abs(latlng.lng - featureLatLng.lng);

	      if (distance < proximity && lngDif < maxLngDif) {
	        showTip = true;
	      }

	      var testScale = d3.scale.pow().exponent(0.2).domain([1, 18]).range([1500000, 50]);
	      return showTip;
	    };

	    /**
	     * returns data for data for heat map intensity
	     * if heatNormalizeData attribute is checked/true
	      normalizes data for heat map intensity
	     *
	     * @method _dataToHeatArray
	     * @param max {Number}
	     * @return {Array}
	     */
	    HeatmapMarker.prototype._dataToHeatArray = function (max) {
	      var self = this;
	      var mapData = this.geoJson;

	      return this.geoJson.features.map(function (feature) {
	        var lat = feature.properties.center[0];
	        var lng = feature.properties.center[1];
	        var heatIntensity;

	        if (!self._attr.heatNormalizeData) {
	          // show bucket value on heatmap
	          heatIntensity = feature.properties.value;
	        } else {
	          // show bucket value normalized to max value
	          heatIntensity = parseInt(feature.properties.value / max * 100);
	        }

	        return [lat, lng, heatIntensity];
	      });
	    };

	    return HeatmapMarker;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(409);
	__webpack_require__(414);
	__webpack_require__(415);
	__webpack_require__(416);
	__webpack_require__(417);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function VisTypeFactory(Private) {

	    /**
	     * Provides the visualizations for the vislib
	     *
	     * @module vislib
	     * @submodule VisTypeFactory
	     * @param Private {Object} Loads any function as an angular module
	     * @return {Function} Returns an Object of Visualization classes
	     */
	    return {
	      histogram: Private(__webpack_require__(409)),
	      pie: Private(__webpack_require__(414)),
	      line: Private(__webpack_require__(415)),
	      area: Private(__webpack_require__(416)),
	      tile_map: Private(__webpack_require__(417))
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(226);
	__webpack_require__(337);
	__webpack_require__(410);
	__webpack_require__(413);
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ColumnChartFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var moment = __webpack_require__(226);

	    var DataClass = Private(__webpack_require__(337));

	    var PointSeriesChart = Private(__webpack_require__(410));
	    var TimeMarker = Private(__webpack_require__(413));
	    var errors = __webpack_require__(220);

	    /**
	     * Vertical Bar Chart Visualization: renders vertical and/or stacked bars
	     *
	     * @class ColumnChart
	     * @constructor
	     * @extends Chart
	     * @param handler {Object} Reference to the Handler Class Constructor
	     * @param el {HTMLElement} HTML element to which the chart will be appended
	     * @param chartData {Object} Elasticsearch query results for this specific chart
	     */
	    _['class'](ColumnChart).inherits(PointSeriesChart);
	    function ColumnChart(handler, chartEl, chartData) {
	      if (!(this instanceof ColumnChart)) {
	        return new ColumnChart(handler, chartEl, chartData);
	      }

	      ColumnChart.Super.apply(this, arguments);

	      // Column chart specific attributes
	      this._attr = _.defaults(handler._attr || {}, {
	        xValue: function xValue(d) {
	          return d.x;
	        },
	        yValue: function yValue(d) {
	          return d.y;
	        }
	      });
	    }

	    /**
	     * Adds SVG rect to Vertical Bar Chart
	     *
	     * @method addBars
	     * @param svg {HTMLElement} SVG to which rect are appended
	     * @param layers {Array} Chart data array
	     * @returns {D3.UpdateSelection} SVG with rect added
	     */
	    ColumnChart.prototype.addBars = function (svg, layers) {
	      var self = this;
	      var color = this.handler.data.getColorFunc();
	      var tooltip = this.tooltip;
	      var isTooltip = this._attr.addTooltip;
	      var layer;
	      var bars;

	      layer = svg.selectAll('.layer').data(layers).enter().append('g').attr('class', function (d, i) {
	        return 'series ' + i;
	      });

	      bars = layer.selectAll('rect').data(function (d) {
	        return d;
	      });

	      bars.exit().remove();

	      bars.enter().append('rect').call(this._addIdentifier).attr('fill', function (d) {
	        return color(d.label);
	      });

	      self.updateBars(bars);

	      // Add tooltip
	      if (isTooltip) {
	        bars.call(tooltip.render());
	      }

	      return bars;
	    };

	    /**
	     * Determines whether bars are grouped or stacked and updates the D3
	     * selection
	     *
	     * @method updateBars
	     * @param bars {D3.UpdateSelection} SVG with rect added
	     * @returns {D3.UpdateSelection}
	     */
	    ColumnChart.prototype.updateBars = function (bars) {
	      var offset = this._attr.mode;

	      if (offset === 'grouped') {
	        return this.addGroupedBars(bars);
	      }
	      return this.addStackedBars(bars);
	    };

	    /**
	     * Adds stacked bars to column chart visualization
	     *
	     * @method addStackedBars
	     * @param bars {D3.UpdateSelection} SVG with rect added
	     * @returns {D3.UpdateSelection}
	     */
	    ColumnChart.prototype.addStackedBars = function (bars) {
	      var data = this.chartData;
	      var xScale = this.handler.xAxis.xScale;
	      var yScale = this.handler.yAxis.yScale;
	      var height = yScale.range()[0];
	      var yMin = this.handler.yAxis.yScale.domain()[0];
	      var self = this;

	      var barWidth;
	      if (data.ordered && data.ordered.date) {
	        var start = data.ordered.min;
	        var end = moment(data.ordered.min).add(data.ordered.interval).valueOf();

	        barWidth = xScale(end) - xScale(start);
	        barWidth = barWidth - Math.min(barWidth * 0.25, 15);
	      }

	      // update
	      bars.attr('x', function (d) {
	        return xScale(d.x);
	      }).attr('width', function () {
	        return barWidth || xScale.rangeBand();
	      }).attr('y', function (d) {
	        if (d.y < 0) {
	          return yScale(d.y0);
	        }

	        return yScale(d.y0 + d.y);
	      }).attr('height', function (d) {
	        if (d.y < 0) {
	          return Math.abs(yScale(d.y0 + d.y) - yScale(d.y0));
	        }

	        // Due to an issue with D3 not returning zeros correctly when using
	        // an offset='expand', need to add conditional statement to handle zeros
	        // appropriately
	        if (d._input.y === 0) {
	          return 0;
	        }

	        // for split bars or for one series,
	        // last series will have d.y0 = 0
	        if (d.y0 === 0 && yMin > 0) {
	          return yScale(yMin) - yScale(d.y);
	        }

	        return yScale(d.y0) - yScale(d.y0 + d.y);
	      });

	      return bars;
	    };

	    /**
	     * Adds grouped bars to column chart visualization
	     *
	     * @method addGroupedBars
	     * @param bars {D3.UpdateSelection} SVG with rect added
	     * @returns {D3.UpdateSelection}
	     */
	    ColumnChart.prototype.addGroupedBars = function (bars) {
	      var xScale = this.handler.xAxis.xScale;
	      var yScale = this.handler.yAxis.yScale;
	      var yMin = this.handler.yAxis.yMin;
	      var data = this.chartData;
	      var n = data.series.length;
	      var height = yScale.range()[0];
	      var groupSpacingPercentage = 0.15;
	      var isTimeScale = data.ordered && data.ordered.date;
	      var minWidth = 1;
	      var barWidth;

	      // update
	      bars.attr('x', function (d, i, j) {
	        if (isTimeScale) {
	          var groupWidth = xScale(data.ordered.min + data.ordered.interval) - xScale(data.ordered.min);
	          var groupSpacing = groupWidth * groupSpacingPercentage;

	          barWidth = (groupWidth - groupSpacing) / n;

	          return xScale(d.x) + barWidth * j;
	        }
	        return xScale(d.x) + xScale.rangeBand() / n * j;
	      }).attr('width', function () {
	        if (barWidth < minWidth) {
	          throw new errors.ContainerTooSmall();
	        }

	        if (isTimeScale) {
	          return barWidth;
	        }
	        return xScale.rangeBand() / n;
	      }).attr('y', function (d) {
	        if (d.y < 0) {
	          return yScale(0);
	        }

	        return yScale(d.y);
	      }).attr('height', function (d) {
	        return Math.abs(yScale(0) - yScale(d.y));
	      });

	      return bars;
	    };

	    /**
	     * Adds Events to SVG rect
	     * Visualization is only brushable when a brush event is added
	     * If a brush event is added, then a function should be returned.
	     *
	     * @method addBarEvents
	     * @param element {D3.UpdateSelection} target
	     * @param svg {D3.UpdateSelection} chart SVG
	     * @returns {D3.Selection} rect with event listeners attached
	     */
	    ColumnChart.prototype.addBarEvents = function (element, svg) {
	      var events = this.events;
	      var isBrushable = events.isBrushable();
	      var brush = isBrushable ? events.addBrushEvent(svg) : undefined;
	      var hover = events.addHoverEvent();
	      var mouseout = events.addMouseoutEvent();
	      var click = events.addClickEvent();
	      var attachedEvents = element.call(hover).call(mouseout).call(click);

	      if (isBrushable) {
	        attachedEvents.call(brush);
	      }

	      return attachedEvents;
	    };

	    /**
	     * Renders d3 visualization
	     *
	     * @method draw
	     * @returns {Function} Creates the vertical bar chart
	     */
	    ColumnChart.prototype.draw = function () {
	      var self = this;
	      var $elem = $(this.chartEl);
	      var margin = this._attr.margin;
	      var elWidth = this._attr.width = $elem.width();
	      var elHeight = this._attr.height = $elem.height();
	      var yMin = this.handler.yAxis.yMin;
	      var yScale = this.handler.yAxis.yScale;
	      var xScale = this.handler.xAxis.xScale;
	      var minWidth = 20;
	      var minHeight = 20;
	      var addTimeMarker = this._attr.addTimeMarker;
	      var times = this._attr.times || [];
	      var timeMarker;
	      var div;
	      var svg;
	      var width;
	      var height;
	      var layers;
	      var bars;

	      return function (selection) {
	        selection.each(function (data) {
	          layers = self.stackData(data);

	          width = elWidth;
	          height = elHeight - margin.top - margin.bottom;

	          if (addTimeMarker) {
	            timeMarker = new TimeMarker(times, xScale, height);
	          }

	          if (width < minWidth || height < minHeight) {
	            throw new errors.ContainerTooSmall();
	          }

	          div = d3.select(this);

	          svg = div.append('svg').attr('width', width).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(0,' + margin.top + ')');

	          bars = self.addBars(svg, layers);
	          self.createEndZones(svg);

	          // Adds event listeners
	          self.addBarEvents(bars, svg);

	          var line = svg.append('line').attr('class', 'base-line').attr('x1', 0).attr('y1', yScale(0)).attr('x2', width).attr('y2', yScale(0)).style('stroke', '#ddd').style('stroke-width', 1);

	          if (addTimeMarker) {
	            timeMarker.render(svg);
	          }

	          return svg;
	        });
	      };
	    };

	    return ColumnChart;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(411);
	__webpack_require__(382);
	__webpack_require__(412);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesChartProvider(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);

	    var Chart = Private(__webpack_require__(411));
	    var Tooltip = Private(__webpack_require__(382));
	    var touchdownTmpl = _.template(__webpack_require__(412));

	    _['class'](PointSeriesChart).inherits(Chart);
	    function PointSeriesChart(handler, chartEl, chartData) {
	      if (!(this instanceof PointSeriesChart)) {
	        return new PointSeriesChart(handler, chartEl, chartData);
	      }

	      PointSeriesChart.Super.apply(this, arguments);
	    }

	    PointSeriesChart.prototype._stackMixedValues = function (stackCount) {
	      var currentStackOffsets = [0, 0];
	      var currentStackIndex = 0;

	      return function (d, y0, y) {
	        var firstStack = currentStackIndex % stackCount === 0;
	        var lastStack = ++currentStackIndex === stackCount;

	        if (firstStack) {
	          currentStackOffsets = [0, 0];
	        }

	        if (lastStack) currentStackIndex = 0;

	        if (y >= 0) {
	          d.y0 = currentStackOffsets[1];
	          currentStackOffsets[1] += y;
	        } else {
	          d.y0 = currentStackOffsets[0];
	          currentStackOffsets[0] += y;
	        }
	      };
	    };

	    /**
	     * Stacks chart data values
	     *
	     * @method stackData
	     * @param data {Object} Elasticsearch query result for this chart
	     * @returns {Array} Stacked data objects with x, y, and y0 values
	     */
	    PointSeriesChart.prototype.stackData = function (data) {
	      var self = this;
	      var isHistogram = this._attr.type === 'histogram' && this._attr.mode === 'stacked';
	      var stack = this._attr.stack;

	      if (isHistogram) stack.out(self._stackMixedValues(data.series.length));

	      return stack(data.series.map(function (d) {
	        var label = d.label;
	        return d.values.map(function (e, i) {
	          return {
	            _input: e,
	            label: label,
	            x: self._attr.xValue.call(d.values, e, i),
	            y: self._attr.yValue.call(d.values, e, i)
	          };
	        });
	      }));
	    };

	    PointSeriesChart.prototype._invalidLogScaleValues = function (data) {
	      return data.series && data.series.some(function (d) {
	        return d.values && d.values.some(function (e) {
	          return e.y < 1;
	        });
	      });
	    };

	    /**
	     * Creates rects to show buckets outside of the ordered.min and max, returns rects
	     *
	     * @param xScale {Function} D3 xScale function
	     * @param svg {HTMLElement} Reference to SVG
	     * @method createEndZones
	     * @returns {D3.Selection}
	     */
	    PointSeriesChart.prototype.createEndZones = function (svg) {
	      var self = this;
	      var xAxis = this.handler.xAxis;
	      var xScale = xAxis.xScale;
	      var ordered = xAxis.ordered;
	      var missingMinMax = !ordered || _.isUndefined(ordered.min) || _.isUndefined(ordered.max);

	      if (missingMinMax || ordered.endzones === false) return;

	      var attr = this.handler._attr;
	      var height = attr.height;
	      var width = attr.width;
	      var margin = attr.margin;
	      var color = '#004c99';

	      // we don't want to draw endzones over our min and max values, they
	      // are still a part of the dataset. We want to start the endzones just
	      // outside of them so we will use these values rather than ordered.min/max
	      var oneUnit = (ordered.units || _.identity)(1);
	      var beyondMin = ordered.min - oneUnit;
	      var beyondMax = ordered.max + oneUnit;

	      // points on this axis represent the amount of time they cover,
	      // so draw the endzones at the actual time bounds
	      var leftEndzone = {
	        x: 0,
	        w: Math.max(xScale(ordered.min), 0)
	      };

	      var rightLastVal = xAxis.expandLastBucket ? ordered.max : Math.min(ordered.max, _.last(xAxis.xValues));
	      var rightStart = rightLastVal + oneUnit;
	      var rightEndzone = {
	        x: xScale(rightStart),
	        w: Math.max(width - xScale(rightStart), 0)
	      };

	      this.endzones = svg.selectAll('.layer').data([leftEndzone, rightEndzone]).enter().insert('g', '.brush').attr('class', 'endzone').append('rect').attr('class', 'zone').attr('x', function (d) {
	        return d.x;
	      }).attr('y', 0).attr('height', height - margin.top - margin.bottom).attr('width', function (d) {
	        return d.w;
	      });

	      function callPlay(event) {
	        var boundData = event.target.__data__;
	        var mouseChartXCoord = event.clientX - self.chartEl.getBoundingClientRect().left;
	        var wholeBucket = boundData && boundData.x != null;

	        // the min and max that the endzones start in
	        var min = leftEndzone.w;
	        var max = rightEndzone.x;

	        // bounds of the cursor to consider
	        var xLeft = mouseChartXCoord;
	        var xRight = mouseChartXCoord;
	        if (wholeBucket) {
	          xLeft = xScale(boundData.x);
	          xRight = xScale(xAxis.addInterval(boundData.x));
	        }

	        return {
	          wholeBucket: wholeBucket,
	          touchdown: min > xLeft || max < xRight
	        };
	      }

	      function textFormatter() {
	        return touchdownTmpl(callPlay(d3.event));
	      }

	      var endzoneTT = new Tooltip('endzones', this.handler.el, textFormatter, null);
	      this.tooltips.push(endzoneTT);
	      endzoneTT.order = 0;
	      endzoneTT.showCondition = function inEndzone() {
	        return callPlay(d3.event).touchdown;
	      };
	      endzoneTT.render()(svg);
	    };

	    return PointSeriesChart;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(220);
	__webpack_require__(381);
	__webpack_require__(382);
	__webpack_require__(385);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ChartBaseClass(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var errors = __webpack_require__(220);

	    var Dispatch = Private(__webpack_require__(381));
	    var Tooltip = Private(__webpack_require__(382));
	    var dataLabel = __webpack_require__(385);

	    /**
	     * The Base Class for all visualizations.
	     *
	     * @class Chart
	     * @constructor
	     * @param handler {Object} Reference to the Handler Class Constructor
	     * @param el {HTMLElement} HTML element to which the chart will be appended
	     * @param chartData {Object} Elasticsearch query results for this specific chart
	     */
	    function Chart(handler, el, chartData) {
	      if (!(this instanceof Chart)) {
	        return new Chart(handler, el, chartData);
	      }

	      this.handler = handler;
	      this.chartEl = el;
	      this.chartData = chartData;
	      this.tooltips = [];

	      var events = this.events = new Dispatch(handler);

	      if (_.get(this.handler, '_attr.addTooltip')) {
	        var $el = this.handler.el;
	        var formatter = this.handler.data.get('tooltipFormatter');

	        // Add tooltip
	        this.tooltip = new Tooltip('chart', $el, formatter, events);
	        this.tooltips.push(this.tooltip);
	      }

	      this._attr = _.defaults(this.handler._attr || {}, {});
	      this._addIdentifier = _.bind(this._addIdentifier, this);
	    }

	    /**
	     * Renders the chart(s)
	     *
	     * @method render
	     * @returns {HTMLElement} Contains the D3 chart
	     */
	    Chart.prototype.render = function () {
	      var selection = d3.select(this.chartEl);

	      selection.selectAll('*').remove();
	      selection.call(this.draw());
	    };

	    /**
	     * Append the data label to the element
	     *
	     * @method _addIdentifier
	     * @param selection {Object} d3 select object
	     */
	    Chart.prototype._addIdentifier = function (selection, labelProp) {
	      labelProp = labelProp || 'label';
	      var labels = this.handler.data.labels;

	      function resolveLabel(datum) {
	        if (labels.length === 1) return labels[0];
	        if (datum[0]) return datum[0][labelProp];
	        return datum[labelProp];
	      }

	      selection.each(function (datum) {
	        var label = resolveLabel(datum);
	        if (label != null) dataLabel(this, label);
	      });
	    };

	    /**
	     * Removes all DOM elements from the root element
	     *
	     * @method destroy
	     */
	    Chart.prototype.destroy = function () {
	      var selection = d3.select(this.chartEl);
	      this.events.removeAllListeners();
	      this.tooltips.forEach(function (tooltip) {
	        tooltip.destroy();
	      });
	      selection.remove();
	      selection = null;
	    };

	    return Chart;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 412 */
/***/ function(module, exports) {

	module.exports = "<p class=\"vis-tooltip-header bg-info\">\n  <i class=\"fa fa-info-circle vis-tooltip-header-icon\"></i>\n  <span class=\"vis-tooltip-header-text\">\n    <%= wholeBucket ? 'Part of this bucket' : 'This area' %>\n    may contain partial data. <br> The selected time range does not fully cover it.\n  </span>\n</p>"

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(228);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TimeMarkerFactory() {
	    var d3 = __webpack_require__(335);
	    var dateMath = __webpack_require__(228);

	    function TimeMarker(times, xScale, height) {
	      if (!(this instanceof TimeMarker)) {
	        return new TimeMarker(times, xScale, height);
	      }

	      var currentTimeArr = [{
	        'time': new Date().getTime(),
	        'class': 'time-marker',
	        'color': '#c80000',
	        'opacity': 0.3,
	        'width': 2
	      }];

	      this.xScale = xScale;
	      this.height = height;
	      this.times = times.length ? times.map(function (d) {
	        return {
	          'time': dateMath.parse(d.time),
	          'class': d['class'] || 'time-marker',
	          'color': d.color || '#c80000',
	          'opacity': d.opacity || 0.3,
	          'width': d.width || 2
	        };
	      }) : currentTimeArr;
	    }

	    TimeMarker.prototype._isTimeBasedChart = function (selection) {
	      var data = selection.data();
	      return data.every(function (datum) {
	        return datum.ordered && datum.ordered.date;
	      });
	    };

	    TimeMarker.prototype.render = function (selection) {
	      var self = this;

	      // return if not time based chart
	      if (!self._isTimeBasedChart(selection)) return;

	      selection.each(function () {
	        d3.select(this).selectAll('time-marker').data(self.times).enter().append('line').attr('class', function (d) {
	          return d['class'];
	        }).attr('pointer-events', 'none').attr('stroke', function (d) {
	          return d.color;
	        }).attr('stroke-width', function (d) {
	          return d.width;
	        }).attr('stroke-opacity', function (d) {
	          return d.opacity;
	        }).attr('x1', function (d) {
	          return self.xScale(d.time);
	        }).attr('x2', function (d) {
	          return self.xScale(d.time);
	        }).attr('y1', self.height).attr('y2', self.xScale.range()[0]);
	      });
	    };

	    return TimeMarker;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(411);
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PieChartFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);

	    var Chart = Private(__webpack_require__(411));
	    var errors = __webpack_require__(220);

	    /**
	     * Pie Chart Visualization
	     *
	     * @class PieChart
	     * @constructor
	     * @extends Chart
	     * @param handler {Object} Reference to the Handler Class Constructor
	     * @param el {HTMLElement} HTML element to which the chart will be appended
	     * @param chartData {Object} Elasticsearch query results for this specific chart
	     */
	    _['class'](PieChart).inherits(Chart);
	    function PieChart(handler, chartEl, chartData) {
	      if (!(this instanceof PieChart)) {
	        return new PieChart(handler, chartEl, chartData);
	      }
	      PieChart.Super.apply(this, arguments);

	      var charts = this.handler.data.getVisData();
	      this._validatePieData(charts);

	      this._attr = _.defaults(handler._attr || {}, {
	        isDonut: handler._attr.isDonut || false
	      });
	    }

	    /**
	     * Checks whether pie slices have all zero values.
	     * If so, an error is thrown.
	     */
	    PieChart.prototype._validatePieData = function (charts) {
	      var isAllZeros = charts.every(function (chart) {
	        return chart.slices.children.length === 0;
	      });

	      if (isAllZeros) {
	        throw new errors.PieContainsAllZeros();
	      }
	    };

	    /**
	     * Adds Events to SVG paths
	     *
	     * @method addPathEvents
	     * @param element {D3.Selection} Reference to SVG path
	     * @returns {D3.Selection} SVG path with event listeners attached
	     */
	    PieChart.prototype.addPathEvents = function (element) {
	      var events = this.events;

	      return element.call(events.addHoverEvent()).call(events.addMouseoutEvent()).call(events.addClickEvent());
	    };

	    PieChart.prototype.convertToPercentage = function (slices) {
	      (function assignPercentages(slices) {
	        if (slices.sumOfChildren != null) return;

	        var parent = slices;
	        var children = parent.children;
	        var parentPercent = parent.percentOfParent;

	        var sum = parent.sumOfChildren = Math.abs(children.reduce(function (sum, child) {
	          return sum + Math.abs(child.size);
	        }, 0));

	        children.forEach(function (child) {
	          child.percentOfGroup = Math.abs(child.size) / sum;
	          child.percentOfParent = child.percentOfGroup;

	          if (parentPercent != null) {
	            child.percentOfParent *= parentPercent;
	          }

	          if (child.children) {
	            assignPercentages(child);
	          }
	        });
	      })(slices);
	    };

	    /**
	     * Adds pie paths to SVG
	     *
	     * @method addPath
	     * @param width {Number} Width of SVG
	     * @param height {Number} Height of SVG
	     * @param svg {HTMLElement} Chart SVG
	     * @param slices {Object} Chart data
	     * @returns {D3.Selection} SVG with paths attached
	     */
	    PieChart.prototype.addPath = function (width, height, svg, slices) {
	      var self = this;
	      var marginFactor = 0.95;
	      var isDonut = self._attr.isDonut;
	      var radius = Math.min(width, height) / 2 * marginFactor;
	      var color = self.handler.data.getPieColorFunc();
	      var tooltip = self.tooltip;
	      var isTooltip = self._attr.addTooltip;

	      var partition = d3.layout.partition().sort(null).value(function (d) {
	        return d.percentOfParent * 100;
	      });
	      var x = d3.scale.linear().range([0, 2 * Math.PI]);
	      var y = d3.scale.sqrt().range([0, radius]);
	      var arc = d3.svg.arc().startAngle(function (d) {
	        return Math.max(0, Math.min(2 * Math.PI, x(d.x)));
	      }).endAngle(function (d) {
	        return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));
	      }).innerRadius(function (d) {
	        // option for a single layer, i.e pie chart
	        if (d.depth === 1 && !isDonut) {
	          // return no inner radius
	          return 0;
	        }

	        return Math.max(0, y(d.y));
	      }).outerRadius(function (d) {
	        return Math.max(0, y(d.y + d.dy));
	      });

	      var path = svg.datum(slices).selectAll('path').data(partition.nodes).enter().append('path').attr('d', arc).attr('class', function (d) {
	        if (d.depth === 0) {
	          return;
	        }
	        return 'slice';
	      }).call(self._addIdentifier, 'name').style('stroke', '#fff').style('fill', function (d) {
	        if (d.depth === 0) {
	          return 'none';
	        }
	        return color(d.name);
	      });

	      if (isTooltip) {
	        path.call(tooltip.render());
	      }

	      return path;
	    };

	    PieChart.prototype._validateContainerSize = function (width, height) {
	      var minWidth = 20;
	      var minHeight = 20;

	      if (width <= minWidth || height <= minHeight) {
	        throw new errors.ContainerTooSmall();
	      }
	    };

	    /**
	     * Renders d3 visualization
	     *
	     * @method draw
	     * @returns {Function} Creates the pie chart
	     */
	    PieChart.prototype.draw = function () {
	      var self = this;

	      return function (selection) {
	        selection.each(function (data) {
	          var slices = data.slices;
	          var div = d3.select(this);
	          var width = $(this).width();
	          var height = $(this).height();
	          var path;

	          if (!slices.children.length) return;

	          self.convertToPercentage(slices);
	          self._validateContainerSize(width, height);

	          var svg = div.append('svg').attr('width', width).attr('height', height).append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

	          path = self.addPath(width, height, svg, slices);
	          self.addPathEvents(path);

	          return svg;
	        });
	      };
	    };

	    return PieChart;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(220);
	__webpack_require__(410);
	__webpack_require__(413);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function LineChartFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var errors = __webpack_require__(220);

	    var PointSeriesChart = Private(__webpack_require__(410));
	    var TimeMarker = Private(__webpack_require__(413));

	    /**
	     * Line Chart Visualization
	     *
	     * @class LineChart
	     * @constructor
	     * @extends Chart
	     * @param handler {Object} Reference to the Handler Class Constructor
	     * @param el {HTMLElement} HTML element to which the chart will be appended
	     * @param chartData {Object} Elasticsearch query results for this specific chart
	     */
	    _['class'](LineChart).inherits(PointSeriesChart);
	    function LineChart(handler, chartEl, chartData) {
	      if (!(this instanceof LineChart)) {
	        return new LineChart(handler, chartEl, chartData);
	      }

	      LineChart.Super.apply(this, arguments);

	      // Line chart specific attributes
	      this._attr = _.defaults(handler._attr || {}, {
	        interpolate: 'linear',
	        xValue: function xValue(d) {
	          return d.x;
	        },
	        yValue: function yValue(d) {
	          return d.y;
	        }
	      });
	    }

	    /**
	     * Adds Events to SVG circle
	     *
	     * @method addCircleEvents
	     * @param element{D3.UpdateSelection} Reference to SVG circle
	     * @returns {D3.Selection} SVG circles with event listeners attached
	     */
	    LineChart.prototype.addCircleEvents = function (element, svg) {
	      var events = this.events;
	      var isBrushable = events.isBrushable();
	      var brush = isBrushable ? events.addBrushEvent(svg) : undefined;
	      var hover = events.addHoverEvent();
	      var mouseout = events.addMouseoutEvent();
	      var click = events.addClickEvent();
	      var attachedEvents = element.call(hover).call(mouseout).call(click);

	      if (isBrushable) {
	        attachedEvents.call(brush);
	      }

	      return attachedEvents;
	    };

	    /**
	     * Adds circles to SVG
	     *
	     * @method addCircles
	     * @param svg {HTMLElement} SVG to which rect are appended
	     * @param data {Array} Array of object data points
	     * @returns {D3.UpdateSelection} SVG with circles added
	     */
	    LineChart.prototype.addCircles = function (svg, data) {
	      var self = this;
	      var showCircles = this._attr.showCircles;
	      var color = this.handler.data.getColorFunc();
	      var xScale = this.handler.xAxis.xScale;
	      var yScale = this.handler.yAxis.yScale;
	      var ordered = this.handler.data.get('ordered');
	      var tooltip = this.tooltip;
	      var isTooltip = this._attr.addTooltip;

	      var radii = _(data).map(function (series) {
	        return _.pluck(series, '_input.z');
	      }).flattenDeep().reduce(function (result, val) {
	        if (result.min > val) result.min = val;
	        if (result.max < val) result.max = val;
	        return result;
	      }, {
	        min: Infinity,
	        max: -Infinity
	      });

	      var radiusStep = (radii.max - radii.min || radii.max * 100) / Math.pow(this._attr.radiusRatio, 2);

	      var layer = svg.selectAll('.points').data(data).enter().append('g').attr('class', 'points line');

	      var circles = layer.selectAll('circle').data(function appendData(data) {
	        return data.filter(function (d) {
	          return !_.isNull(d.y);
	        });
	      });

	      circles.exit().remove();

	      function cx(d) {
	        if (ordered && ordered.date) {
	          return xScale(d.x);
	        }
	        return xScale(d.x) + xScale.rangeBand() / 2;
	      }

	      function cy(d) {
	        return yScale(d.y);
	      }

	      function cColor(d) {
	        return color(d.label);
	      }

	      function colorCircle(d) {
	        var parent = d3.select(this).node().parentNode;
	        var lengthOfParent = d3.select(parent).data()[0].length;
	        var isVisible = lengthOfParent === 1;

	        // If only 1 point exists, show circle
	        if (!showCircles && !isVisible) return 'none';
	        return cColor(d);
	      }
	      function getCircleRadiusFn(modifier) {
	        return function getCircleRadius(d) {
	          var margin = self._attr.margin;
	          var width = self._attr.width - margin.left - margin.right;
	          var height = self._attr.height - margin.top - margin.bottom;
	          var circleRadius = (d._input.z - radii.min) / radiusStep;

	          return _.min([Math.sqrt((circleRadius || 2) + 2), width, height]) + (modifier || 0);
	        };
	      }

	      circles.enter().append('circle').attr('r', getCircleRadiusFn()).attr('fill-opacity', this._attr.drawLinesBetweenPoints ? 1 : 0.7).attr('cx', cx).attr('cy', cy).attr('class', 'circle-decoration').call(this._addIdentifier).attr('fill', colorCircle);

	      circles.enter().append('circle').attr('r', getCircleRadiusFn(10)).attr('cx', cx).attr('cy', cy).attr('fill', 'transparent').attr('class', 'circle').call(this._addIdentifier).attr('stroke', cColor).attr('stroke-width', 0);

	      if (isTooltip) {
	        circles.call(tooltip.render());
	      }

	      return circles;
	    };

	    /**
	     * Adds path to SVG
	     *
	     * @method addLines
	     * @param svg {HTMLElement} SVG to which path are appended
	     * @param data {Array} Array of object data points
	     * @returns {D3.UpdateSelection} SVG with paths added
	     */
	    LineChart.prototype.addLines = function (svg, data) {
	      var self = this;
	      var xScale = this.handler.xAxis.xScale;
	      var yScale = this.handler.yAxis.yScale;
	      var xAxisFormatter = this.handler.data.get('xAxisFormatter');
	      var color = this.handler.data.getColorFunc();
	      var ordered = this.handler.data.get('ordered');
	      var interpolate = this._attr.smoothLines ? 'cardinal' : this._attr.interpolate;
	      var line = d3.svg.line().defined(function (d) {
	        return !_.isNull(d.y);
	      }).interpolate(interpolate).x(function x(d) {
	        if (ordered && ordered.date) {
	          return xScale(d.x);
	        }
	        return xScale(d.x) + xScale.rangeBand() / 2;
	      }).y(function y(d) {
	        return yScale(d.y);
	      });
	      var lines;

	      lines = svg.selectAll('.lines').data(data).enter().append('g').attr('class', 'pathgroup lines');

	      lines.append('path').call(this._addIdentifier).attr('d', function lineD(d) {
	        return line(d.values);
	      }).attr('fill', 'none').attr('stroke', function lineStroke(d) {
	        return color(d.label);
	      }).attr('stroke-width', 2);

	      return lines;
	    };

	    /**
	     * Adds SVG clipPath
	     *
	     * @method addClipPath
	     * @param svg {HTMLElement} SVG to which clipPath is appended
	     * @param width {Number} SVG width
	     * @param height {Number} SVG height
	     * @returns {D3.UpdateSelection} SVG with clipPath added
	     */
	    LineChart.prototype.addClipPath = function (svg, width, height) {
	      var clipPathBuffer = 5;
	      var startX = 0;
	      var startY = 0 - clipPathBuffer;
	      var id = 'chart-area' + _.uniqueId();

	      return svg.attr('clip-path', 'url(#' + id + ')').append('clipPath').attr('id', id).append('rect').attr('x', startX).attr('y', startY).attr('width', width)
	      // Adding clipPathBuffer to height so it doesn't
	      // cutoff the lower part of the chart
	      .attr('height', height + clipPathBuffer);
	    };

	    /**
	     * Renders d3 visualization
	     *
	     * @method draw
	     * @returns {Function} Creates the line chart
	     */
	    LineChart.prototype.draw = function () {
	      var self = this;
	      var $elem = $(this.chartEl);
	      var margin = this._attr.margin;
	      var elWidth = this._attr.width = $elem.width();
	      var elHeight = this._attr.height = $elem.height();
	      var scaleType = this.handler.yAxis.getScaleType();
	      var yMin = this.handler.yAxis.yMin;
	      var yScale = this.handler.yAxis.yScale;
	      var xScale = this.handler.xAxis.xScale;
	      var minWidth = 20;
	      var minHeight = 20;
	      var startLineX = 0;
	      var lineStrokeWidth = 1;
	      var addTimeMarker = this._attr.addTimeMarker;
	      var times = this._attr.times || [];
	      var timeMarker;
	      var div;
	      var svg;
	      var width;
	      var height;
	      var lines;
	      var circles;

	      return function (selection) {
	        selection.each(function (data) {
	          var el = this;

	          var layers = data.series.map(function mapSeries(d) {
	            var label = d.label;
	            return d.values.map(function mapValues(e, i) {
	              return {
	                _input: e,
	                label: label,
	                x: self._attr.xValue.call(d.values, e, i),
	                y: self._attr.yValue.call(d.values, e, i)
	              };
	            });
	          });

	          width = elWidth - margin.left - margin.right;
	          height = elHeight - margin.top - margin.bottom;

	          if (addTimeMarker) {
	            timeMarker = new TimeMarker(times, xScale, height);
	          }

	          if (self._attr.scale === 'log' && self._invalidLogScaleValues(data)) {
	            throw new errors.InvalidLogScaleValues();
	          }

	          if (width < minWidth || height < minHeight) {
	            throw new errors.ContainerTooSmall();
	          }

	          div = d3.select(el);

	          svg = div.append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

	          self.addClipPath(svg, width, height);
	          if (self._attr.drawLinesBetweenPoints) {
	            lines = self.addLines(svg, data.series);
	          }
	          circles = self.addCircles(svg, layers);
	          self.addCircleEvents(circles, svg);
	          self.createEndZones(svg);

	          var scale = scaleType === 'log' ? yScale(1) : yScale(0);
	          if (scale) {
	            svg.append('line').attr('class', 'base-line').attr('x1', startLineX).attr('y1', scale).attr('x2', width).attr('y2', scale).style('stroke', '#ddd').style('stroke-width', lineStrokeWidth);
	          }

	          if (addTimeMarker) {
	            timeMarker.render(svg);
	          }

	          return svg;
	        });
	      };
	    };

	    return LineChart;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(410);
	__webpack_require__(413);
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AreaChartFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);

	    var PointSeriesChart = Private(__webpack_require__(410));
	    var TimeMarker = Private(__webpack_require__(413));
	    var errors = __webpack_require__(220);

	    /**
	     * Area chart visualization
	     *
	     * @class AreaChart
	     * @constructor
	     * @extends Chart
	     * @param handler {Object} Reference to the Handler Class Constructor
	     * @param el {HTMLElement} HTML element to which the chart will be appended
	     * @param chartData {Object} Elasticsearch query results for this specific
	     * chart
	     */
	    _['class'](AreaChart).inherits(PointSeriesChart);
	    function AreaChart(handler, chartEl, chartData) {
	      if (!(this instanceof AreaChart)) {
	        return new AreaChart(handler, chartEl, chartData);
	      }

	      AreaChart.Super.apply(this, arguments);

	      this.isOverlapping = handler._attr.mode === 'overlap';

	      if (this.isOverlapping) {

	        // Default opacity should return to 0.6 on mouseout
	        handler._attr.defaultOpacity = 0.6;
	      }

	      this.checkIfEnoughData();

	      this._attr = _.defaults(handler._attr || {}, {
	        xValue: function xValue(d) {
	          return d.x;
	        },
	        yValue: function yValue(d) {
	          return d.y;
	        }
	      });
	    }

	    /**
	     * Adds SVG path to area chart
	     *
	     * @method addPath
	     * @param svg {HTMLElement} SVG to which rect are appended
	     * @param layers {Array} Chart data array
	     * @returns {D3.UpdateSelection} SVG with path added
	     */
	    AreaChart.prototype.addPath = function (svg, layers) {
	      var self = this;
	      var ordered = this.handler.data.get('ordered');
	      var isTimeSeries = ordered && ordered.date;
	      var isOverlapping = this.isOverlapping;
	      var color = this.handler.data.getColorFunc();
	      var xScale = this.handler.xAxis.xScale;
	      var yScale = this.handler.yAxis.yScale;
	      var interpolate = this._attr.smoothLines ? 'cardinal' : this._attr.interpolate;
	      var area = d3.svg.area().x(function (d) {
	        if (isTimeSeries) {
	          return xScale(d.x);
	        }
	        return xScale(d.x) + xScale.rangeBand() / 2;
	      }).y0(function (d) {
	        if (isOverlapping) {
	          return yScale(0);
	        }

	        return yScale(d.y0);
	      }).y1(function (d) {
	        if (isOverlapping) {
	          return yScale(d.y);
	        }

	        return yScale(d.y0 + d.y);
	      }).defined(function (d) {
	        return !_.isNull(d.y);
	      }).interpolate(interpolate);

	      // Data layers
	      var layer = svg.selectAll('.layer').data(layers).enter().append('g').attr('class', function (d, i) {
	        return 'pathgroup ' + i;
	      });

	      // Append path
	      var path = layer.append('path').call(this._addIdentifier).style('fill', function (d) {
	        return color(d[0].label);
	      }).classed('overlap_area', function () {
	        return isOverlapping;
	      });

	      // update
	      path.attr('d', function (d) {
	        return area(d);
	      });

	      return path;
	    };

	    /**
	     * Adds Events to SVG circles
	     *
	     * @method addCircleEvents
	     * @param element {D3.UpdateSelection} SVG circles
	     * @returns {D3.Selection} circles with event listeners attached
	     */
	    AreaChart.prototype.addCircleEvents = function (element, svg) {
	      var events = this.events;
	      var isBrushable = events.isBrushable();
	      var brush = isBrushable ? events.addBrushEvent(svg) : undefined;
	      var hover = events.addHoverEvent();
	      var mouseout = events.addMouseoutEvent();
	      var click = events.addClickEvent();
	      var attachedEvents = element.call(hover).call(mouseout).call(click);

	      if (isBrushable) {
	        attachedEvents.call(brush);
	      }

	      return attachedEvents;
	    };

	    /**
	     * Adds SVG circles to area chart
	     *
	     * @method addCircles
	     * @param svg {HTMLElement} SVG to which circles are appended
	     * @param data {Array} Chart data array
	     * @returns {D3.UpdateSelection} SVG with circles added
	     */
	    AreaChart.prototype.addCircles = function (svg, data) {
	      var self = this;
	      var color = this.handler.data.getColorFunc();
	      var xScale = this.handler.xAxis.xScale;
	      var yScale = this.handler.yAxis.yScale;
	      var ordered = this.handler.data.get('ordered');
	      var circleRadius = 12;
	      var circleStrokeWidth = 0;
	      var tooltip = this.tooltip;
	      var isTooltip = this._attr.addTooltip;
	      var isOverlapping = this.isOverlapping;
	      var layer;
	      var circles;

	      layer = svg.selectAll('.points').data(data).enter().append('g').attr('class', 'points area');

	      // append the circles
	      circles = layer.selectAll('circles').data(function appendData(data) {
	        return data.filter(function isZeroOrNull(d) {
	          return d.y !== 0 && !_.isNull(d.y);
	        });
	      });

	      // exit
	      circles.exit().remove();

	      // enter
	      circles.enter().append('circle').call(this._addIdentifier).attr('stroke', function strokeColor(d) {
	        return color(d.label);
	      }).attr('fill', 'transparent').attr('stroke-width', circleStrokeWidth);

	      // update
	      circles.attr('cx', function cx(d) {
	        if (ordered && ordered.date) {
	          return xScale(d.x);
	        }
	        return xScale(d.x) + xScale.rangeBand() / 2;
	      }).attr('cy', function cy(d) {
	        if (isOverlapping) {
	          return yScale(d.y);
	        }
	        return yScale(d.y0 + d.y);
	      }).attr('r', circleRadius);

	      // Add tooltip
	      if (isTooltip) {
	        circles.call(tooltip.render());
	      }

	      return circles;
	    };

	    /**
	     * Adds SVG clipPath
	     *
	     * @method addClipPath
	     * @param svg {HTMLElement} SVG to which clipPath is appended
	     * @param width {Number} SVG width
	     * @param height {Number} SVG height
	     * @returns {D3.UpdateSelection} SVG with clipPath added
	     */
	    AreaChart.prototype.addClipPath = function (svg, width, height) {
	      // Prevents circles from being clipped at the top of the chart
	      var startX = 0;
	      var startY = 0;
	      var id = 'chart-area' + _.uniqueId();

	      // Creating clipPath
	      return svg.attr('clip-path', 'url(#' + id + ')').append('clipPath').attr('id', id).append('rect').attr('x', startX).attr('y', startY).attr('width', width).attr('height', height);
	    };

	    AreaChart.prototype.checkIfEnoughData = function () {
	      var series = this.chartData.series;
	      var message = 'Area charts require more than one data point. Try adding ' + 'an X-Axis Aggregation';

	      var notEnoughData = series.some(function (obj) {
	        return obj.values.length < 2;
	      });

	      if (notEnoughData) {
	        throw new errors.NotEnoughData(message);
	      }
	    };

	    AreaChart.prototype.validateWiggleSelection = function () {
	      var isWiggle = this._attr.mode === 'wiggle';
	      var ordered = this.handler.data.get('ordered');

	      if (isWiggle && !ordered) throw new errors.InvalidWiggleSelection();
	    };

	    /**
	     * Renders d3 visualization
	     *
	     * @method draw
	     * @returns {Function} Creates the area chart
	     */
	    AreaChart.prototype.draw = function () {
	      // Attributes
	      var self = this;
	      var xScale = this.handler.xAxis.xScale;
	      var $elem = $(this.chartEl);
	      var margin = this._attr.margin;
	      var elWidth = this._attr.width = $elem.width();
	      var elHeight = this._attr.height = $elem.height();
	      var yMin = this.handler.yAxis.yMin;
	      var yScale = this.handler.yAxis.yScale;
	      var minWidth = 20;
	      var minHeight = 20;
	      var addTimeMarker = this._attr.addTimeMarker;
	      var times = this._attr.times || [];
	      var timeMarker;
	      var div;
	      var svg;
	      var width;
	      var height;
	      var layers;
	      var circles;
	      var path;

	      return function (selection) {
	        selection.each(function (data) {
	          // Stack data
	          layers = self.stackData(data);

	          // Get the width and height
	          width = elWidth;
	          height = elHeight - margin.top - margin.bottom;

	          if (addTimeMarker) {
	            timeMarker = new TimeMarker(times, xScale, height);
	          }

	          if (width < minWidth || height < minHeight) {
	            throw new errors.ContainerTooSmall();
	          }
	          self.validateWiggleSelection();

	          // Select the current DOM element
	          div = d3.select(this);

	          // Create the canvas for the visualization
	          svg = div.append('svg').attr('width', width).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', 'translate(0,' + margin.top + ')');

	          // add clipPath to hide circles when they go out of bounds
	          self.addClipPath(svg, width, height);
	          self.createEndZones(svg);

	          // add path
	          path = self.addPath(svg, layers);

	          if (yMin < 0 && self._attr.mode !== 'wiggle' && self._attr.mode !== 'silhouette') {

	            // Draw line at yScale 0 value
	            svg.append('line').attr('class', 'zero-line').attr('x1', 0).attr('y1', yScale(0)).attr('x2', width).attr('y2', yScale(0)).style('stroke', '#ddd').style('stroke-width', 1);
	          }

	          // add circles
	          circles = self.addCircles(svg, layers);

	          // add click and hover events to circles
	          self.addCircleEvents(circles, svg);

	          // chart base line
	          var line = svg.append('line').attr('class', 'base-line').attr('x1', 0).attr('y1', yScale(0)).attr('x2', width).attr('y2', yScale(0)).style('stroke', '#ddd').style('stroke-width', 1);

	          if (addTimeMarker) {
	            timeMarker.render(svg);
	          }

	          return svg;
	        });
	      };
	    };

	    return AreaChart;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(335);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(411);
	__webpack_require__(395);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TileMapFactory(Private) {
	    var d3 = __webpack_require__(335);
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);

	    var Chart = Private(__webpack_require__(411));
	    var TileMapMap = Private(__webpack_require__(395));

	    /**
	     * Tile Map Visualization: renders maps
	     *
	     * @class TileMap
	     * @constructor
	     * @extends Chart
	     * @param handler {Object} Reference to the Handler Class Constructor
	     * @param chartEl {HTMLElement} HTML element to which the map will be appended
	     * @param chartData {Object} Elasticsearch query results for this map
	     */
	    _['class'](TileMap).inherits(Chart);
	    function TileMap(handler, chartEl, chartData) {
	      if (!(this instanceof TileMap)) {
	        return new TileMap(handler, chartEl, chartData);
	      }

	      TileMap.Super.apply(this, arguments);

	      // track the map objects
	      this.maps = [];
	      this._chartData = chartData || {};
	      _.assign(this, this._chartData);

	      this._appendGeoExtents();
	    }

	    /**
	     * Draws tile map, called on chart render
	     *
	     * @method draw
	     * @return {Function} - function to add a map to a selection
	     */
	    TileMap.prototype.draw = function () {
	      var self = this;

	      // clean up old maps
	      self.destroy();

	      return function (selection) {
	        selection.each(function () {
	          self._appendMap(this);
	        });
	      };
	    };

	    /**
	     * Invalidate the size of the map, so that leaflet will resize to fit.
	     * then moves to center
	     *
	     * @method resizeArea
	     * @return {undefined}
	     */
	    TileMap.prototype.resizeArea = function () {
	      this.maps.forEach(function (map) {
	        map.updateSize();
	      });
	    };

	    /**
	     * clean up the maps
	     *
	     * @method destroy
	     * @return {undefined}
	     */
	    TileMap.prototype.destroy = function () {
	      this.maps = this.maps.filter(function (map) {
	        map.destroy();
	      });
	    };

	    /**
	     * Adds allmin and allmax properties to geoJson data
	     *
	     * @method _appendMap
	     * @param selection {Object} d3 selection
	     */
	    TileMap.prototype._appendGeoExtents = function () {
	      // add allmin and allmax to geoJson
	      var geoMinMax = this.handler.data.getGeoExtents();
	      this.geoJson.properties.allmin = geoMinMax.min;
	      this.geoJson.properties.allmax = geoMinMax.max;
	    };

	    /**
	     * Renders map
	     *
	     * @method _appendMap
	     * @param selection {Object} d3 selection
	     */
	    TileMap.prototype._appendMap = function (selection) {
	      var container = $(selection).addClass('tilemap');

	      var map = new TileMapMap(container, this._chartData, {
	        // center: this._attr.mapCenter,
	        // zoom: this._attr.mapZoom,
	        events: this.events,
	        markerType: this._attr.mapType,
	        tooltipFormatter: this.tooltipFormatter,
	        valueFormatter: this.valueFormatter,
	        attr: this._attr
	      });

	      // add title for splits
	      if (this.title) {
	        map.addTitle(this.title);
	      }

	      // add fit to bounds control
	      if (_.get(this.geoJson, 'features.length') > 0) {
	        map.addFitControl();
	        map.addBoundingControl();
	      }

	      this.maps.push(map);
	    };

	    return TileMap;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 418 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(335);
	__webpack_require__(336);
	__webpack_require__(420);
	__webpack_require__(238);
	__webpack_require__(394);
	__webpack_require__(408);
	__webpack_require__(220);
	__webpack_require__(418);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function VisFactory(Private) {
	    var _ = __webpack_require__(192);
	    var d3 = __webpack_require__(335);

	    var Binder = __webpack_require__(336);

	    var ResizeChecker = Private(__webpack_require__(420));
	    var Events = Private(__webpack_require__(238));
	    var handlerTypes = Private(__webpack_require__(394));
	    var chartTypes = Private(__webpack_require__(408));
	    var errors = __webpack_require__(220);
	    __webpack_require__(418);

	    /**
	     * Creates the visualizations.
	     *
	     * @class Vis
	     * @constructor
	     * @param $el {HTMLElement} jQuery selected HTML element
	     * @param config {Object} Parameters that define the chart type and chart options
	     */
	    _['class'](Vis).inherits(Events);
	    function Vis($el, config) {
	      if (!(this instanceof Vis)) {
	        return new Vis($el, config);
	      }
	      Vis.Super.apply(this, arguments);
	      this.el = $el.get ? $el.get(0) : $el;
	      this.binder = new Binder();
	      this.ChartClass = chartTypes[config.type];
	      this._attr = _.defaults({}, config || {}, {
	        legendOpen: true
	      });

	      // bind the resize function so it can be used as an event handler
	      this.resize = _.bind(this.resize, this);
	      this.resizeChecker = new ResizeChecker(this.el);
	      this.binder.on(this.resizeChecker, 'resize', this.resize);
	    }

	    /**
	     * Renders the visualization
	     *
	     * @method render
	     * @param data {Object} Elasticsearch query results
	     */
	    Vis.prototype.render = function (data) {
	      var chartType = this._attr.type;

	      if (!data) {
	        throw new Error('No valid data!');
	      }

	      if (this.handler) {
	        this.data = null;
	        this._runOnHandler('destroy');
	      }

	      this.data = data;
	      this.handler = handlerTypes[chartType](this) || handlerTypes.column(this);
	      this._runOnHandler('render');
	    };

	    /**
	     * Resizes the visualization
	     *
	     * @method resize
	     */
	    Vis.prototype.resize = function () {
	      if (!this.data) {
	        // TODO: need to come up with a solution for resizing when no data is available
	        return;
	      }

	      if (this.handler && _.isFunction(this.handler.resize)) {
	        this._runOnHandler('resize');
	      } else {
	        this.render(this.data);
	      }
	    };

	    Vis.prototype._runOnHandler = function (method) {
	      try {
	        this.handler[method]();
	      } catch (error) {
	        // If involving height and width of the container, log error to screen.
	        // Because we have to wait for the DOM element to initialize, we do not
	        // want to throw an error when the DOM `el` is zero
	        if (error instanceof errors.ContainerTooSmall || error instanceof errors.InvalidWiggleSelection || error instanceof errors.InvalidLogScaleValues || error instanceof errors.PieContainsAllZeros || error instanceof errors.NotEnoughData || error instanceof errors.NoResults) {
	          this.handler.error(error.message);
	        } else {
	          throw error;
	        }
	      }
	    };

	    /**
	     * Destroys the visualization
	     * Removes chart and all elements associated with it.
	     * Removes chart and all elements associated with it.
	     * Remove event listeners and pass destroy call down to owned objects.
	     *
	     * @method destroy
	     */
	    Vis.prototype.destroy = function () {
	      var selection = d3.select(this.el).select('.vis-wrapper');

	      this.binder.destroy();
	      this.resizeChecker.destroy();
	      if (this.handler) this._runOnHandler('destroy');

	      selection.remove();
	      selection = null;
	    };

	    /**
	     * Sets attributes on the visualization
	     *
	     * @method set
	     * @param name {String} An attribute name
	     * @param val {*} Value to which the attribute name is set
	     */
	    Vis.prototype.set = function (name, val) {
	      this._attr[name] = val;
	      this.render(this.data);
	    };

	    /**
	     * Gets attributes from the visualization
	     *
	     * @method get
	     * @param name {String} An attribute name
	     * @returns {*} The value of the attribute name
	     */
	    Vis.prototype.get = function (name) {
	      return this._attr[name];
	    };

	    /**
	     * Turns on event listeners.
	     *
	     * @param event {String}
	     * @param listener{Function}
	     * @returns {*}
	     */
	    Vis.prototype.on = function (event, listener) {
	      var first = this.listenerCount(event) === 0;
	      var ret = Events.prototype.on.call(this, event, listener);
	      var added = this.listenerCount(event) > 0;

	      // if this is the first listener added for the event
	      // enable the event in the handler
	      if (first && added && this.handler) this.handler.enable(event);

	      return ret;
	    };

	    /**
	     * Turns off event listeners.
	     *
	     * @param event {String}
	     * @param listener{Function}
	     * @returns {*}
	     */
	    Vis.prototype.off = function (event, listener) {
	      var last = this.listenerCount(event) === 1;
	      var ret = Events.prototype.off.call(this, event, listener);
	      var removed = this.listenerCount(event) === 0;

	      // Once all listeners are removed, disable the events in the handler
	      if (last && removed && this.handler) this.handler.disable(event);
	      return ret;
	    };

	    return Vis;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(238);
	__webpack_require__(421);
	__webpack_require__(422);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ResizeCheckerFactory(Private, Notifier, $rootScope) {
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);

	    var EventEmitter = Private(__webpack_require__(238));
	    var reflowWatcher = Private(__webpack_require__(421));
	    var sequencer = __webpack_require__(422);

	    var SCHEDULE = ResizeChecker.SCHEDULE = sequencer.createEaseIn(100, // shortest delay
	    10000, // longest delay
	    50 // tick count
	    );

	    // maximum ms that we can delay emitting 'resize'. This is only used
	    // to debounce resizes when the size of the element is constantly changing
	    var MS_MAX_RESIZE_DELAY = ResizeChecker.MS_MAX_RESIZE_DELAY = 500;

	    /**
	     * Checks the size of an element on a regular basis. Provides
	     * an event that is emited when the element has changed size.
	     *
	     * @class ResizeChecker
	     * @param {HtmlElement} el - the element to track the size of
	     */
	    _['class'](ResizeChecker).inherits(EventEmitter);
	    function ResizeChecker(el) {
	      ResizeChecker.Super.call(this);

	      this.$el = $(el);
	      this.notify = new Notifier({ location: 'Vislib ResizeChecker ' + _.uniqueId() });

	      this.saveSize();

	      this.check = _.bind(this.check, this);
	      this.check();

	      this.onReflow = _.bind(this.onReflow, this);
	      reflowWatcher.on('reflow', this.onReflow);
	    }

	    ResizeChecker.prototype.onReflow = function () {
	      this.startSchedule(SCHEDULE);
	    };

	    /**
	     * Read the size of the element
	     *
	     * @method read
	     * @return {object} - an object with keys `w` (width) and `h` (height)
	     */
	    ResizeChecker.prototype.read = function () {
	      return {
	        w: this.$el[0].clientWidth,
	        h: this.$el[0].clientHeight
	      };
	    };

	    /**
	     * Save the element size, preventing it from being considered as an
	     * update.
	     *
	     * @method save
	     * @param  {object} [size] - optional size to save, otherwise #read() is called
	     * @return {boolean} - true if their was a change in the new
	     */
	    ResizeChecker.prototype.saveSize = function (size) {
	      if (!size) size = this.read();

	      if (this._equalsSavedSize(size)) {
	        return false;
	      }

	      this._savedSize = size;
	      return true;
	    };

	    /**
	     * Determine if a given size matches the currently saved size.
	     *
	     * @private
	     * @method _equalsSavedSize
	     * @param  {object} a - an object that matches the return value of #read()
	     * @return {boolean} - true if the passed in value matches the saved size
	     */
	    ResizeChecker.prototype._equalsSavedSize = function (a) {
	      var b = this._savedSize || {};
	      return a.w === b.w && a.h === b.h;
	    };

	    /**
	     * Read the time that the dirty state last changed.
	     *
	     * @method lastDirtyChange
	     * @return {timestamp} - the unix timestamp (in ms) of the last update
	     *                       to the dirty state
	     */
	    ResizeChecker.prototype.lastDirtyChange = function () {
	      return this._dirtyChangeStamp;
	    };

	    /**
	     * Record the dirty state
	     *
	     * @method saveDirty
	     * @param  {boolean} val
	     * @return {boolean} - true if the dirty state changed by this save
	     */
	    ResizeChecker.prototype.saveDirty = function (val) {
	      val = !!val;

	      if (val === this._isDirty) return false;

	      this._isDirty = val;
	      this._dirtyChangeStamp = Date.now();
	      return true;
	    };

	    /**
	     * The check routine that executes regularly and will reschedule itself
	     * to run again in the future. It determines the state of the elements
	     * size and decides when to emit the "update" event.
	     *
	     * @method check
	     * @return {void}
	     */
	    ResizeChecker.prototype.check = function () {
	      var newSize = this.read();
	      var dirty = this.saveSize(newSize);
	      var dirtyChanged = this.saveDirty(dirty);

	      var doneDirty = !dirty && dirtyChanged;
	      var muchDirty = dirty && this.lastDirtyChange() - Date.now() > MS_MAX_RESIZE_DELAY;
	      if (doneDirty || muchDirty) {
	        this.emit('resize', newSize);
	      }

	      // if the dirty state is unchanged, continue using the previous schedule
	      if (!dirtyChanged) {
	        return this.continueSchedule();
	      }

	      return this.startSchedule(SCHEDULE);
	    };

	    /**
	     * Start running a new schedule, using one of the SCHEDULE_* constants.
	     *
	     * @method startSchedule
	     * @param  {integer[]} schedule - an array of millisecond times that should
	     *                              be used to schedule calls to #check();
	     * @return {integer} - the id of the next timer
	     */
	    ResizeChecker.prototype.startSchedule = function (schedule) {
	      this._tick = -1;
	      this._currentSchedule = schedule;
	      return this.continueSchedule();
	    };

	    /**
	     * Continue running the current schedule. MUST BE CALLED AFTER #startSchedule()
	     *
	     * @method continueSchedule
	     * @return {integer} - the id of the next timer
	     */
	    ResizeChecker.prototype.continueSchedule = function () {
	      clearTimeout(this._timerId);

	      if (this._tick < this._currentSchedule.length - 1) {
	        // at the end of the schedule, don't progress any further but repeat the last value
	        this._tick += 1;
	      }

	      var check = this.check; // already bound
	      var tick = this._tick;
	      var notify = this.notify;
	      var ms = this._currentSchedule[this._tick];
	      return this._timerId = setTimeout(function () {
	        check();
	      }, ms);
	    };

	    /**
	     * Signal that the ResizeChecker should shutdown.
	     *
	     * Cleans up it's listeners and timers.
	     *
	     * @method destroy
	     * @return {void}
	     */
	    ResizeChecker.prototype.destroy = function () {
	      reflowWatcher.off('reflow', this.onReflow);
	      clearTimeout(this._timerId);
	    };

	    return ResizeChecker;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(209);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(238);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ReflowWatcherService(Private, $rootScope, $http) {
	    var angular = __webpack_require__(209);
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);

	    var EventEmitter = Private(__webpack_require__(238));
	    var $body = $(document.body);
	    var $window = $(window);

	    var MOUSE_EVENTS = 'mouseup';
	    var WINDOW_EVENTS = 'resize';

	    _['class'](ReflowWatcher).inherits(EventEmitter);
	    /**
	     * Watches global activity which might hint at a change in the content, which
	     * in turn provides a hint to resizers that they should check their size
	     */
	    function ReflowWatcher() {
	      ReflowWatcher.Super.call(this);

	      // bound version of trigger that can be used as a handler
	      this.trigger = _.bind(this.trigger, this);
	      this._emitReflow = _.bind(this._emitReflow, this);

	      // list of functions to call that will unbind our watchers
	      this._unwatchers = [$rootScope.$watchCollection(function () {
	        return $http.pendingRequests;
	      }, this.trigger)];

	      $body.on(MOUSE_EVENTS, this.trigger);
	      $window.on(WINDOW_EVENTS, this.trigger);
	    }

	    /**
	     * Simply emit reflow, but in a way that can be bound and passed to
	     * other functions. Using _.bind caused extra arguments to be added, and
	     * then emitted to other places. No Bueno
	     *
	     * @return {void}
	     */
	    ReflowWatcher.prototype._emitReflow = function () {
	      this.emit('reflow');
	    };

	    /**
	     * Emit the "reflow" event in the next tick of the digest cycle
	     * @return {void}
	     */
	    ReflowWatcher.prototype.trigger = function () {
	      $rootScope.$evalAsync(this._emitReflow);
	    };

	    /**
	     * Signal to the ReflowWatcher that it should clean up it's listeners
	     * @return {void}
	     */
	    ReflowWatcher.prototype.destroy = function () {
	      $body.off(MOUSE_EVENTS, this.trigger);
	      $window.off(WINDOW_EVENTS, this.trigger);
	      _.callEach(this._unwatchers);
	    };

	    return new ReflowWatcher();
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  function create(min, max, length, mod) {
	    var seq = new Array(length);

	    var valueDist = max - min;

	    // range of values that the mod creates
	    var modRange = [mod(0, length), mod(length - 1, length)];

	    // distance between
	    var modRangeDist = modRange[1] - modRange[0];

	    _.times(length, function (i) {
	      var modIPercent = (mod(i, length) - modRange[0]) / modRangeDist;

	      // percent applied to distance and added to min to
	      // produce value
	      seq[i] = min + valueDist * modIPercent;
	    });

	    seq.min = min;
	    seq.max = max;

	    return seq;
	  }

	  return {
	    /**
	     * Create an exponential sequence of numbers.
	     *
	     * Creates a curve resembling:
	     *
	     *                                                         ;
	     *                                                         /
	     *                                                        /
	     *                                                     .-'
	     *                                                 _.-"
	     *                                            _.-'"
	     *                                      _,.-'"
	     *                               _,..-'"
	     *                       _,..-'""
	     *              _,..-'""
	     *  ____,..--'""
	     *
	     * @param {number} min - the min value to produce
	     * @param {number} max - the max value to produce
	     * @param {number} length - the number of values to produce
	     * @return {number[]} - an array containing the sequence
	     */
	    createEaseIn: _.partialRight(create, function (i, length) {
	      // generates numbers from 1 to +Infinity
	      return i * Math.pow(i, 1.1111);
	    }),

	    /**
	     * Create an sequence of numbers using sine.
	     *
	     * Create a curve resembling:
	     *
	     *                                            ____,..--'""
	     *                                    _,..-'""
	     *                            _,..-'""
	     *                     _,..-'"
	     *               _,.-'"
	     *          _.-'"
	     *      _.-"
	     *   .-'
	     *  /
	     * /
	     * ;
	     *
	     *
	     * @param {number} min - the min value to produce
	     * @param {number} max - the max value to produce
	     * @param {number} length - the number of values to produce
	     * @return {number[]} - an array containing the sequence
	     */
	    createEaseOut: _.partialRight(create, function (i, length) {
	      // adapted from output of http://www.timotheegroleau.com/Flash/experiments/easing_function_generator.htm
	      // generates numbers from 0 to 100

	      var ts = (i /= length) * i;
	      var tc = ts * i;
	      return 100 * (0.5 * tc * ts + -3 * ts * ts + 6.5 * tc + -7 * ts + 4 * i);
	    })
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(424);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(424);

	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);

	  __webpack_require__(214).get('kibana').directive('collapsibleSidebar', function () {
	    // simply a list of all of all of angulars .col-md-* classes except 12
	    var listOfWidthClasses = _.times(11, function (i) {
	      return 'col-md-' + i;
	    });

	    return {
	      restrict: 'C',
	      link: function link($scope, $elem) {
	        var $collapser = $('<div class="sidebar-collapser"><div class="chevron-cont"></div></div>');
	        var $siblings = $elem.siblings();

	        var siblingsClass = listOfWidthClasses.reduce(function (prev, className) {
	          if (prev) return prev;
	          return $siblings.hasClass(className) && className;
	        }, false);

	        $collapser.on('click', function () {
	          $elem.toggleClass('closed');
	          // if there is are only two elements we can assume the other one will take 100% of the width
	          if ($siblings.length === 1 && siblingsClass) {
	            $siblings.toggleClass(siblingsClass + ' col-md-12');
	          }
	        }).appendTo($elem);
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 424 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(426);
	__webpack_require__(427);
	__webpack_require__(429);
	__webpack_require__(430);
	__webpack_require__(192);
	__webpack_require__(250);
	__webpack_require__(433);
	__webpack_require__(434);
	__webpack_require__(446);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var app = __webpack_require__(214).get('apps/discover');

	  __webpack_require__(426);
	  __webpack_require__(427);
	  __webpack_require__(429);
	  __webpack_require__(430);

	  app.directive('discFieldChooser', function ($location, globalState, config, $route, Private) {
	    var _ = __webpack_require__(192);
	    var rison = __webpack_require__(250);
	    var fieldCalculator = __webpack_require__(433);
	    var FieldList = Private(__webpack_require__(434));

	    return {
	      restrict: 'E',
	      scope: {
	        columns: '=',
	        hits: '=',
	        fieldCounts: '=',
	        state: '=',
	        indexPattern: '=',
	        indexPatternList: '=',
	        updateFilterInQuery: '=filter'
	      },
	      template: __webpack_require__(446),
	      link: function link($scope) {
	        $scope.setIndexPattern = function (id) {
	          $scope.state.index = id;
	          $scope.state.save();
	        };

	        $scope.$watch('state.index', function (id, previousId) {
	          if (previousId == null || previousId === id) return;
	          $route.reload();
	        });

	        var filter = $scope.filter = {
	          props: ['type', 'indexed', 'analyzed', 'missing', 'name'],
	          defaults: {
	            missing: true
	          },
	          boolOpts: [{ label: 'any', value: undefined }, { label: 'yes', value: true }, { label: 'no', value: false }],
	          toggleVal: function toggleVal(name, def) {
	            if (filter.vals[name] !== def) filter.vals[name] = def;else filter.vals[name] = undefined;
	          },
	          reset: function reset() {
	            filter.vals = _.clone(filter.defaults);
	          },
	          isFieldSelected: function isFieldSelected(field) {
	            return field.display;
	          },
	          isFieldFiltered: function isFieldFiltered(field) {
	            var matchFilter = filter.vals.type == null || field.type === filter.vals.type;
	            var isAnalyzed = filter.vals.analyzed == null || field.analyzed === filter.vals.analyzed;
	            var isIndexed = filter.vals.indexed == null || field.indexed === filter.vals.indexed;
	            var scriptedOrMissing = !filter.vals.missing || field.scripted || field.rowCount > 0;
	            var matchName = !filter.vals.name || field.name.indexOf(filter.vals.name) !== -1;

	            return !field.display && matchFilter && isAnalyzed && isIndexed && scriptedOrMissing && matchName;
	          },
	          popularity: function popularity(field) {
	            return field.count > 0;
	          },
	          getActive: function getActive() {
	            return _.some(filter.props, function (prop) {
	              return filter.vals[prop] !== filter.defaults[prop];
	            });
	          }
	        };

	        // set the initial values to the defaults
	        filter.reset();

	        $scope.$watchCollection('filter.vals', function () {
	          filter.active = filter.getActive();
	        });

	        $scope.toggle = function (fieldName) {
	          $scope.increaseFieldCounter(fieldName);
	          _.toggleInOut($scope.columns, fieldName);
	        };

	        $scope.$watchMulti(['[]fieldCounts', '[]columns', '[]hits'], function (cur, prev) {
	          var newHits = cur[2] !== prev[2];
	          var fields = $scope.fields;
	          var columns = $scope.columns || [];
	          var fieldCounts = $scope.fieldCounts;

	          if (!fields || newHits) {
	            $scope.fields = fields = getFields();
	          }

	          if (!fields) return;

	          // group the fields into popular and up-popular lists
	          _.chain(fields).each(function (field) {
	            field.displayOrder = _.indexOf(columns, field.name) + 1;
	            field.display = !!field.displayOrder;
	            field.rowCount = fieldCounts[field.name];
	          }).sortBy(function (field) {
	            return (field.count || 0) * -1;
	          }).groupBy(function (field) {
	            if (field.display) return 'selected';
	            return field.count > 0 ? 'popular' : 'unpopular';
	          }).tap(function (groups) {
	            groups.selected = _.sortBy(groups.selected || [], 'displayOrder');

	            groups.popular = groups.popular || [];
	            groups.unpopular = groups.unpopular || [];

	            // move excess popular fields to un-popular list
	            var extras = groups.popular.splice(config.get('fields:popularLimit'));
	            groups.unpopular = extras.concat(groups.unpopular);
	          }).each(function (group, name) {
	            $scope[name + 'Fields'] = _.sortBy(group, name === 'selected' ? 'display' : 'name');
	          }).commit();

	          // include undefined so the user can clear the filter
	          $scope.fieldTypes = _.union([undefined], _.pluck(fields, 'type'));
	        });

	        $scope.increaseFieldCounter = function (fieldName) {
	          $scope.indexPattern.popularizeField(fieldName, 1);
	        };

	        $scope.runAgg = function (field) {
	          var agg = {};
	          var isGeoPoint = field.type === 'geo_point';
	          var type = isGeoPoint ? 'tile_map' : 'histogram';
	          // If we're visualizing a date field, and our index is time based (and thus has a time filter),
	          // then run a date histogram
	          if (field.type === 'date' && $scope.indexPattern.timeFieldName === field.name) {
	            agg = {
	              type: 'date_histogram',
	              schema: 'segment',
	              params: {
	                field: field.name,
	                interval: 'auto'
	              }
	            };
	          } else if (isGeoPoint) {
	            agg = {
	              type: 'geohash_grid',
	              schema: 'segment',
	              params: {
	                field: field.name,
	                precision: 3
	              }
	            };
	          } else {
	            agg = {
	              type: 'terms',
	              schema: 'segment',
	              params: {
	                field: field.name,
	                size: config.get('discover:aggs:terms:size', 20),
	                orderBy: '2'
	              }
	            };
	          }

	          $location.path('/visualize/create').search({
	            indexPattern: $scope.state.index,
	            type: type,
	            _a: rison.encode({
	              filters: $scope.state.filters || [],
	              query: $scope.state.query || undefined,
	              vis: {
	                type: type,
	                aggs: [agg, { schema: 'metric', type: 'count', 'id': '2' }]
	              }
	            })
	          });
	        };

	        $scope.details = function (field, recompute) {
	          if (_.isUndefined(field.details) || recompute) {
	            field.details = fieldCalculator.getFieldValueCounts({
	              hits: $scope.hits,
	              field: field,
	              count: 5,
	              grouped: false
	            });
	            _.each(field.details.buckets, function (bucket) {
	              bucket.display = field.format.convert(bucket.value);
	            });
	            $scope.increaseFieldCounter(field, 1);
	          } else {
	            delete field.details;
	          }
	        };

	        function getFields() {
	          var prevFields = $scope.fields;
	          var indexPattern = $scope.indexPattern;
	          var hits = $scope.hits;
	          var fieldCounts = $scope.fieldCounts;

	          if (!indexPattern || !hits || !fieldCounts) return;

	          var fieldSpecs = indexPattern.fields.slice(0);
	          var fieldNamesInDocs = _.keys(fieldCounts);
	          var fieldNamesInIndexPattern = _.keys(indexPattern.fields.byName);

	          _.difference(fieldNamesInDocs, fieldNamesInIndexPattern).forEach(function (unknownFieldName) {
	            fieldSpecs.push({
	              name: unknownFieldName,
	              type: 'unknown'
	            });
	          });

	          var fields = new FieldList(indexPattern, fieldSpecs);

	          if (prevFields) {
	            fields.forEach(function (field) {
	              field.details = _.get(prevFields, ['byName', field.name, 'details']);
	            });
	          }

	          return fields;
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(206);
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var $ = __webpack_require__(206);
	  var _ = __webpack_require__(192);

	  module.directive('cssTruncate', function ($timeout) {
	    return {
	      restrict: 'A',
	      scope: {},
	      link: function link($scope, $elem, attrs) {

	        $elem.css({
	          overflow: 'hidden',
	          'white-space': 'nowrap',
	          'text-overflow': 'ellipsis',
	          'word-break': 'break-all'
	        });

	        if (attrs.cssTruncateExpandable != null) {
	          $scope.$watch(function () {
	            return $elem.html();
	          }, function () {
	            if ($elem[0].offsetWidth < $elem[0].scrollWidth) {
	              $elem.css({ 'cursor': 'pointer' });
	              $elem.bind('click', function () {
	                $scope.toggle();
	              });
	            }
	          });
	        }

	        $scope.toggle = function () {
	          if ($elem.css('white-space') !== 'normal') {
	            $elem.css({ 'white-space': 'normal' });
	          } else {
	            $elem.css({ 'white-space': 'nowrap' });
	          }
	        };

	        $scope.$on('$destroy', function () {
	          $elem.unbind('click');
	          $elem.unbind('mouseenter');
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(428);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  __webpack_require__(428);

	  module.directive('fieldName', function ($compile, $rootScope, $filter) {
	    return {
	      restrict: 'AE',
	      scope: {
	        'field': '=',
	        'fieldName': '=',
	        'fieldType': '='
	      },
	      link: function link($scope, $el) {

	        var typeIcon = function typeIcon(fieldType) {
	          switch (fieldType) {
	            case 'source':
	              return '<i class="fa fa-file-text-o "></i>';
	            case 'string':
	              return '<i><strong>t</strong></i>';
	            case 'murmur3':
	              return '<i><strong>h</strong></i>';
	            case 'number':
	              return '<i><strong>#</strong></i>';
	            case 'date':
	              return '<i class="fa fa-clock-o"></i>';
	            case 'ip':
	              return '<i class="fa fa-laptop"></i>';
	            case 'geo_point':
	              return '<i class="fa fa-globe"></i>';
	            case 'boolean':
	              return '<i class="fa fa-adjust"></i>';
	            case 'conflict':
	              return '<i class="fa fa-warning"></i>';
	            default:
	              return '<i><strong>?</strong></i>';
	          }
	        };

	        $rootScope.$watchMulti.call($scope, ['field', 'fieldName', 'fieldType', 'field.rowCount'], function () {

	          var type = $scope.field ? $scope.field.type : $scope.fieldType;
	          var name = $scope.field ? $scope.field.name : $scope.fieldName;
	          var results = $scope.field ? !$scope.field.rowCount && !$scope.field.scripted : false;
	          var scripted = $scope.field ? $scope.field.scripted : false;

	          var displayName = $filter('shortDots')(name);

	          $el.text(displayName).attr('title', name).toggleClass('no-results', results).toggleClass('scripted', scripted).prepend(typeIcon(type));
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	// Shorts dot notated strings
	// eg: foo.bar.baz becomes f.b.baz
	// 'foo.bar.baz'.replace(/(.+?\.)/g,function(v) {return v[0]+'.';});
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').filter('shortDots', function (Private) {
	    return Private(shortDotsFilterProvider);
	  });

	  function shortDotsFilterProvider(config, $rootScope) {
	    var filter;

	    function updateFilter() {
	      filter = config.get('shortDots:enable') ? _.shortenDottedString : _.identity;
	    }

	    updateFilter();
	    $rootScope.$on('change:config.shortDots:enable', updateFilter);
	    $rootScope.$on('init:config', updateFilter);

	    return function (str) {
	      return filter(str);
	    };
	  }

	  return shortDotsFilterProvider;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	// Filters out all duplicate items in an array
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').filter('unique', function () {
	    return function (arr) {
	      var list = _.unique(arr);
	      return list;
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(206);
	__webpack_require__(214);
	__webpack_require__(431);
	__webpack_require__(192);
	__webpack_require__(426);
	__webpack_require__(427);
	__webpack_require__(432);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var $ = __webpack_require__(206);
	  var app = __webpack_require__(214).get('apps/discover');
	  var html = __webpack_require__(431);
	  var _ = __webpack_require__(192);

	  __webpack_require__(426);
	  __webpack_require__(427);

	  app.directive('discoverField', function ($compile) {
	    return {
	      restrict: 'E',
	      template: html,
	      replace: true,
	      link: function link($scope, $elem) {
	        var detailsElem;
	        var detailScope = $scope.$new();

	        var detailsHtml = __webpack_require__(432);

	        var init = function init() {
	          if ($scope.field.details) {
	            $scope.toggleDetails($scope.field, true);
	          }
	        };

	        var getWarnings = function getWarnings(field) {
	          var warnings = [];

	          if (!field.scripted) {
	            if (!field.doc_values && field.type !== 'boolean' && !(field.analyzed && field.type === 'string')) {
	              warnings.push('Doc values are not enabled on this field. This may lead to excess heap consumption when visualizing.');
	            }

	            if (field.analyzed && field.type === 'string') {
	              warnings.push('This is an analyzed string field.' + ' Analyzed strings are highly unique and can use a lot of memory to visualize.' + ' Values such as foo-bar will be broken into foo and bar.');
	            }

	            if (!field.indexed) {
	              warnings.push('This field is not indexed and can not be visualized.');
	            }
	          }

	          if (field.scripted) {
	            warnings.push('Scripted fields can take a long time to execute.');
	          }

	          if (warnings.length > 1) {
	            warnings = warnings.map(function (warning, i) {
	              return (i > 0 ? '\n' : '') + (i + 1) + ' - ' + warning;
	            });
	          }

	          return warnings;
	        };

	        $scope.toggleDisplay = function (field) {
	          // inheritted param to fieldChooser
	          $scope.toggle(field.name);
	          if (field.display) $scope.increaseFieldCounter(field);

	          // we are now displaying the field, kill it's details
	          if (field.details) {
	            $scope.toggleDetails(field);
	          }
	        };

	        $scope.toggleDetails = function (field, recompute) {
	          if (_.isUndefined(field.details) || recompute) {
	            // This is inherited from fieldChooser
	            $scope.details(field, recompute);
	            detailScope.$destroy();
	            detailScope = $scope.$new();
	            detailScope.warnings = getWarnings(field);

	            detailsElem = $(detailsHtml);
	            $compile(detailsElem)(detailScope);
	            $elem.append(detailsElem);
	          } else {
	            delete field.details;
	            detailsElem.remove();
	          }
	        };

	        init();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 431 */
/***/ function(module, exports) {

	module.exports = "\n    <li bindonce class=\"sidebar-item\" bo-attr bo-attr-field=\"field.name\">\n      <div ng-click=\"toggleDetails(field)\" class=\"sidebar-item-title\">\n        <field-name field=\"field\"></field-name>\n        <button\n          ng-click=\"toggleDisplay(field)\"\n          bo-class=\"field.display ? 'btn-danger' : 'btn-primary'\"\n          bo-text=\"field.display ? 'remove' : 'add'\"\n          class=\"btn btn-xs btn-primary discover-field-toggle\" ></button>\n      </div>\n    </li>\n"

/***/ },
/* 432 */
/***/ function(module, exports) {

	module.exports = "      <div bindonce>\n        <div class=\"discover-field-details\">\n          <h5 ng-show=\"!field.details.error\">Quick Count <kbn-info info=\"Top 5 values based on documents in the table\" placement=\"right\"></kbn-info>\n            <span ng-if=\"!field.details.error\" class=\"small discover-field-details-count\">\n              (\n              <a ng-show=\"field.indexed\" ng-click=\"updateFilterInQuery('_exists_', field.name, '+')\">{{field.details.exists}}</a>\n              <span ng-show=\"!field.indexed\">{{field.details.exists}}</span>\n              /{{field.details.total}} records\n              )\n            </span>\n          </h5>\n\n          <div class=\"clearfix\"></div>\n\n          <div ng-if=\"field.details.error\" class=\"discover-field-details-error\">{{field.details.error}}</div>\n\n          <div ng-if=\"!field.details.error\">\n            <div ng-repeat=\"bucket in field.details.buckets\" class=\"discover-field-details-item\">\n              <div>\n                <span ng-show=\"field.filterable\" class=\"pull-right\">\n                  <i aria-hidden=\"true\" class=\"fa fa-search-minus pull-right discover-field-details-filter\"\n                    ng-click=\"updateFilterInQuery(field, bucket.value, '-')\"></i>\n                  <i aria-hidden=\"true\" class=\"fa fa-search-plus pull-right discover-field-details-filter\"\n                    ng-click=\"updateFilterInQuery(field, bucket.value, '+')\"></i>\n                </span>\n                <div css-truncate css-truncate-expandable=\"true\" class=\"discover-field-details-value\">\n                  {{bucket.display}} <i ng-show=\"bucket.display === ''\">Empty string</i>\n                </div>\n              </div>\n              <kbn-tooltip text=\"{{bucket.count}}\" placement=\"right\" append-to-body=\"1\">\n                <progressbar value=\"bucket.percent\" max=\"100\" animate=\"false\"><span>{{bucket.percent}}%</span></progressbar>\n              </kbn-tooltip>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div ng-show=\"field.indexed || field.scripted\"\n        ng-click=\"runAgg(field)\"\n        class=\"sidebar-item-button primary\">\n          Visualize\n          <span class=\"discover-field-vis-warning\" ng-show=\"warnings.length\" tooltip=\"{{warnings.join(' ')}}\">\n          ( {{warnings.length}} <ng-pluralize count=\"warnings.length\" when=\"{'1':'warning', 'other':'warnings'}\"></ng-pluralize> <i aria-hidden=\"true\" class=\"fa fa-warning\"></i> )\n          </span>\n      </div>\n\n      <div ng-show=\"!field.indexed && !field.scripted\"\n          disabled=\"disabled\"\n          tooltip=\"This field is not indexed thus unavailable for visualization and search\"\n          class=\"sidebar-item-button primary\">Not Indexed</div>\n"

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  function getFieldValues(hits, field) {
	    var name = field.name;
	    var flattenHit = field.indexPattern.flattenHit;
	    return _.map(hits, function (hit) {
	      return flattenHit(hit)[name];
	    });
	  }

	  function getFieldValueCounts(params) {
	    params = _.defaults(params, {
	      count: 5,
	      grouped: false
	    });

	    if (params.field.type === 'geo_point' || params.field.type === 'geo_shape' || params.field.type === 'attachment') {
	      return { error: 'Analysis is not available for geo fields.' };
	    }

	    var allValues = getFieldValues(params.hits, params.field);
	    var counts;
	    var missing = _countMissing(allValues);

	    try {
	      var groups = _groupValues(allValues, params);
	      counts = _.map(_.sortBy(groups, 'count').reverse().slice(0, params.count), function (bucket) {
	        return {
	          value: bucket.value,
	          count: bucket.count,
	          percent: (bucket.count / (params.hits.length - missing) * 100).toFixed(1)
	        };
	      });

	      if (params.hits.length - missing === 0) {
	        return {
	          error: 'This field is present in your elasticsearch mapping' + ' but not in any documents in the search results.' + ' You may still be able to visualize or search on it.'
	        };
	      }

	      return {
	        total: params.hits.length,
	        exists: params.hits.length - missing,
	        missing: missing,
	        buckets: counts
	      };
	    } catch (e) {
	      return { error: e.message };
	    }
	  }

	  // returns a count of fields in the array that are undefined or null
	  function _countMissing(array) {
	    return array.length - _.without(array, undefined, null).length;
	  }

	  function _groupValues(allValues, params) {
	    var groups = {};
	    var k;

	    allValues.forEach(function (value) {
	      if (_.isObject(value) && !_.isArray(value)) {
	        throw new Error('Analysis is not available for object fields');
	      }

	      if (_.isArray(value) && !params.grouped) {
	        k = value;
	      } else {
	        k = value == null ? undefined : [value];
	      }

	      _.each(k, function (key) {
	        if (_.has(groups, key)) {
	          groups[key].count++;
	        } else {
	          groups[key] = {
	            value: params.grouped ? value : key,
	            count: 1
	          };
	        }
	      });
	    });

	    return groups;
	  }

	  return {
	    _groupValues: _groupValues,
	    _countMissing: _countMissing,
	    getFieldValues: getFieldValues,
	    getFieldValueCounts: getFieldValueCounts
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(435);
	__webpack_require__(441);
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FieldListProvider(Private) {
	    var Field = Private(__webpack_require__(435));
	    var IndexedArray = __webpack_require__(441);
	    var _ = __webpack_require__(192);

	    _['class'](FieldList).inherits(IndexedArray);
	    function FieldList(indexPattern, specs) {
	      FieldList.Super.call(this, {
	        index: ['name'],
	        group: ['type'],
	        initialSet: specs.map(function (field) {
	          return new Field(indexPattern, field);
	        })
	      });
	    }

	    return FieldList;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(436);
	__webpack_require__(440);
	__webpack_require__(443);
	__webpack_require__(445);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FieldObjectProvider(Private, shortDotsFilter, $rootScope, Notifier) {
	    var notify = new Notifier({ location: 'IndexPattern Field' });
	    var FieldFormat = Private(__webpack_require__(436));
	    var fieldTypes = Private(__webpack_require__(440));
	    var fieldFormats = Private(__webpack_require__(443));
	    var ObjDefine = __webpack_require__(445);

	    function Field(indexPattern, spec) {
	      // unwrap old instances of Field
	      if (spec instanceof Field) spec = spec.$$spec;

	      // constuct this object using ObjDefine class, which
	      // extends the Field.prototype but gets it's properties
	      // defined using the logic below
	      var obj = new ObjDefine(spec, Field.prototype);

	      if (spec.name === '_source') {
	        spec.type = '_source';
	      }

	      // find the type for this field, fallback to unknown type
	      var type = fieldTypes.byName[spec.type];
	      if (spec.type && !type) {
	        notify.error('Unknown field type "' + spec.type + '"' + ' for field "' + spec.name + '"' + ' in indexPattern "' + indexPattern.id + '"');
	      }

	      if (!type) type = fieldTypes.byName.unknown;

	      var format = spec.format;
	      if (!format || !(format instanceof FieldFormat)) {
	        format = indexPattern.fieldFormatMap[spec.name] || fieldFormats.getDefaultInstance(spec.type);
	      }

	      var indexed = !!spec.indexed;
	      var scripted = !!spec.scripted;
	      var sortable = spec.name === '_score' || (indexed || scripted) && type.sortable;
	      var bucketable = indexed || scripted;
	      var filterable = spec.name === '_id' || scripted || indexed && type.filterable;

	      obj.fact('name');
	      obj.fact('type');
	      obj.writ('count', spec.count || 0);

	      // scripted objs
	      obj.fact('scripted', scripted);
	      obj.writ('script', scripted ? spec.script : null);
	      obj.writ('lang', scripted ? spec.lang || 'expression' : null);

	      // mapping info
	      obj.fact('indexed', indexed);
	      obj.fact('analyzed', !!spec.analyzed);
	      obj.fact('doc_values', !!spec.doc_values);

	      // usage flags, read-only and won't be saved
	      obj.comp('format', format);
	      obj.comp('sortable', sortable);
	      obj.comp('bucketable', bucketable);
	      obj.comp('filterable', filterable);

	      // computed values
	      obj.comp('indexPattern', indexPattern);
	      obj.comp('displayName', shortDotsFilter(spec.name));
	      obj.comp('$$spec', spec);

	      return obj.create();
	    }

	    Field.prototype.routes = {
	      edit: '/settings/indices/{{indexPattern.id}}/field/{{name}}'
	    };

	    return Field;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(437);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FieldFormatClassProvider(config, $rootScope, Private) {
	    var _ = __webpack_require__(192);
	    var contentTypes = Private(__webpack_require__(437));

	    function FieldFormat(params) {
	      var self = this;

	      // give the constructor a more appropriate name
	      self.type = self.constructor;

	      // keep the params and defaults seperate
	      self._params = params || {};
	      self._paramDefaults = self.type.paramDefaults || {};

	      // one content type, so assume text
	      if (_.isFunction(self._convert)) {
	        self._convert = { text: self._convert };
	      }

	      contentTypes.setup(self);
	    }

	    FieldFormat.from = function (converter) {
	      _['class'](FieldFormatFromConverter).inherits(FieldFormat);
	      function FieldFormatFromConverter(params) {
	        FieldFormatFromConverter.Super.call(this, params);
	      }
	      FieldFormatFromConverter.prototype._convert = converter;
	      return FieldFormatFromConverter;
	    };

	    /**
	     * Convert a raw value to a formated string
	     * @param  {any} value
	     * @param  {string} [contentType=text] - optional content type, the only two contentTypes
	     *                                currently supported are "html" and "text", which helps
	     *                                formatters adjust to different contexts
	     * @return {string} - the formatted string, which is assumed to be html, safe for
	     *                    injecting into the DOM or a DOM attribute
	     */
	    FieldFormat.prototype.convert = function (value, contentType) {
	      return this.getConverterFor(contentType)(value);
	    };

	    /**
	     * Get a convert function that is bound to a specific contentType
	     * @param  {string} [contentType=text]
	     * @return {function} - a bound converter function
	     */
	    FieldFormat.prototype.getConverterFor = function (contentType) {
	      return this._convert[contentType || 'text'];
	    };

	    /**
	     * Get the value of a param. This value may be a default value.
	     *
	     * @param  {string} name - the param name to fetch
	     * @return {any}
	     */
	    FieldFormat.prototype.param = function (name) {
	      var val = this._params[name];
	      if (val || val === false || val === 0) {
	        // truthy, false, or 0 are fine
	        // '', NaN, null, undefined, etc are not
	        return val;
	      }

	      return this._paramDefaults[name];
	    };

	    /**
	     * Get all of the params in a single object
	     * @return {object}
	     */
	    FieldFormat.prototype.params = function () {
	      return _.cloneDeep(_.defaults({}, this._params, this._paramDefaults));
	    };

	    /**
	     * serialize this format to a simple POJO, with only the params
	     * that are not default
	     *
	     * @return {object}
	     */
	    FieldFormat.prototype.toJSON = function () {
	      var type = this.type;
	      var defaults = this._paramDefaults;

	      var params = _.transform(this._params, function (uniqParams, val, param) {
	        if (val !== defaults[param]) {
	          uniqParams[param] = val;
	        }
	      }, {});

	      if (!_.size(params)) {
	        params = undefined;
	      }

	      return {
	        id: type.id,
	        params: params
	      };
	    };

	    return FieldFormat;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(438);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function contentTypesProvider(highlightFilter) {
	    var _ = __webpack_require__(192);
	    var angular = __webpack_require__(209);
	    __webpack_require__(438);

	    var types = {
	      html: function html(format, convert) {
	        return function recurse(value, field, hit) {
	          if (!value || typeof value.map !== 'function') {
	            return convert.call(format, value, field, hit);
	          }

	          var subVals = value.map(function (v) {
	            return recurse(v, field, hit);
	          });
	          var useMultiLine = subVals.some(function (sub) {
	            return sub.indexOf('\n') > -1;
	          });

	          return subVals.join(',' + (useMultiLine ? '\n' : ' '));
	        };
	      },

	      text: function text(format, convert) {
	        return function recurse(value) {
	          if (!value || typeof value.map !== 'function') {
	            return convert.call(format, value);
	          }

	          // format a list of values. In text contexts we just use JSON encoding
	          return angular.toJson(value.map(recurse), true);
	        };
	      }
	    };

	    function fallbackText(value) {
	      return _.asPrettyString(value);
	    }

	    function fallbackHtml(value, field, hit) {
	      var formatted = _.escape(this.convert(value, 'text'));

	      if (!hit || !hit.highlight || !hit.highlight[field.name]) {
	        return formatted;
	      } else {
	        return highlightFilter(formatted, hit.highlight[field.name]);
	      }
	    }

	    function setup(format) {
	      var src = format._convert || {};
	      var converters = format._convert = {};

	      converters.text = types.text(format, src.text || fallbackText);
	      converters.html = types.html(format, src.html || fallbackHtml);

	      return format._convert;
	    }

	    return {
	      types: types,
	      setup: setup
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(439);
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(439);

	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  var module = __webpack_require__(214).get('kibana');

	  module.filter('highlight', function (highlightTags) {
	    return function (formatted, highlight) {
	      if (typeof formatted === 'object') formatted = angular.toJson(formatted);

	      _.each(highlight, function (section) {
	        section = _.escape(section);

	        // Strip out the highlight tags to compare against the formatted string
	        var untagged = section.split(highlightTags.pre).join('').split(highlightTags.post).join('');

	        // Replace all highlight tags with proper html tags
	        var tagged = section.split(highlightTags.pre).join('<mark>').split(highlightTags.post).join('</mark>');

	        // Replace all instances of the untagged string with the properly tagged string
	        formatted = formatted.split(untagged).join(tagged);
	      });

	      return formatted;
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');

	  // By default, ElasticSearch surrounds matched values in <em></em>. This is not ideal because it is possible that
	  // the value could contain <em></em> in the value. We define these custom tags that we would never expect to see
	  // inside a field value.
	  module.constant('highlightTags', {
	    pre: '@kibana-highlighted-field@',
	    post: '@/kibana-highlighted-field@'
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(441);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function IndexPatternFieldTypes() {
	    var IndexedArray = __webpack_require__(441);

	    return new IndexedArray({
	      index: ['name'],
	      group: ['sortable', 'filterable'],
	      immutable: true,
	      initialSet: [{ name: 'ip', sortable: true, filterable: true }, { name: 'date', sortable: true, filterable: true }, { name: 'string', sortable: true, filterable: true }, { name: 'number', sortable: true, filterable: true }, { name: 'boolean', sortable: true, filterable: true }, { name: 'conflict', sortable: false, filterable: false }, { name: 'geo_point', sortable: false, filterable: false }, { name: 'geo_shape', sortable: false, filterable: false }, { name: 'attachment', sortable: false, filterable: false }, { name: 'murmur3', sortable: false, filterable: false }, { name: 'unknown', sortable: false, filterable: false }, { name: '_source', sortable: false, filterable: false }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(223);
	__webpack_require__(192);
	__webpack_require__(442);

	'use strict';

	var _Object$defineProperty = __webpack_require__(223)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

	  var _ = __webpack_require__(192);

	  var inflector = __webpack_require__(442);
	  var pathGetter = _(_.get).rearg(1, 0).ary(2);
	  var inflectIndex = inflector('by');
	  var inflectOrder = inflector('in', 'Order');

	  var CLEAR_CACHE = {};
	  var OPT_NAMES = IndexedArray.OPT_NAMES = ['index', 'group', 'order', 'initialSet', 'immutable'];

	  /**
	   * Generic extension of Array class, which will index (and reindex) the
	   * objects it contains based on their properties.
	   *
	   * @class  IndexedArray
	   * @module utils
	   * @constructor
	   * @param {object}   [config]            - describes the properties of this registry object
	   * @param {string[]} [config.index]      - a list of props/paths that should be used to index the docs.
	   * @param {string[]} [config.group]      - a list of keys/paths to group docs by.
	   * @param {string[]} [config.order]      - a list of keys/paths to order the keys by.
	   * @param {object[]} [config.initialSet] - the initial dataset the IndexedArray should contain.
	   * @param {boolean}  [config.immutable]  - a flag that hints to people reading the implementation
	   *                                       that this IndexedArray should not be modified. It's modification
	   *                                       methods are also removed
	   */
	  _['class'](IndexedArray).inherits(Array);
	  function IndexedArray(config) {
	    IndexedArray.Super.call(this);

	    // just to remind future us that this list is important
	    config = _.pick(config || {}, OPT_NAMES);

	    this.raw = [];

	    // setup indices
	    this._indexNames = _.union(this._setupIndices(config.group, inflectIndex, _.organizeBy), this._setupIndices(config.index, inflectIndex, _.indexBy), this._setupIndices(config.order, inflectOrder, _.sortBy));

	    if (config.initialSet) {
	      this.push.apply(this, config.initialSet);
	    }

	    if (config.immutable) {
	      // just a hint, bugs caused by updates not propogating would be very
	      // very very hard to track down
	      this.push = this.splice = undefined;
	    }
	  }

	  /**
	   * Create indices for a group of object properties. getters and setters are used to
	   * read and control the indices.
	   *
	   * @param  {string[]} props   - the properties that should be used to index docs
	   * @param  {function} inflect - a function that will be called with a property name, and
	   *                            creates the public property at which the index will be exposed
	   * @param  {function} op      - the function that will be used to create the indices, it is passed
	   *                            the raw representaion of the registry, and a getter for reading the
	   *                            right prop
	   *
	   * @returns {string[]}        - the public keys of all indices created
	   */
	  IndexedArray.prototype._setupIndices = function (props, inflect, op) {
	    // shortcut for empty props
	    if (!props || props.length === 0) return;

	    var self = this;
	    return props.map(function (prop) {

	      var from = pathGetter.partial(prop).value();
	      var to = inflect(prop);
	      var cache;

	      _Object$defineProperty(self, to, {
	        enumerable: false,
	        configurable: false,

	        set: function set(val) {
	          // can't set any value other than the CLEAR_CACHE constant
	          if (val === CLEAR_CACHE) {
	            cache = false;
	          } else {
	            throw new TypeError(to + ' can not be set, it is a computed index of values');
	          }
	        },
	        get: function get() {
	          return cache || (cache = op(self.raw, from));
	        }
	      });

	      return to;
	    });
	  };

	  /**
	   * (Re)run index/group/order procedures to create indices of
	   * sub-objects.
	   *
	   * @return {undefined}
	   */
	  IndexedArray.prototype._clearIndices = function () {
	    var self = this;
	    self._indexNames.forEach(function (name) {
	      self[name] = CLEAR_CACHE;
	    });
	  };

	  /**
	   * Copy all array methods which have side-effects, and wrap them
	   * in a function that will reindex after each call, as well
	   * as duplex the operation to the .raw version of the IndexedArray.
	   *
	   * @param  {[type]} method [description]
	   * @return {[type]}        [description]
	   */
	  'pop push shift splice unshift reverse'.split(' ').forEach(function (method) {
	    var orig = Array.prototype[method];

	    IndexedArray.prototype[method] = function () /* args... */{
	      // call the original method with this context
	      orig.apply(this, arguments);

	      // run the indexers
	      this._clearIndices();

	      // call the original method on our "raw" array, and return the result(s)
	      return orig.apply(this.raw, arguments);
	    };
	  });

	  /**
	  * Remove items from this based on a predicate
	  * @param {function|object|string} predicate - the predicate used to decide what is removed
	  * @param {object} context - this binding for predicate
	  * @return {array} - the removed data
	  */
	  IndexedArray.prototype.remove = function (predicate, context) {
	    var out = _.remove(this, predicate, context);
	    _.remove(this.raw, predicate, context);
	    this._clearIndices();
	    return out;
	  };

	  /**
	   * provide a hook for the JSON serializer
	   * @return {array} - a plain, vanilla array with our same data
	   */
	  IndexedArray.prototype.toJSON = function () {
	    return this.raw;
	  };

	  return IndexedArray;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

	  function upFirst(str, total) {
	    return str.charAt(0).toUpperCase() + (total ? str.substr(1).toLowerCase() : str.substr(1));
	  }

	  function startsWith(str, test) {
	    return str.substr(0, test.length).toLowerCase() === test.toLowerCase();
	  }

	  function endsWith(str, test) {
	    var tooShort = str.length < test.length;
	    if (tooShort) return;

	    return str.substr(str.length - test.length).toLowerCase() === test.toLowerCase();
	  }

	  function inflector(prefix, postfix) {
	    return function inflect(key) {
	      var inflected;

	      if (key.indexOf('.') !== -1) {
	        inflected = key.split('.').map(function (step, i) {
	          return i === 0 ? step : upFirst(step, true);
	        }).join('');
	      } else {
	        inflected = key;
	      }

	      if (prefix && !startsWith(key, prefix)) {
	        inflected = prefix + upFirst(inflected);
	      }

	      if (postfix && !endsWith(key, postfix)) {
	        inflected = inflected + postfix;
	      }

	      return inflected;
	    };
	  }

	  return inflector;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(444);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return __webpack_require__(444)({
	    name: 'fieldFormats',
	    index: ['id'],
	    group: ['fieldType'],

	    constructor: function constructor(config, $rootScope) {
	      var self = this;
	      var defaultMap;

	      function init() {
	        parseDefaultTypeMap();
	        $rootScope.$on('init:config', parseDefaultTypeMap);
	        $rootScope.$on('change:config.format:defaultTypeMap', parseDefaultTypeMap);
	      }

	      /**
	       * Get the id of the default type for this field type
	       * using the format:defaultTypeMap config map
	       *
	       * @param  {String} fieldType - the field type
	       * @return {String}
	       */
	      self.getDefaultConfig = function (fieldType) {
	        return defaultMap[fieldType] || defaultMap._default_;
	      };

	      /**
	       * Get a FieldFormat type (class) by it's id.
	       *
	       * @param  {String} formatId - the format id
	       * @return {Function}
	       */
	      self.getType = function (formatId) {
	        return self.byId[formatId];
	      };

	      /**
	       * Get the default FieldFormat type (class) for
	       * a field type, using the format:defaultTypeMap.
	       *
	       * @param  {String} fieldType
	       * @return {Function}
	       */
	      self.getDefaultType = function (fieldType) {
	        return self.byId[self.getDefaultConfig(fieldType).id];
	      };

	      /**
	       * Get the singleton instance of the FieldFormat type by it's id.
	       *
	       * @param  {String} formatId
	       * @return {FieldFormat}
	       */
	      self.getInstance = _.memoize(function (formatId) {
	        var FieldFormat = self.byId[formatId];
	        return new FieldFormat();
	      });

	      /**
	       * Get the default fieldFormat instance for a field format.
	       *
	       * @param  {String} fieldType
	       * @return {FieldFormat}
	       */
	      self.getDefaultInstance = _.memoize(function (fieldType) {
	        var conf = self.getDefaultConfig(fieldType);
	        var FieldFormat = self.byId[conf.id];
	        return new FieldFormat(conf.params);
	      });

	      function parseDefaultTypeMap() {
	        defaultMap = config.get('format:defaultTypeMap');
	        _.forOwn(self, function (fn) {
	          if (_.isFunction(fn) && fn.cache) {
	            // clear all memoize caches
	            fn.cache = new _.memoize.Cache();
	          }
	        });
	      }

	      init();
	    }
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(441);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var IndexedArray = __webpack_require__(441);
	  var notPropsOptNames = IndexedArray.OPT_NAMES.concat('constructor');

	  /**
	   * Create a registry, which is just a Private module provider.
	   *
	   * The registry allows modifying the values it will provide
	   * using the #register method.
	   *
	   * To access these modules, pass the registry to the Private
	   * module loader.
	   *
	   * # Examples
	   *
	   * + register a module
	   * ```js
	   * var registry = require('ui/registry/vis_types');
	   * registry.add(function InjectablePrivateModule($http, Promise) {
	   *   ...
	   * })
	   * ```
	   *
	   * + get all registered modules
	   * ```js
	   * var visTypes = Private(require('ui/registry/vis_types'));
	   * ```
	   *
	   *
	   * @param  {object} [spec] - an object describing the properties of
	   *                         the registry to create. Any property specified
	   *                         that is not listed below will be mixed into the
	   *                         final IndexedArray object.
	   *
	   * # init
	   * @param {Function} [spec.constructor] - an injectable function that is called when
	   *                                      the registry is first instanciated by the app.
	   *
	   * # IndexedArray params
	   * @param {array[String]} [spec.index] - passed to the IndexedArray constructor
	   * @param {array[String]} [spec.group] - passed to the IndexedArray constructor
	   * @param {array[String]} [spec.order] - passed to the IndexedArray constructor
	   * @param {array[String]} [spec.initialSet] - passed to the IndexedArray constructor
	   * @param {array[String]} [spec.immutable] - passed to the IndexedArray constructor
	   *
	   * @return {[type]}      [description]
	   */
	  return function createRegistry(spec) {
	    spec = spec || {};

	    var constructor = _.has(spec, 'constructor') && spec.constructor;
	    var iaOpts = _.defaults(_.pick(spec, IndexedArray.OPT_NAMES), { index: ['name'] });
	    var props = _.omit(spec, notPropsOptNames);
	    var providers = [];

	    /**
	     * This is the Private module that will be instanciated by
	     *
	     * @tag:PrivateModule
	     * @return {IndexedArray} - an indexed array containing the values
	     *                          that were registered, the registry spec
	     *                          defines how things will be indexed.
	     */
	    var registry = function registry(Private, $injector) {
	      // index all of the modules
	      iaOpts.initialSet = providers.map(Private);
	      var modules = new IndexedArray(iaOpts);

	      // mixin other props
	      _.assign(modules, props);

	      // construct
	      if (constructor) {
	        modules = $injector.invoke(constructor, modules) || modules;
	      }

	      return modules;
	    };

	    registry.displayName = '[registry ' + props.name + ']';

	    registry.register = function (privateModule) {
	      providers.push(privateModule);
	      return registry;
	    };

	    return registry;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(201);
	__webpack_require__(223);
	__webpack_require__(192);

	'use strict';

	var _Object$create = __webpack_require__(201)['default'];

	var _Object$defineProperty = __webpack_require__(223)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  function ObjDefine(defaults, prototype) {
	    this.obj; // created by this.create()

	    this.descs = {};
	    this.defaults = defaults || {};
	    this.prototype = prototype || Object.prototype;
	  }

	  ObjDefine.REDEFINE_SUPPORTED = (function () {
	    var a = _Object$create(Object.prototype, {
	      prop: {
	        configurable: true,
	        value: 1
	      }
	    });

	    Object.defineProperty(a, 'prop', {
	      configurable: true,
	      value: 2
	    });

	    return a.prop === 2;
	  })();

	  /**
	   * normal value, writable and exported in JSON
	   *
	   * @param  {any} v - value
	   * @return {object} - property descriptor
	   */
	  ObjDefine.prototype.writ = function (name, val) {
	    this._define(name, val, true, true);
	  };

	  /**
	   * known value, exported in JSON, not changeable
	   *
	   * @param  {any} v - value
	   * @return {object} - property descriptor
	   */
	  ObjDefine.prototype.fact = function (name, val) {
	    this._define(name, val, true);
	  };

	  /**
	   * computed fact, not exported or changeable
	   *
	   * @param  {any} v - value
	   * @return {object} - property descriptor
	   */
	  ObjDefine.prototype.comp = function (name, val) {
	    this._define(name, val);
	  };

	  /**
	   * Creates an object, decorated by the property descriptors
	   * created by other ObjDefine methods and inheritting form the
	   * prototype
	   *
	   * # note:
	   * If a value is writable, but the value is undefined, the property will
	   * be created by not exported to JSON unless the property is written to
	   *
	   * @return {object} - created object
	   */
	  ObjDefine.prototype.create = function () {
	    var self = this;
	    self.obj = _Object$create(this.prototype, self.descs);

	    if (!ObjDefine.REDEFINE_SUPPORTED && !self.prototype.toJSON) {
	      // since we can't redefine properties as enumerable we will
	      // clone the object on serialization and choose which properties
	      // to include or trim manually. This is currently only in use in PhantomJS
	      // due to https://github.com/ariya/phantomjs/issues/11856
	      self.obj.toJSON = function () {
	        return _.transform(self.obj, function (json, val, key) {
	          var desc = self.descs[key];
	          if (desc && desc.enumerable && val == null) return;
	          json[key] = val;
	        }, {});
	      };
	    }

	    return self.obj;
	  };

	  /**
	   * Private APIS
	   */

	  ObjDefine.prototype._define = function (name, val, exported, changeable) {
	    val = val != null ? val : this.defaults[name];
	    this.descs[name] = this._describe(name, val, !!exported, !!changeable);
	  };

	  ObjDefine.prototype._describe = function (name, val, exported, changeable) {
	    var self = this;
	    var exists = val != null;

	    if (exported && ObjDefine.REDEFINE_SUPPORTED) {
	      return {
	        enumerable: exists,
	        configurable: true,
	        get: _.constant(val),
	        set: function set(update) {
	          if (!changeable) return false;

	          // change the descriptor, since the value now exists.
	          self.descs[name] = self._describe(name, update, exported, changeable);

	          // apply the updated descriptor
	          _Object$defineProperty(self.obj, name, self.descs[name]);
	        }
	      };
	    }

	    if (exported && !ObjDefine.REDEFINE_SUPPORTED) {
	      return {
	        enumerable: true,
	        configurable: true,
	        writable: changeable,
	        value: val
	      };
	    }

	    return {
	      enumerable: false,
	      writable: changeable,
	      configurable: true,
	      value: val
	    };
	  };

	  return ObjDefine;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 446 */
/***/ function(module, exports) {

	module.exports = "<div class=\"sidebar-list\">\n  <div ng-show=\"indexPatternList.length > 1\">\n    <div class=\"index-pattern\" ng-click=\"showIndexPatternSelection = !showIndexPatternSelection\">\n      <div css-truncate title=\"{{indexPattern.id}}\">{{indexPattern.id}}</div>\n      <i ng-hide=\"showIndexPatternSelection\" class=\"fa fa-caret-down\"></i>\n      <i ng-show=\"showIndexPatternSelection\" class=\"fa fa-caret-up\"></i>\n    </div>\n    <div ng-show=\"showIndexPatternSelection\">\n      <ul class=\"list-unstyled sidebar-item index-pattern-selection\">\n        <li css-truncate class=\"sidebar-item-title\" title=\"{{id}}\" ng-repeat=\"id in indexPatternList | orderBy\" ng-show=\"indexPattern.id != id\" ng-click=\"setIndexPattern(id)\">{{id}}</li>\n      </ul>\n      <div ng-click=\"showIndexPatternSelection = !showIndexPatternSelection\" class=\"discover-field-details-close\">\n        <i class=\"fa fa-chevron-up\"></i>\n      </div>\n    </div>\n  </div>\n  <div ng-hide=\"indexPatternList.length > 1\">\n    <div class=\"index-pattern\">\n      <div css-truncate>{{ indexPattern.id }}</div>\n    </div>\n  </div>\n\n  <div class=\"sidebar-list-header\">\n    <h5>Selected Fields</h5>\n  </div>\n  <ul class=\"list-unstyled discover-selected-fields\" >\n    <discover-field ng-repeat=\"field in fields.raw|filter:{display:true}\">\n    </discover-field>\n  </ul>\n\n  <div class=\"sidebar-list-header sidebar-item\">\n    <h5>Available Fields\n      <i\n        ng-class=\"{ 'fa-chevron-right': !showFields, 'fa-chevron-down': showFields }\"\n        ng-click=\"showFields = !showFields\"\n        aria-hidden=\"true\"\n        class=\"fa visible-xs visible-sm pull-right field-collapse-toggle\" ></i>\n      <button\n        ng-class=\"{ 'btn-default': !filter.active, 'btn-success': filter.active, 'hidden-xs': !showFields, 'hidden-sm': !showFields }\"\n        class=\"btn btn-xs btn-default pull-right discover-field-filter-toggle\"\n        ng-click=\"showFilter = !showFilter\"\n        aria-label=\"Field Settings\"\n        aria-haspopup=\"true\"\n        aria-expanded=\"{{showFilter}}\">\n        <i aria-hidden=\"true\" class=\"fa fa-gear\"></i>\n      </button>\n    </h5>\n  </div>\n\n  <div class=\"sidebar-item\" ng-show=\"showFilter\">\n    <div ng-click=\"showFilter = !showFilter\" class=\"discover-field-details-close\">\n        <i aria-hidden=\"true\" class=\"fa fa-chevron-up\"></i>\n    </div>\n    <form role=\"form\" class=\"discover-field-details\">\n      <div class=\"form-group\">\n        <label>\n          Analyzed\n        </label>\n        <select\n          ng-options=\"opt.value as opt.label for opt in filter.boolOpts\"\n          ng-model=\"filter.vals.analyzed\"\n          class=\"form-control\">\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          Indexed\n        </label>\n        <select\n          ng-options=\"opt.value as opt.label for opt in filter.boolOpts\"\n          ng-model=\"filter.vals.indexed\"\n          class=\"form-control\">\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          Type\n        </label>\n        <select\n          ng-options=\"field as field for field in fieldTypes\"\n          ng-model=\"filter.vals.type\"\n          class=\"form-control\">\n        </select>\n      </div>\n      <div class=\"form-group\">\n        <label>\n          Field name\n        </label>\n        <input type=\"text\" class=\"form-control\" ng-model=\"filter.vals.name\">\n      </div>\n      <div class=\"form-group\">\n        <label>\n          <input type=\"checkbox\" ng-model=\"filter.vals.missing\">\n          Hide Missing Fields\n        </label>\n      </div>\n    </form>\n    <div\n      ng-click=\"filter.reset()\"\n      ng-disabled=\"!filter.active\"\n      class=\"sidebar-item-button danger ng-scope\">\n      Reset Filters\n    </div>\n  </div>\n\n  <ul\n    ng-show=\"(popularFields | filter:filter.isFieldFiltered).length > 0\"\n    ng-class=\"{ 'hidden-sm': !showFields, 'hidden-xs': !showFields }\"\n    class=\"list-unstyled sidebar-well discover-popular-fields\">\n    <li class=\"sidebar-item sidebar-list-header\">\n      <h6>Popular</h6>\n    </li>\n    <discover-field\n      ng-repeat=\"field in popularFields | filter:filter.isFieldFiltered\">\n    </discover-field>\n  </ul>\n\n  <ul\n    ng-class=\"{ 'hidden-sm': !showFields, 'hidden-xs': !showFields  }\"\n    class=\"list-unstyled discover-unpopular-fields\">\n    <discover-field\n      ng-repeat=\"field in unpopularFields | filter:filter.isFieldFiltered\">\n    </discover-field>\n  </ul>\n\n</div>\n"

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(226);
	__webpack_require__(304);
	__webpack_require__(448);
	__webpack_require__(250);
	__webpack_require__(228);
	__webpack_require__(449);
	__webpack_require__(474);
	__webpack_require__(308);
	__webpack_require__(481);
	__webpack_require__(488);
	__webpack_require__(489);
	__webpack_require__(490);
	__webpack_require__(495);
	__webpack_require__(496);
	__webpack_require__(500);
	__webpack_require__(547);
	__webpack_require__(215);
	__webpack_require__(439);
	__webpack_require__(214);
	__webpack_require__(216);
	__webpack_require__(548);
	__webpack_require__(549);
	__webpack_require__(649);
	__webpack_require__(650);
	__webpack_require__(651);
	__webpack_require__(652);
	__webpack_require__(670);
	__webpack_require__(593);
	__webpack_require__(671);
	__webpack_require__(672);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  var moment = __webpack_require__(226);
	  var ConfigTemplate = __webpack_require__(304);
	  var getSort = __webpack_require__(448);
	  var rison = __webpack_require__(250);

	  var dateMath = __webpack_require__(228);

	  __webpack_require__(449);
	  __webpack_require__(474);
	  __webpack_require__(308);
	  __webpack_require__(481);
	  __webpack_require__(488);
	  __webpack_require__(489);
	  __webpack_require__(490);
	  __webpack_require__(495);
	  __webpack_require__(496);
	  __webpack_require__(500);
	  __webpack_require__(547);
	  __webpack_require__(215);
	  __webpack_require__(439);

	  var app = __webpack_require__(214).get('apps/discover', ['kibana/notify', 'kibana/courier', 'kibana/index_patterns']);

	  __webpack_require__(216).when('/discover/:id?', {
	    template: __webpack_require__(548),
	    reloadOnSearch: false,
	    resolve: {
	      ip: function ip(Promise, courier, config, $location) {
	        return courier.indexPatterns.getIds().then(function (list) {
	          var stateRison = $location.search()._a;

	          var state;
	          try {
	            state = rison.decode(stateRison);
	          } catch (e) {
	            state = {};
	          }

	          var specified = !!state.index;
	          var exists = _.contains(list, state.index);
	          var id = exists ? state.index : config.get('defaultIndex');

	          return Promise.props({
	            list: list,
	            loaded: courier.indexPatterns.get(id),
	            stateVal: state.index,
	            stateValFound: specified && exists
	          });
	        });
	      },
	      savedSearch: function savedSearch(courier, savedSearches, $route) {
	        return savedSearches.get($route.current.params.id)['catch'](courier.redirectWhenMissing({
	          'search': '/discover',
	          'index-pattern': '/settings/objects/savedSearches/' + $route.current.params.id
	        }));
	      }
	    }
	  });

	  app.controller('discover', function ($scope, config, courier, $route, $window, Notifier, AppState, timefilter, Promise, Private, kbnUrl, highlightTags) {

	    var Vis = Private(__webpack_require__(549));
	    var docTitle = Private(__webpack_require__(649));
	    var brushEvent = Private(__webpack_require__(650));
	    var HitSortFn = Private(__webpack_require__(651));
	    var queryFilter = Private(__webpack_require__(652));
	    var filterManager = Private(__webpack_require__(670));

	    var notify = new Notifier({
	      location: 'Discover'
	    });

	    $scope.intervalOptions = Private(__webpack_require__(593));
	    $scope.showInterval = false;

	    $scope.intervalEnabled = function (interval) {
	      return interval.val !== 'custom';
	    };

	    $scope.toggleInterval = function () {
	      $scope.showInterval = !$scope.showInterval;
	    };

	    // config panel templates
	    $scope.configTemplate = new ConfigTemplate({
	      load: __webpack_require__(671),
	      save: __webpack_require__(672)
	    });

	    $scope.timefilter = timefilter;

	    // the saved savedSearch
	    var savedSearch = $route.current.locals.savedSearch;
	    $scope.$on('$destroy', savedSearch.destroy);

	    // the actual courier.SearchSource
	    $scope.searchSource = savedSearch.searchSource;
	    $scope.indexPattern = resolveIndexPatternLoading();
	    $scope.searchSource.set('index', $scope.indexPattern);

	    if (savedSearch.id) {
	      docTitle.change(savedSearch.title);
	    }

	    var $state = $scope.state = new AppState(getStateDefaults());
	    function getStateDefaults() {
	      return {
	        query: $scope.searchSource.get('query') || '',
	        sort: getSort.array(savedSearch.sort, $scope.indexPattern),
	        columns: savedSearch.columns || ['_source'],
	        index: $scope.indexPattern.id,
	        interval: 'auto',
	        filters: _.cloneDeep($scope.searchSource.getOwn('filter'))
	      };
	    }

	    $state.index = $scope.indexPattern.id;
	    $state.sort = getSort.array($state.sort, $scope.indexPattern);

	    $scope.$watchCollection('state.columns', function () {
	      $state.save();
	    });

	    $scope.opts = {
	      // number of records to fetch, then paginate through
	      sampleSize: config.get('discover:sampleSize'),
	      // Index to match
	      index: $scope.indexPattern.id,
	      timefield: $scope.indexPattern.timeFieldName,
	      savedSearch: savedSearch,
	      indexPatternList: $route.current.locals.ip.list
	    };

	    var init = _.once(function () {
	      var showTotal = 5;
	      $scope.failuresShown = showTotal;
	      $scope.showAllFailures = function () {
	        $scope.failuresShown = $scope.failures.length;
	      };
	      $scope.showLessFailures = function () {
	        $scope.failuresShown = showTotal;
	      };

	      $scope.updateDataSource().then(function () {
	        $scope.$listen(timefilter, 'fetch', function () {
	          $scope.fetch();
	        });

	        $scope.$watchCollection('state.sort', function (sort) {
	          if (!sort) return;

	          // get the current sort from {key: val} to ["key", "val"];
	          var currentSort = _.pairs($scope.searchSource.get('sort')).pop();

	          // if the searchSource doesn't know, tell it so
	          if (!angular.equals(sort, currentSort)) $scope.fetch();
	        });

	        // update data source when filters update
	        $scope.$listen(queryFilter, 'update', function () {
	          return $scope.updateDataSource().then(function () {
	            $state.save();
	          });
	        });

	        // update data source when hitting forward/back and the query changes
	        $scope.$listen($state, 'fetch_with_changes', function (diff) {
	          if (diff.indexOf('query') >= 0) $scope.fetch();
	        });

	        // fetch data when filters fire fetch event
	        $scope.$listen(queryFilter, 'fetch', $scope.fetch);

	        $scope.$watch('opts.timefield', function (timefield) {
	          timefilter.enabled = !!timefield;
	        });

	        $scope.$watch('state.interval', function (interval, oldInterval) {
	          if (interval !== oldInterval && interval === 'auto') {
	            $scope.showInterval = false;
	          }
	          $scope.fetch();
	        });

	        $scope.$watch('vis.aggs', function () {
	          var buckets = $scope.vis.aggs.bySchemaGroup.buckets;

	          if (buckets && buckets.length === 1) {
	            $scope.intervalName = 'by ' + buckets[0].buckets.getInterval().description;
	          } else {
	            $scope.intervalName = 'auto';
	          }
	        });

	        $scope.$watchMulti(['rows', 'fetchStatus'], (function updateResultState() {
	          var prev = {};
	          var status = {
	            LOADING: 'loading', // initial data load
	            READY: 'ready', // results came back
	            NO_RESULTS: 'none' // no results came back
	          };

	          function pick(rows, oldRows, fetchStatus) {
	            // initial state, pretend we are loading
	            if (rows == null && oldRows == null) return status.LOADING;

	            var rowsEmpty = _.isEmpty(rows);
	            if (rowsEmpty && fetchStatus) return status.LOADING;else if (!rowsEmpty) return status.READY;else return status.NO_RESULTS;
	          }

	          return function () {
	            var current = {
	              rows: $scope.rows,
	              fetchStatus: $scope.fetchStatus
	            };

	            $scope.resultState = pick(current.rows, prev.rows, current.fetchStatus, prev.fetchStatus);

	            prev = current;
	          };
	        })());

	        $scope.searchSource.onError(function (err) {
	          console.log(err);
	          notify.error('An error occurred with your request. Reset your inputs and try again.');
	        })['catch'](notify.fatal);

	        function initForTime() {
	          return setupVisualization().then($scope.updateTime);
	        }

	        return Promise.resolve($scope.opts.timefield && initForTime()).then(function () {
	          init.complete = true;
	          $state.replace();
	          $scope.$emit('application.load');
	        });
	      });
	    });

	    $scope.opts.saveDataSource = function () {
	      return $scope.updateDataSource().then(function () {
	        savedSearch.id = savedSearch.title;
	        savedSearch.columns = $scope.state.columns;
	        savedSearch.sort = $scope.state.sort;

	        return savedSearch.save().then(function (id) {
	          $scope.configTemplate.close('save');

	          if (id) {
	            notify.info('Saved Data Source "' + savedSearch.title + '"');
	            if (savedSearch.id !== $route.current.params.id) {
	              kbnUrl.change('/discover/{{id}}', { id: savedSearch.id });
	            } else {
	              // Update defaults so that "reload saved query" functions correctly
	              $state.setDefaults(getStateDefaults());
	            }
	          }
	        });
	      })['catch'](notify.error);
	    };

	    $scope.opts.fetch = $scope.fetch = function () {
	      // ignore requests to fetch before the app inits
	      if (!init.complete) return;

	      $scope.updateTime();

	      $scope.updateDataSource().then(setupVisualization).then(function () {
	        $state.save();
	        return courier.fetch();
	      })['catch'](notify.error);
	    };

	    $scope.searchSource.onBeginSegmentedFetch(function (segmented) {

	      function flushResponseData() {
	        $scope.hits = 0;
	        $scope.faliures = [];
	        $scope.rows = [];
	        $scope.fieldCounts = {};
	      }

	      if (!$scope.rows) flushResponseData();

	      var sort = $state.sort;
	      var timeField = $scope.indexPattern.timeFieldName;
	      var totalSize = $scope.size || $scope.opts.sampleSize;

	      /**
	       * Basically an emum.
	       *
	       * opts:
	       *   "time" - sorted by the timefield
	       *   "non-time" - explicitly sorted by a non-time field, NOT THE SAME AS `sortBy !== "time"`
	       *   "implicit" - no sorting set, NOT THE SAME AS "non-time"
	       *
	       * @type {String}
	       */
	      var sortBy = (function () {
	        if (!_.isArray(sort)) return 'implicit';else if (sort[0] === '_score') return 'implicit';else if (sort[0] === timeField) return 'time';else return 'non-time';
	      })();

	      var sortFn = null;
	      if (sortBy === 'non-time') {
	        sortFn = new HitSortFn(sort[1]);
	      }

	      $scope.updateTime();
	      if (sort[0] === '_score') segmented.setMaxSegments(1);
	      segmented.setDirection(sortBy === 'time' ? sort[1] || 'desc' : 'desc');
	      segmented.setSize(sortBy === 'time' ? $scope.opts.sampleSize : false);

	      // triggered when the status updated
	      segmented.on('status', function (status) {
	        $scope.fetchStatus = status;
	      });

	      segmented.on('first', function () {
	        flushResponseData();
	      });

	      segmented.on('segment', notify.timed('handle each segment', function (resp) {
	        if (resp._shards.failed > 0) {
	          $scope.failures = _.union($scope.failures, resp._shards.failures);
	          $scope.failures = _.uniq($scope.failures, false, function (failure) {
	            return failure.index + failure.shard + failure.reason;
	          });
	        }

	        var rows = $scope.rows;
	        var indexPattern = $scope.searchSource.get('index');

	        // merge the rows and the hits, use a new array to help watchers
	        rows = $scope.rows = rows.concat(resp.hits.hits);

	        if (sortFn) {
	          notify.event('resort rows', function () {
	            rows.sort(sortFn);
	            rows = $scope.rows = rows.slice(0, totalSize);
	            $scope.fieldCounts = {};
	          });
	        }

	        notify.event('flatten hit and count fields', function () {
	          var counts = $scope.fieldCounts;
	          $scope.rows.forEach(function (hit) {
	            // skip this work if we have already done it and we are NOT sorting.
	            // ---
	            // when we are sorting results, we need to redo the counts each time because the
	            // "top 500" may change with each response
	            if (hit.$$_counted && !sortFn) return;
	            hit.$$_counted = true;

	            var fields = _.keys(indexPattern.flattenHit(hit));
	            var n = fields.length;
	            var field;
	            while (field = fields[--n]) {
	              if (counts[field]) counts[field] += 1;else counts[field] = 1;
	            }
	          });
	        });
	      }));

	      segmented.on('mergedSegment', function (merged) {
	        $scope.mergedEsResp = merged;
	        $scope.hits = merged.hits.total;
	      });

	      segmented.on('complete', function () {
	        if ($scope.fetchStatus.hitCount === 0) {
	          flushResponseData();
	        }

	        $scope.fetchStatus = null;
	      });
	    })['catch'](notify.fatal);

	    $scope.updateTime = function () {
	      $scope.timeRange = {
	        from: dateMath.parse(timefilter.time.from),
	        to: dateMath.parse(timefilter.time.to, true)
	      };
	    };

	    $scope.resetQuery = function () {
	      kbnUrl.change('/discover/{{id}}', { id: $route.current.params.id });
	    };

	    $scope.newQuery = function () {
	      kbnUrl.change('/discover');
	    };

	    $scope.updateDataSource = Promise.method(function () {
	      $scope.searchSource.size($scope.opts.sampleSize).sort(getSort($state.sort, $scope.indexPattern)).query(!$state.query ? null : $state.query).highlight({
	        pre_tags: [highlightTags.pre],
	        post_tags: [highlightTags.post],
	        fields: { '*': {} },
	        require_field_match: false,
	        fragment_size: 2147483647 // Limit of an integer.
	      }).set('filter', queryFilter.getFilters());
	    });

	    // TODO: On array fields, negating does not negate the combination, rather all terms
	    $scope.filterQuery = function (field, values, operation) {
	      $scope.indexPattern.popularizeField(field, 1);
	      filterManager.add(field, values, operation, $state.index);
	    };

	    $scope.toTop = function () {
	      $window.scrollTo(0, 0);
	    };

	    var loadingVis;
	    function setupVisualization() {
	      // If we're not setting anything up we need to return an empty promise
	      if (!$scope.opts.timefield) return Promise.resolve();
	      if (loadingVis) return loadingVis;

	      var visStateAggs = [{
	        type: 'count',
	        schema: 'metric'
	      }, {
	        type: 'date_histogram',
	        schema: 'segment',
	        params: {
	          field: $scope.opts.timefield,
	          interval: $state.interval,
	          min_doc_count: 0
	        }
	      }];

	      // we have a vis, just modify the aggs
	      if ($scope.vis) {
	        var visState = $scope.vis.getState();
	        visState.aggs = visStateAggs;

	        $scope.vis.setState(visState);
	        return Promise.resolve($scope.vis);
	      }

	      $scope.vis = new Vis($scope.indexPattern, {
	        type: 'histogram',
	        params: {
	          addLegend: false,
	          addTimeMarker: true
	        },
	        listeners: {
	          click: function click(e) {
	            console.log(e);
	            timefilter.time.from = moment(e.point.x);
	            timefilter.time.to = moment(e.point.x + e.data.ordered.interval);
	            timefilter.time.mode = 'absolute';
	          },
	          brush: brushEvent
	        },
	        aggs: visStateAggs
	      });

	      $scope.searchSource.aggs(function () {
	        $scope.vis.requesting();
	        return $scope.vis.aggs.toDsl();
	      });

	      // stash this promise so that other calls to setupVisualization will have to wait
	      loadingVis = new Promise(function (resolve) {
	        $scope.$on('ready:vis', function () {
	          resolve($scope.vis);
	        });
	      })['finally'](function () {
	        // clear the loading flag
	        loadingVis = null;
	      });

	      return loadingVis;
	    }

	    function resolveIndexPatternLoading() {
	      var props = $route.current.locals.ip;
	      var loaded = props.loaded;
	      var stateVal = props.stateVal;
	      var stateValFound = props.stateValFound;

	      var own = $scope.searchSource.getOwn('index');

	      if (own && !stateVal) return own;
	      if (stateVal && !stateValFound) {
	        var err = '"' + stateVal + '" is not a configured pattern. ';
	        if (own) {
	          notify.warning(err + ' Using the saved index pattern: "' + own.id + '"');
	          return own;
	        }

	        notify.warning(err + ' Using the default index pattern: "' + loaded.id + '"');
	      }
	      return loaded;
	    }

	    init();
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  /**
	   * Take a sorting array and make it into an object
	   * @param {array} 2 item array [fieldToSort, directionToSort]
	   * @param {object} indexPattern used for determining default sort
	   * @returns {object} a sort object suitable for returning to elasticsearch
	   */
	  function getSort(sort, indexPattern) {
	    var sortObj = {};
	    var field;
	    var direction;

	    function isSortable(field) {
	      return indexPattern.fields.byName[field] && indexPattern.fields.byName[field].sortable;
	    }

	    if (_.isArray(sort) && sort.length === 2 && isSortable(sort[0])) {
	      // At some point we need to refact the sorting logic, this array sucks.
	      field = sort[0];
	      direction = sort[1];
	    } else if (indexPattern.timeFieldName && isSortable(indexPattern.timeFieldName)) {
	      field = indexPattern.timeFieldName;
	      direction = 'desc';
	    }

	    if (field) {
	      sortObj[field] = direction;
	    } else {
	      sortObj._score = 'desc';
	    }

	    return sortObj;
	  }

	  getSort.array = function (sort, indexPattern) {
	    return _(getSort(sort, indexPattern)).pairs().pop();
	  };

	  return getSort;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(450);
	__webpack_require__(448);
	__webpack_require__(451);
	__webpack_require__(452);
	__webpack_require__(453);
	__webpack_require__(454);
	__webpack_require__(456);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  var html = __webpack_require__(450);
	  var getSort = __webpack_require__(448);

	  __webpack_require__(451);
	  __webpack_require__(452);
	  __webpack_require__(453);
	  __webpack_require__(454);
	  __webpack_require__(456);

	  __webpack_require__(214).get('kibana').directive('docTable', function (config, Notifier, getAppState) {
	    return {
	      restrict: 'E',
	      template: html,
	      scope: {
	        sorting: '=',
	        columns: '=',
	        hits: '=?', // You really want either hits & indexPattern, OR searchSource
	        indexPattern: '=?',
	        searchSource: '=?',
	        infiniteScroll: '=?',
	        filter: '=?'
	      },
	      link: function link($scope) {
	        var notify = new Notifier();
	        $scope.limit = 50;
	        $scope.persist = {
	          sorting: $scope.sorting,
	          columns: $scope.columns
	        };

	        var prereq = (function () {
	          var fns = [];

	          return function register(fn) {
	            fns.push(fn);

	            return function () {
	              fn.apply(this, arguments);

	              if (fns.length) {
	                _.pull(fns, fn);
	                if (!fns.length) {
	                  $scope.$root.$broadcast('ready:vis');
	                }
	              }
	            };
	          };
	        })();

	        $scope.addRows = function () {
	          $scope.limit += 50;
	        };

	        // This exists to fix the problem of an empty initial column list not playing nice with watchCollection.
	        $scope.$watch('columns', function (columns) {
	          if (columns.length !== 0) return;

	          var $state = getAppState();
	          $scope.columns.push('_source');
	          if ($state) $state.replace();
	        });

	        $scope.$watchCollection('columns', function (columns, oldColumns) {
	          if (oldColumns.length === 1 && oldColumns[0] === '_source' && $scope.columns.length > 1) {
	            _.pull($scope.columns, '_source');
	          }

	          if ($scope.columns.length === 0) $scope.columns.push('_source');
	        });

	        $scope.$watch('searchSource', prereq(function (searchSource) {
	          if (!$scope.searchSource) return;

	          $scope.indexPattern = $scope.searchSource.get('index');

	          $scope.searchSource.size(config.get('discover:sampleSize'));
	          $scope.searchSource.sort(getSort($scope.sorting, $scope.indexPattern));

	          // Set the watcher after initialization
	          $scope.$watchCollection('sorting', function (newSort, oldSort) {
	            // Don't react if sort values didn't really change
	            if (newSort === oldSort) return;
	            $scope.searchSource.sort(getSort(newSort, $scope.indexPattern));
	            $scope.searchSource.fetchQueued();
	          });

	          $scope.$on('$destroy', function () {
	            if ($scope.searchSource) $scope.searchSource.destroy();
	          });

	          // TODO: we need to have some way to clean up result requests
	          $scope.searchSource.onResults().then(function onResults(resp) {
	            // Reset infinite scroll limit
	            $scope.limit = 50;

	            // Abort if something changed
	            if ($scope.searchSource !== $scope.searchSource) return;

	            $scope.hits = resp.hits.hits;

	            return $scope.searchSource.onResults().then(onResults);
	          })['catch'](notify.fatal);

	          $scope.searchSource.onError(notify.error)['catch'](notify.fatal);
	        }));
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 450 */
/***/ function(module, exports) {

	module.exports = "<div\n  ng-if=\"hits.length\"\n  ng-class=\"{ loading: searchSource.activeFetchCount > 0 }\">\n  <paginate ng-if=\"!infiniteScroll\" list=\"hits\" per-page=\"50\" top-controls=\"true\">\n    <table class=\"kbn-table table\" ng-if=\"indexPattern\">\n      <thead\n        kbn-table-header\n        columns=\"columns\"\n        index-pattern=\"indexPattern\"\n        sorting=\"sorting\">\n      </thead>\n      <tbody>\n        <tr ng-repeat=\"row in page|limitTo:limit track by row._index+row._type+row._id+row._score\"\n          kbn-table-row=\"row\"\n          columns=\"columns\"\n          sorting=\"sorting\"\n          index-pattern=\"indexPattern\"\n          filter=\"filter\"\n          class=\"discover-table-row\"></tr>\n      </tbody>\n    </table>\n  </paginate>\n\n  <table ng-if=\"infiniteScroll\" class=\"kbn-table table\" ng-if=\"indexPattern\">\n    <thead\n      kbn-table-header\n      columns=\"columns\"\n      index-pattern=\"indexPattern\"\n      sorting=\"sorting\">\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"row in hits|limitTo:limit track by row._index+row._type+row._id+row._score\"\n        kbn-table-row=\"row\"\n        columns=\"columns\"\n        sorting=\"sorting\"\n        index-pattern=\"indexPattern\"\n        filter=\"filter\"\n        class=\"discover-table-row\"></tr>\n    </tbody>\n  </table>\n  <kbn-infinite-scroll ng-if=\"infiniteScroll\" more=\"addRows\"></kbn-infinite-scroll>\n</div>\n<div ng-if=\"hits != null && !hits.length\" class=\"table-vis-error\">\n  <h2><i class=\"fa fa-meh-o\"></i></h2>\n  <h4>No results found</h4>\n</div>"

/***/ },
/* 451 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(206);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var $ = __webpack_require__(206);

	  module.directive('kbnTruncated', function ($compile) {
	    return {
	      restrict: 'E',
	      scope: {
	        orig: '@',
	        length: '@'
	      },
	      template: function template($element, attrs) {
	        var template = '<span>{{text}}</span>';
	        template += '<span ng-if="orig.length > length"> <a ng-click="toggle()">{{action}}</a></span>';
	        return template;
	      },
	      link: function link($scope, $element, attrs) {

	        var fullText = $scope.orig;
	        var truncated = fullText.substring(0, $scope.length);

	        if (fullText === truncated) {
	          $scope.text = fullText;
	          return;
	        }

	        truncated += '...';

	        $scope.expanded = false;
	        $scope.text = truncated;
	        $scope.action = 'more';

	        $scope.toggle = function () {
	          $scope.expanded = !$scope.expanded;
	          $scope.text = $scope.expanded ? fullText : truncated;
	          $scope.action = $scope.expanded ? 'less' : 'more';
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(206);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var $ = __webpack_require__(206);

	  module.directive('kbnInfiniteScroll', function () {
	    return {
	      restrict: 'E',
	      scope: {
	        more: '='
	      },
	      link: function link($scope, $element, attrs) {
	        var $window = $(window);
	        var checkTimer;

	        function onScroll() {
	          if (!$scope.more) return;

	          var winHeight = $window.height();
	          var winBottom = winHeight + $window.scrollTop();
	          var elTop = $element.offset().top;
	          var remaining = elTop - winBottom;

	          if (remaining <= winHeight * 0.50) {
	            $scope[$scope.$$phase ? '$eval' : '$apply'](function () {
	              var more = $scope.more();
	            });
	          }
	        }

	        function scheduleCheck() {
	          if (checkTimer) return;
	          checkTimer = setTimeout(function () {
	            checkTimer = null;
	            onScroll();
	          }, 50);
	        }

	        $window.on('scroll', scheduleCheck);
	        $scope.$on('$destroy', function () {
	          clearTimeout(checkTimer);
	          $window.off('scroll', scheduleCheck);
	        });
	        scheduleCheck();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(428);
	__webpack_require__(455);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var module = __webpack_require__(214).get('app/discover');

	  __webpack_require__(428);

	  module.directive('kbnTableHeader', function (shortDotsFilter) {
	    var headerHtml = __webpack_require__(455);
	    return {
	      restrict: 'A',
	      scope: {
	        columns: '=',
	        sorting: '=',
	        indexPattern: '='
	      },
	      template: headerHtml,
	      controller: function controller($scope) {

	        var sortableField = function sortableField(field) {
	          if (!$scope.indexPattern) return;
	          var sortable = _.get($scope.indexPattern.fields.byName[field], 'sortable');
	          return sortable;
	        };

	        $scope.tooltip = function (column) {
	          if (!sortableField(column)) return '';
	          return 'Sort by ' + shortDotsFilter(column);
	        };

	        $scope.canRemove = function (name) {
	          return name !== '_source' || $scope.columns.length !== 1;
	        };

	        $scope.headerClass = function (column) {
	          if (!sortableField(column)) return;

	          var sorting = $scope.sorting;
	          var defaultClass = ['fa', 'fa-sort-up', 'table-header-sortchange'];

	          if (!sorting || column !== sorting[0]) return defaultClass;
	          return ['fa', sorting[1] === 'asc' ? 'fa-sort-up' : 'fa-sort-down'];
	        };

	        $scope.moveLeft = function (column) {
	          var index = _.indexOf($scope.columns, column);
	          if (index === 0) return;

	          _.move($scope.columns, index, --index);
	        };

	        $scope.moveRight = function (column) {
	          var index = _.indexOf($scope.columns, column);
	          if (index === $scope.columns.length - 1) return;

	          _.move($scope.columns, index, ++index);
	        };

	        $scope.toggleColumn = function (fieldName) {
	          _.toggleInOut($scope.columns, fieldName);
	        };

	        $scope.sort = function (column) {
	          if (!column || !sortableField(column)) return;

	          var sorting = $scope.sorting = $scope.sorting || [];

	          var direction = sorting[1] || 'asc';
	          if (sorting[0] !== column) {
	            direction = 'asc';
	          } else {
	            direction = sorting[1] === 'asc' ? 'desc' : 'asc';
	          }

	          $scope.sorting[0] = column;
	          $scope.sorting[1] = direction;
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 455 */
/***/ function(module, exports) {

	module.exports = "<tr>\n  <th width=\"1%\"></th>\n  <th ng-if=\"indexPattern.timeFieldName\">\n    <span>Time <i ng-class=\"headerClass(indexPattern.timeFieldName)\" ng-click=\"sort(indexPattern.timeFieldName)\" tooltip=\"Sort by time\"></i></span>\n  </th>\n  <th ng-repeat=\"name in columns\">\n    <span class=\"table-header-name\">\n      {{name | shortDots}} <i ng-class=\"headerClass(name)\" ng-click=\"sort(name)\" tooltip=\"{{tooltip(name)}}\" tooltip-append-to-body=\"1\"></i>\n    </span>\n    <span class=\"table-header-move\">\n      <i ng-click=\"toggleColumn(name)\" ng-show=\"canRemove(name)\" class=\"fa fa-remove\" tooltip=\"Remove column\" tooltip-append-to-body=\"1\"></i>\n      <i ng-click=\"moveLeft(name)\" class=\"fa fa-angle-double-left\" ng-show=\"!$first\" tooltip=\"Move column to the left\" tooltip-append-to-body=\"1\"></i>\n      <i ng-click=\"moveRight(name)\" class=\"fa fa-angle-double-right\" ng-show=\"!$last\" tooltip=\"Move column to the right\" tooltip-append-to-body=\"1\"></i>\n    </span>\n  </th>\n</tr>"

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(457);
	__webpack_require__(214);
	__webpack_require__(438);
	__webpack_require__(439);
	__webpack_require__(458);
	__webpack_require__(468);
	__webpack_require__(428);
	__webpack_require__(469);
	__webpack_require__(470);
	__webpack_require__(471);
	__webpack_require__(472);
	__webpack_require__(473);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var addWordBreaks = __webpack_require__(457);
	  var module = __webpack_require__(214).get('app/discover');

	  __webpack_require__(438);
	  __webpack_require__(439);
	  __webpack_require__(458);
	  __webpack_require__(468);
	  __webpack_require__(428);

	  // guesstimate at the minimum number of chars wide cells in the table should be
	  var MIN_LINE_LENGTH = 20;

	  /**
	   * kbnTableRow directive
	   *
	   * Display a row in the table
	   * ```
	   * <tr ng-repeat="row in rows" kbn-table-row="row"></tr>
	   * ```
	   */
	  module.directive('kbnTableRow', function ($compile) {
	    var noWhiteSpace = __webpack_require__(469);
	    var openRowHtml = __webpack_require__(470);
	    var detailsHtml = __webpack_require__(471);
	    var cellTemplate = _.template(noWhiteSpace(__webpack_require__(472)));
	    var truncateByHeightTemplate = _.template(noWhiteSpace(__webpack_require__(473)));

	    return {
	      restrict: 'A',
	      scope: {
	        columns: '=',
	        filter: '=',
	        indexPattern: '=',
	        row: '=kbnTableRow'
	      },
	      link: function link($scope, $el) {
	        $el.after('<tr>');
	        $el.empty();

	        var init = function init() {
	          createSummaryRow($scope.row, $scope.row._id);
	        };

	        // when we compile the details, we use this $scope
	        var $detailsScope;

	        // when we compile the toggle button in the summary, we use this $scope
	        var $toggleScope;

	        // toggle display of the rows details, a full list of the fields from each row
	        $scope.toggleRow = function () {
	          var $detailsTr = $el.next();

	          $scope.open = !$scope.open;

	          ///
	          // add/remove $details children
	          ///

	          $detailsTr.toggle($scope.open);

	          if (!$scope.open) {
	            // close the child scope if it exists
	            $detailsScope.$destroy();
	            // no need to go any further
	            return;
	          } else {
	            $detailsScope = $scope.$new();
	          }

	          // empty the details and rebuild it
	          $detailsTr.html(detailsHtml);

	          $detailsScope.row = $scope.row;

	          $compile($detailsTr)($detailsScope);
	        };

	        $scope.$watchCollection('columns', function () {
	          createSummaryRow($scope.row, $scope.row._id);
	        });

	        $scope.$watchMulti(['indexPattern.timeFieldName', 'row.highlight'], function () {
	          createSummaryRow($scope.row, $scope.row._id);
	        });

	        // create a tr element that lists the value for each *column*
	        function createSummaryRow(row) {
	          var indexPattern = $scope.indexPattern;

	          // We just create a string here because its faster.
	          var newHtmls = [openRowHtml];

	          if (indexPattern.timeFieldName) {
	            newHtmls.push(cellTemplate({
	              timefield: true,
	              formatted: _displayField(row, indexPattern.timeFieldName)
	            }));
	          }

	          $scope.columns.forEach(function (column) {
	            newHtmls.push(cellTemplate({
	              timefield: false,
	              sourcefield: column === '_source',
	              formatted: _displayField(row, column, true)
	            }));
	          });

	          var $cells = $el.children();
	          newHtmls.forEach(function (html, i) {
	            var $cell = $cells.eq(i);
	            if ($cell.data('discover:html') === html) return;

	            var reuse = _.find($cells.slice(i + 1), function (cell) {
	              return $.data(cell, 'discover:html') === html;
	            });

	            var $target = reuse ? $(reuse).detach() : $(html);
	            $target.data('discover:html', html);
	            var $before = $cells.eq(i - 1);
	            if ($before.size()) {
	              $before.after($target);
	            } else {
	              $el.append($target);
	            }

	            // rebuild cells since we modified the children
	            $cells = $el.children();

	            if (i === 0 && !reuse) {
	              $toggleScope = $scope.$new();
	              $compile($target)($toggleScope);
	            }
	          });

	          if ($scope.open) {
	            $detailsScope.row = row;
	          }

	          // trim off cells that were not used rest of the cells
	          $cells.filter(':gt(' + (newHtmls.length - 1) + ')').remove();
	        }

	        /**
	         * Fill an element with the value of a field
	         */
	        function _displayField(row, fieldName, breakWords) {
	          var indexPattern = $scope.indexPattern;
	          var text = indexPattern.formatField(row, fieldName);

	          if (breakWords) {
	            text = addWordBreaks(text, MIN_LINE_LENGTH);

	            if (text.length > MIN_LINE_LENGTH) {
	              return truncateByHeightTemplate({
	                body: text
	              });
	            }
	          }

	          return text;
	        }

	        init();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function addWordBreaks(text, minLineLength) {
	    text = text || '';
	    var lineSize = 0;
	    var newText = '';
	    var inHtmlTag = false;
	    var inHtmlChar = false;

	    for (var i = 0, len = text.length; i < len; i++) {
	      var chr = text.charAt(i);
	      newText += chr;

	      switch (chr) {
	        case ' ':
	        case ':':
	        case ',':
	          // natural line break, reset line size
	          lineSize = 0;
	          break;
	        case '<':
	          inHtmlTag = true;
	          break;
	        case '>':
	          inHtmlTag = false;
	          lineSize = 0;
	          break;
	        case '&':
	          inHtmlChar = true;
	          break;
	        case ';':
	          inHtmlChar = false;
	          lineSize = 0;
	          break;
	        default:
	          if (!inHtmlTag && !inHtmlChar) lineSize++;
	          break;
	      }

	      if (lineSize > minLineLength) {
	        // continuous text is longer then we want,
	        // so break it up with a <wbr>
	        lineSize = 0;
	        newText += '<wbr>';
	      }
	    }

	    return newText;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(459);
	__webpack_require__(466);
	__webpack_require__(467);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  __webpack_require__(459);

	  var html = __webpack_require__(466);
	  __webpack_require__(467);

	  __webpack_require__(214).get('kibana').directive('docViewer', function (config, Private) {
	    return {
	      restrict: 'E',
	      template: html,
	      scope: {
	        hit: '=',
	        indexPattern: '=',
	        filter: '=?',
	        columns: '=?'
	      },
	      link: {
	        pre: function pre($scope) {
	          $scope.aceLoaded = function (editor) {
	            editor.$blockScrolling = Infinity;
	          };
	        },

	        post: function post($scope, $el, attr) {
	          // If a field isn't in the mapping, use this
	          $scope.mode = 'table';
	          $scope.mapping = $scope.indexPattern.fields.byName;
	          $scope.flattened = $scope.indexPattern.flattenHit($scope.hit);
	          $scope.hitJson = angular.toJson($scope.hit, true);
	          $scope.formatted = $scope.indexPattern.formatHit($scope.hit);
	          $scope.fields = _.keys($scope.flattened).sort();

	          $scope.toggleColumn = function (fieldName) {
	            _.toggleInOut($scope.columns, fieldName);
	          };

	          $scope.showArrayInObjectsWarning = function (row, field) {
	            var value = $scope.flattened[field];
	            return _.isArray(value) && typeof value[0] === 'object';
	          };
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(460);
	__webpack_require__(463);
	__webpack_require__(465);

	__webpack_require__(214).get('kibana', ['ui.ace']);

	module.exports = window.ace;


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	/* ***** BEGIN LICENSE BLOCK *****
	 * Distributed under the BSD license:
	 *
	 * Copyright (c) 2010, Ajax.org B.V.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *     * Redistributions of source code must retain the above copyright
	 *       notice, this list of conditions and the following disclaimer.
	 *     * Redistributions in binary form must reproduce the above copyright
	 *       notice, this list of conditions and the following disclaimer in the
	 *       documentation and/or other materials provided with the distribution.
	 *     * Neither the name of Ajax.org B.V. nor the
	 *       names of its contributors may be used to endorse or promote products
	 *       derived from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * ***** END LICENSE BLOCK ***** */

	/**
	 * Define a module along with a payload
	 * @param module a name for the payload
	 * @param payload a function to call with (acequire, exports, module) params
	 */

	(function() {

	var ACE_NAMESPACE = "ace";

	var global = (function() { return this; })();
	if (!global && typeof window != "undefined") global = window; // strict mode


	if (!ACE_NAMESPACE && typeof acequirejs !== "undefined")
	    return;


	var define = function(module, deps, payload) {
	    if (typeof module !== "string") {
	        if (define.original)
	            define.original.apply(this, arguments);
	        else {
	            console.error("dropping module because define wasn\'t a string.");
	            console.trace();
	        }
	        return;
	    }
	    if (arguments.length == 2)
	        payload = deps;
	    if (!define.modules[module]) {
	        define.payloads[module] = payload;
	        define.modules[module] = null;
	    }
	};

	define.modules = {};
	define.payloads = {};

	/**
	 * Get at functionality ace.define()ed using the function above
	 */
	var _acequire = function(parentId, module, callback) {
	    if (typeof module === "string") {
	        var payload = lookup(parentId, module);
	        if (payload != undefined) {
	            callback && callback();
	            return payload;
	        }
	    } else if (Object.prototype.toString.call(module) === "[object Array]") {
	        var params = [];
	        for (var i = 0, l = module.length; i < l; ++i) {
	            var dep = lookup(parentId, module[i]);
	            if (dep == undefined && acequire.original)
	                return;
	            params.push(dep);
	        }
	        return callback && callback.apply(null, params) || true;
	    }
	};

	var acequire = function(module, callback) {
	    var packagedModule = _acequire("", module, callback);
	    if (packagedModule == undefined && acequire.original)
	        return acequire.original.apply(this, arguments);
	    return packagedModule;
	};

	var normalizeModule = function(parentId, moduleName) {
	    // normalize plugin acequires
	    if (moduleName.indexOf("!") !== -1) {
	        var chunks = moduleName.split("!");
	        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
	    }
	    // normalize relative acequires
	    if (moduleName.charAt(0) == ".") {
	        var base = parentId.split("/").slice(0, -1).join("/");
	        moduleName = base + "/" + moduleName;

	        while(moduleName.indexOf(".") !== -1 && previous != moduleName) {
	            var previous = moduleName;
	            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
	        }
	    }
	    return moduleName;
	};

	/**
	 * Internal function to lookup moduleNames and resolve them by calling the
	 * definition function if needed.
	 */
	var lookup = function(parentId, moduleName) {
	    moduleName = normalizeModule(parentId, moduleName);

	    var module = define.modules[moduleName];
	    if (!module) {
	        module = define.payloads[moduleName];
	        if (typeof module === 'function') {
	            var exports = {};
	            var mod = {
	                id: moduleName,
	                uri: '',
	                exports: exports,
	                packaged: true
	            };

	            var req = function(module, callback) {
	                return _acequire(moduleName, module, callback);
	            };

	            var returnValue = module(req, exports, mod);
	            exports = returnValue || mod.exports;
	            define.modules[moduleName] = exports;
	            delete define.payloads[moduleName];
	        }
	        module = define.modules[moduleName] = exports || module;
	    }
	    return module;
	};

	function exportAce(ns) {
	    var root = global;
	    if (ns) {
	        if (!global[ns])
	            global[ns] = {};
	        root = global[ns];
	    }

	    if (!root.define || !root.define.packaged) {
	        define.original = root.define;
	        root.define = define;
	        root.define.packaged = true;
	    }

	    if (!root.acequire || !root.acequire.packaged) {
	        acequire.original = root.acequire;
	        root.acequire = acequire;
	        root.acequire.packaged = true;
	    }
	}

	exportAce(ACE_NAMESPACE);

	})();

	ace.define("ace/lib/regexp",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	    var real = {
	            exec: RegExp.prototype.exec,
	            test: RegExp.prototype.test,
	            match: String.prototype.match,
	            replace: String.prototype.replace,
	            split: String.prototype.split
	        },
	        compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
	        compliantLastIndexIncrement = function () {
	            var x = /^/g;
	            real.test.call(x, "");
	            return !x.lastIndex;
	        }();

	    if (compliantLastIndexIncrement && compliantExecNpcg)
	        return;
	    RegExp.prototype.exec = function (str) {
	        var match = real.exec.apply(this, arguments),
	            name, r2;
	        if ( typeof(str) == 'string' && match) {
	            if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
	                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
	                real.replace.call(str.slice(match.index), r2, function () {
	                    for (var i = 1; i < arguments.length - 2; i++) {
	                        if (arguments[i] === undefined)
	                            match[i] = undefined;
	                    }
	                });
	            }
	            if (this._xregexp && this._xregexp.captureNames) {
	                for (var i = 1; i < match.length; i++) {
	                    name = this._xregexp.captureNames[i - 1];
	                    if (name)
	                       match[name] = match[i];
	                }
	            }
	            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
	                this.lastIndex--;
	        }
	        return match;
	    };
	    if (!compliantLastIndexIncrement) {
	        RegExp.prototype.test = function (str) {
	            var match = real.exec.call(this, str);
	            if (match && this.global && !match[0].length && (this.lastIndex > match.index))
	                this.lastIndex--;
	            return !!match;
	        };
	    }

	    function getNativeFlags (regex) {
	        return (regex.global     ? "g" : "") +
	               (regex.ignoreCase ? "i" : "") +
	               (regex.multiline  ? "m" : "") +
	               (regex.extended   ? "x" : "") + // Proposed for ES4; included in AS3
	               (regex.sticky     ? "y" : "");
	    }

	    function indexOf (array, item, from) {
	        if (Array.prototype.indexOf) // Use the native array method if available
	            return array.indexOf(item, from);
	        for (var i = from || 0; i < array.length; i++) {
	            if (array[i] === item)
	                return i;
	        }
	        return -1;
	    }

	});

	ace.define("ace/lib/es5-shim",["require","exports","module"], function(acequire, exports, module) {

	function Empty() {}

	if (!Function.prototype.bind) {
	    Function.prototype.bind = function bind(that) { // .length is 1
	        var target = this;
	        if (typeof target != "function") {
	            throw new TypeError("Function.prototype.bind called on incompatible " + target);
	        }
	        var args = slice.call(arguments, 1); // for normal call
	        var bound = function () {

	            if (this instanceof bound) {

	                var result = target.apply(
	                    this,
	                    args.concat(slice.call(arguments))
	                );
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;

	            } else {
	                return target.apply(
	                    that,
	                    args.concat(slice.call(arguments))
	                );

	            }

	        };
	        if(target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            Empty.prototype = null;
	        }
	        return bound;
	    };
	}
	var call = Function.prototype.call;
	var prototypeOfArray = Array.prototype;
	var prototypeOfObject = Object.prototype;
	var slice = prototypeOfArray.slice;
	var _toString = call.bind(prototypeOfObject.toString);
	var owns = call.bind(prototypeOfObject.hasOwnProperty);
	var defineGetter;
	var defineSetter;
	var lookupGetter;
	var lookupSetter;
	var supportsAccessors;
	if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
	    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
	    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
	    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
	    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
	}
	if ([1,2].splice(0).length != 2) {
	    if(function() { // test IE < 9 to splice bug - see issue #138
	        function makeArray(l) {
	            var a = new Array(l+2);
	            a[0] = a[1] = 0;
	            return a;
	        }
	        var array = [], lengthBefore;
	        
	        array.splice.apply(array, makeArray(20));
	        array.splice.apply(array, makeArray(26));

	        lengthBefore = array.length; //46
	        array.splice(5, 0, "XXX"); // add one element

	        lengthBefore + 1 == array.length

	        if (lengthBefore + 1 == array.length) {
	            return true;// has right splice implementation without bugs
	        }
	    }()) {//IE 6/7
	        var array_splice = Array.prototype.splice;
	        Array.prototype.splice = function(start, deleteCount) {
	            if (!arguments.length) {
	                return [];
	            } else {
	                return array_splice.apply(this, [
	                    start === void 0 ? 0 : start,
	                    deleteCount === void 0 ? (this.length - start) : deleteCount
	                ].concat(slice.call(arguments, 2)))
	            }
	        };
	    } else {//IE8
	        Array.prototype.splice = function(pos, removeCount){
	            var length = this.length;
	            if (pos > 0) {
	                if (pos > length)
	                    pos = length;
	            } else if (pos == void 0) {
	                pos = 0;
	            } else if (pos < 0) {
	                pos = Math.max(length + pos, 0);
	            }

	            if (!(pos+removeCount < length))
	                removeCount = length - pos;

	            var removed = this.slice(pos, pos+removeCount);
	            var insert = slice.call(arguments, 2);
	            var add = insert.length;            
	            if (pos === length) {
	                if (add) {
	                    this.push.apply(this, insert);
	                }
	            } else {
	                var remove = Math.min(removeCount, length - pos);
	                var tailOldPos = pos + remove;
	                var tailNewPos = tailOldPos + add - remove;
	                var tailCount = length - tailOldPos;
	                var lengthAfterRemove = length - remove;

	                if (tailNewPos < tailOldPos) { // case A
	                    for (var i = 0; i < tailCount; ++i) {
	                        this[tailNewPos+i] = this[tailOldPos+i];
	                    }
	                } else if (tailNewPos > tailOldPos) { // case B
	                    for (i = tailCount; i--; ) {
	                        this[tailNewPos+i] = this[tailOldPos+i];
	                    }
	                } // else, add == remove (nothing to do)

	                if (add && pos === lengthAfterRemove) {
	                    this.length = lengthAfterRemove; // truncate array
	                    this.push.apply(this, insert);
	                } else {
	                    this.length = lengthAfterRemove + add; // reserves space
	                    for (i = 0; i < add; ++i) {
	                        this[pos+i] = insert[i];
	                    }
	                }
	            }
	            return removed;
	        };
	    }
	}
	if (!Array.isArray) {
	    Array.isArray = function isArray(obj) {
	        return _toString(obj) == "[object Array]";
	    };
	}
	var boxedString = Object("a"),
	    splitString = boxedString[0] != "a" || !(0 in boxedString);

	if (!Array.prototype.forEach) {
	    Array.prototype.forEach = function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(); // TODO message
	        }

	        while (++i < length) {
	            if (i in self) {
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    };
	}
	if (!Array.prototype.map) {
	    Array.prototype.map = function map(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            result = Array(length),
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self)
	                result[i] = fun.call(thisp, self[i], i, object);
	        }
	        return result;
	    };
	}
	if (!Array.prototype.filter) {
	    Array.prototype.filter = function filter(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                    object,
	            length = self.length >>> 0,
	            result = [],
	            value,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                value = self[i];
	                if (fun.call(thisp, value, i, object)) {
	                    result.push(value);
	                }
	            }
	        }
	        return result;
	    };
	}
	if (!Array.prototype.every) {
	    Array.prototype.every = function every(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self && !fun.call(thisp, self[i], i, object)) {
	                return false;
	            }
	        }
	        return true;
	    };
	}
	if (!Array.prototype.some) {
	    Array.prototype.some = function some(fun /*, thisp */) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }

	        for (var i = 0; i < length; i++) {
	            if (i in self && fun.call(thisp, self[i], i, object)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}
	if (!Array.prototype.reduce) {
	    Array.prototype.reduce = function reduce(fun /*, initial*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }
	        if (!length && arguments.length == 1) {
	            throw new TypeError("reduce of empty array with no initial value");
	        }

	        var i = 0;
	        var result;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i++];
	                    break;
	                }
	                if (++i >= length) {
	                    throw new TypeError("reduce of empty array with no initial value");
	                }
	            } while (true);
	        }

	        for (; i < length; i++) {
	            if (i in self) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        }

	        return result;
	    };
	}
	if (!Array.prototype.reduceRight) {
	    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
	        var object = toObject(this),
	            self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                object,
	            length = self.length >>> 0;
	        if (_toString(fun) != "[object Function]") {
	            throw new TypeError(fun + " is not a function");
	        }
	        if (!length && arguments.length == 1) {
	            throw new TypeError("reduceRight of empty array with no initial value");
	        }

	        var result, i = length - 1;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i--];
	                    break;
	                }
	                if (--i < 0) {
	                    throw new TypeError("reduceRight of empty array with no initial value");
	                }
	            } while (true);
	        }

	        do {
	            if (i in this) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        } while (i--);

	        return result;
	    };
	}
	if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
	    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {
	        var self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                toObject(this),
	            length = self.length >>> 0;

	        if (!length) {
	            return -1;
	        }

	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
	    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
	        var self = splitString && _toString(this) == "[object String]" ?
	                this.split("") :
	                toObject(this),
	            length = self.length >>> 0;

	        if (!length) {
	            return -1;
	        }
	        var i = length - 1;
	        if (arguments.length > 1) {
	            i = Math.min(i, toInteger(arguments[1]));
	        }
	        i = i >= 0 ? i : length - Math.abs(i);
	        for (; i >= 0; i--) {
	            if (i in self && sought === self[i]) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	if (!Object.getPrototypeOf) {
	    Object.getPrototypeOf = function getPrototypeOf(object) {
	        return object.__proto__ || (
	            object.constructor ?
	            object.constructor.prototype :
	            prototypeOfObject
	        );
	    };
	}
	if (!Object.getOwnPropertyDescriptor) {
	    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
	                         "non-object: ";
	    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
	        if ((typeof object != "object" && typeof object != "function") || object === null)
	            throw new TypeError(ERR_NON_OBJECT + object);
	        if (!owns(object, property))
	            return;

	        var descriptor, getter, setter;
	        descriptor =  { enumerable: true, configurable: true };
	        if (supportsAccessors) {
	            var prototype = object.__proto__;
	            object.__proto__ = prototypeOfObject;

	            var getter = lookupGetter(object, property);
	            var setter = lookupSetter(object, property);
	            object.__proto__ = prototype;

	            if (getter || setter) {
	                if (getter) descriptor.get = getter;
	                if (setter) descriptor.set = setter;
	                return descriptor;
	            }
	        }
	        descriptor.value = object[property];
	        return descriptor;
	    };
	}
	if (!Object.getOwnPropertyNames) {
	    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
	        return Object.keys(object);
	    };
	}
	if (!Object.create) {
	    var createEmpty;
	    if (Object.prototype.__proto__ === null) {
	        createEmpty = function () {
	            return { "__proto__": null };
	        };
	    } else {
	        createEmpty = function () {
	            var empty = {};
	            for (var i in empty)
	                empty[i] = null;
	            empty.constructor =
	            empty.hasOwnProperty =
	            empty.propertyIsEnumerable =
	            empty.isPrototypeOf =
	            empty.toLocaleString =
	            empty.toString =
	            empty.valueOf =
	            empty.__proto__ = null;
	            return empty;
	        }
	    }

	    Object.create = function create(prototype, properties) {
	        var object;
	        if (prototype === null) {
	            object = createEmpty();
	        } else {
	            if (typeof prototype != "object")
	                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
	            var Type = function () {};
	            Type.prototype = prototype;
	            object = new Type();
	            object.__proto__ = prototype;
	        }
	        if (properties !== void 0)
	            Object.defineProperties(object, properties);
	        return object;
	    };
	}

	function doesDefinePropertyWork(object) {
	    try {
	        Object.defineProperty(object, "sentinel", {});
	        return "sentinel" in object;
	    } catch (exception) {
	    }
	}
	if (Object.defineProperty) {
	    var definePropertyWorksOnObject = doesDefinePropertyWork({});
	    var definePropertyWorksOnDom = typeof document == "undefined" ||
	        doesDefinePropertyWork(document.createElement("div"));
	    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
	        var definePropertyFallback = Object.defineProperty;
	    }
	}

	if (!Object.defineProperty || definePropertyFallback) {
	    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
	    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: "
	    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
	                                      "on this javascript engine";

	    Object.defineProperty = function defineProperty(object, property, descriptor) {
	        if ((typeof object != "object" && typeof object != "function") || object === null)
	            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
	        if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
	            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
	        if (definePropertyFallback) {
	            try {
	                return definePropertyFallback.call(Object, object, property, descriptor);
	            } catch (exception) {
	            }
	        }
	        if (owns(descriptor, "value")) {

	            if (supportsAccessors && (lookupGetter(object, property) ||
	                                      lookupSetter(object, property)))
	            {
	                var prototype = object.__proto__;
	                object.__proto__ = prototypeOfObject;
	                delete object[property];
	                object[property] = descriptor.value;
	                object.__proto__ = prototype;
	            } else {
	                object[property] = descriptor.value;
	            }
	        } else {
	            if (!supportsAccessors)
	                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
	            if (owns(descriptor, "get"))
	                defineGetter(object, property, descriptor.get);
	            if (owns(descriptor, "set"))
	                defineSetter(object, property, descriptor.set);
	        }

	        return object;
	    };
	}
	if (!Object.defineProperties) {
	    Object.defineProperties = function defineProperties(object, properties) {
	        for (var property in properties) {
	            if (owns(properties, property))
	                Object.defineProperty(object, property, properties[property]);
	        }
	        return object;
	    };
	}
	if (!Object.seal) {
	    Object.seal = function seal(object) {
	        return object;
	    };
	}
	if (!Object.freeze) {
	    Object.freeze = function freeze(object) {
	        return object;
	    };
	}
	try {
	    Object.freeze(function () {});
	} catch (exception) {
	    Object.freeze = (function freeze(freezeObject) {
	        return function freeze(object) {
	            if (typeof object == "function") {
	                return object;
	            } else {
	                return freezeObject(object);
	            }
	        };
	    })(Object.freeze);
	}
	if (!Object.preventExtensions) {
	    Object.preventExtensions = function preventExtensions(object) {
	        return object;
	    };
	}
	if (!Object.isSealed) {
	    Object.isSealed = function isSealed(object) {
	        return false;
	    };
	}
	if (!Object.isFrozen) {
	    Object.isFrozen = function isFrozen(object) {
	        return false;
	    };
	}
	if (!Object.isExtensible) {
	    Object.isExtensible = function isExtensible(object) {
	        if (Object(object) === object) {
	            throw new TypeError(); // TODO message
	        }
	        var name = '';
	        while (owns(object, name)) {
	            name += '?';
	        }
	        object[name] = true;
	        var returnValue = owns(object, name);
	        delete object[name];
	        return returnValue;
	    };
	}
	if (!Object.keys) {
	    var hasDontEnumBug = true,
	        dontEnums = [
	            "toString",
	            "toLocaleString",
	            "valueOf",
	            "hasOwnProperty",
	            "isPrototypeOf",
	            "propertyIsEnumerable",
	            "constructor"
	        ],
	        dontEnumsLength = dontEnums.length;

	    for (var key in {"toString": null}) {
	        hasDontEnumBug = false;
	    }

	    Object.keys = function keys(object) {

	        if (
	            (typeof object != "object" && typeof object != "function") ||
	            object === null
	        ) {
	            throw new TypeError("Object.keys called on a non-object");
	        }

	        var keys = [];
	        for (var name in object) {
	            if (owns(object, name)) {
	                keys.push(name);
	            }
	        }

	        if (hasDontEnumBug) {
	            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
	                var dontEnum = dontEnums[i];
	                if (owns(object, dontEnum)) {
	                    keys.push(dontEnum);
	                }
	            }
	        }
	        return keys;
	    };

	}
	if (!Date.now) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
	    "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
	    "\u2029\uFEFF";
	if (!String.prototype.trim || ws.trim()) {
	    ws = "[" + ws + "]";
	    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
	        trimEndRegexp = new RegExp(ws + ws + "*$");
	    String.prototype.trim = function trim() {
	        return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
	    };
	}

	function toInteger(n) {
	    n = +n;
	    if (n !== n) { // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}

	function isPrimitive(input) {
	    var type = typeof input;
	    return (
	        input === null ||
	        type === "undefined" ||
	        type === "boolean" ||
	        type === "number" ||
	        type === "string"
	    );
	}

	function toPrimitive(input) {
	    var val, valueOf, toString;
	    if (isPrimitive(input)) {
	        return input;
	    }
	    valueOf = input.valueOf;
	    if (typeof valueOf === "function") {
	        val = valueOf.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    toString = input.toString;
	    if (typeof toString === "function") {
	        val = toString.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    throw new TypeError();
	}
	var toObject = function (o) {
	    if (o == null) { // this matches both null and undefined
	        throw new TypeError("can't convert "+o+" to object");
	    }
	    return Object(o);
	};

	});

	ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/regexp","ace/lib/es5-shim"], function(acequire, exports, module) {
	"use strict";

	acequire("./regexp");
	acequire("./es5-shim");

	});

	ace.define("ace/lib/dom",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var XHTML_NS = "http://www.w3.org/1999/xhtml";

	exports.getDocumentHead = function(doc) {
	    if (!doc)
	        doc = document;
	    return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
	}

	exports.createElement = function(tag, ns) {
	    return document.createElementNS ?
	           document.createElementNS(ns || XHTML_NS, tag) :
	           document.createElement(tag);
	};

	exports.hasCssClass = function(el, name) {
	    var classes = (el.className || "").split(/\s+/g);
	    return classes.indexOf(name) !== -1;
	};
	exports.addCssClass = function(el, name) {
	    if (!exports.hasCssClass(el, name)) {
	        el.className += " " + name;
	    }
	};
	exports.removeCssClass = function(el, name) {
	    var classes = el.className.split(/\s+/g);
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        classes.splice(index, 1);
	    }
	    el.className = classes.join(" ");
	};

	exports.toggleCssClass = function(el, name) {
	    var classes = el.className.split(/\s+/g), add = true;
	    while (true) {
	        var index = classes.indexOf(name);
	        if (index == -1) {
	            break;
	        }
	        add = false;
	        classes.splice(index, 1);
	    }
	    if(add)
	        classes.push(name);

	    el.className = classes.join(" ");
	    return add;
	};
	exports.setCssClass = function(node, className, include) {
	    if (include) {
	        exports.addCssClass(node, className);
	    } else {
	        exports.removeCssClass(node, className);
	    }
	};

	exports.hasCssString = function(id, doc) {
	    var index = 0, sheets;
	    doc = doc || document;

	    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
	        while (index < sheets.length)
	            if (sheets[index++].owningElement.id === id) return true;
	    } else if ((sheets = doc.getElementsByTagName("style"))) {
	        while (index < sheets.length)
	            if (sheets[index++].id === id) return true;
	    }

	    return false;
	};

	exports.importCssString = function importCssString(cssText, id, doc) {
	    doc = doc || document;
	    if (id && exports.hasCssString(id, doc))
	        return null;
	    
	    var style;
	    
	    if (doc.createStyleSheet) {
	        style = doc.createStyleSheet();
	        style.cssText = cssText;
	        if (id)
	            style.owningElement.id = id;
	    } else {
	        style = doc.createElementNS
	            ? doc.createElementNS(XHTML_NS, "style")
	            : doc.createElement("style");

	        style.appendChild(doc.createTextNode(cssText));
	        if (id)
	            style.id = id;

	        exports.getDocumentHead(doc).appendChild(style);
	    }
	};

	exports.importCssStylsheet = function(uri, doc) {
	    if (doc.createStyleSheet) {
	        doc.createStyleSheet(uri);
	    } else {
	        var link = exports.createElement('link');
	        link.rel = 'stylesheet';
	        link.href = uri;

	        exports.getDocumentHead(doc).appendChild(link);
	    }
	};

	exports.getInnerWidth = function(element) {
	    return (
	        parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
	        parseInt(exports.computedStyle(element, "paddingRight"), 10) + 
	        element.clientWidth
	    );
	};

	exports.getInnerHeight = function(element) {
	    return (
	        parseInt(exports.computedStyle(element, "paddingTop"), 10) +
	        parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
	        element.clientHeight
	    );
	};


	if (typeof document == "undefined")
	    return;

	if (window.pageYOffset !== undefined) {
	    exports.getPageScrollTop = function() {
	        return window.pageYOffset;
	    };

	    exports.getPageScrollLeft = function() {
	        return window.pageXOffset;
	    };
	}
	else {
	    exports.getPageScrollTop = function() {
	        return document.body.scrollTop;
	    };

	    exports.getPageScrollLeft = function() {
	        return document.body.scrollLeft;
	    };
	}

	if (window.getComputedStyle)
	    exports.computedStyle = function(element, style) {
	        if (style)
	            return (window.getComputedStyle(element, "") || {})[style] || "";
	        return window.getComputedStyle(element, "") || {};
	    };
	else
	    exports.computedStyle = function(element, style) {
	        if (style)
	            return element.currentStyle[style];
	        return element.currentStyle;
	    };

	exports.scrollbarWidth = function(document) {
	    var inner = exports.createElement("ace_inner");
	    inner.style.width = "100%";
	    inner.style.minWidth = "0px";
	    inner.style.height = "200px";
	    inner.style.display = "block";

	    var outer = exports.createElement("ace_outer");
	    var style = outer.style;

	    style.position = "absolute";
	    style.left = "-10000px";
	    style.overflow = "hidden";
	    style.width = "200px";
	    style.minWidth = "0px";
	    style.height = "150px";
	    style.display = "block";

	    outer.appendChild(inner);

	    var body = document.documentElement;
	    body.appendChild(outer);

	    var noScrollbar = inner.offsetWidth;

	    style.overflow = "scroll";
	    var withScrollbar = inner.offsetWidth;

	    if (noScrollbar == withScrollbar) {
	        withScrollbar = outer.clientWidth;
	    }

	    body.removeChild(outer);

	    return noScrollbar-withScrollbar;
	};
	exports.setInnerHtml = function(el, innerHtml) {
	    var element = el.cloneNode(false);//document.createElement("div");
	    element.innerHTML = innerHtml;
	    el.parentNode.replaceChild(element, el);
	    return element;
	};

	if ("textContent" in document.documentElement) {
	    exports.setInnerText = function(el, innerText) {
	        el.textContent = innerText;
	    };

	    exports.getInnerText = function(el) {
	        return el.textContent;
	    };
	}
	else {
	    exports.setInnerText = function(el, innerText) {
	        el.innerText = innerText;
	    };

	    exports.getInnerText = function(el) {
	        return el.innerText;
	    };
	}

	exports.getParentWindow = function(document) {
	    return document.defaultView || document.parentWindow;
	};

	});

	ace.define("ace/lib/oop",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	exports.inherits = function(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	            value: ctor,
	            enumerable: false,
	            writable: true,
	            configurable: true
	        }
	    });
	};

	exports.mixin = function(obj, mixin) {
	    for (var key in mixin) {
	        obj[key] = mixin[key];
	    }
	    return obj;
	};

	exports.implement = function(proto, mixin) {
	    exports.mixin(proto, mixin);
	};

	});

	ace.define("ace/lib/keys",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	acequire("./fixoldbrowsers");

	var oop = acequire("./oop");
	var Keys = (function() {
	    var ret = {
	        MODIFIER_KEYS: {
	            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
	        },

	        KEY_MODS: {
	            "ctrl": 1, "alt": 2, "option" : 2, "shift": 4,
	            "super": 8, "meta": 8, "command": 8, "cmd": 8
	        },

	        FUNCTION_KEYS : {
	            8  : "Backspace",
	            9  : "Tab",
	            13 : "Return",
	            19 : "Pause",
	            27 : "Esc",
	            32 : "Space",
	            33 : "PageUp",
	            34 : "PageDown",
	            35 : "End",
	            36 : "Home",
	            37 : "Left",
	            38 : "Up",
	            39 : "Right",
	            40 : "Down",
	            44 : "Print",
	            45 : "Insert",
	            46 : "Delete",
	            96 : "Numpad0",
	            97 : "Numpad1",
	            98 : "Numpad2",
	            99 : "Numpad3",
	            100: "Numpad4",
	            101: "Numpad5",
	            102: "Numpad6",
	            103: "Numpad7",
	            104: "Numpad8",
	            105: "Numpad9",
	            '-13': "NumpadEnter",
	            112: "F1",
	            113: "F2",
	            114: "F3",
	            115: "F4",
	            116: "F5",
	            117: "F6",
	            118: "F7",
	            119: "F8",
	            120: "F9",
	            121: "F10",
	            122: "F11",
	            123: "F12",
	            144: "Numlock",
	            145: "Scrolllock"
	        },

	        PRINTABLE_KEYS: {
	           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',
	           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',
	           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',
	           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',
	           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',
	           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',
	          186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
	          219: '[', 220: '\\',221: ']', 222: '\''
	        }
	    };
	    var name, i;
	    for (i in ret.FUNCTION_KEYS) {
	        name = ret.FUNCTION_KEYS[i].toLowerCase();
	        ret[name] = parseInt(i, 10);
	    }
	    for (i in ret.PRINTABLE_KEYS) {
	        name = ret.PRINTABLE_KEYS[i].toLowerCase();
	        ret[name] = parseInt(i, 10);
	    }
	    oop.mixin(ret, ret.MODIFIER_KEYS);
	    oop.mixin(ret, ret.PRINTABLE_KEYS);
	    oop.mixin(ret, ret.FUNCTION_KEYS);
	    ret.enter = ret["return"];
	    ret.escape = ret.esc;
	    ret.del = ret["delete"];
	    ret[173] = '-';
	    
	    (function() {
	        var mods = ["cmd", "ctrl", "alt", "shift"];
	        for (var i = Math.pow(2, mods.length); i--;) {            
	            ret.KEY_MODS[i] = mods.filter(function(x) {
	                return i & ret.KEY_MODS[x];
	            }).join("-") + "-";
	        }
	    })();

	    ret.KEY_MODS[0] = "";
	    ret.KEY_MODS[-1] = "input-";

	    return ret;
	})();
	oop.mixin(exports, Keys);

	exports.keyCodeToString = function(keyCode) {
	    var keyString = Keys[keyCode];
	    if (typeof keyString != "string")
	        keyString = String.fromCharCode(keyCode);
	    return keyString.toLowerCase();
	};

	});

	ace.define("ace/lib/useragent",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	exports.OS = {
	    LINUX: "LINUX",
	    MAC: "MAC",
	    WINDOWS: "WINDOWS"
	};
	exports.getOS = function() {
	    if (exports.isMac) {
	        return exports.OS.MAC;
	    } else if (exports.isLinux) {
	        return exports.OS.LINUX;
	    } else {
	        return exports.OS.WINDOWS;
	    }
	};
	if (typeof navigator != "object")
	    return;

	var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
	var ua = navigator.userAgent;
	exports.isWin = (os == "win");
	exports.isMac = (os == "mac");
	exports.isLinux = (os == "linux");
	exports.isIE = 
	    (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
	    ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1])
	    : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]); // for ie
	    
	exports.isOldIE = exports.isIE && exports.isIE < 9;
	exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
	exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/)||[])[1], 10) < 4;
	exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
	exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

	exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

	exports.isAIR = ua.indexOf("AdobeAIR") >= 0;

	exports.isIPad = ua.indexOf("iPad") >= 0;

	exports.isTouchPad = ua.indexOf("TouchPad") >= 0;

	exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;

	});

	ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var keys = acequire("./keys");
	var useragent = acequire("./useragent");

	exports.addListener = function(elem, type, callback) {
	    if (elem.addEventListener) {
	        return elem.addEventListener(type, callback, false);
	    }
	    if (elem.attachEvent) {
	        var wrapper = function() {
	            callback.call(elem, window.event);
	        };
	        callback._wrapper = wrapper;
	        elem.attachEvent("on" + type, wrapper);
	    }
	};

	exports.removeListener = function(elem, type, callback) {
	    if (elem.removeEventListener) {
	        return elem.removeEventListener(type, callback, false);
	    }
	    if (elem.detachEvent) {
	        elem.detachEvent("on" + type, callback._wrapper || callback);
	    }
	};
	exports.stopEvent = function(e) {
	    exports.stopPropagation(e);
	    exports.preventDefault(e);
	    return false;
	};

	exports.stopPropagation = function(e) {
	    if (e.stopPropagation)
	        e.stopPropagation();
	    else
	        e.cancelBubble = true;
	};

	exports.preventDefault = function(e) {
	    if (e.preventDefault)
	        e.preventDefault();
	    else
	        e.returnValue = false;
	};
	exports.getButton = function(e) {
	    if (e.type == "dblclick")
	        return 0;
	    if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
	        return 2;
	    if (e.preventDefault) {
	        return e.button;
	    }
	    else {
	        return {1:0, 2:2, 4:1}[e.button];
	    }
	};

	exports.capture = function(el, eventHandler, releaseCaptureHandler) {
	    function onMouseUp(e) {
	        eventHandler && eventHandler(e);
	        releaseCaptureHandler && releaseCaptureHandler(e);

	        exports.removeListener(document, "mousemove", eventHandler, true);
	        exports.removeListener(document, "mouseup", onMouseUp, true);
	        exports.removeListener(document, "dragstart", onMouseUp, true);
	    }

	    exports.addListener(document, "mousemove", eventHandler, true);
	    exports.addListener(document, "mouseup", onMouseUp, true);
	    exports.addListener(document, "dragstart", onMouseUp, true);
	    
	    return onMouseUp;
	};

	exports.addMouseWheelListener = function(el, callback) {
	    if ("onmousewheel" in el) {
	        exports.addListener(el, "mousewheel", function(e) {
	            var factor = 8;
	            if (e.wheelDeltaX !== undefined) {
	                e.wheelX = -e.wheelDeltaX / factor;
	                e.wheelY = -e.wheelDeltaY / factor;
	            } else {
	                e.wheelX = 0;
	                e.wheelY = -e.wheelDelta / factor;
	            }
	            callback(e);
	        });
	    } else if ("onwheel" in el) {
	        exports.addListener(el, "wheel",  function(e) {
	            var factor = 0.35;
	            switch (e.deltaMode) {
	                case e.DOM_DELTA_PIXEL:
	                    e.wheelX = e.deltaX * factor || 0;
	                    e.wheelY = e.deltaY * factor || 0;
	                    break;
	                case e.DOM_DELTA_LINE:
	                case e.DOM_DELTA_PAGE:
	                    e.wheelX = (e.deltaX || 0) * 5;
	                    e.wheelY = (e.deltaY || 0) * 5;
	                    break;
	            }
	            
	            callback(e);
	        });
	    } else {
	        exports.addListener(el, "DOMMouseScroll", function(e) {
	            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
	                e.wheelX = (e.detail || 0) * 5;
	                e.wheelY = 0;
	            } else {
	                e.wheelX = 0;
	                e.wheelY = (e.detail || 0) * 5;
	            }
	            callback(e);
	        });
	    }
	};

	exports.addMultiMouseDownListener = function(el, timeouts, eventHandler, callbackName) {
	    var clicks = 0;
	    var startX, startY, timer; 
	    var eventNames = {
	        2: "dblclick",
	        3: "tripleclick",
	        4: "quadclick"
	    };

	    exports.addListener(el, "mousedown", function(e) {
	        if (exports.getButton(e) !== 0) {
	            clicks = 0;
	        } else if (e.detail > 1) {
	            clicks++;
	            if (clicks > 4)
	                clicks = 1;
	        } else {
	            clicks = 1;
	        }
	        if (useragent.isIE) {
	            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
	            if (!timer || isNewClick)
	                clicks = 1;
	            if (timer)
	                clearTimeout(timer);
	            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);

	            if (clicks == 1) {
	                startX = e.clientX;
	                startY = e.clientY;
	            }
	        }
	        
	        e._clicks = clicks;

	        eventHandler[callbackName]("mousedown", e);

	        if (clicks > 4)
	            clicks = 0;
	        else if (clicks > 1)
	            return eventHandler[callbackName](eventNames[clicks], e);
	    });

	    if (useragent.isOldIE) {
	        exports.addListener(el, "dblclick", function(e) {
	            clicks = 2;
	            if (timer)
	                clearTimeout(timer);
	            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);
	            eventHandler[callbackName]("mousedown", e);
	            eventHandler[callbackName](eventNames[clicks], e);
	        });
	    }
	};

	var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
	    ? function(e) {
	        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
	    }
	    : function(e) {
	        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
	    };

	exports.getModifierString = function(e) {
	    return keys.KEY_MODS[getModifierHash(e)];
	};

	function normalizeCommandKeys(callback, e, keyCode) {
	    var hashId = getModifierHash(e);

	    if (!useragent.isMac && pressedKeys) {
	        if (pressedKeys[91] || pressedKeys[92])
	            hashId |= 8;
	        if (pressedKeys.altGr) {
	            if ((3 & hashId) != 3)
	                pressedKeys.altGr = 0;
	            else
	                return;
	        }
	        if (keyCode === 18 || keyCode === 17) {
	            var location = "location" in e ? e.location : e.keyLocation;
	            if (keyCode === 17 && location === 1) {
	                if (pressedKeys[keyCode] == 1)
	                    ts = e.timeStamp;
	            } else if (keyCode === 18 && hashId === 3 && location === 2) {
	                var dt = e.timestamp - ts;
	                if (dt < 50)
	                    pressedKeys.altGr = true;
	            }
	        }
	    }
	    
	    if (keyCode in keys.MODIFIER_KEYS) {
	        keyCode = -1;
	    }

	    if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
	        keyCode = -1;
	    }
	    
	    if (!hashId && keyCode === 13) {
	        var location = "location" in e ? e.location : e.keyLocation;
	        if (location === 3) {
	            callback(e, hashId, -keyCode);
	            if (e.defaultPrevented)
	                return;
	        }
	    }
	    
	    if (useragent.isChromeOS && hashId & 8) {
	        callback(e, hashId, keyCode);
	        if (e.defaultPrevented)
	            return;
	        else
	            hashId &= ~8;
	    }
	    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
	        return false;
	    }
	    
	    return callback(e, hashId, keyCode);
	}

	var pressedKeys = null;
	var ts = 0;
	exports.addCommandKeyListener = function(el, callback) {
	    var addListener = exports.addListener;
	    if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
	        var lastKeyDownKeyCode = null;
	        addListener(el, "keydown", function(e) {
	            lastKeyDownKeyCode = e.keyCode;
	        });
	        addListener(el, "keypress", function(e) {
	            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
	        });
	    } else {
	        var lastDefaultPrevented = null;

	        addListener(el, "keydown", function(e) {
	            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
	            var result = normalizeCommandKeys(callback, e, e.keyCode);
	            lastDefaultPrevented = e.defaultPrevented;
	            return result;
	        });

	        addListener(el, "keypress", function(e) {
	            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
	                exports.stopEvent(e);
	                lastDefaultPrevented = null;
	            }
	        });

	        addListener(el, "keyup", function(e) {
	            pressedKeys[e.keyCode] = null;
	        });

	        if (!pressedKeys) {
	            pressedKeys = Object.create(null);
	            addListener(window, "focus", function(e) {
	                pressedKeys = Object.create(null);
	            });
	        }
	    }
	};

	if (window.postMessage && !useragent.isOldIE) {
	    var postMessageId = 1;
	    exports.nextTick = function(callback, win) {
	        win = win || window;
	        var messageName = "zero-timeout-message-" + postMessageId;
	        exports.addListener(win, "message", function listener(e) {
	            if (e.data == messageName) {
	                exports.stopPropagation(e);
	                exports.removeListener(win, "message", listener);
	                callback();
	            }
	        });
	        win.postMessage(messageName, "*");
	    };
	}


	exports.nextFrame = window.requestAnimationFrame ||
	    window.mozRequestAnimationFrame ||
	    window.webkitRequestAnimationFrame ||
	    window.msRequestAnimationFrame ||
	    window.oRequestAnimationFrame;

	if (exports.nextFrame)
	    exports.nextFrame = exports.nextFrame.bind(window);
	else
	    exports.nextFrame = function(callback) {
	        setTimeout(callback, 17);
	    };
	});

	ace.define("ace/lib/lang",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	exports.last = function(a) {
	    return a[a.length - 1];
	};

	exports.stringReverse = function(string) {
	    return string.split("").reverse().join("");
	};

	exports.stringRepeat = function (string, count) {
	    var result = '';
	    while (count > 0) {
	        if (count & 1)
	            result += string;

	        if (count >>= 1)
	            string += string;
	    }
	    return result;
	};

	var trimBeginRegexp = /^\s\s*/;
	var trimEndRegexp = /\s\s*$/;

	exports.stringTrimLeft = function (string) {
	    return string.replace(trimBeginRegexp, '');
	};

	exports.stringTrimRight = function (string) {
	    return string.replace(trimEndRegexp, '');
	};

	exports.copyObject = function(obj) {
	    var copy = {};
	    for (var key in obj) {
	        copy[key] = obj[key];
	    }
	    return copy;
	};

	exports.copyArray = function(array){
	    var copy = [];
	    for (var i=0, l=array.length; i<l; i++) {
	        if (array[i] && typeof array[i] == "object")
	            copy[i] = this.copyObject( array[i] );
	        else 
	            copy[i] = array[i];
	    }
	    return copy;
	};

	exports.deepCopy = function (obj) {
	    if (typeof obj !== "object" || !obj)
	        return obj;
	    var cons = obj.constructor;
	    if (cons === RegExp)
	        return obj;
	    
	    var copy = cons();
	    for (var key in obj) {
	        if (typeof obj[key] === "object") {
	            copy[key] = exports.deepCopy(obj[key]);
	        } else {
	            copy[key] = obj[key];
	        }
	    }
	    return copy;
	};

	exports.arrayToMap = function(arr) {
	    var map = {};
	    for (var i=0; i<arr.length; i++) {
	        map[arr[i]] = 1;
	    }
	    return map;

	};

	exports.createMap = function(props) {
	    var map = Object.create(null);
	    for (var i in props) {
	        map[i] = props[i];
	    }
	    return map;
	};
	exports.arrayRemove = function(array, value) {
	  for (var i = 0; i <= array.length; i++) {
	    if (value === array[i]) {
	      array.splice(i, 1);
	    }
	  }
	};

	exports.escapeRegExp = function(str) {
	    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
	};

	exports.escapeHTML = function(str) {
	    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
	};

	exports.getMatchOffsets = function(string, regExp) {
	    var matches = [];

	    string.replace(regExp, function(str) {
	        matches.push({
	            offset: arguments[arguments.length-2],
	            length: str.length
	        });
	    });

	    return matches;
	};
	exports.deferredCall = function(fcn) {
	    var timer = null;
	    var callback = function() {
	        timer = null;
	        fcn();
	    };

	    var deferred = function(timeout) {
	        deferred.cancel();
	        timer = setTimeout(callback, timeout || 0);
	        return deferred;
	    };

	    deferred.schedule = deferred;

	    deferred.call = function() {
	        this.cancel();
	        fcn();
	        return deferred;
	    };

	    deferred.cancel = function() {
	        clearTimeout(timer);
	        timer = null;
	        return deferred;
	    };
	    
	    deferred.isPending = function() {
	        return timer;
	    };

	    return deferred;
	};


	exports.delayedCall = function(fcn, defaultTimeout) {
	    var timer = null;
	    var callback = function() {
	        timer = null;
	        fcn();
	    };

	    var _self = function(timeout) {
	        if (timer == null)
	            timer = setTimeout(callback, timeout || defaultTimeout);
	    };

	    _self.delay = function(timeout) {
	        timer && clearTimeout(timer);
	        timer = setTimeout(callback, timeout || defaultTimeout);
	    };
	    _self.schedule = _self;

	    _self.call = function() {
	        this.cancel();
	        fcn();
	    };

	    _self.cancel = function() {
	        timer && clearTimeout(timer);
	        timer = null;
	    };

	    _self.isPending = function() {
	        return timer;
	    };

	    return _self;
	};
	});

	ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var BROKEN_SETDATA = useragent.isChrome < 18;
	var USE_IE_MIME_TYPE =  useragent.isIE;

	var TextInput = function(parentNode, host) {
	    var text = dom.createElement("textarea");
	    text.className = "ace_text-input";

	    if (useragent.isTouchPad)
	        text.setAttribute("x-palm-disable-auto-cap", true);

	    text.setAttribute("wrap", "off");
	    text.setAttribute("autocorrect", "off");
	    text.setAttribute("autocapitalize", "off");
	    text.setAttribute("spellcheck", false);

	    text.style.opacity = "0";
	    if (useragent.isOldIE) text.style.top = "-1000px";
	    parentNode.insertBefore(text, parentNode.firstChild);

	    var PLACEHOLDER = "\x01\x01";

	    var copied = false;
	    var pasted = false;
	    var inComposition = false;
	    var tempStyle = '';
	    var isSelectionEmpty = true;
	    try { var isFocused = document.activeElement === text; } catch(e) {}
	    
	    event.addListener(text, "blur", function(e) {
	        host.onBlur(e);
	        isFocused = false;
	    });
	    event.addListener(text, "focus", function(e) {
	        isFocused = true;
	        host.onFocus(e);
	        resetSelection();
	    });
	    this.focus = function() {
	        if (tempStyle) return text.focus();
	        text.style.position = "fixed";
	        text.style.top = "-1000px";
	        text.focus();
	        setTimeout(function() {
	            text.style.position = "";
	        }, 0);
	    };
	    this.blur = function() { text.blur(); };
	    this.isFocused = function() {
	        return isFocused;
	    };
	    var syncSelection = lang.delayedCall(function() {
	        isFocused && resetSelection(isSelectionEmpty);
	    });
	    var syncValue = lang.delayedCall(function() {
	         if (!inComposition) {
	            text.value = PLACEHOLDER;
	            isFocused && resetSelection();
	         }
	    });

	    function resetSelection(isEmpty) {
	        if (inComposition)
	            return;
	        inComposition = true;

	        if (inputHandler) {
	            selectionStart = 0;
	            selectionEnd = isEmpty ? 0 : text.value.length - 1;
	        } else {
	            var selectionStart = isEmpty ? 2 : 1;
	            var selectionEnd = 2;
	        }
	        try {
	            text.setSelectionRange(selectionStart, selectionEnd);
	        } catch(e){}

	        inComposition = false;
	    }

	    function resetValue() {
	        if (inComposition)
	            return;
	        text.value = PLACEHOLDER;
	        if (useragent.isWebKit)
	            syncValue.schedule();
	    }

	    useragent.isWebKit || host.addEventListener('changeSelection', function() {
	        if (host.selection.isEmpty() != isSelectionEmpty) {
	            isSelectionEmpty = !isSelectionEmpty;
	            syncSelection.schedule();
	        }
	    });

	    resetValue();
	    if (isFocused)
	        host.onFocus();


	    var isAllSelected = function(text) {
	        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
	    };
	    if (!text.setSelectionRange && text.createTextRange) {
	        text.setSelectionRange = function(selectionStart, selectionEnd) {
	            var range = this.createTextRange();
	            range.collapse(true);
	            range.moveStart('character', selectionStart);
	            range.moveEnd('character', selectionEnd);
	            range.select();
	        };
	        isAllSelected = function(text) {
	            try {
	                var range = text.ownerDocument.selection.createRange();
	            }catch(e) {}
	            if (!range || range.parentElement() != text) return false;
	                return range.text == text.value;
	        }
	    }
	    if (useragent.isOldIE) {
	        var inPropertyChange = false;
	        var onPropertyChange = function(e){
	            if (inPropertyChange)
	                return;
	            var data = text.value;
	            if (inComposition || !data || data == PLACEHOLDER)
	                return;
	            if (e && data == PLACEHOLDER[0])
	                return syncProperty.schedule();

	            sendText(data);
	            inPropertyChange = true;
	            resetValue();
	            inPropertyChange = false;
	        };
	        var syncProperty = lang.delayedCall(onPropertyChange);
	        event.addListener(text, "propertychange", onPropertyChange);

	        var keytable = { 13:1, 27:1 };
	        event.addListener(text, "keyup", function (e) {
	            if (inComposition && (!text.value || keytable[e.keyCode]))
	                setTimeout(onCompositionEnd, 0);
	            if ((text.value.charCodeAt(0)||0) < 129) {
	                return syncProperty.call();
	            }
	            inComposition ? onCompositionUpdate() : onCompositionStart();
	        });
	        event.addListener(text, "keydown", function (e) {
	            syncProperty.schedule(50);
	        });
	    }

	    var onSelect = function(e) {
	        if (copied) {
	            copied = false;
	        } else if (isAllSelected(text)) {
	            host.selectAll();
	            resetSelection();
	        } else if (inputHandler) {
	            resetSelection(host.selection.isEmpty());
	        }
	    };

	    var inputHandler = null;
	    this.setInputHandler = function(cb) {inputHandler = cb};
	    this.getInputHandler = function() {return inputHandler};
	    var afterContextMenu = false;
	    
	    var sendText = function(data) {
	        if (inputHandler) {
	            data = inputHandler(data);
	            inputHandler = null;
	        }
	        if (pasted) {
	            resetSelection();
	            if (data)
	                host.onPaste(data);
	            pasted = false;
	        } else if (data == PLACEHOLDER.charAt(0)) {
	            if (afterContextMenu)
	                host.execCommand("del", {source: "ace"});
	            else // some versions of android do not fire keydown when pressing backspace
	                host.execCommand("backspace", {source: "ace"});
	        } else {
	            if (data.substring(0, 2) == PLACEHOLDER)
	                data = data.substr(2);
	            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
	                data = data.substr(1);
	            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
	                data = data.slice(0, -1);
	            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
	                data = data.slice(0, -1);
	            
	            if (data)
	                host.onTextInput(data);
	        }
	        if (afterContextMenu)
	            afterContextMenu = false;
	    };
	    var onInput = function(e) {
	        if (inComposition)
	            return;
	        var data = text.value;
	        sendText(data);
	        resetValue();
	    };
	    
	    var handleClipboardData = function(e, data) {
	        var clipboardData = e.clipboardData || window.clipboardData;
	        if (!clipboardData || BROKEN_SETDATA)
	            return;
	        var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
	        if (data) {
	            return clipboardData.setData(mime, data) !== false;
	        } else {
	            return clipboardData.getData(mime);
	        }
	    };

	    var doCopy = function(e, isCut) {
	        var data = host.getCopyText();
	        if (!data)
	            return event.preventDefault(e);

	        if (handleClipboardData(e, data)) {
	            isCut ? host.onCut() : host.onCopy();
	            event.preventDefault(e);
	        } else {
	            copied = true;
	            text.value = data;
	            text.select();
	            setTimeout(function(){
	                copied = false;
	                resetValue();
	                resetSelection();
	                isCut ? host.onCut() : host.onCopy();
	            });
	        }
	    };
	    
	    var onCut = function(e) {
	        doCopy(e, true);
	    };
	    
	    var onCopy = function(e) {
	        doCopy(e, false);
	    };
	    
	    var onPaste = function(e) {
	        var data = handleClipboardData(e);
	        if (typeof data == "string") {
	            if (data)
	                host.onPaste(data);
	            if (useragent.isIE)
	                setTimeout(resetSelection);
	            event.preventDefault(e);
	        }
	        else {
	            text.value = "";
	            pasted = true;
	        }
	    };

	    event.addCommandKeyListener(text, host.onCommandKey.bind(host));

	    event.addListener(text, "select", onSelect);

	    event.addListener(text, "input", onInput);

	    event.addListener(text, "cut", onCut);
	    event.addListener(text, "copy", onCopy);
	    event.addListener(text, "paste", onPaste);
	    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){
	        event.addListener(parentNode, "keydown", function(e) {
	            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
	                return;

	            switch (e.keyCode) {
	                case 67:
	                    onCopy(e);
	                    break;
	                case 86:
	                    onPaste(e);
	                    break;
	                case 88:
	                    onCut(e);
	                    break;
	            }
	        });
	    }
	    var onCompositionStart = function(e) {
	        if (inComposition || !host.onCompositionStart || host.$readOnly) 
	            return;
	        inComposition = {};
	        host.onCompositionStart();
	        setTimeout(onCompositionUpdate, 0);
	        host.on("mousedown", onCompositionEnd);
	        if (!host.selection.isEmpty()) {
	            host.insert("");
	            host.session.markUndoGroup();
	            host.selection.clearSelection();
	        }
	        host.session.markUndoGroup();
	    };

	    var onCompositionUpdate = function() {
	        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
	            return;
	        var val = text.value.replace(/\x01/g, "");
	        if (inComposition.lastValue === val) return;
	        
	        host.onCompositionUpdate(val);
	        if (inComposition.lastValue)
	            host.undo();
	        inComposition.lastValue = val;
	        if (inComposition.lastValue) {
	            var r = host.selection.getRange();
	            host.insert(inComposition.lastValue);
	            host.session.markUndoGroup();
	            inComposition.range = host.selection.getRange();
	            host.selection.setRange(r);
	            host.selection.clearSelection();
	        }
	    };

	    var onCompositionEnd = function(e) {
	        if (!host.onCompositionEnd || host.$readOnly) return;
	        var c = inComposition;
	        inComposition = false;
	        var timer = setTimeout(function() {
	            timer = null;
	            var str = text.value.replace(/\x01/g, "");
	            if (inComposition)
	                return;
	            else if (str == c.lastValue)
	                resetValue();
	            else if (!c.lastValue && str) {
	                resetValue();
	                sendText(str);
	            }
	        });
	        inputHandler = function compositionInputHandler(str) {
	            if (timer)
	                clearTimeout(timer);
	            str = str.replace(/\x01/g, "");
	            if (str == c.lastValue)
	                return "";
	            if (c.lastValue && timer)
	                host.undo();
	            return str;
	        };
	        host.onCompositionEnd();
	        host.removeListener("mousedown", onCompositionEnd);
	        if (e.type == "compositionend" && c.range) {
	            host.selection.setRange(c.range);
	        }
	    };
	    
	    

	    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);

	    event.addListener(text, "compositionstart", onCompositionStart);
	    if (useragent.isGecko) {
	        event.addListener(text, "text", function(){syncComposition.schedule()});
	    } else {
	        event.addListener(text, "keyup", function(){syncComposition.schedule()});
	        event.addListener(text, "keydown", function(){syncComposition.schedule()});
	    }
	    event.addListener(text, "compositionend", onCompositionEnd);

	    this.getElement = function() {
	        return text;
	    };

	    this.setReadOnly = function(readOnly) {
	       text.readOnly = readOnly;
	    };

	    this.onContextMenu = function(e) {
	        afterContextMenu = true;
	        resetSelection(host.selection.isEmpty());
	        host._emit("nativecontextmenu", {target: host, domEvent: e});
	        this.moveToMouse(e, true);
	    };
	    
	    this.moveToMouse = function(e, bringToFront) {
	        if (!bringToFront && useragent.isOldIE)
	            return;
	        if (!tempStyle)
	            tempStyle = text.style.cssText;
	        text.style.cssText = (bringToFront ? "z-index:100000;" : "")
	            + "height:" + text.style.height + ";"
	            + (useragent.isIE ? "opacity:0.1;" : "");

	        var rect = host.container.getBoundingClientRect();
	        var style = dom.computedStyle(host.container);
	        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
	        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
	        var maxTop = rect.bottom - top - text.clientHeight -2;
	        var move = function(e) {
	            text.style.left = e.clientX - left - 2 + "px";
	            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
	        }; 
	        move(e);

	        if (e.type != "mousedown")
	            return;

	        if (host.renderer.$keepTextAreaAtCursor)
	            host.renderer.$keepTextAreaAtCursor = null;
	        if (useragent.isWin && !useragent.isOldIE)
	            event.capture(host.container, move, onContextMenuClose);
	    };

	    this.onContextMenuClose = onContextMenuClose;
	    var closeTimeout;
	    function onContextMenuClose() {
	        clearTimeout(closeTimeout)
	        closeTimeout = setTimeout(function () {
	            if (tempStyle) {
	                text.style.cssText = tempStyle;
	                tempStyle = '';
	            }
	            if (host.renderer.$keepTextAreaAtCursor == null) {
	                host.renderer.$keepTextAreaAtCursor = true;
	                host.renderer.$moveTextAreaToCursor();
	            }
	        }, useragent.isOldIE ? 200 : 0);
	    }

	    var onContextMenu = function(e) {
	        host.textInput.onContextMenu(e);
	        onContextMenuClose();
	    };
	    event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
	    event.addListener(text, "contextmenu", onContextMenu);
	};

	exports.TextInput = TextInput;
	});

	ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");

	var DRAG_OFFSET = 0; // pixels

	function DefaultHandlers(mouseHandler) {
	    mouseHandler.$clickSelection = null;

	    var editor = mouseHandler.editor;
	    editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
	    editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
	    editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
	    editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
	    editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));

	    var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
	        "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];

	    exports.forEach(function(x) {
	        mouseHandler[x] = this[x];
	    }, this);

	    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
	    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
	}

	(function() {

	    this.onMouseDown = function(ev) {
	        var inSelection = ev.inSelection();
	        var pos = ev.getDocumentPosition();
	        this.mousedownEvent = ev;
	        var editor = this.editor;

	        var button = ev.getButton();
	        if (button !== 0) {
	            var selectionRange = editor.getSelectionRange();
	            var selectionEmpty = selectionRange.isEmpty();
	            editor.$blockScrolling++;
	            if (selectionEmpty)
	                editor.selection.moveToPosition(pos);
	            editor.$blockScrolling--;
	            editor.textInput.onContextMenu(ev.domEvent);
	            return; // stopping event here breaks contextmenu on ff mac
	        }

	        this.mousedownEvent.time = Date.now();
	        if (inSelection && !editor.isFocused()) {
	            editor.focus();
	            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
	                this.setState("focusWait");
	                this.captureMouse(ev);
	                return;
	            }
	        }

	        this.captureMouse(ev);
	        this.startSelect(pos, ev.domEvent._clicks > 1);
	        return ev.preventDefault();
	    };

	    this.startSelect = function(pos, waitForClickSelection) {
	        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var editor = this.editor;
	        editor.$blockScrolling++;
	        if (this.mousedownEvent.getShiftKey())
	            editor.selection.selectToPosition(pos);
	        else if (!waitForClickSelection)
	            editor.selection.moveToPosition(pos);
	        if (!waitForClickSelection)
	            this.select();
	        if (editor.renderer.scroller.setCapture) {
	            editor.renderer.scroller.setCapture();
	        }
	        editor.setStyle("ace_selecting");
	        this.setState("select");
	        editor.$blockScrolling--;
	    };

	    this.select = function() {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        editor.$blockScrolling++;
	        if (this.$clickSelection) {
	            var cmp = this.$clickSelection.comparePoint(cursor);

	            if (cmp == -1) {
	                anchor = this.$clickSelection.end;
	            } else if (cmp == 1) {
	                anchor = this.$clickSelection.start;
	            } else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.$blockScrolling--;
	        editor.renderer.scrollCursorIntoView();
	    };

	    this.extendSelectionBy = function(unitName) {
	        var anchor, editor = this.editor;
	        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
	        var range = editor.selection[unitName](cursor.row, cursor.column);
	        editor.$blockScrolling++;
	        if (this.$clickSelection) {
	            var cmpStart = this.$clickSelection.comparePoint(range.start);
	            var cmpEnd = this.$clickSelection.comparePoint(range.end);

	            if (cmpStart == -1 && cmpEnd <= 0) {
	                anchor = this.$clickSelection.end;
	                if (range.end.row != cursor.row || range.end.column != cursor.column)
	                    cursor = range.start;
	            } else if (cmpEnd == 1 && cmpStart >= 0) {
	                anchor = this.$clickSelection.start;
	                if (range.start.row != cursor.row || range.start.column != cursor.column)
	                    cursor = range.end;
	            } else if (cmpStart == -1 && cmpEnd == 1) {
	                cursor = range.end;
	                anchor = range.start;
	            } else {
	                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
	                cursor = orientedRange.cursor;
	                anchor = orientedRange.anchor;
	            }
	            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
	        }
	        editor.selection.selectToPosition(cursor);
	        editor.$blockScrolling--;
	        editor.renderer.scrollCursorIntoView();
	    };

	    this.selectEnd =
	    this.selectAllEnd =
	    this.selectByWordsEnd =
	    this.selectByLinesEnd = function() {
	        this.$clickSelection = null;
	        this.editor.unsetStyle("ace_selecting");
	        if (this.editor.renderer.scroller.releaseCapture) {
	            this.editor.renderer.scroller.releaseCapture();
	        }
	    };

	    this.focusWait = function() {
	        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	        var time = Date.now();

	        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
	            this.startSelect(this.mousedownEvent.getDocumentPosition());
	    };

	    this.onDoubleClick = function(ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;
	        var session = editor.session;

	        var range = session.getBracketRange(pos);
	        if (range) {
	            if (range.isEmpty()) {
	                range.start.column--;
	                range.end.column++;
	            }
	            this.setState("select");
	        } else {
	            range = editor.selection.getWordRange(pos.row, pos.column);
	            this.setState("selectByWords");
	        }
	        this.$clickSelection = range;
	        this.select();
	    };

	    this.onTripleClick = function(ev) {
	        var pos = ev.getDocumentPosition();
	        var editor = this.editor;

	        this.setState("selectByLines");
	        var range = editor.getSelectionRange();
	        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
	            this.$clickSelection = editor.selection.getLineRange(range.start.row);
	            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
	        } else {
	            this.$clickSelection = editor.selection.getLineRange(pos.row);
	        }
	        this.select();
	    };

	    this.onQuadClick = function(ev) {
	        var editor = this.editor;

	        editor.selectAll();
	        this.$clickSelection = editor.getSelectionRange();
	        this.setState("selectAll");
	    };

	    this.onMouseWheel = function(ev) {
	        if (ev.getAccelKey())
	            return;
	        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
	            ev.wheelX = ev.wheelY;
	            ev.wheelY = 0;
	        }

	        var t = ev.domEvent.timeStamp;
	        var dt = t - (this.$lastScrollTime||0);
	        
	        var editor = this.editor;
	        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	        if (isScrolable || dt < 200) {
	            this.$lastScrollTime = t;
	            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
	            return ev.stop();
	        }
	    };

	}).call(DefaultHandlers.prototype);

	exports.DefaultHandlers = DefaultHandlers;

	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}

	function calcRangeOrientation(range, cursor) {
	    if (range.start.row == range.end.row)
	        var cmp = 2 * cursor.column - range.start.column - range.end.column;
	    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
	        var cmp = cursor.column - 4;
	    else
	        var cmp = 2 * cursor.row - range.start.row - range.end.row;

	    if (cmp < 0)
	        return {cursor: range.start, anchor: range.end};
	    else
	        return {cursor: range.end, anchor: range.start};
	}

	});

	ace.define("ace/tooltip",["require","exports","module","ace/lib/oop","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	function Tooltip (parentNode) {
	    this.isOpen = false;
	    this.$element = null;
	    this.$parentNode = parentNode;
	}

	(function() {
	    this.$init = function() {
	        this.$element = dom.createElement("div");
	        this.$element.className = "ace_tooltip";
	        this.$element.style.display = "none";
	        this.$parentNode.appendChild(this.$element);
	        return this.$element;
	    };
	    this.getElement = function() {
	        return this.$element || this.$init();
	    };
	    this.setText = function(text) {
	        dom.setInnerText(this.getElement(), text);
	    };
	    this.setHtml = function(html) {
	        this.getElement().innerHTML = html;
	    };
	    this.setPosition = function(x, y) {
	        this.getElement().style.left = x + "px";
	        this.getElement().style.top = y + "px";
	    };
	    this.setClassName = function(className) {
	        dom.addCssClass(this.getElement(), className);
	    };
	    this.show = function(text, x, y) {
	        if (text != null)
	            this.setText(text);
	        if (x != null && y != null)
	            this.setPosition(x, y);
	        if (!this.isOpen) {
	            this.getElement().style.display = "block";
	            this.isOpen = true;
	        }
	    };

	    this.hide = function() {
	        if (this.isOpen) {
	            this.getElement().style.display = "none";
	            this.isOpen = false;
	        }
	    };
	    this.getHeight = function() {
	        return this.getElement().offsetHeight;
	    };
	    this.getWidth = function() {
	        return this.getElement().offsetWidth;
	    };

	}).call(Tooltip.prototype);

	exports.Tooltip = Tooltip;
	});

	ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event","ace/tooltip"], function(acequire, exports, module) {
	"use strict";
	var dom = acequire("../lib/dom");
	var oop = acequire("../lib/oop");
	var event = acequire("../lib/event");
	var Tooltip = acequire("../tooltip").Tooltip;

	function GutterHandler(mouseHandler) {
	    var editor = mouseHandler.editor;
	    var gutter = editor.renderer.$gutterLayer;
	    var tooltip = new GutterTooltip(editor.container);

	    mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
	        if (!editor.isFocused() || e.getButton() != 0)
	            return;
	        var gutterRegion = gutter.getRegion(e);

	        if (gutterRegion == "foldWidgets")
	            return;

	        var row = e.getDocumentPosition().row;
	        var selection = editor.session.selection;

	        if (e.getShiftKey())
	            selection.selectTo(row, 0);
	        else {
	            if (e.domEvent.detail == 2) {
	                editor.selectAll();
	                return e.preventDefault();
	            }
	            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
	        }
	        mouseHandler.setState("selectByLines");
	        mouseHandler.captureMouse(e);
	        return e.preventDefault();
	    });


	    var tooltipTimeout, mouseEvent, tooltipAnnotation;

	    function showTooltip() {
	        var row = mouseEvent.getDocumentPosition().row;
	        var annotation = gutter.$annotations[row];
	        if (!annotation)
	            return hideTooltip();

	        var maxRow = editor.session.getLength();
	        if (row == maxRow) {
	            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
	            var pos = mouseEvent.$pos;
	            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
	                return hideTooltip();
	        }

	        if (tooltipAnnotation == annotation)
	            return;
	        tooltipAnnotation = annotation.text.join("<br/>");

	        tooltip.setHtml(tooltipAnnotation);
	        tooltip.show();
	        editor.on("mousewheel", hideTooltip);

	        if (mouseHandler.$tooltipFollowsMouse) {
	            moveTooltip(mouseEvent);
	        } else {
	            var gutterElement = gutter.$cells[editor.session.documentToScreenRow(row, 0)].element;
	            var rect = gutterElement.getBoundingClientRect();
	            var style = tooltip.getElement().style;
	            style.left = rect.right + "px";
	            style.top = rect.bottom + "px";
	        }
	    }

	    function hideTooltip() {
	        if (tooltipTimeout)
	            tooltipTimeout = clearTimeout(tooltipTimeout);
	        if (tooltipAnnotation) {
	            tooltip.hide();
	            tooltipAnnotation = null;
	            editor.removeEventListener("mousewheel", hideTooltip);
	        }
	    }

	    function moveTooltip(e) {
	        tooltip.setPosition(e.x, e.y);
	    }

	    mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
	        var target = e.domEvent.target || e.domEvent.srcElement;
	        if (dom.hasCssClass(target, "ace_fold-widget"))
	            return hideTooltip();

	        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
	            moveTooltip(e);

	        mouseEvent = e;
	        if (tooltipTimeout)
	            return;
	        tooltipTimeout = setTimeout(function() {
	            tooltipTimeout = null;
	            if (mouseEvent && !mouseHandler.isMousePressed)
	                showTooltip();
	            else
	                hideTooltip();
	        }, 50);
	    });

	    event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
	        mouseEvent = null;
	        if (!tooltipAnnotation || tooltipTimeout)
	            return;

	        tooltipTimeout = setTimeout(function() {
	            tooltipTimeout = null;
	            hideTooltip();
	        }, 50);
	    });
	    
	    editor.on("changeSession", hideTooltip);
	}

	function GutterTooltip(parentNode) {
	    Tooltip.call(this, parentNode);
	}

	oop.inherits(GutterTooltip, Tooltip);

	(function(){
	    this.setPosition = function(x, y) {
	        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
	        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
	        var width = this.getWidth();
	        var height = this.getHeight();
	        x += 15;
	        y += 15;
	        if (x + width > windowWidth) {
	            x -= (x + width) - windowWidth;
	        }
	        if (y + height > windowHeight) {
	            y -= 20 + height;
	        }
	        Tooltip.prototype.setPosition.call(this, x, y);
	    };

	}).call(GutterTooltip.prototype);



	exports.GutterHandler = GutterHandler;

	});

	ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
	    this.domEvent = domEvent;
	    this.editor = editor;
	    
	    this.x = this.clientX = domEvent.clientX;
	    this.y = this.clientY = domEvent.clientY;

	    this.$pos = null;
	    this.$inSelection = null;
	    
	    this.propagationStopped = false;
	    this.defaultPrevented = false;
	};

	(function() {  
	    
	    this.stopPropagation = function() {
	        event.stopPropagation(this.domEvent);
	        this.propagationStopped = true;
	    };
	    
	    this.preventDefault = function() {
	        event.preventDefault(this.domEvent);
	        this.defaultPrevented = true;
	    };
	    
	    this.stop = function() {
	        this.stopPropagation();
	        this.preventDefault();
	    };
	    this.getDocumentPosition = function() {
	        if (this.$pos)
	            return this.$pos;
	        
	        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
	        return this.$pos;
	    };
	    this.inSelection = function() {
	        if (this.$inSelection !== null)
	            return this.$inSelection;
	            
	        var editor = this.editor;
	        

	        var selectionRange = editor.getSelectionRange();
	        if (selectionRange.isEmpty())
	            this.$inSelection = false;
	        else {
	            var pos = this.getDocumentPosition();
	            this.$inSelection = selectionRange.contains(pos.row, pos.column);
	        }

	        return this.$inSelection;
	    };
	    this.getButton = function() {
	        return event.getButton(this.domEvent);
	    };
	    this.getShiftKey = function() {
	        return this.domEvent.shiftKey;
	    };
	    
	    this.getAccelKey = useragent.isMac
	        ? function() { return this.domEvent.metaKey; }
	        : function() { return this.domEvent.ctrlKey; };
	    
	}).call(MouseEvent.prototype);

	});

	ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");

	var AUTOSCROLL_DELAY = 200;
	var SCROLL_CURSOR_DELAY = 200;
	var SCROLL_CURSOR_HYSTERESIS = 5;

	function DragdropHandler(mouseHandler) {

	    var editor = mouseHandler.editor;

	    var blankImage = dom.createElement("img");
	    blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	    if (useragent.isOpera)
	        blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";

	    var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];

	     exports.forEach(function(x) {
	         mouseHandler[x] = this[x];
	    }, this);
	    editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));


	    var mouseTarget = editor.container;
	    var dragSelectionMarker, x, y;
	    var timerId, range;
	    var dragCursor, counter = 0;
	    var dragOperation;
	    var isInternal;
	    var autoScrollStartTime;
	    var cursorMovedTime;
	    var cursorPointOnCaretMoved;

	    this.onDragStart = function(e) {
	        if (this.cancelDrag || !mouseTarget.draggable) {
	            var self = this;
	            setTimeout(function(){
	                self.startSelect();
	                self.captureMouse(e);
	            }, 0);
	            return e.preventDefault();
	        }
	        range = editor.getSelectionRange();

	        var dataTransfer = e.dataTransfer;
	        dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
	        if (useragent.isOpera) {
	            editor.container.appendChild(blankImage);
	            blankImage.scrollTop = 0;
	        }
	        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
	        if (useragent.isOpera) {
	            editor.container.removeChild(blankImage);
	        }
	        dataTransfer.clearData();
	        dataTransfer.setData("Text", editor.session.getTextRange());

	        isInternal = true;
	        this.setState("drag");
	    };

	    this.onDragEnd = function(e) {
	        mouseTarget.draggable = false;
	        isInternal = false;
	        this.setState(null);
	        if (!editor.getReadOnly()) {
	            var dropEffect = e.dataTransfer.dropEffect;
	            if (!dragOperation && dropEffect == "move")
	                editor.session.remove(editor.getSelectionRange());
	            editor.renderer.$cursorLayer.setBlinking(true);
	        }
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	    };

	    this.onDragEnter = function(e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker)
	            addDragMarker();
	        counter++;
	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };

	    this.onDragOver = function(e) {
	        if (editor.getReadOnly() || !canAccept(e.dataTransfer))
	            return;
	        x = e.clientX;
	        y = e.clientY;
	        if (!dragSelectionMarker) {
	            addDragMarker();
	            counter++;
	        }
	        if (onMouseMoveTimer !== null)
	            onMouseMoveTimer = null;

	        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
	        return event.preventDefault(e);
	    };

	    this.onDragLeave = function(e) {
	        counter--;
	        if (counter <= 0 && dragSelectionMarker) {
	            clearDragMarker();
	            dragOperation = null;
	            return event.preventDefault(e);
	        }
	    };

	    this.onDrop = function(e) {
	        if (!dragCursor)
	            return;
	        var dataTransfer = e.dataTransfer;
	        if (isInternal) {
	            switch (dragOperation) {
	                case "move":
	                    if (range.contains(dragCursor.row, dragCursor.column)) {
	                        range = {
	                            start: dragCursor,
	                            end: dragCursor
	                        };
	                    } else {
	                        range = editor.moveText(range, dragCursor);
	                    }
	                    break;
	                case "copy":
	                    range = editor.moveText(range, dragCursor, true);
	                    break;
	            }
	        } else {
	            var dropData = dataTransfer.getData('Text');
	            range = {
	                start: dragCursor,
	                end: editor.session.insert(dragCursor, dropData)
	            };
	            editor.focus();
	            dragOperation = null;
	        }
	        clearDragMarker();
	        return event.preventDefault(e);
	    };

	    event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
	    event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
	    event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));

	    function scrollCursorIntoView(cursor, prevCursor) {
	        var now = Date.now();
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        var hMovement = !prevCursor || cursor.column != prevCursor.column;
	        if (!cursorMovedTime || vMovement || hMovement) {
	            editor.$blockScrolling += 1;
	            editor.moveCursorToPosition(cursor);
	            editor.$blockScrolling -= 1;
	            cursorMovedTime = now;
	            cursorPointOnCaretMoved = {x: x, y: y};
	        } else {
	            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
	            if (distance > SCROLL_CURSOR_HYSTERESIS) {
	                cursorMovedTime = null;
	            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
	                editor.renderer.scrollCursorIntoView();
	                cursorMovedTime = null;
	            }
	        }
	    }

	    function autoScroll(cursor, prevCursor) {
	        var now = Date.now();
	        var lineHeight = editor.renderer.layerConfig.lineHeight;
	        var characterWidth = editor.renderer.layerConfig.characterWidth;
	        var editorRect = editor.renderer.scroller.getBoundingClientRect();
	        var offsets = {
	           x: {
	               left: x - editorRect.left,
	               right: editorRect.right - x
	           },
	           y: {
	               top: y - editorRect.top,
	               bottom: editorRect.bottom - y
	           }
	        };
	        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
	        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
	        var scrollCursor = {row: cursor.row, column: cursor.column};
	        if (nearestXOffset / characterWidth <= 2) {
	            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
	        }
	        if (nearestYOffset / lineHeight <= 1) {
	            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
	        }
	        var vScroll = cursor.row != scrollCursor.row;
	        var hScroll = cursor.column != scrollCursor.column;
	        var vMovement = !prevCursor || cursor.row != prevCursor.row;
	        if (vScroll || (hScroll && !vMovement)) {
	            if (!autoScrollStartTime)
	                autoScrollStartTime = now;
	            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
	                editor.renderer.scrollCursorIntoView(scrollCursor);
	        } else {
	            autoScrollStartTime = null;
	        }
	    }

	    function onDragInterval() {
	        var prevCursor = dragCursor;
	        dragCursor = editor.renderer.screenToTextCoordinates(x, y);
	        scrollCursorIntoView(dragCursor, prevCursor);
	        autoScroll(dragCursor, prevCursor);
	    }

	    function addDragMarker() {
	        range = editor.selection.toOrientedRange();
	        dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
	        editor.clearSelection();
	        if (editor.isFocused())
	            editor.renderer.$cursorLayer.setBlinking(false);
	        clearInterval(timerId);
	        onDragInterval();
	        timerId = setInterval(onDragInterval, 20);
	        counter = 0;
	        event.addListener(document, "mousemove", onMouseMove);
	    }

	    function clearDragMarker() {
	        clearInterval(timerId);
	        editor.session.removeMarker(dragSelectionMarker);
	        dragSelectionMarker = null;
	        editor.$blockScrolling += 1;
	        editor.selection.fromOrientedRange(range);
	        editor.$blockScrolling -= 1;
	        if (editor.isFocused() && !isInternal)
	            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
	        range = null;
	        dragCursor = null;
	        counter = 0;
	        autoScrollStartTime = null;
	        cursorMovedTime = null;
	        event.removeListener(document, "mousemove", onMouseMove);
	    }
	    var onMouseMoveTimer = null;
	    function onMouseMove() {
	        if (onMouseMoveTimer == null) {
	            onMouseMoveTimer = setTimeout(function() {
	                if (onMouseMoveTimer != null && dragSelectionMarker)
	                    clearDragMarker();
	            }, 20);
	        }
	    }

	    function canAccept(dataTransfer) {
	        var types = dataTransfer.types;
	        return !types || Array.prototype.some.call(types, function(type) {
	            return type == 'text/plain' || type == 'Text';
	        });
	    }

	    function getDropEffect(e) {
	        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
	        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];

	        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
	        var effectAllowed = "uninitialized";
	        try {
	            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
	        } catch (e) {}
	        var dropEffect = "none";

	        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";
	        else if (moveAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "move";
	        else if (copyAllowed.indexOf(effectAllowed) >= 0)
	            dropEffect = "copy";

	        return dropEffect;
	    }
	}

	(function() {

	    this.dragWait = function() {
	        var interval = Date.now() - this.mousedownEvent.time;
	        if (interval > this.editor.getDragDelay())
	            this.startDrag();
	    };

	    this.dragWaitEnd = function() {
	        var target = this.editor.container;
	        target.draggable = false;
	        this.startSelect(this.mousedownEvent.getDocumentPosition());
	        this.selectEnd();
	    };

	    this.dragReadyEnd = function(e) {
	        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
	        this.editor.unsetStyle("ace_dragging");
	        this.editor.renderer.setCursorStyle("");
	        this.dragWaitEnd();
	    };

	    this.startDrag = function(){
	        this.cancelDrag = false;
	        var editor = this.editor;
	        var target = editor.container;
	        target.draggable = true;
	        editor.renderer.$cursorLayer.setBlinking(false);
	        editor.setStyle("ace_dragging");
	        var cursorStyle = useragent.isWin ? "default" : "move";
	        editor.renderer.setCursorStyle(cursorStyle);
	        this.setState("dragReady");
	    };

	    this.onMouseDrag = function(e) {
	        var target = this.editor.container;
	        if (useragent.isIE && this.state == "dragReady") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 3)
	                target.dragDrop();
	        }
	        if (this.state === "dragWait") {
	            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
	            if (distance > 0) {
	                target.draggable = false;
	                this.startSelect(this.mousedownEvent.getDocumentPosition());
	            }
	        }
	    };

	    this.onMouseDown = function(e) {
	        if (!this.$dragEnabled)
	            return;
	        this.mousedownEvent = e;
	        var editor = this.editor;

	        var inSelection = e.inSelection();
	        var button = e.getButton();
	        var clickCount = e.domEvent.detail || 1;
	        if (clickCount === 1 && button === 0 && inSelection) {
	            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
	                return;
	            this.mousedownEvent.time = Date.now();
	            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
	            if ("unselectable" in eventTarget)
	                eventTarget.unselectable = "on";
	            if (editor.getDragDelay()) {
	                if (useragent.isWebKit) {
	                    this.cancelDrag = true;
	                    var mouseTarget = editor.container;
	                    mouseTarget.draggable = true;
	                }
	                this.setState("dragWait");
	            } else {
	                this.startDrag();
	            }
	            this.captureMouse(e, this.onMouseDrag.bind(this));
	            e.defaultPrevented = true;
	        }
	    };

	}).call(DragdropHandler.prototype);


	function calcDistance(ax, ay, bx, by) {
	    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
	}

	exports.DragdropHandler = DragdropHandler;

	});

	ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";
	var dom = acequire("./dom");

	exports.get = function (url, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.onreadystatechange = function () {
	        if (xhr.readyState === 4) {
	            callback(xhr.responseText);
	        }
	    };
	    xhr.send(null);
	};

	exports.loadScript = function(path, callback) {
	    var head = dom.getDocumentHead();
	    var s = document.createElement('script');

	    s.src = path;
	    head.appendChild(s);

	    s.onload = s.onreadystatechange = function(_, isAbort) {
	        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
	            s = s.onload = s.onreadystatechange = null;
	            if (!isAbort)
	                callback();
	        }
	    };
	};
	exports.qualifyURL = function(url) {
	    var a = document.createElement('a');
	    a.href = url;
	    return a.href;
	}

	});

	ace.define("ace/lib/event_emitter",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var EventEmitter = {};
	var stopPropagation = function() { this.propagationStopped = true; };
	var preventDefault = function() { this.defaultPrevented = true; };

	EventEmitter._emit =
	EventEmitter._dispatchEvent = function(eventName, e) {
	    this._eventRegistry || (this._eventRegistry = {});
	    this._defaultHandlers || (this._defaultHandlers = {});

	    var listeners = this._eventRegistry[eventName] || [];
	    var defaultHandler = this._defaultHandlers[eventName];
	    if (!listeners.length && !defaultHandler)
	        return;

	    if (typeof e != "object" || !e)
	        e = {};

	    if (!e.type)
	        e.type = eventName;
	    if (!e.stopPropagation)
	        e.stopPropagation = stopPropagation;
	    if (!e.preventDefault)
	        e.preventDefault = preventDefault;

	    listeners = listeners.slice();
	    for (var i=0; i<listeners.length; i++) {
	        listeners[i](e, this);
	        if (e.propagationStopped)
	            break;
	    }
	    
	    if (defaultHandler && !e.defaultPrevented)
	        return defaultHandler(e, this);
	};


	EventEmitter._signal = function(eventName, e) {
	    var listeners = (this._eventRegistry || {})[eventName];
	    if (!listeners)
	        return;
	    listeners = listeners.slice();
	    for (var i=0; i<listeners.length; i++)
	        listeners[i](e, this);
	};

	EventEmitter.once = function(eventName, callback) {
	    var _self = this;
	    callback && this.addEventListener(eventName, function newCallback() {
	        _self.removeEventListener(eventName, newCallback);
	        callback.apply(null, arguments);
	    });
	};


	EventEmitter.setDefaultHandler = function(eventName, callback) {
	    var handlers = this._defaultHandlers
	    if (!handlers)
	        handlers = this._defaultHandlers = {_disabled_: {}};
	    
	    if (handlers[eventName]) {
	        var old = handlers[eventName];
	        var disabled = handlers._disabled_[eventName];
	        if (!disabled)
	            handlers._disabled_[eventName] = disabled = [];
	        disabled.push(old);
	        var i = disabled.indexOf(callback);
	        if (i != -1) 
	            disabled.splice(i, 1);
	    }
	    handlers[eventName] = callback;
	};
	EventEmitter.removeDefaultHandler = function(eventName, callback) {
	    var handlers = this._defaultHandlers
	    if (!handlers)
	        return;
	    var disabled = handlers._disabled_[eventName];
	    
	    if (handlers[eventName] == callback) {
	        var old = handlers[eventName];
	        if (disabled)
	            this.setDefaultHandler(eventName, disabled.pop());
	    } else if (disabled) {
	        var i = disabled.indexOf(callback);
	        if (i != -1)
	            disabled.splice(i, 1);
	    }
	};

	EventEmitter.on =
	EventEmitter.addEventListener = function(eventName, callback, capturing) {
	    this._eventRegistry = this._eventRegistry || {};

	    var listeners = this._eventRegistry[eventName];
	    if (!listeners)
	        listeners = this._eventRegistry[eventName] = [];

	    if (listeners.indexOf(callback) == -1)
	        listeners[capturing ? "unshift" : "push"](callback);
	    return callback;
	};

	EventEmitter.off =
	EventEmitter.removeListener =
	EventEmitter.removeEventListener = function(eventName, callback) {
	    this._eventRegistry = this._eventRegistry || {};

	    var listeners = this._eventRegistry[eventName];
	    if (!listeners)
	        return;

	    var index = listeners.indexOf(callback);
	    if (index !== -1)
	        listeners.splice(index, 1);
	};

	EventEmitter.removeAllListeners = function(eventName) {
	    if (this._eventRegistry) this._eventRegistry[eventName] = [];
	};

	exports.EventEmitter = EventEmitter;

	});

	ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"no use strict";

	var oop = acequire("./oop");
	var EventEmitter = acequire("./event_emitter").EventEmitter;

	var optionsProvider = {
	    setOptions: function(optList) {
	        Object.keys(optList).forEach(function(key) {
	            this.setOption(key, optList[key]);
	        }, this);
	    },
	    getOptions: function(optionNames) {
	        var result = {};
	        if (!optionNames) {
	            optionNames = Object.keys(this.$options);
	        } else if (!Array.isArray(optionNames)) {
	            result = optionNames;
	            optionNames = Object.keys(result);
	        }
	        optionNames.forEach(function(key) {
	            result[key] = this.getOption(key);
	        }, this);
	        return result;
	    },
	    setOption: function(name, value) {
	        if (this["$" + name] === value)
	            return;
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);

	        if (!opt.handlesSet)
	            this["$" + name] = value;
	        if (opt && opt.set)
	            opt.set.call(this, value);
	    },
	    getOption: function(name) {
	        var opt = this.$options[name];
	        if (!opt) {
	            return warn('misspelled option "' + name + '"');
	        }
	        if (opt.forwardTo)
	            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
	        return opt && opt.get ? opt.get.call(this) : this["$" + name];
	    }
	};

	function warn(message) {
	    if (typeof console != "undefined" && console.warn)
	        console.warn.apply(console, arguments);
	}

	function reportError(msg, data) {
	    var e = new Error(msg);
	    e.data = data;
	    if (typeof console == "object" && console.error)
	        console.error(e);
	    setTimeout(function() { throw e; });
	}

	var AppConfig = function() {
	    this.$defaultOptions = {};
	};

	(function() {
	    oop.implement(this, EventEmitter);
	    this.defineOptions = function(obj, path, options) {
	        if (!obj.$options)
	            this.$defaultOptions[path] = obj.$options = {};

	        Object.keys(options).forEach(function(key) {
	            var opt = options[key];
	            if (typeof opt == "string")
	                opt = {forwardTo: opt};

	            opt.name || (opt.name = key);
	            obj.$options[opt.name] = opt;
	            if ("initialValue" in opt)
	                obj["$" + opt.name] = opt.initialValue;
	        });
	        oop.implement(obj, optionsProvider);

	        return this;
	    };

	    this.resetOptions = function(obj) {
	        Object.keys(obj.$options).forEach(function(key) {
	            var opt = obj.$options[key];
	            if ("value" in opt)
	                obj.setOption(key, opt.value);
	        });
	    };

	    this.setDefaultValue = function(path, name, value) {
	        var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
	        if (opts[name]) {
	            if (opts.forwardTo)
	                this.setDefaultValue(opts.forwardTo, name, value);
	            else
	                opts[name].value = value;
	        }
	    };

	    this.setDefaultValues = function(path, optionHash) {
	        Object.keys(optionHash).forEach(function(key) {
	            this.setDefaultValue(path, key, optionHash[key]);
	        }, this);
	    };

	    this.warn = warn;
	    this.reportError = reportError;

	}).call(AppConfig.prototype);

	exports.AppConfig = AppConfig;

	});

	ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/lib/net","ace/lib/app_config"], function(acequire, exports, module) {
	"no use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var net = acequire("./lib/net");
	var AppConfig = acequire("./lib/app_config").AppConfig;

	module.exports = exports = new AppConfig();

	var global = (function() {
	    return this;
	})();

	var options = {
	    packaged: false,
	    workerPath: null,
	    modePath: null,
	    themePath: null,
	    basePath: "",
	    suffix: ".js",
	    $moduleUrls: {}
	};

	exports.get = function(key) {
	    if (!options.hasOwnProperty(key))
	        throw new Error("Unknown config key: " + key);

	    return options[key];
	};

	exports.set = function(key, value) {
	    if (!options.hasOwnProperty(key))
	        throw new Error("Unknown config key: " + key);

	    options[key] = value;
	};

	exports.all = function() {
	    return lang.copyObject(options);
	};
	exports.moduleUrl = function(name, component) {
	    if (options.$moduleUrls[name])
	        return options.$moduleUrls[name];

	    var parts = name.split("/");
	    component = component || parts[parts.length - 2] || "";
	    var sep = component == "snippets" ? "/" : "-";
	    var base = parts[parts.length - 1];
	    if (component == "worker" && sep == "-") {
	        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
	        base = base.replace(re, "");
	    }

	    if ((!base || base == component) && parts.length > 1)
	        base = parts[parts.length - 2];
	    var path = options[component + "Path"];
	    if (path == null) {
	        path = options.basePath;
	    } else if (sep == "/") {
	        component = sep = "";
	    }
	    if (path && path.slice(-1) != "/")
	        path += "/";
	    return path + component + sep + base + this.get("suffix");
	};

	exports.setModuleUrl = function(name, subst) {
	    return options.$moduleUrls[name] = subst;
	};

	exports.$loading = {};
	exports.loadModule = function(moduleName, onLoad) {
	    var module, moduleType;
	    if (Array.isArray(moduleName)) {
	        moduleType = moduleName[0];
	        moduleName = moduleName[1];
	    }

	    try {
	        module = acequire(moduleName);
	    } catch (e) {}
	    if (module && !exports.$loading[moduleName])
	        return onLoad && onLoad(module);

	    if (!exports.$loading[moduleName])
	        exports.$loading[moduleName] = [];

	    exports.$loading[moduleName].push(onLoad);

	    if (exports.$loading[moduleName].length > 1)
	        return;

	    var afterLoad = function() {
	        acequire([moduleName], function(module) {
	            exports._emit("load.module", {name: moduleName, module: module});
	            var listeners = exports.$loading[moduleName];
	            exports.$loading[moduleName] = null;
	            listeners.forEach(function(onLoad) {
	                onLoad && onLoad(module);
	            });
	        });
	    };

	    if (!exports.get("packaged"))
	        return afterLoad();
	    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
	};
	init(true);function init(packaged) {

	    options.packaged = packaged || acequire.packaged || module.packaged || (global.define && __webpack_require__(461).packaged);

	    if (!global.document)
	        return "";

	    var scriptOptions = {};
	    var scriptUrl = "";
	    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill
	    var currentDocument = currentScript && currentScript.ownerDocument || document;
	    
	    var scripts = currentDocument.getElementsByTagName("script");
	    for (var i=0; i<scripts.length; i++) {
	        var script = scripts[i];

	        var src = script.src || script.getAttribute("src");
	        if (!src)
	            continue;

	        var attributes = script.attributes;
	        for (var j=0, l=attributes.length; j < l; j++) {
	            var attr = attributes[j];
	            if (attr.name.indexOf("data-ace-") === 0) {
	                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
	            }
	        }

	        var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
	        if (m)
	            scriptUrl = m[1];
	    }

	    if (scriptUrl) {
	        scriptOptions.base = scriptOptions.base || scriptUrl;
	        scriptOptions.packaged = true;
	    }

	    scriptOptions.basePath = scriptOptions.base;
	    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
	    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
	    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
	    delete scriptOptions.base;

	    for (var key in scriptOptions)
	        if (typeof scriptOptions[key] !== "undefined")
	            exports.set(key, scriptOptions[key]);
	};

	exports.init = init;

	function deHyphenate(str) {
	    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });
	}

	});

	ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/config"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
	var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
	var MouseEvent = acequire("./mouse_event").MouseEvent;
	var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
	var config = acequire("../config");

	var MouseHandler = function(editor) {
	    var _self = this;
	    this.editor = editor;

	    new DefaultHandlers(this);
	    new DefaultGutterHandler(this);
	    new DragdropHandler(this);

	    var focusEditor = function(e) {
	        if (!document.hasFocus || !document.hasFocus())
	            window.focus();
	        editor.focus();
	    };

	    var mouseTarget = editor.renderer.getMouseEventTarget();
	    event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
	    event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
	    event.addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, "onMouseEvent");
	    if (editor.renderer.scrollBarV) {
	        event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, "onMouseEvent");
	        event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, "onMouseEvent");
	        if (useragent.isIE) {
	            event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
	            event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
	        }
	    }
	    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));

	    var gutterEl = editor.renderer.$gutter;
	    event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
	    event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
	    event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
	    event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));

	    event.addListener(mouseTarget, "mousedown", focusEditor);

	    event.addListener(gutterEl, "mousedown", function(e) {
	        editor.focus();
	        return event.preventDefault(e);
	    });

	    editor.on("mousemove", function(e){
	        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
	            return;

	        var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
	        var range = editor.session.selection.getRange();
	        var renderer = editor.renderer;

	        if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
	            renderer.setCursorStyle("default");
	        } else {
	            renderer.setCursorStyle("");
	        }
	    });
	};

	(function() {
	    this.onMouseEvent = function(name, e) {
	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };

	    this.onMouseMove = function(name, e) {
	        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
	        if (!listeners || !listeners.length)
	            return;

	        this.editor._emit(name, new MouseEvent(e, this.editor));
	    };

	    this.onMouseWheel = function(name, e) {
	        var mouseEvent = new MouseEvent(e, this.editor);
	        mouseEvent.speed = this.$scrollSpeed * 2;
	        mouseEvent.wheelX = e.wheelX;
	        mouseEvent.wheelY = e.wheelY;

	        this.editor._emit(name, mouseEvent);
	    };

	    this.setState = function(state) {
	        this.state = state;
	    };

	    this.captureMouse = function(ev, mouseMoveHandler) {
	        this.x = ev.x;
	        this.y = ev.y;

	        this.isMousePressed = true;
	        var renderer = this.editor.renderer;
	        if (renderer.$keepTextAreaAtCursor)
	            renderer.$keepTextAreaAtCursor = null;

	        var self = this;
	        var onMouseMove = function(e) {
	            if (!e) return;
	            if (useragent.isWebKit && !e.which && self.releaseMouse)
	                return self.releaseMouse();

	            self.x = e.clientX;
	            self.y = e.clientY;
	            mouseMoveHandler && mouseMoveHandler(e);
	            self.mouseEvent = new MouseEvent(e, self.editor);
	            self.$mouseMoved = true;
	        };

	        var onCaptureEnd = function(e) {
	            clearInterval(timerId);
	            onCaptureInterval();
	            self[self.state + "End"] && self[self.state + "End"](e);
	            self.state = "";
	            if (renderer.$keepTextAreaAtCursor == null) {
	                renderer.$keepTextAreaAtCursor = true;
	                renderer.$moveTextAreaToCursor();
	            }
	            self.isMousePressed = false;
	            self.$onCaptureMouseMove = self.releaseMouse = null;
	            e && self.onMouseEvent("mouseup", e);
	        };

	        var onCaptureInterval = function() {
	            self[self.state] && self[self.state]();
	            self.$mouseMoved = false;
	        };

	        if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
	            return setTimeout(function() {onCaptureEnd(ev);});
	        }

	        self.$onCaptureMouseMove = onMouseMove;
	        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
	        var timerId = setInterval(onCaptureInterval, 20);
	    };
	    this.releaseMouse = null;
	    this.cancelContextMenu = function() {
	        var stop = function(e) {
	            if (e && e.domEvent && e.domEvent.type != "contextmenu")
	                return;
	            this.editor.off("nativecontextmenu", stop);
	            if (e && e.domEvent)
	                event.stopEvent(e.domEvent);
	        }.bind(this);
	        setTimeout(stop, 10);
	        this.editor.on("nativecontextmenu", stop);
	    };
	}).call(MouseHandler.prototype);

	config.defineOptions(MouseHandler.prototype, "mouseHandler", {
	    scrollSpeed: {initialValue: 2},
	    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
	    dragEnabled: {initialValue: true},
	    focusTimout: {initialValue: 0},
	    tooltipFollowsMouse: {initialValue: true}
	});


	exports.MouseHandler = MouseHandler;
	});

	ace.define("ace/mouse/fold_handler",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	function FoldHandler(editor) {

	    editor.on("click", function(e) {
	        var position = e.getDocumentPosition();
	        var session = editor.session;
	        var fold = session.getFoldAt(position.row, position.column, 1);
	        if (fold) {
	            if (e.getAccelKey())
	                session.removeFold(fold);
	            else
	                session.expandFold(fold);

	            e.stop();
	        }
	    });

	    editor.on("gutterclick", function(e) {
	        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

	        if (gutterRegion == "foldWidgets") {
	            var row = e.getDocumentPosition().row;
	            var session = editor.session;
	            if (session.foldWidgets && session.foldWidgets[row])
	                editor.session.onFoldWidgetClick(row, e);
	            if (!editor.isFocused())
	                editor.focus();
	            e.stop();
	        }
	    });

	    editor.on("gutterdblclick", function(e) {
	        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

	        if (gutterRegion == "foldWidgets") {
	            var row = e.getDocumentPosition().row;
	            var session = editor.session;
	            var data = session.getParentFoldRangeData(row, true);
	            var range = data.range || data.firstRange;

	            if (range) {
	                row = range.start.row;
	                var fold = session.getFoldAt(row, session.getLine(row).length, 1);

	                if (fold) {
	                    session.removeFold(fold);
	                } else {
	                    session.addFold("...", range);
	                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});
	                }
	            }
	            e.stop();
	        }
	    });
	}

	exports.FoldHandler = FoldHandler;

	});

	ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"], function(acequire, exports, module) {
	"use strict";

	var keyUtil  = acequire("../lib/keys");
	var event = acequire("../lib/event");

	var KeyBinding = function(editor) {
	    this.$editor = editor;
	    this.$data = {editor: editor};
	    this.$handlers = [];
	    this.setDefaultHandler(editor.commands);
	};

	(function() {
	    this.setDefaultHandler = function(kb) {
	        this.removeKeyboardHandler(this.$defaultHandler);
	        this.$defaultHandler = kb;
	        this.addKeyboardHandler(kb, 0);
	    };

	    this.setKeyboardHandler = function(kb) {
	        var h = this.$handlers;
	        if (h[h.length - 1] == kb)
	            return;

	        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
	            this.removeKeyboardHandler(h[h.length - 1]);

	        this.addKeyboardHandler(kb, 1);
	    };

	    this.addKeyboardHandler = function(kb, pos) {
	        if (!kb)
	            return;
	        if (typeof kb == "function" && !kb.handleKeyboard)
	            kb.handleKeyboard = kb;
	        var i = this.$handlers.indexOf(kb);
	        if (i != -1)
	            this.$handlers.splice(i, 1);

	        if (pos == undefined)
	            this.$handlers.push(kb);
	        else
	            this.$handlers.splice(pos, 0, kb);

	        if (i == -1 && kb.attach)
	            kb.attach(this.$editor);
	    };

	    this.removeKeyboardHandler = function(kb) {
	        var i = this.$handlers.indexOf(kb);
	        if (i == -1)
	            return false;
	        this.$handlers.splice(i, 1);
	        kb.detach && kb.detach(this.$editor);
	        return true;
	    };

	    this.getKeyboardHandler = function() {
	        return this.$handlers[this.$handlers.length - 1];
	    };

	    this.getStatusText = function() {
	        var data = this.$data;
	        var editor = data.editor;
	        return this.$handlers.map(function(h) {
	            return h.getStatusText && h.getStatusText(editor, data) || "";
	        }).filter(Boolean).join(" ");
	    };

	    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
	        var toExecute;
	        var success = false;
	        var commands = this.$editor.commands;

	        for (var i = this.$handlers.length; i--;) {
	            toExecute = this.$handlers[i].handleKeyboard(
	                this.$data, hashId, keyString, keyCode, e
	            );
	            if (!toExecute || !toExecute.command)
	                continue;
	            if (toExecute.command == "null") {
	                success = true;
	            } else {
	                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);                
	            }
	            if (success && e && hashId != -1 && 
	                toExecute.passEvent != true && toExecute.command.passEvent != true
	            ) {
	                event.stopEvent(e);
	            }
	            if (success)
	                break;
	        }
	        return success;
	    };

	    this.onCommandKey = function(e, hashId, keyCode) {
	        var keyString = keyUtil.keyCodeToString(keyCode);
	        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
	    };

	    this.onTextInput = function(text) {
	        var success = this.$callKeyboardHandlers(-1, text);
	        if (!success)
	            this.$editor.commands.exec("insertstring", this.$editor, text);
	    };

	}).call(KeyBinding.prototype);

	exports.KeyBinding = KeyBinding;
	});

	ace.define("ace/range",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var comparePoints = function(p1, p2) {
	    return p1.row - p2.row || p1.column - p2.column;
	};
	var Range = function(startRow, startColumn, endRow, endColumn) {
	    this.start = {
	        row: startRow,
	        column: startColumn
	    };

	    this.end = {
	        row: endRow,
	        column: endColumn
	    };
	};

	(function() {
	    this.isEqual = function(range) {
	        return this.start.row === range.start.row &&
	            this.end.row === range.end.row &&
	            this.start.column === range.start.column &&
	            this.end.column === range.end.column;
	    };
	    this.toString = function() {
	        return ("Range: [" + this.start.row + "/" + this.start.column +
	            "] -> [" + this.end.row + "/" + this.end.column + "]");
	    };

	    this.contains = function(row, column) {
	        return this.compare(row, column) == 0;
	    };
	    this.compareRange = function(range) {
	        var cmp,
	            end = range.end,
	            start = range.start;

	        cmp = this.compare(end.row, end.column);
	        if (cmp == 1) {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == 1) {
	                return 2;
	            } else if (cmp == 0) {
	                return 1;
	            } else {
	                return 0;
	            }
	        } else if (cmp == -1) {
	            return -2;
	        } else {
	            cmp = this.compare(start.row, start.column);
	            if (cmp == -1) {
	                return -1;
	            } else if (cmp == 1) {
	                return 42;
	            } else {
	                return 0;
	            }
	        }
	    };
	    this.comparePoint = function(p) {
	        return this.compare(p.row, p.column);
	    };
	    this.containsRange = function(range) {
	        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
	    };
	    this.intersects = function(range) {
	        var cmp = this.compareRange(range);
	        return (cmp == -1 || cmp == 0 || cmp == 1);
	    };
	    this.isEnd = function(row, column) {
	        return this.end.row == row && this.end.column == column;
	    };
	    this.isStart = function(row, column) {
	        return this.start.row == row && this.start.column == column;
	    };
	    this.setStart = function(row, column) {
	        if (typeof row == "object") {
	            this.start.column = row.column;
	            this.start.row = row.row;
	        } else {
	            this.start.row = row;
	            this.start.column = column;
	        }
	    };
	    this.setEnd = function(row, column) {
	        if (typeof row == "object") {
	            this.end.column = row.column;
	            this.end.row = row.row;
	        } else {
	            this.end.row = row;
	            this.end.column = column;
	        }
	    };
	    this.inside = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column) || this.isStart(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.insideStart = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isEnd(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.insideEnd = function(row, column) {
	        if (this.compare(row, column) == 0) {
	            if (this.isStart(row, column)) {
	                return false;
	            } else {
	                return true;
	            }
	        }
	        return false;
	    };
	    this.compare = function(row, column) {
	        if (!this.isMultiLine()) {
	            if (row === this.start.row) {
	                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
	            };
	        }

	        if (row < this.start.row)
	            return -1;

	        if (row > this.end.row)
	            return 1;

	        if (this.start.row === row)
	            return column >= this.start.column ? 0 : -1;

	        if (this.end.row === row)
	            return column <= this.end.column ? 0 : 1;

	        return 0;
	    };
	    this.compareStart = function(row, column) {
	        if (this.start.row == row && this.start.column == column) {
	            return -1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.compareEnd = function(row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.compareInside = function(row, column) {
	        if (this.end.row == row && this.end.column == column) {
	            return 1;
	        } else if (this.start.row == row && this.start.column == column) {
	            return -1;
	        } else {
	            return this.compare(row, column);
	        }
	    };
	    this.clipRows = function(firstRow, lastRow) {
	        if (this.end.row > lastRow)
	            var end = {row: lastRow + 1, column: 0};
	        else if (this.end.row < firstRow)
	            var end = {row: firstRow, column: 0};

	        if (this.start.row > lastRow)
	            var start = {row: lastRow + 1, column: 0};
	        else if (this.start.row < firstRow)
	            var start = {row: firstRow, column: 0};

	        return Range.fromPoints(start || this.start, end || this.end);
	    };
	    this.extend = function(row, column) {
	        var cmp = this.compare(row, column);

	        if (cmp == 0)
	            return this;
	        else if (cmp == -1)
	            var start = {row: row, column: column};
	        else
	            var end = {row: row, column: column};

	        return Range.fromPoints(start || this.start, end || this.end);
	    };

	    this.isEmpty = function() {
	        return (this.start.row === this.end.row && this.start.column === this.end.column);
	    };
	    this.isMultiLine = function() {
	        return (this.start.row !== this.end.row);
	    };
	    this.clone = function() {
	        return Range.fromPoints(this.start, this.end);
	    };
	    this.collapseRows = function() {
	        if (this.end.column == 0)
	            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)
	        else
	            return new Range(this.start.row, 0, this.end.row, 0)
	    };
	    this.toScreenRange = function(session) {
	        var screenPosStart = session.documentToScreenPosition(this.start);
	        var screenPosEnd = session.documentToScreenPosition(this.end);

	        return new Range(
	            screenPosStart.row, screenPosStart.column,
	            screenPosEnd.row, screenPosEnd.column
	        );
	    };
	    this.moveBy = function(row, column) {
	        this.start.row += row;
	        this.start.column += column;
	        this.end.row += row;
	        this.end.column += column;
	    };

	}).call(Range.prototype);
	Range.fromPoints = function(start, end) {
	    return new Range(start.row, start.column, end.row, end.column);
	};
	Range.comparePoints = comparePoints;

	Range.comparePoints = function(p1, p2) {
	    return p1.row - p2.row || p1.column - p2.column;
	};


	exports.Range = Range;
	});

	ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var lang = acequire("./lib/lang");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Range = acequire("./range").Range;
	var Selection = function(session) {
	    this.session = session;
	    this.doc = session.getDocument();

	    this.clearSelection();
	    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
	    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);

	    var self = this;
	    this.lead.on("change", function(e) {
	        self._emit("changeCursor");
	        if (!self.$isEmpty)
	            self._emit("changeSelection");
	        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
	            self.$desiredColumn = null;
	    });

	    this.selectionAnchor.on("change", function() {
	        if (!self.$isEmpty)
	            self._emit("changeSelection");
	    });
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.isEmpty = function() {
	        return (this.$isEmpty || (
	            this.anchor.row == this.lead.row &&
	            this.anchor.column == this.lead.column
	        ));
	    };
	    this.isMultiLine = function() {
	        if (this.isEmpty()) {
	            return false;
	        }

	        return this.getRange().isMultiLine();
	    };
	    this.getCursor = function() {
	        return this.lead.getPosition();
	    };
	    this.setSelectionAnchor = function(row, column) {
	        this.anchor.setPosition(row, column);

	        if (this.$isEmpty) {
	            this.$isEmpty = false;
	            this._emit("changeSelection");
	        }
	    };
	    this.getSelectionAnchor = function() {
	        if (this.$isEmpty)
	            return this.getSelectionLead();
	        else
	            return this.anchor.getPosition();
	    };
	    this.getSelectionLead = function() {
	        return this.lead.getPosition();
	    };
	    this.shiftSelection = function(columns) {
	        if (this.$isEmpty) {
	            this.moveCursorTo(this.lead.row, this.lead.column + columns);
	            return;
	        }

	        var anchor = this.getSelectionAnchor();
	        var lead = this.getSelectionLead();

	        var isBackwards = this.isBackwards();

	        if (!isBackwards || anchor.column !== 0)
	            this.setSelectionAnchor(anchor.row, anchor.column + columns);

	        if (isBackwards || lead.column !== 0) {
	            this.$moveSelection(function() {
	                this.moveCursorTo(lead.row, lead.column + columns);
	            });
	        }
	    };
	    this.isBackwards = function() {
	        var anchor = this.anchor;
	        var lead = this.lead;
	        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
	    };
	    this.getRange = function() {
	        var anchor = this.anchor;
	        var lead = this.lead;

	        if (this.isEmpty())
	            return Range.fromPoints(lead, lead);

	        if (this.isBackwards()) {
	            return Range.fromPoints(lead, anchor);
	        }
	        else {
	            return Range.fromPoints(anchor, lead);
	        }
	    };
	    this.clearSelection = function() {
	        if (!this.$isEmpty) {
	            this.$isEmpty = true;
	            this._emit("changeSelection");
	        }
	    };
	    this.selectAll = function() {
	        var lastRow = this.doc.getLength() - 1;
	        this.setSelectionAnchor(0, 0);
	        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
	    };
	    this.setRange =
	    this.setSelectionRange = function(range, reverse) {
	        if (reverse) {
	            this.setSelectionAnchor(range.end.row, range.end.column);
	            this.selectTo(range.start.row, range.start.column);
	        } else {
	            this.setSelectionAnchor(range.start.row, range.start.column);
	            this.selectTo(range.end.row, range.end.column);
	        }
	        if (this.getRange().isEmpty())
	            this.$isEmpty = true;
	        this.$desiredColumn = null;
	    };

	    this.$moveSelection = function(mover) {
	        var lead = this.lead;
	        if (this.$isEmpty)
	            this.setSelectionAnchor(lead.row, lead.column);

	        mover.call(this);
	    };
	    this.selectTo = function(row, column) {
	        this.$moveSelection(function() {
	            this.moveCursorTo(row, column);
	        });
	    };
	    this.selectToPosition = function(pos) {
	        this.$moveSelection(function() {
	            this.moveCursorToPosition(pos);
	        });
	    };
	    this.moveTo = function(row, column) {
	        this.clearSelection();
	        this.moveCursorTo(row, column);
	    };
	    this.moveToPosition = function(pos) {
	        this.clearSelection();
	        this.moveCursorToPosition(pos);
	    };
	    this.selectUp = function() {
	        this.$moveSelection(this.moveCursorUp);
	    };
	    this.selectDown = function() {
	        this.$moveSelection(this.moveCursorDown);
	    };
	    this.selectRight = function() {
	        this.$moveSelection(this.moveCursorRight);
	    };
	    this.selectLeft = function() {
	        this.$moveSelection(this.moveCursorLeft);
	    };
	    this.selectLineStart = function() {
	        this.$moveSelection(this.moveCursorLineStart);
	    };
	    this.selectLineEnd = function() {
	        this.$moveSelection(this.moveCursorLineEnd);
	    };
	    this.selectFileEnd = function() {
	        this.$moveSelection(this.moveCursorFileEnd);
	    };
	    this.selectFileStart = function() {
	        this.$moveSelection(this.moveCursorFileStart);
	    };
	    this.selectWordRight = function() {
	        this.$moveSelection(this.moveCursorWordRight);
	    };
	    this.selectWordLeft = function() {
	        this.$moveSelection(this.moveCursorWordLeft);
	    };
	    this.getWordRange = function(row, column) {
	        if (typeof column == "undefined") {
	            var cursor = row || this.lead;
	            row = cursor.row;
	            column = cursor.column;
	        }
	        return this.session.getWordRange(row, column);
	    };
	    this.selectWord = function() {
	        this.setSelectionRange(this.getWordRange());
	    };
	    this.selectAWord = function() {
	        var cursor = this.getCursor();
	        var range = this.session.getAWordRange(cursor.row, cursor.column);
	        this.setSelectionRange(range);
	    };

	    this.getLineRange = function(row, excludeLastChar) {
	        var rowStart = typeof row == "number" ? row : this.lead.row;
	        var rowEnd;

	        var foldLine = this.session.getFoldLine(rowStart);
	        if (foldLine) {
	            rowStart = foldLine.start.row;
	            rowEnd = foldLine.end.row;
	        } else {
	            rowEnd = rowStart;
	        }
	        if (excludeLastChar === true)
	            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
	        else
	            return new Range(rowStart, 0, rowEnd + 1, 0);
	    };
	    this.selectLine = function() {
	        this.setSelectionRange(this.getLineRange());
	    };
	    this.moveCursorUp = function() {
	        this.moveCursorBy(-1, 0);
	    };
	    this.moveCursorDown = function() {
	        this.moveCursorBy(1, 0);
	    };
	    this.moveCursorLeft = function() {
	        var cursor = this.lead.getPosition(),
	            fold;

	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	        } else if (cursor.column === 0) {
	            if (cursor.row > 0) {
	                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(" ").length-1 == tabSize)
	                this.moveCursorBy(0, -tabSize);
	            else
	                this.moveCursorBy(0, -1);
	        }
	    };
	    this.moveCursorRight = function() {
	        var cursor = this.lead.getPosition(),
	            fold;
	        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	        }
	        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
	            if (this.lead.row < this.doc.getLength() - 1) {
	                this.moveCursorTo(this.lead.row + 1, 0);
	            }
	        }
	        else {
	            var tabSize = this.session.getTabSize();
	            var cursor = this.lead;
	            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(" ").length-1 == tabSize)
	                this.moveCursorBy(0, tabSize);
	            else
	                this.moveCursorBy(0, 1);
	        }
	    };
	    this.moveCursorLineStart = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var screenRow = this.session.documentToScreenRow(row, column);
	        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
	        var beforeCursor = this.session.getDisplayLine(
	            row, null, firstColumnPosition.row,
	            firstColumnPosition.column
	        );

	        var leadingSpace = beforeCursor.match(/^\s*/);
	        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
	            firstColumnPosition.column += leadingSpace[0].length;
	        this.moveCursorToPosition(firstColumnPosition);
	    };
	    this.moveCursorLineEnd = function() {
	        var lead = this.lead;
	        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
	        if (this.lead.column == lineEnd.column) {
	            var line = this.session.getLine(lineEnd.row);
	            if (lineEnd.column == line.length) {
	                var textEnd = line.search(/\s+$/);
	                if (textEnd > 0)
	                    lineEnd.column = textEnd;
	            }
	        }

	        this.moveCursorTo(lineEnd.row, lineEnd.column);
	    };
	    this.moveCursorFileEnd = function() {
	        var row = this.doc.getLength() - 1;
	        var column = this.doc.getLine(row).length;
	        this.moveCursorTo(row, column);
	    };
	    this.moveCursorFileStart = function() {
	        this.moveCursorTo(0, 0);
	    };
	    this.moveCursorLongWordRight = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);

	        var match;
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            this.moveCursorTo(fold.end.row, fold.end.column);
	            return;
	        }
	        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
	            column += this.session.nonTokenRe.lastIndex;
	            this.session.nonTokenRe.lastIndex = 0;
	            rightOfCursor = line.substring(column);
	        }
	        if (column >= line.length) {
	            this.moveCursorTo(row, line.length);
	            this.moveCursorRight();
	            if (row < this.doc.getLength() - 1)
	                this.moveCursorWordRight();
	            return;
	        }
	        if (match = this.session.tokenRe.exec(rightOfCursor)) {
	            column += this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }

	        this.moveCursorTo(row, column);
	    };
	    this.moveCursorLongWordLeft = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1)) {
	            this.moveCursorTo(fold.start.row, fold.start.column);
	            return;
	        }

	        var str = this.session.getFoldStringAt(row, column, -1);
	        if (str == null) {
	            str = this.doc.getLine(row).substring(0, column);
	        }

	        var leftOfCursor = lang.stringReverse(str);
	        var match;
	        this.session.nonTokenRe.lastIndex = 0;
	        this.session.tokenRe.lastIndex = 0;
	        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
	            column -= this.session.nonTokenRe.lastIndex;
	            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
	            this.session.nonTokenRe.lastIndex = 0;
	        }
	        if (column <= 0) {
	            this.moveCursorTo(row, 0);
	            this.moveCursorLeft();
	            if (row > 0)
	                this.moveCursorWordLeft();
	            return;
	        }
	        if (match = this.session.tokenRe.exec(leftOfCursor)) {
	            column -= this.session.tokenRe.lastIndex;
	            this.session.tokenRe.lastIndex = 0;
	        }

	        this.moveCursorTo(row, column);
	    };

	    this.$shortWordEndIndex = function(rightOfCursor) {
	        var match, index = 0, ch;
	        var whitespaceRe = /\s/;
	        var tokenRe = this.session.tokenRe;

	        tokenRe.lastIndex = 0;
	        if (match = this.session.tokenRe.exec(rightOfCursor)) {
	            index = this.session.tokenRe.lastIndex;
	        } else {
	            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                index ++;

	            if (index < 1) {
	                tokenRe.lastIndex = 0;
	                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
	                    tokenRe.lastIndex = 0;
	                    index ++;
	                    if (whitespaceRe.test(ch)) {
	                        if (index > 2) {
	                            index--;
	                            break;
	                        } else {
	                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
	                                index ++;
	                            if (index > 2)
	                                break;
	                        }
	                    }
	                }
	            }
	        }
	        tokenRe.lastIndex = 0;

	        return index;
	    };

	    this.moveCursorShortWordRight = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;
	        var line = this.doc.getLine(row);
	        var rightOfCursor = line.substring(column);

	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold)
	            return this.moveCursorTo(fold.end.row, fold.end.column);

	        if (column == line.length) {
	            var l = this.doc.getLength();
	            do {
	                row++;
	                rightOfCursor = this.doc.getLine(row);
	            } while (row < l && /^\s*$/.test(rightOfCursor));

	            if (!/^\s+/.test(rightOfCursor))
	                rightOfCursor = "";
	            column = 0;
	        }

	        var index = this.$shortWordEndIndex(rightOfCursor);

	        this.moveCursorTo(row, column + index);
	    };

	    this.moveCursorShortWordLeft = function() {
	        var row = this.lead.row;
	        var column = this.lead.column;

	        var fold;
	        if (fold = this.session.getFoldAt(row, column, -1))
	            return this.moveCursorTo(fold.start.row, fold.start.column);

	        var line = this.session.getLine(row).substring(0, column);
	        if (column === 0) {
	            do {
	                row--;
	                line = this.doc.getLine(row);
	            } while (row > 0 && /^\s*$/.test(line));

	            column = line.length;
	            if (!/\s+$/.test(line))
	                line = "";
	        }

	        var leftOfCursor = lang.stringReverse(line);
	        var index = this.$shortWordEndIndex(leftOfCursor);

	        return this.moveCursorTo(row, column - index);
	    };

	    this.moveCursorWordRight = function() {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordRight();
	        else
	            this.moveCursorShortWordRight();
	    };

	    this.moveCursorWordLeft = function() {
	        if (this.session.$selectLongWords)
	            this.moveCursorLongWordLeft();
	        else
	            this.moveCursorShortWordLeft();
	    };
	    this.moveCursorBy = function(rows, chars) {
	        var screenPos = this.session.documentToScreenPosition(
	            this.lead.row,
	            this.lead.column
	        );

	        if (chars === 0) {
	            if (this.$desiredColumn)
	                screenPos.column = this.$desiredColumn;
	            else
	                this.$desiredColumn = screenPos.column;
	        }

	        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
	        
	        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
	            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])
	                docPos.row++;
	        }
	        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
	    };
	    this.moveCursorToPosition = function(position) {
	        this.moveCursorTo(position.row, position.column);
	    };
	    this.moveCursorTo = function(row, column, keepDesiredColumn) {
	        var fold = this.session.getFoldAt(row, column, 1);
	        if (fold) {
	            row = fold.start.row;
	            column = fold.start.column;
	        }

	        this.$keepDesiredColumnOnChange = true;
	        this.lead.setPosition(row, column);
	        this.$keepDesiredColumnOnChange = false;

	        if (!keepDesiredColumn)
	            this.$desiredColumn = null;
	    };
	    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
	        var pos = this.session.screenToDocumentPosition(row, column);
	        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
	    };
	    this.detach = function() {
	        this.lead.detach();
	        this.anchor.detach();
	        this.session = this.doc = null;
	    };

	    this.fromOrientedRange = function(range) {
	        this.setSelectionRange(range, range.cursor == range.start);
	        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
	    };

	    this.toOrientedRange = function(range) {
	        var r = this.getRange();
	        if (range) {
	            range.start.column = r.start.column;
	            range.start.row = r.start.row;
	            range.end.column = r.end.column;
	            range.end.row = r.end.row;
	        } else {
	            range = r;
	        }

	        range.cursor = this.isBackwards() ? range.start : range.end;
	        range.desiredColumn = this.$desiredColumn;
	        return range;
	    };
	    this.getRangeOfMovements = function(func) {
	        var start = this.getCursor();
	        try {
	            func.call(null, this);
	            var end = this.getCursor();
	            return Range.fromPoints(start,end);
	        } catch(e) {
	            return Range.fromPoints(start,start);
	        } finally {
	            this.moveCursorToPosition(start);
	        }
	    };

	    this.toJSON = function() {
	        if (this.rangeCount) {
	            var data = this.ranges.map(function(r) {
	                var r1 = r.clone();
	                r1.isBackwards = r.cursor == r.start;
	                return r1;
	            });
	        } else {
	            var data = this.getRange();
	            data.isBackwards = this.isBackwards();
	        }
	        return data;
	    };

	    this.fromJSON = function(data) {
	        if (data.start == undefined) {
	            if (this.rangeList) {
	                this.toSingleRange(data[0]);
	                for (var i = data.length; i--; ) {
	                    var r = Range.fromPoints(data[i].start, data[i].end);
	                    if (data.isBackwards)
	                        r.cursor = r.start;
	                    this.addRange(r, true);
	                }
	                return;
	            } else
	                data = data[0];
	        }
	        if (this.rangeList)
	            this.toSingleRange(data);
	        this.setSelectionRange(data, data.isBackwards);
	    };

	    this.isEqual = function(data) {
	        if ((data.length || this.rangeCount) && data.length != this.rangeCount)
	            return false;
	        if (!data.length || !this.ranges)
	            return this.getRange().isEqual(data);

	        for (var i = this.ranges.length; i--; ) {
	            if (!this.ranges[i].isEqual(data[i]))
	                return false;
	        }
	        return true;
	    };

	}).call(Selection.prototype);

	exports.Selection = Selection;
	});

	ace.define("ace/tokenizer",["require","exports","module","ace/config"], function(acequire, exports, module) {
	"use strict";

	var config = acequire("./config");
	var MAX_TOKEN_COUNT = 2000;
	var Tokenizer = function(rules) {
	    this.states = rules;

	    this.regExps = {};
	    this.matchMappings = {};
	    for (var key in this.states) {
	        var state = this.states[key];
	        var ruleRegExps = [];
	        var matchTotal = 0;
	        var mapping = this.matchMappings[key] = {defaultToken: "text"};
	        var flag = "g";

	        var splitterRurles = [];
	        for (var i = 0; i < state.length; i++) {
	            var rule = state[i];
	            if (rule.defaultToken)
	                mapping.defaultToken = rule.defaultToken;
	            if (rule.caseInsensitive)
	                flag = "gi";
	            if (rule.regex == null)
	                continue;

	            if (rule.regex instanceof RegExp)
	                rule.regex = rule.regex.toString().slice(1, -1);
	            var adjustedregex = rule.regex;
	            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
	            if (Array.isArray(rule.token)) {
	                if (rule.token.length == 1 || matchcount == 1) {
	                    rule.token = rule.token[0];
	                } else if (matchcount - 1 != rule.token.length) {
	                    this.reportError("number of classes and regexp groups doesn't match", {
	                        rule: rule,
	                        groupCount: matchcount - 1
	                    });
	                    rule.token = rule.token[0];
	                } else {
	                    rule.tokenArray = rule.token;
	                    rule.token = null;
	                    rule.onMatch = this.$arrayTokens;
	                }
	            } else if (typeof rule.token == "function" && !rule.onMatch) {
	                if (matchcount > 1)
	                    rule.onMatch = this.$applyToken;
	                else
	                    rule.onMatch = rule.token;
	            }

	            if (matchcount > 1) {
	                if (/\\\d/.test(rule.regex)) {
	                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
	                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
	                    });
	                } else {
	                    matchcount = 1;
	                    adjustedregex = this.removeCapturingGroups(rule.regex);
	                }
	                if (!rule.splitRegex && typeof rule.token != "string")
	                    splitterRurles.push(rule); // flag will be known only at the very end
	            }

	            mapping[matchTotal] = i;
	            matchTotal += matchcount;

	            ruleRegExps.push(adjustedregex);
	            if (!rule.onMatch)
	                rule.onMatch = null;
	        }
	        
	        if (!ruleRegExps.length) {
	            mapping[0] = 0;
	            ruleRegExps.push("$");
	        }
	        
	        splitterRurles.forEach(function(rule) {
	            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
	        }, this);

	        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
	    }
	};

	(function() {
	    this.$setMaxTokenCount = function(m) {
	        MAX_TOKEN_COUNT = m | 0;
	    };
	    
	    this.$applyToken = function(str) {
	        var values = this.splitRegex.exec(str).slice(1);
	        var types = this.token.apply(this, values);
	        if (typeof types === "string")
	            return [{type: types, value: str}];

	        var tokens = [];
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i]
	                };
	        }
	        return tokens;
	    },

	    this.$arrayTokens = function(str) {
	        if (!str)
	            return [];
	        var values = this.splitRegex.exec(str);
	        if (!values)
	            return "text";
	        var tokens = [];
	        var types = this.tokenArray;
	        for (var i = 0, l = types.length; i < l; i++) {
	            if (values[i + 1])
	                tokens[tokens.length] = {
	                    type: types[i],
	                    value: values[i + 1]
	                };
	        }
	        return tokens;
	    };

	    this.removeCapturingGroups = function(src) {
	        var r = src.replace(
	            /\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g,
	            function(x, y) {return y ? "(?:" : x;}
	        );
	        return r;
	    };

	    this.createSplitterRegexp = function(src, flag) {
	        if (src.indexOf("(?=") != -1) {
	            var stack = 0;
	            var inChClass = false;
	            var lastCapture = {};
	            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(
	                m, esc, parenOpen, parenClose, square, index
	            ) {
	                if (inChClass) {
	                    inChClass = square != "]";
	                } else if (square) {
	                    inChClass = true;
	                } else if (parenClose) {
	                    if (stack == lastCapture.stack) {
	                        lastCapture.end = index+1;
	                        lastCapture.stack = -1;
	                    }
	                    stack--;
	                } else if (parenOpen) {
	                    stack++;
	                    if (parenOpen.length != 1) {
	                        lastCapture.stack = stack
	                        lastCapture.start = index;
	                    }
	                }
	                return m;
	            });

	            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
	                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
	        }
	        return new RegExp(src, (flag||"").replace("g", ""));
	    };
	    this.getLineTokens = function(line, startState) {
	        if (startState && typeof startState != "string") {
	            var stack = startState.slice(0);
	            startState = stack[0];
	            if (startState === "#tmp") {
	                stack.shift()
	                startState = stack.shift()
	            }
	        } else
	            var stack = [];

	        var currentState = startState || "start";
	        var state = this.states[currentState];
	        if (!state) {
	            currentState = "start";
	            state = this.states[currentState];
	        }
	        var mapping = this.matchMappings[currentState];
	        var re = this.regExps[currentState];
	        re.lastIndex = 0;

	        var match, tokens = [];
	        var lastIndex = 0;
	        var matchAttempts = 0;

	        var token = {type: null, value: ""};

	        while (match = re.exec(line)) {
	            var type = mapping.defaultToken;
	            var rule = null;
	            var value = match[0];
	            var index = re.lastIndex;

	            if (index - value.length > lastIndex) {
	                var skipped = line.substring(lastIndex, index - value.length);
	                if (token.type == type) {
	                    token.value += skipped;
	                } else {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {type: type, value: skipped};
	                }
	            }

	            for (var i = 0; i < match.length-2; i++) {
	                if (match[i + 1] === undefined)
	                    continue;

	                rule = state[mapping[i]];

	                if (rule.onMatch)
	                    type = rule.onMatch(value, currentState, stack);
	                else
	                    type = rule.token;

	                if (rule.next) {
	                    if (typeof rule.next == "string") {
	                        currentState = rule.next;
	                    } else {
	                        currentState = rule.next(currentState, stack);
	                    }
	                    
	                    state = this.states[currentState];
	                    if (!state) {
	                        this.reportError("state doesn't exist", currentState);
	                        currentState = "start";
	                        state = this.states[currentState];
	                    }
	                    mapping = this.matchMappings[currentState];
	                    lastIndex = index;
	                    re = this.regExps[currentState];
	                    re.lastIndex = index;
	                }
	                break;
	            }

	            if (value) {
	                if (typeof type === "string") {
	                    if ((!rule || rule.merge !== false) && token.type === type) {
	                        token.value += value;
	                    } else {
	                        if (token.type)
	                            tokens.push(token);
	                        token = {type: type, value: value};
	                    }
	                } else if (type) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {type: null, value: ""};
	                    for (var i = 0; i < type.length; i++)
	                        tokens.push(type[i]);
	                }
	            }

	            if (lastIndex == line.length)
	                break;

	            lastIndex = index;

	            if (matchAttempts++ > MAX_TOKEN_COUNT) {
	                if (matchAttempts > 2 * line.length) {
	                    this.reportError("infinite loop with in ace tokenizer", {
	                        startState: startState,
	                        line: line
	                    });
	                }
	                while (lastIndex < line.length) {
	                    if (token.type)
	                        tokens.push(token);
	                    token = {
	                        value: line.substring(lastIndex, lastIndex += 2000),
	                        type: "overflow"
	                    };
	                }
	                currentState = "start";
	                stack = [];
	                break;
	            }
	        }

	        if (token.type)
	            tokens.push(token);
	        
	        if (stack.length > 1) {
	            if (stack[0] !== currentState)
	                stack.unshift("#tmp", currentState);
	        }
	        return {
	            tokens : tokens,
	            state : stack.length ? stack : currentState
	        };
	    };

	    this.reportError = config.reportError;

	}).call(Tokenizer.prototype);

	exports.Tokenizer = Tokenizer;
	});

	ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("../lib/lang");

	var TextHighlightRules = function() {

	    this.$rules = {
	        "start" : [{
	            token : "empty_line",
	            regex : '^$'
	        }, {
	            defaultToken : "text"
	        }]
	    };
	};

	(function() {

	    this.addRules = function(rules, prefix) {
	        if (!prefix) {
	            for (var key in rules)
	                this.$rules[key] = rules[key];
	            return;
	        }
	        for (var key in rules) {
	            var state = rules[key];
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (rule.next || rule.onMatch) {
	                    if (typeof rule.next != "string") {
	                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
	                            rule.nextState = prefix + rule.nextState;
	                    } else {
	                        if (rule.next.indexOf(prefix) !== 0)
	                            rule.next = prefix + rule.next;
	                    }
	                }
	            }
	            this.$rules[prefix + key] = state;
	        }
	    };

	    this.getRules = function() {
	        return this.$rules;
	    };

	    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
	        var embedRules = typeof HighlightRules == "function"
	            ? new HighlightRules().getRules()
	            : HighlightRules;
	        if (states) {
	            for (var i = 0; i < states.length; i++)
	                states[i] = prefix + states[i];
	        } else {
	            states = [];
	            for (var key in embedRules)
	                states.push(prefix + key);
	        }

	        this.addRules(embedRules, prefix);

	        if (escapeRules) {
	            var addRules = Array.prototype[append ? "push" : "unshift"];
	            for (var i = 0; i < states.length; i++)
	                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
	        }

	        if (!this.$embeds)
	            this.$embeds = [];
	        this.$embeds.push(prefix);
	    };

	    this.getEmbeds = function() {
	        return this.$embeds;
	    };

	    var pushState = function(currentState, stack) {
	        if (currentState != "start" || stack.length)
	            stack.unshift(this.nextState, currentState);
	        return this.nextState;
	    };
	    var popState = function(currentState, stack) {
	        stack.shift();
	        return stack.shift() || "start";
	    };

	    this.normalizeRules = function() {
	        var id = 0;
	        var rules = this.$rules;
	        function processState(key) {
	            var state = rules[key];
	            state.processed = true;
	            for (var i = 0; i < state.length; i++) {
	                var rule = state[i];
	                if (!rule.regex && rule.start) {
	                    rule.regex = rule.start;
	                    if (!rule.next)
	                        rule.next = [];
	                    rule.next.push({
	                        defaultToken: rule.token
	                    }, {
	                        token: rule.token + ".end",
	                        regex: rule.end || rule.start,
	                        next: "pop"
	                    });
	                    rule.token = rule.token + ".start";
	                    rule.push = true;
	                }
	                var next = rule.next || rule.push;
	                if (next && Array.isArray(next)) {
	                    var stateName = rule.stateName;
	                    if (!stateName)  {
	                        stateName = rule.token;
	                        if (typeof stateName != "string")
	                            stateName = stateName[0] || "";
	                        if (rules[stateName])
	                            stateName += id++;
	                    }
	                    rules[stateName] = next;
	                    rule.next = stateName;
	                    processState(stateName);
	                } else if (next == "pop") {
	                    rule.next = popState;
	                }

	                if (rule.push) {
	                    rule.nextState = rule.next || rule.push;
	                    rule.next = pushState;
	                    delete rule.push;
	                }

	                if (rule.rules) {
	                    for (var r in rule.rules) {
	                        if (rules[r]) {
	                            if (rules[r].push)
	                                rules[r].push.apply(rules[r], rule.rules[r]);
	                        } else {
	                            rules[r] = rule.rules[r];
	                        }
	                    }
	                }
	                if (rule.include || typeof rule == "string") {
	                    var includeName = rule.include || rule;
	                    var toInsert = rules[includeName];
	                } else if (Array.isArray(rule))
	                    toInsert = rule;

	                if (toInsert) {
	                    var args = [i, 1].concat(toInsert);
	                    if (rule.noEscape)
	                        args = args.filter(function(x) {return !x.next;});
	                    state.splice.apply(state, args);
	                    i--;
	                    toInsert = null;
	                }
	                
	                if (rule.keywordMap) {
	                    rule.token = this.createKeywordMapper(
	                        rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive
	                    );
	                    delete rule.defaultToken;
	                }
	            }
	        }
	        Object.keys(rules).forEach(processState, this);
	    };

	    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
	        var keywords = Object.create(null);
	        Object.keys(map).forEach(function(className) {
	            var a = map[className];
	            if (ignoreCase)
	                a = a.toLowerCase();
	            var list = a.split(splitChar || "|");
	            for (var i = list.length; i--; )
	                keywords[list[i]] = className;
	        });
	        if (Object.getPrototypeOf(keywords)) {
	            keywords.__proto__ = null;
	        }
	        this.$keywordList = Object.keys(keywords);
	        map = null;
	        return ignoreCase
	            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }
	            : function(value) {return keywords[value] || defaultToken };
	    };

	    this.getKeywords = function() {
	        return this.$keywords;
	    };

	}).call(TextHighlightRules.prototype);

	exports.TextHighlightRules = TextHighlightRules;
	});

	ace.define("ace/mode/behaviour",["require","exports","module"], function(acequire, exports, module) {
	"use strict";

	var Behaviour = function() {
	   this.$behaviours = {};
	};

	(function () {

	    this.add = function (name, action, callback) {
	        switch (undefined) {
	          case this.$behaviours:
	              this.$behaviours = {};
	          case this.$behaviours[name]:
	              this.$behaviours[name] = {};
	        }
	        this.$behaviours[name][action] = callback;
	    }
	    
	    this.addBehaviours = function (behaviours) {
	        for (var key in behaviours) {
	            for (var action in behaviours[key]) {
	                this.add(key, action, behaviours[key][action]);
	            }
	        }
	    }
	    
	    this.remove = function (name) {
	        if (this.$behaviours && this.$behaviours[name]) {
	            delete this.$behaviours[name];
	        }
	    }
	    
	    this.inherit = function (mode, filter) {
	        if (typeof mode === "function") {
	            var behaviours = new mode().getBehaviours(filter);
	        } else {
	            var behaviours = mode.getBehaviours(filter);
	        }
	        this.addBehaviours(behaviours);
	    }
	    
	    this.getBehaviours = function (filter) {
	        if (!filter) {
	            return this.$behaviours;
	        } else {
	            var ret = {}
	            for (var i = 0; i < filter.length; i++) {
	                if (this.$behaviours[filter[i]]) {
	                    ret[filter[i]] = this.$behaviours[filter[i]];
	                }
	            }
	            return ret;
	        }
	    }

	}).call(Behaviour.prototype);

	exports.Behaviour = Behaviour;
	});

	ace.define("ace/unicode",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	exports.packages = {};

	addUnicodePackage({
	    L:  "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	    Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
	    Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
	    Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
	    Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
	    Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
	    M:  "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
	    Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
	    Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
	    Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
	    N:  "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	    Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
	    Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
	    No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
	    P:  "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
	    Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
	    Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
	    Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
	    Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
	    Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
	    Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
	    Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
	    S:  "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
	    Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
	    Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
	    Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
	    So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
	    Z:  "002000A01680180E2000-200A20282029202F205F3000",
	    Zs: "002000A01680180E2000-200A202F205F3000",
	    Zl: "2028",
	    Zp: "2029",
	    C:  "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
	    Cc: "0000-001F007F-009F",
	    Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
	    Co: "E000-F8FF",
	    Cs: "D800-DFFF",
	    Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
	});

	function addUnicodePackage (pack) {
	    var codePoint = /\w{4}/g;
	    for (var name in pack)
	        exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
	};

	});

	ace.define("ace/token_iterator",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var TokenIterator = function(session, initialRow, initialColumn) {
	    this.$session = session;
	    this.$row = initialRow;
	    this.$rowTokens = session.getTokens(initialRow);

	    var token = session.getTokenAt(initialRow, initialColumn);
	    this.$tokenIndex = token ? token.index : -1;
	};

	(function() { 
	    this.stepBackward = function() {
	        this.$tokenIndex -= 1;
	        
	        while (this.$tokenIndex < 0) {
	            this.$row -= 1;
	            if (this.$row < 0) {
	                this.$row = 0;
	                return null;
	            }
	                
	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = this.$rowTokens.length - 1;
	        }
	            
	        return this.$rowTokens[this.$tokenIndex];
	    };   
	    this.stepForward = function() {
	        this.$tokenIndex += 1;
	        var rowCount;
	        while (this.$tokenIndex >= this.$rowTokens.length) {
	            this.$row += 1;
	            if (!rowCount)
	                rowCount = this.$session.getLength();
	            if (this.$row >= rowCount) {
	                this.$row = rowCount - 1;
	                return null;
	            }

	            this.$rowTokens = this.$session.getTokens(this.$row);
	            this.$tokenIndex = 0;
	        }
	            
	        return this.$rowTokens[this.$tokenIndex];
	    };      
	    this.getCurrentToken = function () {
	        return this.$rowTokens[this.$tokenIndex];
	    };      
	    this.getCurrentTokenRow = function () {
	        return this.$row;
	    };     
	    this.getCurrentTokenColumn = function() {
	        var rowTokens = this.$rowTokens;
	        var tokenIndex = this.$tokenIndex;
	        var column = rowTokens[tokenIndex].start;
	        if (column !== undefined)
	            return column;
	            
	        column = 0;
	        while (tokenIndex > 0) {
	            tokenIndex -= 1;
	            column += rowTokens[tokenIndex].value.length;
	        }
	        
	        return column;  
	    };
	            
	}).call(TokenIterator.prototype);

	exports.TokenIterator = TokenIterator;
	});

	ace.define("ace/mode/text",["require","exports","module","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Tokenizer = acequire("../tokenizer").Tokenizer;
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
	var Behaviour = acequire("./behaviour").Behaviour;
	var unicode = acequire("../unicode");
	var lang = acequire("../lib/lang");
	var TokenIterator = acequire("../token_iterator").TokenIterator;
	var Range = acequire("../range").Range;

	var Mode = function() {
	    this.HighlightRules = TextHighlightRules;
	    this.$behaviour = new Behaviour();
	};

	(function() {

	    this.tokenRe = new RegExp("^["
	        + unicode.packages.L
	        + unicode.packages.Mn + unicode.packages.Mc
	        + unicode.packages.Nd
	        + unicode.packages.Pc + "\\$_]+", "g"
	    );

	    this.nonTokenRe = new RegExp("^(?:[^"
	        + unicode.packages.L
	        + unicode.packages.Mn + unicode.packages.Mc
	        + unicode.packages.Nd
	        + unicode.packages.Pc + "\\$_]|\\s])+", "g"
	    );

	    this.getTokenizer = function() {
	        if (!this.$tokenizer) {
	            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
	            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
	        }
	        return this.$tokenizer;
	    };

	    this.lineCommentStart = "";
	    this.blockComment = "";

	    this.toggleCommentLines = function(state, session, startRow, endRow) {
	        var doc = session.doc;

	        var ignoreBlankLines = true;
	        var shouldRemove = true;
	        var minIndent = Infinity;
	        var tabSize = session.getTabSize();
	        var insertAtTabStop = false;

	        if (!this.lineCommentStart) {
	            if (!this.blockComment)
	                return false;
	            var lineCommentStart = this.blockComment.start;
	            var lineCommentEnd = this.blockComment.end;
	            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
	            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");

	            var comment = function(line, i) {
	                if (testRemove(line, i))
	                    return;
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);
	                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
	                }
	            };

	            var uncomment = function(line, i) {
	                var m;
	                if (m = line.match(regexpEnd))
	                    doc.removeInLine(i, line.length - m[0].length, line.length);
	                if (m = line.match(regexpStart))
	                    doc.removeInLine(i, m[1].length, m[0].length);
	            };

	            var testRemove = function(line, row) {
	                if (regexpStart.test(line))
	                    return true;
	                var tokens = session.getTokens(row);
	                for (var i = 0; i < tokens.length; i++) {
	                    if (tokens[i].type === 'comment')
	                        return true;
	                }
	            };
	        } else {
	            if (Array.isArray(this.lineCommentStart)) {
	                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
	                var lineCommentStart = this.lineCommentStart[0];
	            } else {
	                var regexpStart = lang.escapeRegExp(this.lineCommentStart);
	                var lineCommentStart = this.lineCommentStart;
	            }
	            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
	            
	            insertAtTabStop = session.getUseSoftTabs();

	            var uncomment = function(line, i) {
	                var m = line.match(regexpStart);
	                if (!m) return;
	                var start = m[1].length, end = m[0].length;
	                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
	                    end--;
	                doc.removeInLine(i, start, end);
	            };
	            var commentWithSpace = lineCommentStart + " ";
	            var comment = function(line, i) {
	                if (!ignoreBlankLines || /\S/.test(line)) {
	                    if (shouldInsertSpace(line, minIndent, minIndent))
	                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);
	                    else
	                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);
	                }
	            };
	            var testRemove = function(line, i) {
	                return regexpStart.test(line);
	            };
	            
	            var shouldInsertSpace = function(line, before, after) {
	                var spaces = 0;
	                while (before-- && line.charAt(before) == " ")
	                    spaces++;
	                if (spaces % tabSize != 0)
	                    return false;
	                var spaces = 0;
	                while (line.charAt(after++) == " ")
	                    spaces++;
	                if (tabSize > 2)
	                    return spaces % tabSize != tabSize - 1;
	                else
	                    return spaces % tabSize == 0;
	                return true;
	            };
	        }

	        function iter(fun) {
	            for (var i = startRow; i <= endRow; i++)
	                fun(doc.getLine(i), i);
	        }


	        var minEmptyLength = Infinity;
	        iter(function(line, i) {
	            var indent = line.search(/\S/);
	            if (indent !== -1) {
	                if (indent < minIndent)
	                    minIndent = indent;
	                if (shouldRemove && !testRemove(line, i))
	                    shouldRemove = false;
	            } else if (minEmptyLength > line.length) {
	                minEmptyLength = line.length;
	            }
	        });

	        if (minIndent == Infinity) {
	            minIndent = minEmptyLength;
	            ignoreBlankLines = false;
	            shouldRemove = false;
	        }

	        if (insertAtTabStop && minIndent % tabSize != 0)
	            minIndent = Math.floor(minIndent / tabSize) * tabSize;

	        iter(shouldRemove ? uncomment : comment);
	    };

	    this.toggleBlockComment = function(state, session, range, cursor) {
	        var comment = this.blockComment;
	        if (!comment)
	            return;
	        if (!comment.start && comment[0])
	            comment = comment[0];

	        var iterator = new TokenIterator(session, cursor.row, cursor.column);
	        var token = iterator.getCurrentToken();

	        var sel = session.selection;
	        var initialRange = session.selection.toOrientedRange();
	        var startRow, colDiff;

	        if (token && /comment/.test(token.type)) {
	            var startRange, endRange;
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.start);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    startRange = new Range(row, column, row, column + comment.start.length);
	                    break;
	                }
	                token = iterator.stepBackward();
	            }

	            var iterator = new TokenIterator(session, cursor.row, cursor.column);
	            var token = iterator.getCurrentToken();
	            while (token && /comment/.test(token.type)) {
	                var i = token.value.indexOf(comment.end);
	                if (i != -1) {
	                    var row = iterator.getCurrentTokenRow();
	                    var column = iterator.getCurrentTokenColumn() + i;
	                    endRange = new Range(row, column, row, column + comment.end.length);
	                    break;
	                }
	                token = iterator.stepForward();
	            }
	            if (endRange)
	                session.remove(endRange);
	            if (startRange) {
	                session.remove(startRange);
	                startRow = startRange.start.row;
	                colDiff = -comment.start.length;
	            }
	        } else {
	            colDiff = comment.start.length;
	            startRow = range.start.row;
	            session.insert(range.end, comment.end);
	            session.insert(range.start, comment.start);
	        }
	        if (initialRange.start.row == startRow)
	            initialRange.start.column += colDiff;
	        if (initialRange.end.row == startRow)
	            initialRange.end.column += colDiff;
	        session.selection.fromOrientedRange(initialRange);
	    };

	    this.getNextLineIndent = function(state, line, tab) {
	        return this.$getIndent(line);
	    };

	    this.checkOutdent = function(state, line, input) {
	        return false;
	    };

	    this.autoOutdent = function(state, doc, row) {
	    };

	    this.$getIndent = function(line) {
	        return line.match(/^\s*/)[0];
	    };

	    this.createWorker = function(session) {
	        return null;
	    };

	    this.createModeDelegates = function (mapping) {
	        this.$embeds = [];
	        this.$modes = {};
	        for (var i in mapping) {
	            if (mapping[i]) {
	                this.$embeds.push(i);
	                this.$modes[i] = new mapping[i]();
	            }
	        }

	        var delegations = ['toggleBlockComment', 'toggleCommentLines', 'getNextLineIndent', 
	            'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];

	        for (var i = 0; i < delegations.length; i++) {
	            (function(scope) {
	              var functionName = delegations[i];
	              var defaultHandler = scope[functionName];
	              scope[delegations[i]] = function() {
	                  return this.$delegator(functionName, arguments, defaultHandler);
	              };
	            } (this));
	        }
	    };

	    this.$delegator = function(method, args, defaultHandler) {
	        var state = args[0];
	        if (typeof state != "string")
	            state = state[0];
	        for (var i = 0; i < this.$embeds.length; i++) {
	            if (!this.$modes[this.$embeds[i]]) continue;

	            var split = state.split(this.$embeds[i]);
	            if (!split[0] && split[1]) {
	                args[0] = split[1];
	                var mode = this.$modes[this.$embeds[i]];
	                return mode[method].apply(mode, args);
	            }
	        }
	        var ret = defaultHandler.apply(this, args);
	        return defaultHandler ? ret : undefined;
	    };

	    this.transformAction = function(state, action, editor, session, param) {
	        if (this.$behaviour) {
	            var behaviours = this.$behaviour.getBehaviours();
	            for (var key in behaviours) {
	                if (behaviours[key][action]) {
	                    var ret = behaviours[key][action].apply(this, arguments);
	                    if (ret) {
	                        return ret;
	                    }
	                }
	            }
	        }
	    };
	    
	    this.getKeywords = function(append) {
	        if (!this.completionKeywords) {
	            var rules = this.$tokenizer.rules;
	            var completionKeywords = [];
	            for (var rule in rules) {
	                var ruleItr = rules[rule];
	                for (var r = 0, l = ruleItr.length; r < l; r++) {
	                    if (typeof ruleItr[r].token === "string") {
	                        if (/keyword|support|storage/.test(ruleItr[r].token))
	                            completionKeywords.push(ruleItr[r].regex);
	                    }
	                    else if (typeof ruleItr[r].token === "object") {
	                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    
	                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
	                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
	                                completionKeywords.push(rule.substr(1, rule.length - 2));
	                            }
	                        }
	                    }
	                }
	            }
	            this.completionKeywords = completionKeywords;
	        }
	        if (!append)
	            return this.$keywordList;
	        return completionKeywords.concat(this.$keywordList || []);
	    };
	    
	    this.$createKeywordList = function() {
	        if (!this.$highlightRules)
	            this.getTokenizer();
	        return this.$keywordList = this.$highlightRules.$keywordList || [];
	    };

	    this.getCompletions = function(state, session, pos, prefix) {
	        var keywords = this.$keywordList || this.$createKeywordList();
	        return keywords.map(function(word) {
	            return {
	                name: word,
	                value: word,
	                score: 0,
	                meta: "keyword"
	            };
	        });
	    };

	    this.$id = "ace/mode/text";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});

	ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

	var Anchor = exports.Anchor = function(doc, row, column) {
	    this.$onChange = this.onChange.bind(this);
	    this.attach(doc);
	    
	    if (typeof column == "undefined")
	        this.setPosition(row.row, row.column);
	    else
	        this.setPosition(row, column);
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.getPosition = function() {
	        return this.$clipPositionToDocument(this.row, this.column);
	    };
	    this.getDocument = function() {
	        return this.document;
	    };
	    this.$insertRight = false;
	    this.onChange = function(e) {
	        var delta = e.data;
	        var range = delta.range;

	        if (range.start.row == range.end.row && range.start.row != this.row)
	            return;

	        if (range.start.row > this.row)
	            return;

	        if (range.start.row == this.row && range.start.column > this.column)
	            return;

	        var row = this.row;
	        var column = this.column;
	        var start = range.start;
	        var end = range.end;

	        if (delta.action === "insertText") {
	            if (start.row === row && start.column <= column) {
	                if (start.column === column && this.$insertRight) {
	                } else if (start.row === end.row) {
	                    column += end.column - start.column;
	                } else {
	                    column -= start.column;
	                    row += end.row - start.row;
	                }
	            } else if (start.row !== end.row && start.row < row) {
	                row += end.row - start.row;
	            }
	        } else if (delta.action === "insertLines") {
	            if (start.row === row && column === 0 && this.$insertRight) {
	            }
	            else if (start.row <= row) {
	                row += end.row - start.row;
	            }
	        } else if (delta.action === "removeText") {
	            if (start.row === row && start.column < column) {
	                if (end.column >= column)
	                    column = start.column;
	                else
	                    column = Math.max(0, column - (end.column - start.column));

	            } else if (start.row !== end.row && start.row < row) {
	                if (end.row === row)
	                    column = Math.max(0, column - end.column) + start.column;
	                row -= (end.row - start.row);
	            } else if (end.row === row) {
	                row -= end.row - start.row;
	                column = Math.max(0, column - end.column) + start.column;
	            }
	        } else if (delta.action == "removeLines") {
	            if (start.row <= row) {
	                if (end.row <= row)
	                    row -= end.row - start.row;
	                else {
	                    row = start.row;
	                    column = 0;
	                }
	            }
	        }

	        this.setPosition(row, column, true);
	    };
	    this.setPosition = function(row, column, noClip) {
	        var pos;
	        if (noClip) {
	            pos = {
	                row: row,
	                column: column
	            };
	        } else {
	            pos = this.$clipPositionToDocument(row, column);
	        }

	        if (this.row == pos.row && this.column == pos.column)
	            return;

	        var old = {
	            row: this.row,
	            column: this.column
	        };

	        this.row = pos.row;
	        this.column = pos.column;
	        this._signal("change", {
	            old: old,
	            value: pos
	        });
	    };
	    this.detach = function() {
	        this.document.removeEventListener("change", this.$onChange);
	    };
	    this.attach = function(doc) {
	        this.document = doc || this.document;
	        this.document.on("change", this.$onChange);
	    };
	    this.$clipPositionToDocument = function(row, column) {
	        var pos = {};

	        if (row >= this.document.getLength()) {
	            pos.row = Math.max(0, this.document.getLength() - 1);
	            pos.column = this.document.getLine(pos.row).length;
	        }
	        else if (row < 0) {
	            pos.row = 0;
	            pos.column = 0;
	        }
	        else {
	            pos.row = row;
	            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
	        }

	        if (column < 0)
	            pos.column = 0;

	        return pos;
	    };

	}).call(Anchor.prototype);

	});

	ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/lib/event_emitter","ace/range","ace/anchor"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Range = acequire("./range").Range;
	var Anchor = acequire("./anchor").Anchor;

	var Document = function(text) {
	    this.$lines = [];
	    if (text.length === 0) {
	        this.$lines = [""];
	    } else if (Array.isArray(text)) {
	        this._insertLines(0, text);
	    } else {
	        this.insert({row: 0, column:0}, text);
	    }
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.setValue = function(text) {
	        var len = this.getLength();
	        this.remove(new Range(0, 0, len, this.getLine(len-1).length));
	        this.insert({row: 0, column:0}, text);
	    };
	    this.getValue = function() {
	        return this.getAllLines().join(this.getNewLineCharacter());
	    };
	    this.createAnchor = function(row, column) {
	        return new Anchor(this, row, column);
	    };
	    if ("aaa".split(/a/).length === 0)
	        this.$split = function(text) {
	            return text.replace(/\r\n|\r/g, "\n").split("\n");
	        };
	    else
	        this.$split = function(text) {
	            return text.split(/\r\n|\r|\n/);
	        };


	    this.$detectNewLine = function(text) {
	        var match = text.match(/^.*?(\r\n|\r|\n)/m);
	        this.$autoNewLine = match ? match[1] : "\n";
	        this._signal("changeNewLineMode");
	    };
	    this.getNewLineCharacter = function() {
	        switch (this.$newLineMode) {
	          case "windows":
	            return "\r\n";
	          case "unix":
	            return "\n";
	          default:
	            return this.$autoNewLine || "\n";
	        }
	    };

	    this.$autoNewLine = "";
	    this.$newLineMode = "auto";
	    this.setNewLineMode = function(newLineMode) {
	        if (this.$newLineMode === newLineMode)
	            return;

	        this.$newLineMode = newLineMode;
	        this._signal("changeNewLineMode");
	    };
	    this.getNewLineMode = function() {
	        return this.$newLineMode;
	    };
	    this.isNewLine = function(text) {
	        return (text == "\r\n" || text == "\r" || text == "\n");
	    };
	    this.getLine = function(row) {
	        return this.$lines[row] || "";
	    };
	    this.getLines = function(firstRow, lastRow) {
	        return this.$lines.slice(firstRow, lastRow + 1);
	    };
	    this.getAllLines = function() {
	        return this.getLines(0, this.getLength());
	    };
	    this.getLength = function() {
	        return this.$lines.length;
	    };
	    this.getTextRange = function(range) {
	        if (range.start.row == range.end.row) {
	            return this.getLine(range.start.row)
	                .substring(range.start.column, range.end.column);
	        }
	        var lines = this.getLines(range.start.row, range.end.row);
	        lines[0] = (lines[0] || "").substring(range.start.column);
	        var l = lines.length - 1;
	        if (range.end.row - range.start.row == l)
	            lines[l] = lines[l].substring(0, range.end.column);
	        return lines.join(this.getNewLineCharacter());
	    };

	    this.$clipPosition = function(position) {
	        var length = this.getLength();
	        if (position.row >= length) {
	            position.row = Math.max(0, length - 1);
	            position.column = this.getLine(length-1).length;
	        } else if (position.row < 0)
	            position.row = 0;
	        return position;
	    };
	    this.insert = function(position, text) {
	        if (!text || text.length === 0)
	            return position;

	        position = this.$clipPosition(position);
	        if (this.getLength() <= 1)
	            this.$detectNewLine(text);

	        var lines = this.$split(text);
	        var firstLine = lines.splice(0, 1)[0];
	        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];

	        position = this.insertInLine(position, firstLine);
	        if (lastLine !== null) {
	            position = this.insertNewLine(position); // terminate first line
	            position = this._insertLines(position.row, lines);
	            position = this.insertInLine(position, lastLine || "");
	        }
	        return position;
	    };
	    this.insertLines = function(row, lines) {
	        if (row >= this.getLength())
	            return this.insert({row: row, column: 0}, "\n" + lines.join("\n"));
	        return this._insertLines(Math.max(row, 0), lines);
	    };
	    this._insertLines = function(row, lines) {
	        if (lines.length == 0)
	            return {row: row, column: 0};
	        while (lines.length > 20000) {
	            var end = this._insertLines(row, lines.slice(0, 20000));
	            lines = lines.slice(20000);
	            row = end.row;
	        }

	        var args = [row, 0];
	        args.push.apply(args, lines);
	        this.$lines.splice.apply(this.$lines, args);

	        var range = new Range(row, 0, row + lines.length, 0);
	        var delta = {
	            action: "insertLines",
	            range: range,
	            lines: lines
	        };
	        this._signal("change", { data: delta });
	        return range.end;
	    };
	    this.insertNewLine = function(position) {
	        position = this.$clipPosition(position);
	        var line = this.$lines[position.row] || "";

	        this.$lines[position.row] = line.substring(0, position.column);
	        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));

	        var end = {
	            row : position.row + 1,
	            column : 0
	        };

	        var delta = {
	            action: "insertText",
	            range: Range.fromPoints(position, end),
	            text: this.getNewLineCharacter()
	        };
	        this._signal("change", { data: delta });

	        return end;
	    };
	    this.insertInLine = function(position, text) {
	        if (text.length == 0)
	            return position;

	        var line = this.$lines[position.row] || "";

	        this.$lines[position.row] = line.substring(0, position.column) + text
	                + line.substring(position.column);

	        var end = {
	            row : position.row,
	            column : position.column + text.length
	        };

	        var delta = {
	            action: "insertText",
	            range: Range.fromPoints(position, end),
	            text: text
	        };
	        this._signal("change", { data: delta });

	        return end;
	    };
	    this.remove = function(range) {
	        if (!(range instanceof Range))
	            range = Range.fromPoints(range.start, range.end);
	        range.start = this.$clipPosition(range.start);
	        range.end = this.$clipPosition(range.end);

	        if (range.isEmpty())
	            return range.start;

	        var firstRow = range.start.row;
	        var lastRow = range.end.row;

	        if (range.isMultiLine()) {
	            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
	            var lastFullRow = lastRow - 1;

	            if (range.end.column > 0)
	                this.removeInLine(lastRow, 0, range.end.column);

	            if (lastFullRow >= firstFullRow)
	                this._removeLines(firstFullRow, lastFullRow);

	            if (firstFullRow != firstRow) {
	                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
	                this.removeNewLine(range.start.row);
	            }
	        }
	        else {
	            this.removeInLine(firstRow, range.start.column, range.end.column);
	        }
	        return range.start;
	    };
	    this.removeInLine = function(row, startColumn, endColumn) {
	        if (startColumn == endColumn)
	            return;

	        var range = new Range(row, startColumn, row, endColumn);
	        var line = this.getLine(row);
	        var removed = line.substring(startColumn, endColumn);
	        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
	        this.$lines.splice(row, 1, newLine);

	        var delta = {
	            action: "removeText",
	            range: range,
	            text: removed
	        };
	        this._signal("change", { data: delta });
	        return range.start;
	    };
	    this.removeLines = function(firstRow, lastRow) {
	        if (firstRow < 0 || lastRow >= this.getLength())
	            return this.remove(new Range(firstRow, 0, lastRow + 1, 0));
	        return this._removeLines(firstRow, lastRow);
	    };

	    this._removeLines = function(firstRow, lastRow) {
	        var range = new Range(firstRow, 0, lastRow + 1, 0);
	        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);

	        var delta = {
	            action: "removeLines",
	            range: range,
	            nl: this.getNewLineCharacter(),
	            lines: removed
	        };
	        this._signal("change", { data: delta });
	        return removed;
	    };
	    this.removeNewLine = function(row) {
	        var firstLine = this.getLine(row);
	        var secondLine = this.getLine(row+1);

	        var range = new Range(row, firstLine.length, row+1, 0);
	        var line = firstLine + secondLine;

	        this.$lines.splice(row, 2, line);

	        var delta = {
	            action: "removeText",
	            range: range,
	            text: this.getNewLineCharacter()
	        };
	        this._signal("change", { data: delta });
	    };
	    this.replace = function(range, text) {
	        if (!(range instanceof Range))
	            range = Range.fromPoints(range.start, range.end);
	        if (text.length == 0 && range.isEmpty())
	            return range.start;
	        if (text == this.getTextRange(range))
	            return range.end;

	        this.remove(range);
	        if (text) {
	            var end = this.insert(range.start, text);
	        }
	        else {
	            end = range.start;
	        }

	        return end;
	    };
	    this.applyDeltas = function(deltas) {
	        for (var i=0; i<deltas.length; i++) {
	            var delta = deltas[i];
	            var range = Range.fromPoints(delta.range.start, delta.range.end);

	            if (delta.action == "insertLines")
	                this.insertLines(range.start.row, delta.lines);
	            else if (delta.action == "insertText")
	                this.insert(range.start, delta.text);
	            else if (delta.action == "removeLines")
	                this._removeLines(range.start.row, range.end.row - 1);
	            else if (delta.action == "removeText")
	                this.remove(range);
	        }
	    };
	    this.revertDeltas = function(deltas) {
	        for (var i=deltas.length-1; i>=0; i--) {
	            var delta = deltas[i];

	            var range = Range.fromPoints(delta.range.start, delta.range.end);

	            if (delta.action == "insertLines")
	                this._removeLines(range.start.row, range.end.row - 1);
	            else if (delta.action == "insertText")
	                this.remove(range);
	            else if (delta.action == "removeLines")
	                this._insertLines(range.start.row, delta.lines);
	            else if (delta.action == "removeText")
	                this.insert(range.start, delta.text);
	        }
	    };
	    this.indexToPosition = function(index, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        for (var i = startRow || 0, l = lines.length; i < l; i++) {
	            index -= lines[i].length + newlineLength;
	            if (index < 0)
	                return {row: i, column: index + lines[i].length + newlineLength};
	        }
	        return {row: l-1, column: lines[l-1].length};
	    };
	    this.positionToIndex = function(pos, startRow) {
	        var lines = this.$lines || this.getAllLines();
	        var newlineLength = this.getNewLineCharacter().length;
	        var index = 0;
	        var row = Math.min(pos.row, lines.length);
	        for (var i = startRow || 0; i < row; ++i)
	            index += lines[i].length + newlineLength;

	        return index + pos.column;
	    };

	}).call(Document.prototype);

	exports.Document = Document;
	});

	ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;

	var BackgroundTokenizer = function(tokenizer, editor) {
	    this.running = false;
	    this.lines = [];
	    this.states = [];
	    this.currentLine = 0;
	    this.tokenizer = tokenizer;

	    var self = this;

	    this.$worker = function() {
	        if (!self.running) { return; }

	        var workerStart = new Date();
	        var currentLine = self.currentLine;
	        var endLine = -1;
	        var doc = self.doc;

	        while (self.lines[currentLine])
	            currentLine++;

	        var startLine = currentLine;

	        var len = doc.getLength();
	        var processedLines = 0;
	        self.running = false;
	        while (currentLine < len) {
	            self.$tokenizeRow(currentLine);
	            endLine = currentLine;
	            do {
	                currentLine++;
	            } while (self.lines[currentLine]);
	            processedLines ++;
	            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                
	                self.running = setTimeout(self.$worker, 20);
	                break;
	            }
	        }
	        self.currentLine = currentLine;
	        
	        if (startLine <= endLine)
	            self.fireUpdateEvent(startLine, endLine);
	    };
	};

	(function(){

	    oop.implement(this, EventEmitter);
	    this.setTokenizer = function(tokenizer) {
	        this.tokenizer = tokenizer;
	        this.lines = [];
	        this.states = [];

	        this.start(0);
	    };
	    this.setDocument = function(doc) {
	        this.doc = doc;
	        this.lines = [];
	        this.states = [];

	        this.stop();
	    };
	    this.fireUpdateEvent = function(firstRow, lastRow) {
	        var data = {
	            first: firstRow,
	            last: lastRow
	        };
	        this._signal("update", {data: data});
	    };
	    this.start = function(startRow) {
	        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
	        this.lines.splice(this.currentLine, this.lines.length);
	        this.states.splice(this.currentLine, this.states.length);

	        this.stop();
	        this.running = setTimeout(this.$worker, 700);
	    };
	    
	    this.scheduleStart = function() {
	        if (!this.running)
	            this.running = setTimeout(this.$worker, 700);
	    }

	    this.$updateOnChange = function(delta) {
	        var range = delta.range;
	        var startRow = range.start.row;
	        var len = range.end.row - startRow;

	        if (len === 0) {
	            this.lines[startRow] = null;
	        } else if (delta.action == "removeText" || delta.action == "removeLines") {
	            this.lines.splice(startRow, len + 1, null);
	            this.states.splice(startRow, len + 1, null);
	        } else {
	            var args = Array(len + 1);
	            args.unshift(startRow, 1);
	            this.lines.splice.apply(this.lines, args);
	            this.states.splice.apply(this.states, args);
	        }

	        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());

	        this.stop();
	    };
	    this.stop = function() {
	        if (this.running)
	            clearTimeout(this.running);
	        this.running = false;
	    };
	    this.getTokens = function(row) {
	        return this.lines[row] || this.$tokenizeRow(row);
	    };
	    this.getState = function(row) {
	        if (this.currentLine == row)
	            this.$tokenizeRow(row);
	        return this.states[row] || "start";
	    };

	    this.$tokenizeRow = function(row) {
	        var line = this.doc.getLine(row);
	        var state = this.states[row - 1];

	        var data = this.tokenizer.getLineTokens(line, state, row);

	        if (this.states[row] + "" !== data.state + "") {
	            this.states[row] = data.state;
	            this.lines[row + 1] = null;
	            if (this.currentLine > row + 1)
	                this.currentLine = row + 1;
	        } else if (this.currentLine == row) {
	            this.currentLine = row + 1;
	        }

	        return this.lines[row] = data.tokens;
	    };

	}).call(BackgroundTokenizer.prototype);

	exports.BackgroundTokenizer = BackgroundTokenizer;
	});

	ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var Range = acequire("./range").Range;

	var SearchHighlight = function(regExp, clazz, type) {
	    this.setRegexp(regExp);
	    this.clazz = clazz;
	    this.type = type || "text";
	};

	(function() {
	    this.MAX_RANGES = 500;
	    
	    this.setRegexp = function(regExp) {
	        if (this.regExp+"" == regExp+"")
	            return;
	        this.regExp = regExp;
	        this.cache = [];
	    };

	    this.update = function(html, markerLayer, session, config) {
	        if (!this.regExp)
	            return;
	        var start = config.firstRow, end = config.lastRow;

	        for (var i = start; i <= end; i++) {
	            var ranges = this.cache[i];
	            if (ranges == null) {
	                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
	                if (ranges.length > this.MAX_RANGES)
	                    ranges = ranges.slice(0, this.MAX_RANGES);
	                ranges = ranges.map(function(match) {
	                    return new Range(i, match.offset, i, match.offset + match.length);
	                });
	                this.cache[i] = ranges.length ? ranges : "";
	            }

	            for (var j = ranges.length; j --; ) {
	                markerLayer.drawSingleLineMarker(
	                    html, ranges[j].toScreenRange(session), this.clazz, config);
	            }
	        }
	    };

	}).call(SearchHighlight.prototype);

	exports.SearchHighlight = SearchHighlight;
	});

	ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	function FoldLine(foldData, folds) {
	    this.foldData = foldData;
	    if (Array.isArray(folds)) {
	        this.folds = folds;
	    } else {
	        folds = this.folds = [ folds ];
	    }

	    var last = folds[folds.length - 1];
	    this.range = new Range(folds[0].start.row, folds[0].start.column,
	                           last.end.row, last.end.column);
	    this.start = this.range.start;
	    this.end   = this.range.end;

	    this.folds.forEach(function(fold) {
	        fold.setFoldLine(this);
	    }, this);
	}

	(function() {
	    this.shiftRow = function(shift) {
	        this.start.row += shift;
	        this.end.row += shift;
	        this.folds.forEach(function(fold) {
	            fold.start.row += shift;
	            fold.end.row += shift;
	        });
	    };

	    this.addFold = function(fold) {
	        if (fold.sameRow) {
	            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
	                throw new Error("Can't add a fold to this FoldLine as it has no connection");
	            }
	            this.folds.push(fold);
	            this.folds.sort(function(a, b) {
	                return -a.range.compareEnd(b.start.row, b.start.column);
	            });
	            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
	                this.end.row = fold.end.row;
	                this.end.column =  fold.end.column;
	            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
	                this.start.row = fold.start.row;
	                this.start.column = fold.start.column;
	            }
	        } else if (fold.start.row == this.end.row) {
	            this.folds.push(fold);
	            this.end.row = fold.end.row;
	            this.end.column = fold.end.column;
	        } else if (fold.end.row == this.start.row) {
	            this.folds.unshift(fold);
	            this.start.row = fold.start.row;
	            this.start.column = fold.start.column;
	        } else {
	            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
	        }
	        fold.foldLine = this;
	    };

	    this.containsRow = function(row) {
	        return row >= this.start.row && row <= this.end.row;
	    };

	    this.walk = function(callback, endRow, endColumn) {
	        var lastEnd = 0,
	            folds = this.folds,
	            fold,
	            cmp, stop, isNewRow = true;

	        if (endRow == null) {
	            endRow = this.end.row;
	            endColumn = this.end.column;
	        }

	        for (var i = 0; i < folds.length; i++) {
	            fold = folds[i];

	            cmp = fold.range.compareStart(endRow, endColumn);
	            if (cmp == -1) {
	                callback(null, endRow, endColumn, lastEnd, isNewRow);
	                return;
	            }

	            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
	            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
	            if (stop || cmp === 0) {
	                return;
	            }
	            isNewRow = !fold.sameRow;
	            lastEnd = fold.end.column;
	        }
	        callback(null, endRow, endColumn, lastEnd, isNewRow);
	    };

	    this.getNextFoldTo = function(row, column) {
	        var fold, cmp;
	        for (var i = 0; i < this.folds.length; i++) {
	            fold = this.folds[i];
	            cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                return {
	                    fold: fold,
	                    kind: "after"
	                };
	            } else if (cmp === 0) {
	                return {
	                    fold: fold,
	                    kind: "inside"
	                };
	            }
	        }
	        return null;
	    };

	    this.addRemoveChars = function(row, column, len) {
	        var ret = this.getNextFoldTo(row, column),
	            fold, folds;
	        if (ret) {
	            fold = ret.fold;
	            if (ret.kind == "inside"
	                && fold.start.column != column
	                && fold.start.row != row)
	            {
	                window.console && window.console.log(row, column, fold);
	            } else if (fold.start.row == row) {
	                folds = this.folds;
	                var i = folds.indexOf(fold);
	                if (i === 0) {
	                    this.start.column += len;
	                }
	                for (i; i < folds.length; i++) {
	                    fold = folds[i];
	                    fold.start.column += len;
	                    if (!fold.sameRow) {
	                        return;
	                    }
	                    fold.end.column += len;
	                }
	                this.end.column += len;
	            }
	        }
	    };

	    this.split = function(row, column) {
	        var pos = this.getNextFoldTo(row, column);
	        
	        if (!pos || pos.kind == "inside")
	            return null;
	            
	        var fold = pos.fold;
	        var folds = this.folds;
	        var foldData = this.foldData;
	        
	        var i = folds.indexOf(fold);
	        var foldBefore = folds[i - 1];
	        this.end.row = foldBefore.end.row;
	        this.end.column = foldBefore.end.column;
	        folds = folds.splice(i, folds.length - i);

	        var newFoldLine = new FoldLine(foldData, folds);
	        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
	        return newFoldLine;
	    };

	    this.merge = function(foldLineNext) {
	        var folds = foldLineNext.folds;
	        for (var i = 0; i < folds.length; i++) {
	            this.addFold(folds[i]);
	        }
	        var foldData = this.foldData;
	        foldData.splice(foldData.indexOf(foldLineNext), 1);
	    };

	    this.toString = function() {
	        var ret = [this.range.toString() + ": [" ];

	        this.folds.forEach(function(fold) {
	            ret.push("  " + fold.toString());
	        });
	        ret.push("]");
	        return ret.join("\n");
	    };

	    this.idxToPosition = function(idx) {
	        var lastFoldEndColumn = 0;

	        for (var i = 0; i < this.folds.length; i++) {
	            var fold = this.folds[i];

	            idx -= fold.start.column - lastFoldEndColumn;
	            if (idx < 0) {
	                return {
	                    row: fold.start.row,
	                    column: fold.start.column + idx
	                };
	            }

	            idx -= fold.placeholder.length;
	            if (idx < 0) {
	                return fold.start;
	            }

	            lastFoldEndColumn = fold.end.column;
	        }

	        return {
	            row: this.end.row,
	            column: this.end.column + idx
	        };
	    };
	}).call(FoldLine.prototype);

	exports.FoldLine = FoldLine;
	});

	ace.define("ace/range_list",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";
	var Range = acequire("./range").Range;
	var comparePoints = Range.comparePoints;

	var RangeList = function() {
	    this.ranges = [];
	};

	(function() {
	    this.comparePoints = comparePoints;

	    this.pointIndex = function(pos, excludeEdges, startIndex) {
	        var list = this.ranges;

	        for (var i = startIndex || 0; i < list.length; i++) {
	            var range = list[i];
	            var cmpEnd = comparePoints(pos, range.end);
	            if (cmpEnd > 0)
	                continue;
	            var cmpStart = comparePoints(pos, range.start);
	            if (cmpEnd === 0)
	                return excludeEdges && cmpStart !== 0 ? -i-2 : i;
	            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
	                return i;

	            return -i-1;
	        }
	        return -i - 1;
	    };

	    this.add = function(range) {
	        var excludeEdges = !range.isEmpty();
	        var startIndex = this.pointIndex(range.start, excludeEdges);
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;

	        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);

	        if (endIndex < 0)
	            endIndex = -endIndex - 1;
	        else
	            endIndex++;
	        return this.ranges.splice(startIndex, endIndex - startIndex, range);
	    };

	    this.addList = function(list) {
	        var removed = [];
	        for (var i = list.length; i--; ) {
	            removed.push.call(removed, this.add(list[i]));
	        }
	        return removed;
	    };

	    this.substractPoint = function(pos) {
	        var i = this.pointIndex(pos);

	        if (i >= 0)
	            return this.ranges.splice(i, 1);
	    };
	    this.merge = function() {
	        var removed = [];
	        var list = this.ranges;
	        
	        list = list.sort(function(a, b) {
	            return comparePoints(a.start, b.start);
	        });
	        
	        var next = list[0], range;
	        for (var i = 1; i < list.length; i++) {
	            range = next;
	            next = list[i];
	            var cmp = comparePoints(range.end, next.start);
	            if (cmp < 0)
	                continue;

	            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
	                continue;

	            if (comparePoints(range.end, next.end) < 0) {
	                range.end.row = next.end.row;
	                range.end.column = next.end.column;
	            }

	            list.splice(i, 1);
	            removed.push(next);
	            next = range;
	            i--;
	        }
	        
	        this.ranges = list;

	        return removed;
	    };

	    this.contains = function(row, column) {
	        return this.pointIndex({row: row, column: column}) >= 0;
	    };

	    this.containsPoint = function(pos) {
	        return this.pointIndex(pos) >= 0;
	    };

	    this.rangeAtPoint = function(pos) {
	        var i = this.pointIndex(pos);
	        if (i >= 0)
	            return this.ranges[i];
	    };


	    this.clipRows = function(startRow, endRow) {
	        var list = this.ranges;
	        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
	            return [];

	        var startIndex = this.pointIndex({row: startRow, column: 0});
	        if (startIndex < 0)
	            startIndex = -startIndex - 1;
	        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);
	        if (endIndex < 0)
	            endIndex = -endIndex - 1;

	        var clipped = [];
	        for (var i = startIndex; i < endIndex; i++) {
	            clipped.push(list[i]);
	        }
	        return clipped;
	    };

	    this.removeAll = function() {
	        return this.ranges.splice(0, this.ranges.length);
	    };

	    this.attach = function(session) {
	        if (this.session)
	            this.detach();

	        this.session = session;
	        this.onChange = this.$onChange.bind(this);

	        this.session.on('change', this.onChange);
	    };

	    this.detach = function() {
	        if (!this.session)
	            return;
	        this.session.removeListener('change', this.onChange);
	        this.session = null;
	    };

	    this.$onChange = function(e) {
	        var changeRange = e.data.range;
	        if (e.data.action[0] == "i"){
	            var start = changeRange.start;
	            var end = changeRange.end;
	        } else {
	            var end = changeRange.start;
	            var start = changeRange.end;
	        }
	        var startRow = start.row;
	        var endRow = end.row;
	        var lineDif = endRow - startRow;

	        var colDiff = -start.column + end.column;
	        var ranges = this.ranges;

	        for (var i = 0, n = ranges.length; i < n; i++) {
	            var r = ranges[i];
	            if (r.end.row < startRow)
	                continue;
	            if (r.start.row > startRow)
	                break;

	            if (r.start.row == startRow && r.start.column >= start.column ) {
	                if (r.start.column == start.column && this.$insertRight) {
	                } else {
	                    r.start.column += colDiff;
	                    r.start.row += lineDif;
	                }
	            }
	            if (r.end.row == startRow && r.end.column >= start.column) {
	                if (r.end.column == start.column && this.$insertRight) {
	                    continue;
	                }
	                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                
	                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)
	                        r.end.column -= colDiff;
	                }
	                r.end.column += colDiff;
	                r.end.row += lineDif;
	            }
	        }

	        if (lineDif != 0 && i < n) {
	            for (; i < n; i++) {
	                var r = ranges[i];
	                r.start.row += lineDif;
	                r.end.row += lineDif;
	            }
	        }
	    };

	}).call(RangeList.prototype);

	exports.RangeList = RangeList;
	});

	ace.define("ace/edit_session/fold",["require","exports","module","ace/range","ace/range_list","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var RangeList = acequire("../range_list").RangeList;
	var oop = acequire("../lib/oop")
	var Fold = exports.Fold = function(range, placeholder) {
	    this.foldLine = null;
	    this.placeholder = placeholder;
	    this.range = range;
	    this.start = range.start;
	    this.end = range.end;

	    this.sameRow = range.start.row == range.end.row;
	    this.subFolds = this.ranges = [];
	};

	oop.inherits(Fold, RangeList);

	(function() {

	    this.toString = function() {
	        return '"' + this.placeholder + '" ' + this.range.toString();
	    };

	    this.setFoldLine = function(foldLine) {
	        this.foldLine = foldLine;
	        this.subFolds.forEach(function(fold) {
	            fold.setFoldLine(foldLine);
	        });
	    };

	    this.clone = function() {
	        var range = this.range.clone();
	        var fold = new Fold(range, this.placeholder);
	        this.subFolds.forEach(function(subFold) {
	            fold.subFolds.push(subFold.clone());
	        });
	        fold.collapseChildren = this.collapseChildren;
	        return fold;
	    };

	    this.addSubFold = function(fold) {
	        if (this.range.isEqual(fold))
	            return;

	        if (!this.range.containsRange(fold))
	            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
	        consumeRange(fold, this.start);

	        var row = fold.start.row, column = fold.start.column;
	        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
	            cmp = this.subFolds[i].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        var afterStart = this.subFolds[i];

	        if (cmp == 0)
	            return afterStart.addSubFold(fold);
	        var row = fold.range.end.row, column = fold.range.end.column;
	        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
	            cmp = this.subFolds[j].range.compare(row, column);
	            if (cmp != 1)
	                break;
	        }
	        var afterEnd = this.subFolds[j];

	        if (cmp == 0)
	            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);

	        var consumedFolds = this.subFolds.splice(i, j - i, fold);
	        fold.setFoldLine(this.foldLine);

	        return fold;
	    };
	    
	    this.restoreRange = function(range) {
	        return restoreRange(range, this.start);
	    };

	}).call(Fold.prototype);

	function consumePoint(point, anchor) {
	    point.row -= anchor.row;
	    if (point.row == 0)
	        point.column -= anchor.column;
	}
	function consumeRange(range, anchor) {
	    consumePoint(range.start, anchor);
	    consumePoint(range.end, anchor);
	}
	function restorePoint(point, anchor) {
	    if (point.row == 0)
	        point.column += anchor.column;
	    point.row += anchor.row;
	}
	function restoreRange(range, anchor) {
	    restorePoint(range.start, anchor);
	    restorePoint(range.end, anchor);
	}

	});

	ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var FoldLine = acequire("./fold_line").FoldLine;
	var Fold = acequire("./fold").Fold;
	var TokenIterator = acequire("../token_iterator").TokenIterator;

	function Folding() {
	    this.getFoldAt = function(row, column, side) {
	        var foldLine = this.getFoldLine(row);
	        if (!foldLine)
	            return null;

	        var folds = foldLine.folds;
	        for (var i = 0; i < folds.length; i++) {
	            var fold = folds[i];
	            if (fold.range.contains(row, column)) {
	                if (side == 1 && fold.range.isEnd(row, column)) {
	                    continue;
	                } else if (side == -1 && fold.range.isStart(row, column)) {
	                    continue;
	                }
	                return fold;
	            }
	        }
	    };
	    this.getFoldsInRange = function(range) {
	        var start = range.start;
	        var end = range.end;
	        var foldLines = this.$foldData;
	        var foundFolds = [];

	        start.column += 1;
	        end.column -= 1;

	        for (var i = 0; i < foldLines.length; i++) {
	            var cmp = foldLines[i].range.compareRange(range);
	            if (cmp == 2) {
	                continue;
	            }
	            else if (cmp == -2) {
	                break;
	            }

	            var folds = foldLines[i].folds;
	            for (var j = 0; j < folds.length; j++) {
	                var fold = folds[j];
	                cmp = fold.range.compareRange(range);
	                if (cmp == -2) {
	                    break;
	                } else if (cmp == 2) {
	                    continue;
	                } else
	                if (cmp == 42) {
	                    break;
	                }
	                foundFolds.push(fold);
	            }
	        }
	        start.column -= 1;
	        end.column += 1;

	        return foundFolds;
	    };

	    this.getFoldsInRangeList = function(ranges) {
	        if (Array.isArray(ranges)) {
	            var folds = [];
	            ranges.forEach(function(range) {
	                folds = folds.concat(this.getFoldsInRange(range));
	            }, this);
	        } else {
	            var folds = this.getFoldsInRange(ranges);
	        }
	        return folds;
	    }
	    this.getAllFolds = function() {
	        var folds = [];
	        var foldLines = this.$foldData;
	        
	        for (var i = 0; i < foldLines.length; i++)
	            for (var j = 0; j < foldLines[i].folds.length; j++)
	                folds.push(foldLines[i].folds[j]);

	        return folds;
	    };
	    this.getFoldStringAt = function(row, column, trim, foldLine) {
	        foldLine = foldLine || this.getFoldLine(row);
	        if (!foldLine)
	            return null;

	        var lastFold = {
	            end: { column: 0 }
	        };
	        var str, fold;
	        for (var i = 0; i < foldLine.folds.length; i++) {
	            fold = foldLine.folds[i];
	            var cmp = fold.range.compareEnd(row, column);
	            if (cmp == -1) {
	                str = this
	                    .getLine(fold.start.row)
	                    .substring(lastFold.end.column, fold.start.column);
	                break;
	            }
	            else if (cmp === 0) {
	                return null;
	            }
	            lastFold = fold;
	        }
	        if (!str)
	            str = this.getLine(fold.start.row).substring(lastFold.end.column);

	        if (trim == -1)
	            return str.substring(0, column - lastFold.end.column);
	        else if (trim == 1)
	            return str.substring(column - lastFold.end.column);
	        else
	            return str;
	    };

	    this.getFoldLine = function(docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
	                return foldLine;
	            } else if (foldLine.end.row > docRow) {
	                return null;
	            }
	        }
	        return null;
	    };
	    this.getNextFoldLine = function(docRow, startFoldLine) {
	        var foldData = this.$foldData;
	        var i = 0;
	        if (startFoldLine)
	            i = foldData.indexOf(startFoldLine);
	        if (i == -1)
	            i = 0;
	        for (i; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (foldLine.end.row >= docRow) {
	                return foldLine;
	            }
	        }
	        return null;
	    };

	    this.getFoldedRowCount = function(first, last) {
	        var foldData = this.$foldData, rowCount = last-first+1;
	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i],
	                end = foldLine.end.row,
	                start = foldLine.start.row;
	            if (end >= last) {
	                if(start < last) {
	                    if(start >= first)
	                        rowCount -= last-start;
	                    else
	                        rowCount = 0;//in one fold
	                }
	                break;
	            } else if(end >= first){
	                if (start >= first) //fold inside range
	                    rowCount -=  end-start;
	                else
	                    rowCount -=  end-first+1;
	            }
	        }
	        return rowCount;
	    };

	    this.$addFoldLine = function(foldLine) {
	        this.$foldData.push(foldLine);
	        this.$foldData.sort(function(a, b) {
	            return a.start.row - b.start.row;
	        });
	        return foldLine;
	    };
	    this.addFold = function(placeholder, range) {
	        var foldData = this.$foldData;
	        var added = false;
	        var fold;
	        
	        if (placeholder instanceof Fold)
	            fold = placeholder;
	        else {
	            fold = new Fold(range, placeholder);
	            fold.collapseChildren = range.collapseChildren;
	        }
	        this.$clipRangeToDocument(fold.range);

	        var startRow = fold.start.row;
	        var startColumn = fold.start.column;
	        var endRow = fold.end.row;
	        var endColumn = fold.end.column;
	        if (!(startRow < endRow || 
	            startRow == endRow && startColumn <= endColumn - 2))
	            throw new Error("The range has to be at least 2 characters width");

	        var startFold = this.getFoldAt(startRow, startColumn, 1);
	        var endFold = this.getFoldAt(endRow, endColumn, -1);
	        if (startFold && endFold == startFold)
	            return startFold.addSubFold(fold);

	        if (startFold && !startFold.range.isStart(startRow, startColumn))
	            this.removeFold(startFold);

	        if (endFold && !endFold.range.isEnd(endRow, endColumn))
	            this.removeFold(endFold);
	        var folds = this.getFoldsInRange(fold.range);
	        if (folds.length > 0) {
	            this.removeFolds(folds);
	            folds.forEach(function(subFold) {
	                fold.addSubFold(subFold);
	            });
	        }

	        for (var i = 0; i < foldData.length; i++) {
	            var foldLine = foldData[i];
	            if (endRow == foldLine.start.row) {
	                foldLine.addFold(fold);
	                added = true;
	                break;
	            } else if (startRow == foldLine.end.row) {
	                foldLine.addFold(fold);
	                added = true;
	                if (!fold.sameRow) {
	                    var foldLineNext = foldData[i + 1];
	                    if (foldLineNext && foldLineNext.start.row == endRow) {
	                        foldLine.merge(foldLineNext);
	                        break;
	                    }
	                }
	                break;
	            } else if (endRow <= foldLine.start.row) {
	                break;
	            }
	        }

	        if (!added)
	            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

	        if (this.$useWrapMode)
	            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
	        else
	            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
	        this.$modified = true;
	        this._emit("changeFold", { data: fold, action: "add" });

	        return fold;
	    };

	    this.addFolds = function(folds) {
	        folds.forEach(function(fold) {
	            this.addFold(fold);
	        }, this);
	    };

	    this.removeFold = function(fold) {
	        var foldLine = fold.foldLine;
	        var startRow = foldLine.start.row;
	        var endRow = foldLine.end.row;

	        var foldLines = this.$foldData;
	        var folds = foldLine.folds;
	        if (folds.length == 1) {
	            foldLines.splice(foldLines.indexOf(foldLine), 1);
	        } else
	        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
	            folds.pop();
	            foldLine.end.row = folds[folds.length - 1].end.row;
	            foldLine.end.column = folds[folds.length - 1].end.column;
	        } else
	        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
	            folds.shift();
	            foldLine.start.row = folds[0].start.row;
	            foldLine.start.column = folds[0].start.column;
	        } else
	        if (fold.sameRow) {
	            folds.splice(folds.indexOf(fold), 1);
	        } else
	        {
	            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
	            folds = newFoldLine.folds;
	            folds.shift();
	            newFoldLine.start.row = folds[0].start.row;
	            newFoldLine.start.column = folds[0].start.column;
	        }

	        if (!this.$updating) {
	            if (this.$useWrapMode)
	                this.$updateWrapData(startRow, endRow);
	            else
	                this.$updateRowLengthCache(startRow, endRow);
	        }
	        this.$modified = true;
	        this._emit("changeFold", { data: fold, action: "remove" });
	    };

	    this.removeFolds = function(folds) {
	        var cloneFolds = [];
	        for (var i = 0; i < folds.length; i++) {
	            cloneFolds.push(folds[i]);
	        }

	        cloneFolds.forEach(function(fold) {
	            this.removeFold(fold);
	        }, this);
	        this.$modified = true;
	    };

	    this.expandFold = function(fold) {
	        this.removeFold(fold);
	        fold.subFolds.forEach(function(subFold) {
	            fold.restoreRange(subFold);
	            this.addFold(subFold);
	        }, this);
	        if (fold.collapseChildren > 0) {
	            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);
	        }
	        fold.subFolds = [];
	    };

	    this.expandFolds = function(folds) {
	        folds.forEach(function(fold) {
	            this.expandFold(fold);
	        }, this);
	    };

	    this.unfold = function(location, expandInner) {
	        var range, folds;
	        if (location == null) {
	            range = new Range(0, 0, this.getLength(), 0);
	            expandInner = true;
	        } else if (typeof location == "number")
	            range = new Range(location, 0, location, this.getLine(location).length);
	        else if ("row" in location)
	            range = Range.fromPoints(location, location);
	        else
	            range = location;
	        
	        folds = this.getFoldsInRangeList(range);
	        if (expandInner) {
	            this.removeFolds(folds);
	        } else {
	            var subFolds = folds;
	            while (subFolds.length) {
	                this.expandFolds(subFolds);
	                subFolds = this.getFoldsInRangeList(range);
	            }
	        }
	        if (folds.length)
	            return folds;
	    };
	    this.isRowFolded = function(docRow, startFoldRow) {
	        return !!this.getFoldLine(docRow, startFoldRow);
	    };

	    this.getRowFoldEnd = function(docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.end.row : docRow;
	    };

	    this.getRowFoldStart = function(docRow, startFoldRow) {
	        var foldLine = this.getFoldLine(docRow, startFoldRow);
	        return foldLine ? foldLine.start.row : docRow;
	    };

	    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
	        if (startRow == null)
	            startRow = foldLine.start.row;
	        if (startColumn == null)
	            startColumn = 0;
	        if (endRow == null)
	            endRow = foldLine.end.row;
	        if (endColumn == null)
	            endColumn = this.getLine(endRow).length;
	        var doc = this.doc;
	        var textLine = "";

	        foldLine.walk(function(placeholder, row, column, lastColumn) {
	            if (row < startRow)
	                return;
	            if (row == startRow) {
	                if (column < startColumn)
	                    return;
	                lastColumn = Math.max(startColumn, lastColumn);
	            }

	            if (placeholder != null) {
	                textLine += placeholder;
	            } else {
	                textLine += doc.getLine(row).substring(lastColumn, column);
	            }
	        }, endRow, endColumn);
	        return textLine;
	    };

	    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
	        var foldLine = this.getFoldLine(row);

	        if (!foldLine) {
	            var line;
	            line = this.doc.getLine(row);
	            return line.substring(startColumn || 0, endColumn || line.length);
	        } else {
	            return this.getFoldDisplayLine(
	                foldLine, row, endColumn, startRow, startColumn);
	        }
	    };

	    this.$cloneFoldData = function() {
	        var fd = [];
	        fd = this.$foldData.map(function(foldLine) {
	            var folds = foldLine.folds.map(function(fold) {
	                return fold.clone();
	            });
	            return new FoldLine(fd, folds);
	        });

	        return fd;
	    };

	    this.toggleFold = function(tryToUnfold) {
	        var selection = this.selection;
	        var range = selection.getRange();
	        var fold;
	        var bracketPos;

	        if (range.isEmpty()) {
	            var cursor = range.start;
	            fold = this.getFoldAt(cursor.row, cursor.column);

	            if (fold) {
	                this.expandFold(fold);
	                return;
	            } else if (bracketPos = this.findMatchingBracket(cursor)) {
	                if (range.comparePoint(bracketPos) == 1) {
	                    range.end = bracketPos;
	                } else {
	                    range.start = bracketPos;
	                    range.start.column++;
	                    range.end.column--;
	                }
	            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {
	                if (range.comparePoint(bracketPos) == 1)
	                    range.end = bracketPos;
	                else
	                    range.start = bracketPos;

	                range.start.column++;
	            } else {
	                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
	            }
	        } else {
	            var folds = this.getFoldsInRange(range);
	            if (tryToUnfold && folds.length) {
	                this.expandFolds(folds);
	                return;
	            } else if (folds.length == 1 ) {
	                fold = folds[0];
	            }
	        }

	        if (!fold)
	            fold = this.getFoldAt(range.start.row, range.start.column);

	        if (fold && fold.range.toString() == range.toString()) {
	            this.expandFold(fold);
	            return;
	        }

	        var placeholder = "...";
	        if (!range.isMultiLine()) {
	            placeholder = this.getTextRange(range);
	            if(placeholder.length < 4)
	                return;
	            placeholder = placeholder.trim().substring(0, 2) + "..";
	        }

	        this.addFold(placeholder, range);
	    };

	    this.getCommentFoldRange = function(row, column, dir) {
	        var iterator = new TokenIterator(this, row, column);
	        var token = iterator.getCurrentToken();
	        if (token && /^comment|string/.test(token.type)) {
	            var range = new Range();
	            var re = new RegExp(token.type.replace(/\..*/, "\\."));
	            if (dir != 1) {
	                do {
	                    token = iterator.stepBackward();
	                } while(token && re.test(token.type));
	                iterator.stepForward();
	            }
	            
	            range.start.row = iterator.getCurrentTokenRow();
	            range.start.column = iterator.getCurrentTokenColumn() + 2;

	            iterator = new TokenIterator(this, row, column);
	            
	            if (dir != -1) {
	                do {
	                    token = iterator.stepForward();
	                } while(token && re.test(token.type));
	                token = iterator.stepBackward();
	            } else
	                token = iterator.getCurrentToken();

	            range.end.row = iterator.getCurrentTokenRow();
	            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
	            return range;
	        }
	    };

	    this.foldAll = function(startRow, endRow, depth) {
	        if (depth == undefined)
	            depth = 100000; // JSON.stringify doesn't hanle Infinity
	        var foldWidgets = this.foldWidgets;
	        if (!foldWidgets)
	            return; // mode doesn't support folding
	        endRow = endRow || this.getLength();
	        startRow = startRow || 0;
	        for (var row = startRow; row < endRow; row++) {
	            if (foldWidgets[row] == null)
	                foldWidgets[row] = this.getFoldWidget(row);
	            if (foldWidgets[row] != "start")
	                continue;

	            var range = this.getFoldWidgetRange(row);
	            if (range && range.isMultiLine()
	                && range.end.row <= endRow
	                && range.start.row >= startRow
	            ) {
	                row = range.end.row;
	                try {
	                    var fold = this.addFold("...", range);
	                    if (fold)
	                        fold.collapseChildren = depth;
	                } catch(e) {}
	            }
	        }
	    };
	    this.$foldStyles = {
	        "manual": 1,
	        "markbegin": 1,
	        "markbeginend": 1
	    };
	    this.$foldStyle = "markbegin";
	    this.setFoldStyle = function(style) {
	        if (!this.$foldStyles[style])
	            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
	        
	        if (this.$foldStyle == style)
	            return;

	        this.$foldStyle = style;
	        
	        if (style == "manual")
	            this.unfold();
	        var mode = this.$foldMode;
	        this.$setFolding(null);
	        this.$setFolding(mode);
	    };

	    this.$setFolding = function(foldMode) {
	        if (this.$foldMode == foldMode)
	            return;
	            
	        this.$foldMode = foldMode;
	        
	        this.off('change', this.$updateFoldWidgets);
	        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	        this._emit("changeAnnotation");
	        
	        if (!foldMode || this.$foldStyle == "manual") {
	            this.foldWidgets = null;
	            return;
	        }
	        
	        this.foldWidgets = [];
	        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
	        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
	        
	        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
	        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
	        this.on('change', this.$updateFoldWidgets);
	        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
	    };

	    this.getParentFoldRangeData = function (row, ignoreCurrent) {
	        var fw = this.foldWidgets;
	        if (!fw || (ignoreCurrent && fw[row]))
	            return {};

	        var i = row - 1, firstRange;
	        while (i >= 0) {
	            var c = fw[i];
	            if (c == null)
	                c = fw[i] = this.getFoldWidget(i);

	            if (c == "start") {
	                var range = this.getFoldWidgetRange(i);
	                if (!firstRange)
	                    firstRange = range;
	                if (range && range.end.row >= row)
	                    break;
	            }
	            i--;
	        }

	        return {
	            range: i !== -1 && range,
	            firstRange: firstRange
	        };
	    }

	    this.onFoldWidgetClick = function(row, e) {
	        e = e.domEvent;
	        var options = {
	            children: e.shiftKey,
	            all: e.ctrlKey || e.metaKey,
	            siblings: e.altKey
	        };
	        
	        var range = this.$toggleFoldWidget(row, options);
	        if (!range) {
	            var el = (e.target || e.srcElement)
	            if (el && /ace_fold-widget/.test(el.className))
	                el.className += " ace_invalid";
	        }
	    };
	    
	    this.$toggleFoldWidget = function(row, options) {
	        if (!this.getFoldWidget)
	            return;
	        var type = this.getFoldWidget(row);
	        var line = this.getLine(row);

	        var dir = type === "end" ? -1 : 1;
	        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

	        if (fold) {
	            if (options.children || options.all)
	                this.removeFold(fold);
	            else
	                this.expandFold(fold);
	            return;
	        }

	        var range = this.getFoldWidgetRange(row, true);
	        if (range && !range.isMultiLine()) {
	            fold = this.getFoldAt(range.start.row, range.start.column, 1);
	            if (fold && range.isEqual(fold.range)) {
	                this.removeFold(fold);
	                return;
	            }
	        }
	        
	        if (options.siblings) {
	            var data = this.getParentFoldRangeData(row);
	            if (data.range) {
	                var startRow = data.range.start.row + 1;
	                var endRow = data.range.end.row;
	            }
	            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
	        } else if (options.children) {
	            endRow = range ? range.end.row : this.getLength();
	            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
	        } else if (range) {
	            if (options.all) 
	                range.collapseChildren = 10000;
	            this.addFold("...", range);
	        }
	        
	        return range;
	    };
	    
	    
	    
	    this.toggleFoldWidget = function(toggleParent) {
	        var row = this.selection.getCursor().row;
	        row = this.getRowFoldStart(row);
	        var range = this.$toggleFoldWidget(row, {});
	        
	        if (range)
	            return;
	        var data = this.getParentFoldRangeData(row, true);
	        range = data.range || data.firstRange;
	        
	        if (range) {
	            row = range.start.row;
	            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

	            if (fold) {
	                this.removeFold(fold);
	            } else {
	                this.addFold("...", range);
	            }
	        }
	    };

	    this.updateFoldWidgets = function(e) {
	        var delta = e.data;
	        var range = delta.range;
	        var firstRow = range.start.row;
	        var len = range.end.row - firstRow;

	        if (len === 0) {
	            this.foldWidgets[firstRow] = null;
	        } else if (delta.action == "removeText" || delta.action == "removeLines") {
	            this.foldWidgets.splice(firstRow, len + 1, null);
	        } else {
	            var args = Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.foldWidgets.splice.apply(this.foldWidgets, args);
	        }
	    };
	    this.tokenizerUpdateFoldWidgets = function(e) {
	        var rows = e.data;
	        if (rows.first != rows.last) {
	            if (this.foldWidgets.length > rows.first)
	                this.foldWidgets.splice(rows.first, this.foldWidgets.length);
	        }
	    }
	}

	exports.Folding = Folding;

	});

	ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"], function(acequire, exports, module) {
	"use strict";

	var TokenIterator = acequire("../token_iterator").TokenIterator;
	var Range = acequire("../range").Range;


	function BracketMatch() {

	    this.findMatchingBracket = function(position, chr) {
	        if (position.column == 0) return null;

	        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);
	        if (charBeforeCursor == "") return null;

	        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match)
	            return null;

	        if (match[1])
	            return this.$findClosingBracket(match[1], position);
	        else
	            return this.$findOpeningBracket(match[2], position);
	    };
	    
	    this.getBracketRange = function(pos) {
	        var line = this.getLine(pos.row);
	        var before = true, range;

	        var chr = line.charAt(pos.column-1);
	        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	        if (!match) {
	            chr = line.charAt(pos.column);
	            pos = {row: pos.row, column: pos.column + 1};
	            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
	            before = false;
	        }
	        if (!match)
	            return null;

	        if (match[1]) {
	            var bracketPos = this.$findClosingBracket(match[1], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(pos, bracketPos);
	            if (!before) {
	                range.end.column++;
	                range.start.column--;
	            }
	            range.cursor = range.end;
	        } else {
	            var bracketPos = this.$findOpeningBracket(match[2], pos);
	            if (!bracketPos)
	                return null;
	            range = Range.fromPoints(bracketPos, pos);
	            if (!before) {
	                range.start.column++;
	                range.end.column--;
	            }
	            range.cursor = range.start;
	        }
	        
	        return range;
	    };

	    this.$brackets = {
	        ")": "(",
	        "(": ")",
	        "]": "[",
	        "[": "]",
	        "{": "}",
	        "}": "{"
	    };

	    this.$findOpeningBracket = function(bracket, position, typeRe) {
	        var openBracket = this.$brackets[bracket];
	        var depth = 1;

	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;
	        
	         if (!typeRe){
	            typeRe = new RegExp(
	                "(\\.?" +
	                token.type.replace(".", "\\.").replace("rparen", ".paren")
	                    .replace(/\b(?:end|start|begin)\b/, "")
	                + ")+"
	            );
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
	        var value = token.value;
	        
	        while (true) {
	        
	            while (valueIndex >= 0) {
	                var chr = value.charAt(valueIndex);
	                if (chr == openBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return {row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn()};
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex -= 1;
	            }
	            do {
	                token = iterator.stepBackward();
	            } while (token && !typeRe.test(token.type));

	            if (token == null)
	                break;
	                
	            value = token.value;
	            valueIndex = value.length - 1;
	        }
	        
	        return null;
	    };

	    this.$findClosingBracket = function(bracket, position, typeRe) {
	        var closingBracket = this.$brackets[bracket];
	        var depth = 1;

	        var iterator = new TokenIterator(this, position.row, position.column);
	        var token = iterator.getCurrentToken();
	        if (!token)
	            token = iterator.stepForward();
	        if (!token)
	            return;

	        if (!typeRe){
	            typeRe = new RegExp(
	                "(\\.?" +
	                token.type.replace(".", "\\.").replace("lparen", ".paren")
	                    .replace(/\b(?:end|start|begin)\b/, "")
	                + ")+"
	            );
	        }
	        var valueIndex = position.column - iterator.getCurrentTokenColumn();

	        while (true) {

	            var value = token.value;
	            var valueLength = value.length;
	            while (valueIndex < valueLength) {
	                var chr = value.charAt(valueIndex);
	                if (chr == closingBracket) {
	                    depth -= 1;
	                    if (depth == 0) {
	                        return {row: iterator.getCurrentTokenRow(),
	                            column: valueIndex + iterator.getCurrentTokenColumn()};
	                    }
	                }
	                else if (chr == bracket) {
	                    depth += 1;
	                }
	                valueIndex += 1;
	            }
	            do {
	                token = iterator.stepForward();
	            } while (token && !typeRe.test(token.type));

	            if (token == null)
	                break;

	            valueIndex = 0;
	        }
	        
	        return null;
	    };
	}
	exports.BracketMatch = BracketMatch;

	});

	ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var lang = acequire("./lib/lang");
	var config = acequire("./config");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var Selection = acequire("./selection").Selection;
	var TextMode = acequire("./mode/text").Mode;
	var Range = acequire("./range").Range;
	var Document = acequire("./document").Document;
	var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
	var SearchHighlight = acequire("./search_highlight").SearchHighlight;

	var EditSession = function(text, mode) {
	    this.$breakpoints = [];
	    this.$decorations = [];
	    this.$frontMarkers = {};
	    this.$backMarkers = {};
	    this.$markerId = 1;
	    this.$undoSelect = true;

	    this.$foldData = [];
	    this.$foldData.toString = function() {
	        return this.join("\n");
	    }
	    this.on("changeFold", this.onChangeFold.bind(this));
	    this.$onChange = this.onChange.bind(this);

	    if (typeof text != "object" || !text.getLine)
	        text = new Document(text);

	    this.setDocument(text);
	    this.selection = new Selection(this);

	    config.resetOptions(this);
	    this.setMode(mode);
	    config._signal("session", this);
	};


	(function() {

	    oop.implement(this, EventEmitter);
	    this.setDocument = function(doc) {
	        if (this.doc)
	            this.doc.removeListener("change", this.$onChange);

	        this.doc = doc;
	        doc.on("change", this.$onChange);

	        if (this.bgTokenizer)
	            this.bgTokenizer.setDocument(this.getDocument());

	        this.resetCaches();
	    };
	    this.getDocument = function() {
	        return this.doc;
	    };
	    this.$resetRowCache = function(docRow) {
	        if (!docRow) {
	            this.$docRowCache = [];
	            this.$screenRowCache = [];
	            return;
	        }
	        var l = this.$docRowCache.length;
	        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
	        if (l > i) {
	            this.$docRowCache.splice(i, l);
	            this.$screenRowCache.splice(i, l);
	        }
	    };

	    this.$getRowCacheIndex = function(cacheArray, val) {
	        var low = 0;
	        var hi = cacheArray.length - 1;

	        while (low <= hi) {
	            var mid = (low + hi) >> 1;
	            var c = cacheArray[mid];

	            if (val > c)
	                low = mid + 1;
	            else if (val < c)
	                hi = mid - 1;
	            else
	                return mid;
	        }

	        return low -1;
	    };

	    this.resetCaches = function() {
	        this.$modified = true;
	        this.$wrapData = [];
	        this.$rowLengthCache = [];
	        this.$resetRowCache(0);
	        if (this.bgTokenizer)
	            this.bgTokenizer.start(0);
	    };

	    this.onChangeFold = function(e) {
	        var fold = e.data;
	        this.$resetRowCache(fold.start.row);
	    };

	    this.onChange = function(e) {
	        var delta = e.data;
	        this.$modified = true;

	        this.$resetRowCache(delta.range.start.row);

	        var removedFolds = this.$updateInternalDataOnChange(e);
	        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
	            this.$deltasDoc.push(delta);
	            if (removedFolds && removedFolds.length != 0) {
	                this.$deltasFold.push({
	                    action: "removeFolds",
	                    folds:  removedFolds
	                });
	            }

	            this.$informUndoManager.schedule();
	        }

	        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
	        this._signal("change", e);
	    };
	    this.setValue = function(text) {
	        this.doc.setValue(text);
	        this.selection.moveTo(0, 0);

	        this.$resetRowCache(0);
	        this.$deltas = [];
	        this.$deltasDoc = [];
	        this.$deltasFold = [];
	        this.setUndoManager(this.$undoManager);
	        this.getUndoManager().reset();
	    };
	    this.getValue =
	    this.toString = function() {
	        return this.doc.getValue();
	    };
	    this.getSelection = function() {
	        return this.selection;
	    };
	    this.getState = function(row) {
	        return this.bgTokenizer.getState(row);
	    };
	    this.getTokens = function(row) {
	        return this.bgTokenizer.getTokens(row);
	    };
	    this.getTokenAt = function(row, column) {
	        var tokens = this.bgTokenizer.getTokens(row);
	        var token, c = 0;
	        if (column == null) {
	            i = tokens.length - 1;
	            c = this.getLine(row).length;
	        } else {
	            for (var i = 0; i < tokens.length; i++) {
	                c += tokens[i].value.length;
	                if (c >= column)
	                    break;
	            }
	        }
	        token = tokens[i];
	        if (!token)
	            return null;
	        token.index = i;
	        token.start = c - token.value.length;
	        return token;
	    };
	    this.setUndoManager = function(undoManager) {
	        this.$undoManager = undoManager;
	        this.$deltas = [];
	        this.$deltasDoc = [];
	        this.$deltasFold = [];

	        if (this.$informUndoManager)
	            this.$informUndoManager.cancel();

	        if (undoManager) {
	            var self = this;

	            this.$syncInformUndoManager = function() {
	                self.$informUndoManager.cancel();

	                if (self.$deltasFold.length) {
	                    self.$deltas.push({
	                        group: "fold",
	                        deltas: self.$deltasFold
	                    });
	                    self.$deltasFold = [];
	                }

	                if (self.$deltasDoc.length) {
	                    self.$deltas.push({
	                        group: "doc",
	                        deltas: self.$deltasDoc
	                    });
	                    self.$deltasDoc = [];
	                }

	                if (self.$deltas.length > 0) {
	                    undoManager.execute({
	                        action: "aceupdate",
	                        args: [self.$deltas, self],
	                        merge: self.mergeUndoDeltas
	                    });
	                }
	                self.mergeUndoDeltas = false;
	                self.$deltas = [];
	            };
	            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
	        }
	    };
	    this.markUndoGroup = function() {
	        if (this.$syncInformUndoManager)
	            this.$syncInformUndoManager();
	    };
	    
	    this.$defaultUndoManager = {
	        undo: function() {},
	        redo: function() {},
	        reset: function() {}
	    };
	    this.getUndoManager = function() {
	        return this.$undoManager || this.$defaultUndoManager;
	    };
	    this.getTabString = function() {
	        if (this.getUseSoftTabs()) {
	            return lang.stringRepeat(" ", this.getTabSize());
	        } else {
	            return "\t";
	        }
	    };
	    this.setUseSoftTabs = function(val) {
	        this.setOption("useSoftTabs", val);
	    };
	    this.getUseSoftTabs = function() {
	        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
	    };
	    this.setTabSize = function(tabSize) {
	        this.setOption("tabSize", tabSize);
	    };
	    this.getTabSize = function() {
	        return this.$tabSize;
	    };
	    this.isTabStop = function(position) {
	        return this.$useSoftTabs && (position.column % this.$tabSize === 0);
	    };

	    this.$overwrite = false;
	    this.setOverwrite = function(overwrite) {
	        this.setOption("overwrite", overwrite);
	    };
	    this.getOverwrite = function() {
	        return this.$overwrite;
	    };
	    this.toggleOverwrite = function() {
	        this.setOverwrite(!this.$overwrite);
	    };
	    this.addGutterDecoration = function(row, className) {
	        if (!this.$decorations[row])
	            this.$decorations[row] = "";
	        this.$decorations[row] += " " + className;
	        this._signal("changeBreakpoint", {});
	    };
	    this.removeGutterDecoration = function(row, className) {
	        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
	        this._signal("changeBreakpoint", {});
	    };
	    this.getBreakpoints = function() {
	        return this.$breakpoints;
	    };
	    this.setBreakpoints = function(rows) {
	        this.$breakpoints = [];
	        for (var i=0; i<rows.length; i++) {
	            this.$breakpoints[rows[i]] = "ace_breakpoint";
	        }
	        this._signal("changeBreakpoint", {});
	    };
	    this.clearBreakpoints = function() {
	        this.$breakpoints = [];
	        this._signal("changeBreakpoint", {});
	    };
	    this.setBreakpoint = function(row, className) {
	        if (className === undefined)
	            className = "ace_breakpoint";
	        if (className)
	            this.$breakpoints[row] = className;
	        else
	            delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    this.clearBreakpoint = function(row) {
	        delete this.$breakpoints[row];
	        this._signal("changeBreakpoint", {});
	    };
	    this.addMarker = function(range, clazz, type, inFront) {
	        var id = this.$markerId++;

	        var marker = {
	            range : range,
	            type : type || "line",
	            renderer: typeof type == "function" ? type : null,
	            clazz : clazz,
	            inFront: !!inFront,
	            id: id
	        };

	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        } else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }

	        return id;
	    };
	    this.addDynamicMarker = function(marker, inFront) {
	        if (!marker.update)
	            return;
	        var id = this.$markerId++;
	        marker.id = id;
	        marker.inFront = !!inFront;

	        if (inFront) {
	            this.$frontMarkers[id] = marker;
	            this._signal("changeFrontMarker");
	        } else {
	            this.$backMarkers[id] = marker;
	            this._signal("changeBackMarker");
	        }

	        return marker;
	    };
	    this.removeMarker = function(markerId) {
	        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
	        if (!marker)
	            return;

	        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
	        if (marker) {
	            delete (markers[markerId]);
	            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
	        }
	    };
	    this.getMarkers = function(inFront) {
	        return inFront ? this.$frontMarkers : this.$backMarkers;
	    };

	    this.highlight = function(re) {
	        if (!this.$searchHighlight) {
	            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
	            this.$searchHighlight = this.addDynamicMarker(highlight);
	        }
	        this.$searchHighlight.setRegexp(re);
	    };
	    this.highlightLines = function(startRow, endRow, clazz, inFront) {
	        if (typeof endRow != "number") {
	            clazz = endRow;
	            endRow = startRow;
	        }
	        if (!clazz)
	            clazz = "ace_step";

	        var range = new Range(startRow, 0, endRow, Infinity);
	        range.id = this.addMarker(range, clazz, "fullLine", inFront);
	        return range;
	    };
	    this.setAnnotations = function(annotations) {
	        this.$annotations = annotations;
	        this._signal("changeAnnotation", {});
	    };
	    this.getAnnotations = function() {
	        return this.$annotations || [];
	    };
	    this.clearAnnotations = function() {
	        this.setAnnotations([]);
	    };
	    this.$detectNewLine = function(text) {
	        var match = text.match(/^.*?(\r?\n)/m);
	        if (match) {
	            this.$autoNewLine = match[1];
	        } else {
	            this.$autoNewLine = "\n";
	        }
	    };
	    this.getWordRange = function(row, column) {
	        var line = this.getLine(row);

	        var inToken = false;
	        if (column > 0)
	            inToken = !!line.charAt(column - 1).match(this.tokenRe);

	        if (!inToken)
	            inToken = !!line.charAt(column).match(this.tokenRe);

	        if (inToken)
	            var re = this.tokenRe;
	        else if (/^\s+$/.test(line.slice(column-1, column+1)))
	            var re = /\s/;
	        else
	            var re = this.nonTokenRe;

	        var start = column;
	        if (start > 0) {
	            do {
	                start--;
	            }
	            while (start >= 0 && line.charAt(start).match(re));
	            start++;
	        }

	        var end = column;
	        while (end < line.length && line.charAt(end).match(re)) {
	            end++;
	        }

	        return new Range(row, start, row, end);
	    };
	    this.getAWordRange = function(row, column) {
	        var wordRange = this.getWordRange(row, column);
	        var line = this.getLine(wordRange.end.row);

	        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
	            wordRange.end.column += 1;
	        }
	        return wordRange;
	    };
	    this.setNewLineMode = function(newLineMode) {
	        this.doc.setNewLineMode(newLineMode);
	    };
	    this.getNewLineMode = function() {
	        return this.doc.getNewLineMode();
	    };
	    this.setUseWorker = function(useWorker) { this.setOption("useWorker", useWorker); };
	    this.getUseWorker = function() { return this.$useWorker; };
	    this.onReloadTokenizer = function(e) {
	        var rows = e.data;
	        this.bgTokenizer.start(rows.first);
	        this._signal("tokenizerUpdate", e);
	    };

	    this.$modes = {};
	    this.$mode = null;
	    this.$modeId = null;
	    this.setMode = function(mode, cb) {
	        if (mode && typeof mode === "object") {
	            if (mode.getTokenizer)
	                return this.$onChangeMode(mode);
	            var options = mode;
	            var path = options.path;
	        } else {
	            path = mode || "ace/mode/text";
	        }
	        if (!this.$modes["ace/mode/text"])
	            this.$modes["ace/mode/text"] = new TextMode();

	        if (this.$modes[path] && !options) {
	            this.$onChangeMode(this.$modes[path]);
	            cb && cb();
	            return;
	        }
	        this.$modeId = path;
	        config.loadModule(["mode", path], function(m) {
	            if (this.$modeId !== path)
	                return cb && cb();
	            if (this.$modes[path] && !options) {
	                this.$onChangeMode(this.$modes[path]);
	            } else if (m && m.Mode) {
	                m = new m.Mode(options);
	                if (!options) {
	                    this.$modes[path] = m;
	                    m.$id = path;
	                }
	                this.$onChangeMode(m);
	            }
	            cb && cb();
	        }.bind(this));
	        if (!this.$mode)
	            this.$onChangeMode(this.$modes["ace/mode/text"], true);
	    };

	    this.$onChangeMode = function(mode, $isPlaceholder) {
	        if (!$isPlaceholder)
	            this.$modeId = mode.$id;
	        if (this.$mode === mode) 
	            return;

	        this.$mode = mode;

	        this.$stopWorker();

	        if (this.$useWorker)
	            this.$startWorker();

	        var tokenizer = mode.getTokenizer();

	        if(tokenizer.addEventListener !== undefined) {
	            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
	            tokenizer.addEventListener("update", onReloadTokenizer);
	        }

	        if (!this.bgTokenizer) {
	            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
	            var _self = this;
	            this.bgTokenizer.addEventListener("update", function(e) {
	                _self._signal("tokenizerUpdate", e);
	            });
	        } else {
	            this.bgTokenizer.setTokenizer(tokenizer);
	        }

	        this.bgTokenizer.setDocument(this.getDocument());

	        this.tokenRe = mode.tokenRe;
	        this.nonTokenRe = mode.nonTokenRe;

	        
	        if (!$isPlaceholder) {
	            if (mode.attachToSession)
	                mode.attachToSession(this);
	            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
	            this.$setFolding(mode.foldingRules);
	            this.bgTokenizer.start(0);
	            this._emit("changeMode");
	        }
	    };

	    this.$stopWorker = function() {
	        if (this.$worker) {
	            this.$worker.terminate();
	            this.$worker = null;
	        }
	    };

	    this.$startWorker = function() {
	        try {
	            this.$worker = this.$mode.createWorker(this);
	        } catch (e) {
	            config.warn("Could not load worker", e);
	            this.$worker = null;
	        }
	    };
	    this.getMode = function() {
	        return this.$mode;
	    };

	    this.$scrollTop = 0;
	    this.setScrollTop = function(scrollTop) {
	        if (this.$scrollTop === scrollTop || isNaN(scrollTop))
	            return;

	        this.$scrollTop = scrollTop;
	        this._signal("changeScrollTop", scrollTop);
	    };
	    this.getScrollTop = function() {
	        return this.$scrollTop;
	    };

	    this.$scrollLeft = 0;
	    this.setScrollLeft = function(scrollLeft) {
	        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
	            return;

	        this.$scrollLeft = scrollLeft;
	        this._signal("changeScrollLeft", scrollLeft);
	    };
	    this.getScrollLeft = function() {
	        return this.$scrollLeft;
	    };
	    this.getScreenWidth = function() {
	        this.$computeWidth();
	        if (this.lineWidgets) 
	            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
	        return this.screenWidth;
	    };
	    
	    this.getLineWidgetMaxWidth = function() {
	        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
	        var width = 0;
	        this.lineWidgets.forEach(function(w) {
	            if (w && w.screenWidth > width)
	                width = w.screenWidth;
	        });
	        return this.lineWidgetWidth = width;
	    };

	    this.$computeWidth = function(force) {
	        if (this.$modified || force) {
	            this.$modified = false;

	            if (this.$useWrapMode)
	                return this.screenWidth = this.$wrapLimit;

	            var lines = this.doc.getAllLines();
	            var cache = this.$rowLengthCache;
	            var longestScreenLine = 0;
	            var foldIndex = 0;
	            var foldLine = this.$foldData[foldIndex];
	            var foldStart = foldLine ? foldLine.start.row : Infinity;
	            var len = lines.length;

	            for (var i = 0; i < len; i++) {
	                if (i > foldStart) {
	                    i = foldLine.end.row + 1;
	                    if (i >= len)
	                        break;
	                    foldLine = this.$foldData[foldIndex++];
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }

	                if (cache[i] == null)
	                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

	                if (cache[i] > longestScreenLine)
	                    longestScreenLine = cache[i];
	            }
	            this.screenWidth = longestScreenLine;
	        }
	    };
	    this.getLine = function(row) {
	        return this.doc.getLine(row);
	    };
	    this.getLines = function(firstRow, lastRow) {
	        return this.doc.getLines(firstRow, lastRow);
	    };
	    this.getLength = function() {
	        return this.doc.getLength();
	    };
	    this.getTextRange = function(range) {
	        return this.doc.getTextRange(range || this.selection.getRange());
	    };
	    this.insert = function(position, text) {
	        return this.doc.insert(position, text);
	    };
	    this.remove = function(range) {
	        return this.doc.remove(range);
	    };
	    this.undoChanges = function(deltas, dontSelect) {
	        if (!deltas.length)
	            return;

	        this.$fromUndo = true;
	        var lastUndoRange = null;
	        for (var i = deltas.length - 1; i != -1; i--) {
	            var delta = deltas[i];
	            if (delta.group == "doc") {
	                this.doc.revertDeltas(delta.deltas);
	                lastUndoRange =
	                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
	            } else {
	                delta.deltas.forEach(function(foldDelta) {
	                    this.addFolds(foldDelta.folds);
	                }, this);
	            }
	        }
	        this.$fromUndo = false;
	        lastUndoRange &&
	            this.$undoSelect &&
	            !dontSelect &&
	            this.selection.setSelectionRange(lastUndoRange);
	        return lastUndoRange;
	    };
	    this.redoChanges = function(deltas, dontSelect) {
	        if (!deltas.length)
	            return;

	        this.$fromUndo = true;
	        var lastUndoRange = null;
	        for (var i = 0; i < deltas.length; i++) {
	            var delta = deltas[i];
	            if (delta.group == "doc") {
	                this.doc.applyDeltas(delta.deltas);
	                lastUndoRange =
	                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
	            }
	        }
	        this.$fromUndo = false;
	        lastUndoRange &&
	            this.$undoSelect &&
	            !dontSelect &&
	            this.selection.setSelectionRange(lastUndoRange);
	        return lastUndoRange;
	    };
	    this.setUndoSelect = function(enable) {
	        this.$undoSelect = enable;
	    };

	    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
	        function isInsert(delta) {
	            var insert =
	                delta.action === "insertText" || delta.action === "insertLines";
	            return isUndo ? !insert : insert;
	        }

	        var delta = deltas[0];
	        var range, point;
	        var lastDeltaIsInsert = false;
	        if (isInsert(delta)) {
	            range = Range.fromPoints(delta.range.start, delta.range.end);
	            lastDeltaIsInsert = true;
	        } else {
	            range = Range.fromPoints(delta.range.start, delta.range.start);
	            lastDeltaIsInsert = false;
	        }

	        for (var i = 1; i < deltas.length; i++) {
	            delta = deltas[i];
	            if (isInsert(delta)) {
	                point = delta.range.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range.setStart(delta.range.start);
	                }
	                point = delta.range.end;
	                if (range.compare(point.row, point.column) == 1) {
	                    range.setEnd(delta.range.end);
	                }
	                lastDeltaIsInsert = true;
	            } else {
	                point = delta.range.start;
	                if (range.compare(point.row, point.column) == -1) {
	                    range =
	                        Range.fromPoints(delta.range.start, delta.range.start);
	                }
	                lastDeltaIsInsert = false;
	            }
	        }
	        if (lastUndoRange != null) {
	            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
	                lastUndoRange.start.column += range.end.column - range.start.column;
	                lastUndoRange.end.column += range.end.column - range.start.column;
	            }

	            var cmp = lastUndoRange.compareRange(range);
	            if (cmp == 1) {
	                range.setStart(lastUndoRange.start);
	            } else if (cmp == -1) {
	                range.setEnd(lastUndoRange.end);
	            }
	        }

	        return range;
	    };
	    this.replace = function(range, text) {
	        return this.doc.replace(range, text);
	    };
	    this.moveText = function(fromRange, toPosition, copy) {
	        var text = this.getTextRange(fromRange);
	        var folds = this.getFoldsInRange(fromRange);

	        var toRange = Range.fromPoints(toPosition, toPosition);
	        if (!copy) {
	            this.remove(fromRange);
	            var rowDiff = fromRange.start.row - fromRange.end.row;
	            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
	            if (collDiff) {
	                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
	                    toRange.start.column += collDiff;
	                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
	                    toRange.end.column += collDiff;
	            }
	            if (rowDiff && toRange.start.row >= fromRange.end.row) {
	                toRange.start.row += rowDiff;
	                toRange.end.row += rowDiff;
	            }
	        }

	        toRange.end = this.insert(toRange.start, text);
	        if (folds.length) {
	            var oldStart = fromRange.start;
	            var newStart = toRange.start;
	            var rowDiff = newStart.row - oldStart.row;
	            var collDiff = newStart.column - oldStart.column;
	            this.addFolds(folds.map(function(x) {
	                x = x.clone();
	                if (x.start.row == oldStart.row)
	                    x.start.column += collDiff;
	                if (x.end.row == oldStart.row)
	                    x.end.column += collDiff;
	                x.start.row += rowDiff;
	                x.end.row += rowDiff;
	                return x;
	            }));
	        }

	        return toRange;
	    };
	    this.indentRows = function(startRow, endRow, indentString) {
	        indentString = indentString.replace(/\t/g, this.getTabString());
	        for (var row=startRow; row<=endRow; row++)
	            this.insert({row: row, column:0}, indentString);
	    };
	    this.outdentRows = function (range) {
	        var rowRange = range.collapseRows();
	        var deleteRange = new Range(0, 0, 0, 0);
	        var size = this.getTabSize();

	        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
	            var line = this.getLine(i);

	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            for (var j = 0; j < size; ++j)
	                if (line.charAt(j) != ' ')
	                    break;
	            if (j < size && line.charAt(j) == '\t') {
	                deleteRange.start.column = j;
	                deleteRange.end.column = j + 1;
	            } else {
	                deleteRange.start.column = 0;
	                deleteRange.end.column = j;
	            }
	            this.remove(deleteRange);
	        }
	    };

	    this.$moveLines = function(firstRow, lastRow, dir) {
	        firstRow = this.getRowFoldStart(firstRow);
	        lastRow = this.getRowFoldEnd(lastRow);
	        if (dir < 0) {
	            var row = this.getRowFoldStart(firstRow + dir);
	            if (row < 0) return 0;
	            var diff = row-firstRow;
	        } else if (dir > 0) {
	            var row = this.getRowFoldEnd(lastRow + dir);
	            if (row > this.doc.getLength()-1) return 0;
	            var diff = row-lastRow;
	        } else {
	            firstRow = this.$clipRowToDocument(firstRow);
	            lastRow = this.$clipRowToDocument(lastRow);
	            var diff = lastRow - firstRow + 1;
	        }

	        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
	        var folds = this.getFoldsInRange(range).map(function(x){
	            x = x.clone();
	            x.start.row += diff;
	            x.end.row += diff;
	            return x;
	        });

	        var lines = dir == 0
	            ? this.doc.getLines(firstRow, lastRow)
	            : this.doc.removeLines(firstRow, lastRow);
	        this.doc.insertLines(firstRow+diff, lines);
	        folds.length && this.addFolds(folds);
	        return diff;
	    };
	    this.moveLinesUp = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, -1);
	    };
	    this.moveLinesDown = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 1);
	    };
	    this.duplicateLines = function(firstRow, lastRow) {
	        return this.$moveLines(firstRow, lastRow, 0);
	    };


	    this.$clipRowToDocument = function(row) {
	        return Math.max(0, Math.min(row, this.doc.getLength()-1));
	    };

	    this.$clipColumnToRow = function(row, column) {
	        if (column < 0)
	            return 0;
	        return Math.min(this.doc.getLine(row).length, column);
	    };


	    this.$clipPositionToDocument = function(row, column) {
	        column = Math.max(0, column);

	        if (row < 0) {
	            row = 0;
	            column = 0;
	        } else {
	            var len = this.doc.getLength();
	            if (row >= len) {
	                row = len - 1;
	                column = this.doc.getLine(len-1).length;
	            } else {
	                column = Math.min(this.doc.getLine(row).length, column);
	            }
	        }

	        return {
	            row: row,
	            column: column
	        };
	    };

	    this.$clipRangeToDocument = function(range) {
	        if (range.start.row < 0) {
	            range.start.row = 0;
	            range.start.column = 0;
	        } else {
	            range.start.column = this.$clipColumnToRow(
	                range.start.row,
	                range.start.column
	            );
	        }

	        var len = this.doc.getLength() - 1;
	        if (range.end.row > len) {
	            range.end.row = len;
	            range.end.column = this.doc.getLine(len).length;
	        } else {
	            range.end.column = this.$clipColumnToRow(
	                range.end.row,
	                range.end.column
	            );
	        }
	        return range;
	    };
	    this.$wrapLimit = 80;
	    this.$useWrapMode = false;
	    this.$wrapLimitRange = {
	        min : null,
	        max : null
	    };
	    this.setUseWrapMode = function(useWrapMode) {
	        if (useWrapMode != this.$useWrapMode) {
	            this.$useWrapMode = useWrapMode;
	            this.$modified = true;
	            this.$resetRowCache(0);
	            if (useWrapMode) {
	                var len = this.getLength();
	                this.$wrapData = Array(len);
	                this.$updateWrapData(0, len - 1);
	            }

	            this._signal("changeWrapMode");
	        }
	    };
	    this.getUseWrapMode = function() {
	        return this.$useWrapMode;
	    };
	    this.setWrapLimitRange = function(min, max) {
	        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
	            this.$wrapLimitRange = { min: min, max: max };
	            this.$modified = true;
	            if (this.$useWrapMode)
	                this._signal("changeWrapMode");
	        }
	    };
	    this.adjustWrapLimit = function(desiredLimit, $printMargin) {
	        var limits = this.$wrapLimitRange;
	        if (limits.max < 0)
	            limits = {min: $printMargin, max: $printMargin};
	        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
	        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
	            this.$wrapLimit = wrapLimit;
	            this.$modified = true;
	            if (this.$useWrapMode) {
	                this.$updateWrapData(0, this.getLength() - 1);
	                this.$resetRowCache(0);
	                this._signal("changeWrapLimit");
	            }
	            return true;
	        }
	        return false;
	    };

	    this.$constrainWrapLimit = function(wrapLimit, min, max) {
	        if (min)
	            wrapLimit = Math.max(min, wrapLimit);

	        if (max)
	            wrapLimit = Math.min(max, wrapLimit);

	        return wrapLimit;
	    };
	    this.getWrapLimit = function() {
	        return this.$wrapLimit;
	    };
	    this.setWrapLimit = function (limit) {
	        this.setWrapLimitRange(limit, limit);
	    };
	    this.getWrapLimitRange = function() {
	        return {
	            min : this.$wrapLimitRange.min,
	            max : this.$wrapLimitRange.max
	        };
	    };

	    this.$updateInternalDataOnChange = function(e) {
	        var useWrapMode = this.$useWrapMode;
	        var len;
	        var action = e.data.action;
	        var firstRow = e.data.range.start.row;
	        var lastRow = e.data.range.end.row;
	        var start = e.data.range.start;
	        var end = e.data.range.end;
	        var removedFolds = null;

	        if (action.indexOf("Lines") != -1) {
	            if (action == "insertLines") {
	                lastRow = firstRow + (e.data.lines.length);
	            } else {
	                lastRow = firstRow;
	            }
	            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
	        } else {
	            len = lastRow - firstRow;
	        }

	        this.$updating = true;
	        if (len != 0) {
	            if (action.indexOf("remove") != -1) {
	                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);

	                var foldLines = this.$foldData;
	                removedFolds = this.getFoldsInRange(e.data.range);
	                this.removeFolds(removedFolds);

	                var foldLine = this.getFoldLine(end.row);
	                var idx = 0;
	                if (foldLine) {
	                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
	                    foldLine.shiftRow(-len);

	                    var foldLineBefore = this.getFoldLine(firstRow);
	                    if (foldLineBefore && foldLineBefore !== foldLine) {
	                        foldLineBefore.merge(foldLine);
	                        foldLine = foldLineBefore;
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }

	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= end.row) {
	                        foldLine.shiftRow(-len);
	                    }
	                }

	                lastRow = firstRow;
	            } else {
	                var args = Array(len);
	                args.unshift(firstRow, 0);
	                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
	                arr.splice.apply(arr, args);
	                var foldLines = this.$foldData;
	                var foldLine = this.getFoldLine(firstRow);
	                var idx = 0;
	                if (foldLine) {
	                    var cmp = foldLine.range.compareInside(start.row, start.column);
	                    if (cmp == 0) {
	                        foldLine = foldLine.split(start.row, start.column);
	                        if (foldLine) {
	                            foldLine.shiftRow(len);
	                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
	                        }
	                    } else
	                    if (cmp == -1) {
	                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
	                        foldLine.shiftRow(len);
	                    }
	                    idx = foldLines.indexOf(foldLine) + 1;
	                }

	                for (idx; idx < foldLines.length; idx++) {
	                    var foldLine = foldLines[idx];
	                    if (foldLine.start.row >= firstRow) {
	                        foldLine.shiftRow(len);
	                    }
	                }
	            }
	        } else {
	            len = Math.abs(e.data.range.start.column - e.data.range.end.column);
	            if (action.indexOf("remove") != -1) {
	                removedFolds = this.getFoldsInRange(e.data.range);
	                this.removeFolds(removedFolds);

	                len = -len;
	            }
	            var foldLine = this.getFoldLine(firstRow);
	            if (foldLine) {
	                foldLine.addRemoveChars(firstRow, start.column, len);
	            }
	        }

	        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
	            console.error("doc.getLength() and $wrapData.length have to be the same!");
	        }
	        this.$updating = false;

	        if (useWrapMode)
	            this.$updateWrapData(firstRow, lastRow);
	        else
	            this.$updateRowLengthCache(firstRow, lastRow);

	        return removedFolds;
	    };

	    this.$updateRowLengthCache = function(firstRow, lastRow, b) {
	        this.$rowLengthCache[firstRow] = null;
	        this.$rowLengthCache[lastRow] = null;
	    };

	    this.$updateWrapData = function(firstRow, lastRow) {
	        var lines = this.doc.getAllLines();
	        var tabSize = this.getTabSize();
	        var wrapData = this.$wrapData;
	        var wrapLimit = this.$wrapLimit;
	        var tokens;
	        var foldLine;

	        var row = firstRow;
	        lastRow = Math.min(lastRow, lines.length - 1);
	        while (row <= lastRow) {
	            foldLine = this.getFoldLine(row, foldLine);
	            if (!foldLine) {
	                tokens = this.$getDisplayTokens(lines[row]);
	                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row ++;
	            } else {
	                tokens = [];
	                foldLine.walk(function(placeholder, row, column, lastColumn) {
	                        var walkTokens;
	                        if (placeholder != null) {
	                            walkTokens = this.$getDisplayTokens(
	                                            placeholder, tokens.length);
	                            walkTokens[0] = PLACEHOLDER_START;
	                            for (var i = 1; i < walkTokens.length; i++) {
	                                walkTokens[i] = PLACEHOLDER_BODY;
	                            }
	                        } else {
	                            walkTokens = this.$getDisplayTokens(
	                                lines[row].substring(lastColumn, column),
	                                tokens.length);
	                        }
	                        tokens = tokens.concat(walkTokens);
	                    }.bind(this),
	                    foldLine.end.row,
	                    lines[foldLine.end.row].length + 1
	                );

	                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
	                row = foldLine.end.row + 1;
	            }
	        }
	    };
	    var CHAR = 1,
	        CHAR_EXT = 2,
	        PLACEHOLDER_START = 3,
	        PLACEHOLDER_BODY =  4,
	        PUNCTUATION = 9,
	        SPACE = 10,
	        TAB = 11,
	        TAB_SPACE = 12;


	    this.$computeWrapSplits = function(tokens, wrapLimit) {
	        if (tokens.length == 0) {
	            return [];
	        }

	        var splits = [];
	        var displayLength = tokens.length;
	        var lastSplit = 0, lastDocSplit = 0;

	        var isCode = this.$wrapAsCode;

	        function addSplit(screenPos) {
	            var displayed = tokens.slice(lastSplit, screenPos);
	            var len = displayed.length;
	            displayed.join("").
	                replace(/12/g, function() {
	                    len -= 1;
	                }).
	                replace(/2/g, function() {
	                    len -= 1;
	                });

	            lastDocSplit += len;
	            splits.push(lastDocSplit);
	            lastSplit = screenPos;
	        }

	        while (displayLength - lastSplit > wrapLimit) {
	            var split = lastSplit + wrapLimit;
	            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
	                addSplit(split);
	                continue;
	            }
	            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
	                for (split; split != lastSplit - 1; split--) {
	                    if (tokens[split] == PLACEHOLDER_START) {
	                        break;
	                    }
	                }
	                if (split > lastSplit) {
	                    addSplit(split);
	                    continue;
	                }
	                split = lastSplit + wrapLimit;
	                for (split; split < tokens.length; split++) {
	                    if (tokens[split] != PLACEHOLDER_BODY) {
	                        break;
	                    }
	                }
	                if (split == tokens.length) {
	                    break;  // Breaks the while-loop.
	                }
	                addSplit(split);
	                continue;
	            }
	            var minSplit = Math.max(split - (isCode ? 10 : wrapLimit-(wrapLimit>>2)), lastSplit - 1);
	            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                split --;
	            }
	            if (isCode) {
	                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
	                    split --;
	                }
	                while (split > minSplit && tokens[split] == PUNCTUATION) {
	                    split --;
	                }
	            } else {
	                while (split > minSplit && tokens[split] < SPACE) {
	                    split --;
	                }
	            }
	            if (split > minSplit) {
	                addSplit(++split);
	                continue;
	            }
	            split = lastSplit + wrapLimit;
	            if (tokens[split] == CHAR_EXT)
	                split--;
	            addSplit(split);
	        }
	        return splits;
	    };
	    this.$getDisplayTokens = function(str, offset) {
	        var arr = [];
	        var tabSize;
	        offset = offset || 0;

	        for (var i = 0; i < str.length; i++) {
	            var c = str.charCodeAt(i);
	            if (c == 9) {
	                tabSize = this.getScreenTabSize(arr.length + offset);
	                arr.push(TAB);
	                for (var n = 1; n < tabSize; n++) {
	                    arr.push(TAB_SPACE);
	                }
	            }
	            else if (c == 32) {
	                arr.push(SPACE);
	            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {
	                arr.push(PUNCTUATION);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                arr.push(CHAR, CHAR_EXT);
	            } else {
	                arr.push(CHAR);
	            }
	        }
	        return arr;
	    };
	    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
	        if (maxScreenColumn == 0)
	            return [0, 0];
	        if (maxScreenColumn == null)
	            maxScreenColumn = Infinity;
	        screenColumn = screenColumn || 0;

	        var c, column;
	        for (column = 0; column < str.length; column++) {
	            c = str.charCodeAt(column);
	            if (c == 9) {
	                screenColumn += this.getScreenTabSize(screenColumn);
	            }
	            else if (c >= 0x1100 && isFullWidth(c)) {
	                screenColumn += 2;
	            } else {
	                screenColumn += 1;
	            }
	            if (screenColumn > maxScreenColumn) {
	                break;
	            }
	        }

	        return [screenColumn, column];
	    };

	    this.lineWidgets = null;
	    this.getRowLength = function(row) {
	        if (this.lineWidgets)
	            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        else 
	            h = 0
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1 + h;
	        } else {
	            return this.$wrapData[row].length + 1 + h;
	        }
	    };
	    this.getRowLineCount = function(row) {
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1;
	        } else {
	            return this.$wrapData[row].length + 1;
	        }
	    };
	    this.getScreenLastRowColumn = function(screenRow) {
	        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
	        return this.documentToScreenColumn(pos.row, pos.column);
	    };
	    this.getDocumentLastRowColumn = function(docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.getScreenLastRowColumn(screenRow);
	    };
	    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
	        var screenRow = this.documentToScreenRow(docRow, docColumn);
	        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
	    };
	    this.getRowSplitData = function(row) {
	        if (!this.$useWrapMode) {
	            return undefined;
	        } else {
	            return this.$wrapData[row];
	        }
	    };
	    this.getScreenTabSize = function(screenColumn) {
	        return this.$tabSize - screenColumn % this.$tabSize;
	    };


	    this.screenToDocumentRow = function(screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).row;
	    };


	    this.screenToDocumentColumn = function(screenRow, screenColumn) {
	        return this.screenToDocumentPosition(screenRow, screenColumn).column;
	    };
	    this.screenToDocumentPosition = function(screenRow, screenColumn) {
	        if (screenRow < 0)
	            return {row: 0, column: 0};

	        var line;
	        var docRow = 0;
	        var docColumn = 0;
	        var column;
	        var row = 0;
	        var rowLength = 0;

	        var rowCache = this.$screenRowCache;
	        var i = this.$getRowCacheIndex(rowCache, screenRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var docRow = this.$docRowCache[i];
	            var doCache = screenRow > rowCache[l - 1];
	        } else {
	            var doCache = !l;
	        }

	        var maxRow = this.getLength() - 1;
	        var foldLine = this.getNextFoldLine(docRow);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (row <= screenRow) {
	            rowLength = this.getRowLength(docRow);
	            if (row + rowLength > screenRow || docRow >= maxRow) {
	                break;
	            } else {
	                row += rowLength;
	                docRow++;
	                if (docRow > foldStart) {
	                    docRow = foldLine.end.row+1;
	                    foldLine = this.getNextFoldLine(docRow, foldLine);
	                    foldStart = foldLine ? foldLine.start.row : Infinity;
	                }
	            }

	            if (doCache) {
	                this.$docRowCache.push(docRow);
	                this.$screenRowCache.push(row);
	            }
	        }

	        if (foldLine && foldLine.start.row <= docRow) {
	            line = this.getFoldDisplayLine(foldLine);
	            docRow = foldLine.start.row;
	        } else if (row + rowLength <= screenRow || docRow > maxRow) {
	            return {
	                row: maxRow,
	                column: this.getLine(maxRow).length
	            };
	        } else {
	            line = this.getLine(docRow);
	            foldLine = null;
	        }

	        if (this.$useWrapMode) {
	            var splits = this.$wrapData[docRow];
	            if (splits) {
	                var splitIndex = Math.floor(screenRow - row);
	                column = splits[splitIndex];
	                if(splitIndex > 0 && splits.length) {
	                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
	                    line = line.substring(docColumn);
	                }
	            }
	        }

	        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];
	        if (this.$useWrapMode && docColumn >= column)
	            docColumn = column - 1;

	        if (foldLine)
	            return foldLine.idxToPosition(docColumn);

	        return {row: docRow, column: docColumn};
	    };
	    this.documentToScreenPosition = function(docRow, docColumn) {
	        if (typeof docColumn === "undefined")
	            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
	        else
	            pos = this.$clipPositionToDocument(docRow, docColumn);

	        docRow = pos.row;
	        docColumn = pos.column;

	        var screenRow = 0;
	        var foldStartRow = null;
	        var fold = null;
	        fold = this.getFoldAt(docRow, docColumn, 1);
	        if (fold) {
	            docRow = fold.start.row;
	            docColumn = fold.start.column;
	        }

	        var rowEnd, row = 0;


	        var rowCache = this.$docRowCache;
	        var i = this.$getRowCacheIndex(rowCache, docRow);
	        var l = rowCache.length;
	        if (l && i >= 0) {
	            var row = rowCache[i];
	            var screenRow = this.$screenRowCache[i];
	            var doCache = docRow > rowCache[l - 1];
	        } else {
	            var doCache = !l;
	        }

	        var foldLine = this.getNextFoldLine(row);
	        var foldStart = foldLine ?foldLine.start.row :Infinity;

	        while (row < docRow) {
	            if (row >= foldStart) {
	                rowEnd = foldLine.end.row + 1;
	                if (rowEnd > docRow)
	                    break;
	                foldLine = this.getNextFoldLine(rowEnd, foldLine);
	                foldStart = foldLine ?foldLine.start.row :Infinity;
	            }
	            else {
	                rowEnd = row + 1;
	            }

	            screenRow += this.getRowLength(row);
	            row = rowEnd;

	            if (doCache) {
	                this.$docRowCache.push(row);
	                this.$screenRowCache.push(screenRow);
	            }
	        }
	        var textLine = "";
	        if (foldLine && row >= foldStart) {
	            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
	            foldStartRow = foldLine.start.row;
	        } else {
	            textLine = this.getLine(docRow).substring(0, docColumn);
	            foldStartRow = docRow;
	        }
	        if (this.$useWrapMode) {
	            var wrapRow = this.$wrapData[foldStartRow];
	            if (wrapRow) {
	                var screenRowOffset = 0;
	                while (textLine.length >= wrapRow[screenRowOffset]) {
	                    screenRow ++;
	                    screenRowOffset++;
	                }
	                textLine = textLine.substring(
	                    wrapRow[screenRowOffset - 1] || 0, textLine.length
	                );
	            }
	        }

	        return {
	            row: screenRow,
	            column: this.$getStringScreenWidth(textLine)[0]
	        };
	    };
	    this.documentToScreenColumn = function(row, docColumn) {
	        return this.documentToScreenPosition(row, docColumn).column;
	    };
	    this.documentToScreenRow = function(docRow, docColumn) {
	        return this.documentToScreenPosition(docRow, docColumn).row;
	    };
	    this.getScreenLength = function() {
	        var screenRows = 0;
	        var fold = null;
	        if (!this.$useWrapMode) {
	            screenRows = this.getLength();
	            var foldData = this.$foldData;
	            for (var i = 0; i < foldData.length; i++) {
	                fold = foldData[i];
	                screenRows -= fold.end.row - fold.start.row;
	            }
	        } else {
	            var lastRow = this.$wrapData.length;
	            var row = 0, i = 0;
	            var fold = this.$foldData[i++];
	            var foldStart = fold ? fold.start.row :Infinity;

	            while (row < lastRow) {
	                var splits = this.$wrapData[row];
	                screenRows += splits ? splits.length + 1 : 1;
	                row ++;
	                if (row > foldStart) {
	                    row = fold.end.row+1;
	                    fold = this.$foldData[i++];
	                    foldStart = fold ?fold.start.row :Infinity;
	                }
	            }
	        }
	        if (this.lineWidgets)
	            screenRows += this.$getWidgetScreenLength();

	        return screenRows;
	    };
	    this.$setFontMetrics = function(fm) {
	    };
	    
	    this.destroy = function() {
	        if (this.bgTokenizer) {
	            this.bgTokenizer.setDocument(null);
	            this.bgTokenizer = null;
	        }
	        this.$stopWorker();
	    };
	    function isFullWidth(c) {
	        if (c < 0x1100)
	            return false;
	        return c >= 0x1100 && c <= 0x115F ||
	               c >= 0x11A3 && c <= 0x11A7 ||
	               c >= 0x11FA && c <= 0x11FF ||
	               c >= 0x2329 && c <= 0x232A ||
	               c >= 0x2E80 && c <= 0x2E99 ||
	               c >= 0x2E9B && c <= 0x2EF3 ||
	               c >= 0x2F00 && c <= 0x2FD5 ||
	               c >= 0x2FF0 && c <= 0x2FFB ||
	               c >= 0x3000 && c <= 0x303E ||
	               c >= 0x3041 && c <= 0x3096 ||
	               c >= 0x3099 && c <= 0x30FF ||
	               c >= 0x3105 && c <= 0x312D ||
	               c >= 0x3131 && c <= 0x318E ||
	               c >= 0x3190 && c <= 0x31BA ||
	               c >= 0x31C0 && c <= 0x31E3 ||
	               c >= 0x31F0 && c <= 0x321E ||
	               c >= 0x3220 && c <= 0x3247 ||
	               c >= 0x3250 && c <= 0x32FE ||
	               c >= 0x3300 && c <= 0x4DBF ||
	               c >= 0x4E00 && c <= 0xA48C ||
	               c >= 0xA490 && c <= 0xA4C6 ||
	               c >= 0xA960 && c <= 0xA97C ||
	               c >= 0xAC00 && c <= 0xD7A3 ||
	               c >= 0xD7B0 && c <= 0xD7C6 ||
	               c >= 0xD7CB && c <= 0xD7FB ||
	               c >= 0xF900 && c <= 0xFAFF ||
	               c >= 0xFE10 && c <= 0xFE19 ||
	               c >= 0xFE30 && c <= 0xFE52 ||
	               c >= 0xFE54 && c <= 0xFE66 ||
	               c >= 0xFE68 && c <= 0xFE6B ||
	               c >= 0xFF01 && c <= 0xFF60 ||
	               c >= 0xFFE0 && c <= 0xFFE6;
	    };

	}).call(EditSession.prototype);

	acequire("./edit_session/folding").Folding.call(EditSession.prototype);
	acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);


	config.defineOptions(EditSession.prototype, "session", {
	    wrap: {
	        set: function(value) {
	            if (!value || value == "off")
	                value = false;
	            else if (value == "free")
	                value = true;
	            else if (value == "printMargin")
	                value = -1;
	            else if (typeof value == "string")
	                value = parseInt(value, 10) || false;

	            if (this.$wrap == value)
	                return;
	            this.$wrap = value;
	            if (!value) {
	                this.setUseWrapMode(false);
	            } else {
	                var col = typeof value == "number" ? value : null;
	                this.setWrapLimitRange(col, col);
	                this.setUseWrapMode(true);
	            }
	        },
	        get: function() {
	            if (this.getUseWrapMode()) {
	                if (this.$wrap == -1)
	                    return "printMargin";
	                if (!this.getWrapLimitRange().min)
	                    return "free";
	                return this.$wrap;
	            }
	            return "off";
	        },
	        handlesSet: true
	    },    
	    wrapMethod: {
	        set: function(val) {
	            val = val == "auto"
	                ? this.$mode.type != "text"
	                : val != "text";
	            if (val != this.$wrapAsCode) {
	                this.$wrapAsCode = val;
	                if (this.$useWrapMode) {
	                    this.$modified = true;
	                    this.$resetRowCache(0);
	                    this.$updateWrapData(0, this.getLength() - 1);
	                }
	            }
	        },
	        initialValue: "auto"
	    },
	    firstLineNumber: {
	        set: function() {this._signal("changeBreakpoint");},
	        initialValue: 1
	    },
	    useWorker: {
	        set: function(useWorker) {
	            this.$useWorker = useWorker;

	            this.$stopWorker();
	            if (useWorker)
	                this.$startWorker();
	        },
	        initialValue: true
	    },
	    useSoftTabs: {initialValue: true},
	    tabSize: {
	        set: function(tabSize) {
	            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

	            this.$modified = true;
	            this.$rowLengthCache = [];
	            this.$tabSize = tabSize;
	            this._signal("changeTabSize");
	        },
	        initialValue: 4,
	        handlesSet: true
	    },
	    overwrite: {
	        set: function(val) {this._signal("changeOverwrite");},
	        initialValue: false
	    },
	    newLineMode: {
	        set: function(val) {this.doc.setNewLineMode(val)},
	        get: function() {return this.doc.getNewLineMode()},
	        handlesSet: true
	    },
	    mode: {
	        set: function(val) { this.setMode(val) },
	        get: function() { return this.$modeId }
	    }
	});

	exports.EditSession = EditSession;
	});

	ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("./lib/lang");
	var oop = acequire("./lib/oop");
	var Range = acequire("./range").Range;

	var Search = function() {
	    this.$options = {};
	};

	(function() {
	    this.set = function(options) {
	        oop.mixin(this.$options, options);
	        return this;
	    };
	    this.getOptions = function() {
	        return lang.copyObject(this.$options);
	    };
	    this.setOptions = function(options) {
	        this.$options = options;
	    };
	    this.find = function(session) {
	        var options = this.$options;
	        var iterator = this.$matchIterator(session, options);
	        if (!iterator)
	            return false;

	        var firstRange = null;
	        iterator.forEach(function(range, row, offset) {
	            if (!range.start) {
	                var column = range.offset + (offset || 0);
	                firstRange = new Range(row, column, row, column + range.length);
	                if (!range.length && options.start && options.start.start
	                    && options.skipCurrent != false && firstRange.isEqual(options.start)
	                ) {
	                    firstRange = null;
	                    return false;
	                }
	            } else
	                firstRange = range;
	            return true;
	        });

	        return firstRange;
	    };
	    this.findAll = function(session) {
	        var options = this.$options;
	        if (!options.needle)
	            return [];
	        this.$assembleRegExp(options);

	        var range = options.range;
	        var lines = range
	            ? session.getLines(range.start.row, range.end.row)
	            : session.doc.getAllLines();

	        var ranges = [];
	        var re = options.re;
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var maxRow = lines.length - len;
	            var prevRange;
	            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
	                for (var j = 0; j < len; j++)
	                    if (lines[row + j].search(re[j]) == -1)
	                        continue outer;
	                
	                var startLine = lines[row];
	                var line = lines[row + len - 1];
	                var startIndex = startLine.length - startLine.match(re[0])[0].length;
	                var endIndex = line.match(re[len - 1])[0].length;
	                
	                if (prevRange && prevRange.end.row === row &&
	                    prevRange.end.column > startIndex
	                ) {
	                    continue;
	                }
	                ranges.push(prevRange = new Range(
	                    row, startIndex, row + len - 1, endIndex
	                ));
	                if (len > 2)
	                    row = row + len - 2;
	            }
	        } else {
	            for (var i = 0; i < lines.length; i++) {
	                var matches = lang.getMatchOffsets(lines[i], re);
	                for (var j = 0; j < matches.length; j++) {
	                    var match = matches[j];
	                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
	                }
	            }
	        }

	        if (range) {
	            var startColumn = range.start.column;
	            var endColumn = range.start.column;
	            var i = 0, j = ranges.length - 1;
	            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
	                i++;

	            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
	                j--;
	            
	            ranges = ranges.slice(i, j + 1);
	            for (i = 0, j = ranges.length; i < j; i++) {
	                ranges[i].start.row += range.start.row;
	                ranges[i].end.row += range.start.row;
	            }
	        }

	        return ranges;
	    };
	    this.replace = function(input, replacement) {
	        var options = this.$options;

	        var re = this.$assembleRegExp(options);
	        if (options.$isMultiLine)
	            return replacement;

	        if (!re)
	            return;

	        var match = re.exec(input);
	        if (!match || match[0].length != input.length)
	            return null;
	        
	        replacement = input.replace(re, replacement);
	        if (options.preserveCase) {
	            replacement = replacement.split("");
	            for (var i = Math.min(input.length, input.length); i--; ) {
	                var ch = input[i];
	                if (ch && ch.toLowerCase() != ch)
	                    replacement[i] = replacement[i].toUpperCase();
	                else
	                    replacement[i] = replacement[i].toLowerCase();
	            }
	            replacement = replacement.join("");
	        }
	        
	        return replacement;
	    };

	    this.$matchIterator = function(session, options) {
	        var re = this.$assembleRegExp(options);
	        if (!re)
	            return false;

	        var callback;
	        if (options.$isMultiLine) {
	            var len = re.length;
	            var matchIterator = function(line, row, offset) {
	                var startIndex = line.search(re[0]);
	                if (startIndex == -1)
	                    return;
	                for (var i = 1; i < len; i++) {
	                    line = session.getLine(row + i);
	                    if (line.search(re[i]) == -1)
	                        return;
	                }

	                var endIndex = line.match(re[len - 1])[0].length;

	                var range = new Range(row, startIndex, row + len - 1, endIndex);
	                if (re.offset == 1) {
	                    range.start.row--;
	                    range.start.column = Number.MAX_VALUE;
	                } else if (offset)
	                    range.start.column += offset;

	                if (callback(range))
	                    return true;
	            };
	        } else if (options.backwards) {
	            var matchIterator = function(line, row, startIndex) {
	                var matches = lang.getMatchOffsets(line, re);
	                for (var i = matches.length-1; i >= 0; i--)
	                    if (callback(matches[i], row, startIndex))
	                        return true;
	            };
	        } else {
	            var matchIterator = function(line, row, startIndex) {
	                var matches = lang.getMatchOffsets(line, re);
	                for (var i = 0; i < matches.length; i++)
	                    if (callback(matches[i], row, startIndex))
	                        return true;
	            };
	        }

	        var lineIterator = this.$lineIterator(session, options);

	        return {
	            forEach: function(_callback) {
	                callback = _callback;
	                lineIterator.forEach(matchIterator);
	            }
	        };
	    };

	    this.$assembleRegExp = function(options, $disableFakeMultiline) {
	        if (options.needle instanceof RegExp)
	            return options.re = options.needle;

	        var needle = options.needle;

	        if (!options.needle)
	            return options.re = false;

	        if (!options.regExp)
	            needle = lang.escapeRegExp(needle);

	        if (options.wholeWord)
	            needle = "\\b" + needle + "\\b";

	        var modifier = options.caseSensitive ? "gm" : "gmi";

	        options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
	        if (options.$isMultiLine)
	            return options.re = this.$assembleMultilineRegExp(needle, modifier);

	        try {
	            var re = new RegExp(needle, modifier);
	        } catch(e) {
	            re = false;
	        }
	        return options.re = re;
	    };

	    this.$assembleMultilineRegExp = function(needle, modifier) {
	        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
	        var re = [];
	        for (var i = 0; i < parts.length; i++) try {
	            re.push(new RegExp(parts[i], modifier));
	        } catch(e) {
	            return false;
	        }
	        if (parts[0] == "") {
	            re.shift();
	            re.offset = 1;
	        } else {
	            re.offset = 0;
	        }
	        return re;
	    };

	    this.$lineIterator = function(session, options) {
	        var backwards = options.backwards == true;
	        var skipCurrent = options.skipCurrent != false;

	        var range = options.range;
	        var start = options.start;
	        if (!start)
	            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
	         
	        if (start.start)
	            start = start[skipCurrent != backwards ? "end" : "start"];

	        var firstRow = range ? range.start.row : 0;
	        var lastRow = range ? range.end.row : session.getLength() - 1;

	        var forEach = backwards ? function(callback) {
	                var row = start.row;

	                var line = session.getLine(row).substring(0, start.column);
	                if (callback(line, row))
	                    return;

	                for (row--; row >= firstRow; row--)
	                    if (callback(session.getLine(row), row))
	                        return;

	                if (options.wrap == false)
	                    return;

	                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
	                    if (callback(session.getLine(row), row))
	                        return;
	            } : function(callback) {
	                var row = start.row;

	                var line = session.getLine(row).substr(start.column);
	                if (callback(line, row, start.column))
	                    return;

	                for (row = row+1; row <= lastRow; row++)
	                    if (callback(session.getLine(row), row))
	                        return;

	                if (options.wrap == false)
	                    return;

	                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
	                    if (callback(session.getLine(row), row))
	                        return;
	            };
	        
	        return {forEach: forEach};
	    };

	}).call(Search.prototype);

	exports.Search = Search;
	});

	ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"], function(acequire, exports, module) {
	"use strict";

	var keyUtil = acequire("../lib/keys");
	var useragent = acequire("../lib/useragent");
	var KEY_MODS = keyUtil.KEY_MODS;

	function HashHandler(config, platform) {
	    this.platform = platform || (useragent.isMac ? "mac" : "win");
	    this.commands = {};
	    this.commandKeyBinding = {};
	    this.addCommands(config);
	    this.$singleCommand = true;
	}

	function MultiHashHandler(config, platform) {
	    HashHandler.call(this, config, platform);
	    this.$singleCommand = false;
	}

	MultiHashHandler.prototype = HashHandler.prototype;

	(function() {


	    this.addCommand = function(command) {
	        if (this.commands[command.name])
	            this.removeCommand(command);

	        this.commands[command.name] = command;

	        if (command.bindKey)
	            this._buildKeyHash(command);
	    };

	    this.removeCommand = function(command, keepCommand) {
	        var name = command && (typeof command === 'string' ? command : command.name);
	        command = this.commands[name];
	        if (!keepCommand)
	            delete this.commands[name];
	        var ckb = this.commandKeyBinding;
	        for (var keyId in ckb) {
	            var cmdGroup = ckb[keyId];
	            if (cmdGroup == command) {
	                delete ckb[keyId];
	            } else if (Array.isArray(cmdGroup)) {
	                var i = cmdGroup.indexOf(command);
	                if (i != -1) {
	                    cmdGroup.splice(i, 1);
	                    if (cmdGroup.length == 1)
	                        ckb[keyId] = cmdGroup[0];
	                }
	            }
	        }
	    };

	    this.bindKey = function(key, command, asDefault) {
	        if (typeof key == "object")
	            key = key[this.platform];
	        if (!key)
	            return;
	        if (typeof command == "function")
	            return this.addCommand({exec: command, bindKey: key, name: command.name || key});

	        key.split("|").forEach(function(keyPart) {
	            var chain = "";
	            if (keyPart.indexOf(" ") != -1) {
	                var parts = keyPart.split(/\s+/);
	                keyPart = parts.pop();
	                parts.forEach(function(keyPart) {
	                    var binding = this.parseKeys(keyPart);
	                    var id = KEY_MODS[binding.hashId] + binding.key;
	                    chain += (chain ? " " : "") + id;
	                    this._addCommandToBinding(chain, "chainKeys");
	                }, this);
	                chain += " ";
	            }
	            var binding = this.parseKeys(keyPart);
	            var id = KEY_MODS[binding.hashId] + binding.key;
	            this._addCommandToBinding(chain + id, command, asDefault);
	        }, this);
	    };

	    this._addCommandToBinding = function(keyId, command, asDefault) {
	        var ckb = this.commandKeyBinding, i;
	        if (!command) {
	            delete ckb[keyId];
	        } else if (!ckb[keyId] || this.$singleCommand) {
	            ckb[keyId] = command;
	        } else {
	            if (!Array.isArray(ckb[keyId])) {
	                ckb[keyId] = [ckb[keyId]];
	            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
	                ckb[keyId].splice(i, 1);
	            }

	            if (asDefault || command.isDefault)
	                ckb[keyId].unshift(command);
	            else
	                ckb[keyId].push(command);
	        }
	    };

	    this.addCommands = function(commands) {
	        commands && Object.keys(commands).forEach(function(name) {
	            var command = commands[name];
	            if (!command)
	                return;
	            
	            if (typeof command === "string")
	                return this.bindKey(command, name);

	            if (typeof command === "function")
	                command = { exec: command };

	            if (typeof command !== "object")
	                return;

	            if (!command.name)
	                command.name = name;

	            this.addCommand(command);
	        }, this);
	    };

	    this.removeCommands = function(commands) {
	        Object.keys(commands).forEach(function(name) {
	            this.removeCommand(commands[name]);
	        }, this);
	    };

	    this.bindKeys = function(keyList) {
	        Object.keys(keyList).forEach(function(key) {
	            this.bindKey(key, keyList[key]);
	        }, this);
	    };

	    this._buildKeyHash = function(command) {
	        this.bindKey(command.bindKey, command);
	    };
	    this.parseKeys = function(keys) {
	        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x){return x});
	        var key = parts.pop();

	        var keyCode = keyUtil[key];
	        if (keyUtil.FUNCTION_KEYS[keyCode])
	            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
	        else if (!parts.length)
	            return {key: key, hashId: -1};
	        else if (parts.length == 1 && parts[0] == "shift")
	            return {key: key.toUpperCase(), hashId: -1};

	        var hashId = 0;
	        for (var i = parts.length; i--;) {
	            var modifier = keyUtil.KEY_MODS[parts[i]];
	            if (modifier == null) {
	                if (typeof console != "undefined")
	                    console.error("invalid modifier " + parts[i] + " in " + keys);
	                return false;
	            }
	            hashId |= modifier;
	        }
	        return {key: key, hashId: hashId};
	    };

	    this.findKeyCommand = function findKeyCommand(hashId, keyString) {
	        var key = KEY_MODS[hashId] + keyString;
	        return this.commandKeyBinding[key];
	    };

	    this.handleKeyboard = function(data, hashId, keyString, keyCode) {
	        var key = KEY_MODS[hashId] + keyString;
	        var command = this.commandKeyBinding[key];
	        if (data.$keyChain) {
	            data.$keyChain += " " + key;
	            command = this.commandKeyBinding[data.$keyChain] || command;
	        }

	        if (command) {
	            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
	                data.$keyChain = data.$keyChain || key;
	                return {command: "null"};
	            }
	        }

	        if (data.$keyChain && keyCode > 0)
	            data.$keyChain = "";
	        return {command: command};
	    };

	}).call(HashHandler.prototype);

	exports.HashHandler = HashHandler;
	exports.MultiHashHandler = MultiHashHandler;
	});

	ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var CommandManager = function(platform, commands) {
	    MultiHashHandler.call(this, commands, platform);
	    this.byName = this.commands;
	    this.setDefaultHandler("exec", function(e) {
	        return e.command.exec(e.editor, e.args || {});
	    });
	};

	oop.inherits(CommandManager, MultiHashHandler);

	(function() {

	    oop.implement(this, EventEmitter);

	    this.exec = function(command, editor, args) {
	        if (Array.isArray(command)) {
	            for (var i = command.length; i--; ) {
	                if (this.exec(command[i], editor, args)) return true;
	            }
	            return false;
	        }

	        if (typeof command === "string")
	            command = this.commands[command];

	        if (!command)
	            return false;

	        if (editor && editor.$readOnly && !command.readOnly)
	            return false;

	        var e = {editor: editor, command: command, args: args};
	        e.returnValue = this._emit("exec", e);
	        this._signal("afterExec", e);

	        return e.returnValue === false ? false : true;
	    };

	    this.toggleRecording = function(editor) {
	        if (this.$inReplay)
	            return;

	        editor && editor._emit("changeStatus");
	        if (this.recording) {
	            this.macro.pop();
	            this.removeEventListener("exec", this.$addCommandToMacro);

	            if (!this.macro.length)
	                this.macro = this.oldMacro;

	            return this.recording = false;
	        }
	        if (!this.$addCommandToMacro) {
	            this.$addCommandToMacro = function(e) {
	                this.macro.push([e.command, e.args]);
	            }.bind(this);
	        }

	        this.oldMacro = this.macro;
	        this.macro = [];
	        this.on("exec", this.$addCommandToMacro);
	        return this.recording = true;
	    };

	    this.replay = function(editor) {
	        if (this.$inReplay || !this.macro)
	            return;

	        if (this.recording)
	            return this.toggleRecording(editor);

	        try {
	            this.$inReplay = true;
	            this.macro.forEach(function(x) {
	                if (typeof x == "string")
	                    this.exec(x, editor);
	                else
	                    this.exec(x[0], editor, x[1]);
	            }, this);
	        } finally {
	            this.$inReplay = false;
	        }
	    };

	    this.trimMacro = function(m) {
	        return m.map(function(x){
	            if (typeof x[0] != "string")
	                x[0] = x[0].name;
	            if (!x[1])
	                x = x[0];
	            return x;
	        });
	    };

	}).call(CommandManager.prototype);

	exports.CommandManager = CommandManager;

	});

	ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"], function(acequire, exports, module) {
	"use strict";

	var lang = acequire("../lib/lang");
	var config = acequire("../config");
	var Range = acequire("../range").Range;

	function bindKey(win, mac) {
	    return {win: win, mac: mac};
	}
	exports.commands = [{
	    name: "showSettingsMenu",
	    bindKey: bindKey("Ctrl-,", "Command-,"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/settings_menu", function(module) {
	            module.init(editor);
	            editor.showSettingsMenu();
	        });
	    },
	    readOnly: true
	}, {
	    name: "goToNextError",
	    bindKey: bindKey("Alt-E", "Ctrl-E"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/error_marker", function(module) {
	            module.showErrorMarker(editor, 1);
	        });
	    },
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "goToPreviousError",
	    bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/error_marker", function(module) {
	            module.showErrorMarker(editor, -1);
	        });
	    },
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "selectall",
	    bindKey: bindKey("Ctrl-A", "Command-A"),
	    exec: function(editor) { editor.selectAll(); },
	    readOnly: true
	}, {
	    name: "centerselection",
	    bindKey: bindKey(null, "Ctrl-L"),
	    exec: function(editor) { editor.centerSelection(); },
	    readOnly: true
	}, {
	    name: "gotoline",
	    bindKey: bindKey("Ctrl-L", "Command-L"),
	    exec: function(editor) {
	        var line = parseInt(prompt("Enter line number:"), 10);
	        if (!isNaN(line)) {
	            editor.gotoLine(line);
	        }
	    },
	    readOnly: true
	}, {
	    name: "fold",
	    bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
	    exec: function(editor) { editor.session.toggleFold(false); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "unfold",
	    bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
	    exec: function(editor) { editor.session.toggleFold(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "toggleFoldWidget",
	    bindKey: bindKey("F2", "F2"),
	    exec: function(editor) { editor.session.toggleFoldWidget(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "toggleParentFoldWidget",
	    bindKey: bindKey("Alt-F2", "Alt-F2"),
	    exec: function(editor) { editor.session.toggleFoldWidget(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "foldall",
	    bindKey: bindKey(null, "Ctrl-Command-Option-0"),
	    exec: function(editor) { editor.session.foldAll(); },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "foldOther",
	    bindKey: bindKey("Alt-0", "Command-Option-0"),
	    exec: function(editor) { 
	        editor.session.foldAll();
	        editor.session.unfold(editor.selection.getAllRanges());
	    },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "unfoldall",
	    bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
	    exec: function(editor) { editor.session.unfold(); },
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "findnext",
	    bindKey: bindKey("Ctrl-K", "Command-G"),
	    exec: function(editor) { editor.findNext(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "findprevious",
	    bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
	    exec: function(editor) { editor.findPrevious(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "center",
	    readOnly: true
	}, {
	    name: "selectOrFindNext",
	    bindKey: bindKey("Alt-K", "Ctrl-G"),
	    exec: function(editor) {
	        if (editor.selection.isEmpty())
	            editor.selection.selectWord();
	        else
	            editor.findNext(); 
	    },
	    readOnly: true
	}, {
	    name: "selectOrFindPrevious",
	    bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
	    exec: function(editor) { 
	        if (editor.selection.isEmpty())
	            editor.selection.selectWord();
	        else
	            editor.findPrevious();
	    },
	    readOnly: true
	}, {
	    name: "find",
	    bindKey: bindKey("Ctrl-F", "Command-F"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor)});
	    },
	    readOnly: true
	}, {
	    name: "overwrite",
	    bindKey: "Insert",
	    exec: function(editor) { editor.toggleOverwrite(); },
	    readOnly: true
	}, {
	    name: "selecttostart",
	    bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
	    exec: function(editor) { editor.getSelection().selectFileStart(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "gotostart",
	    bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
	    exec: function(editor) { editor.navigateFileStart(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "selectup",
	    bindKey: bindKey("Shift-Up", "Shift-Up"),
	    exec: function(editor) { editor.getSelection().selectUp(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "golineup",
	    bindKey: bindKey("Up", "Up|Ctrl-P"),
	    exec: function(editor, args) { editor.navigateUp(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttoend",
	    bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
	    exec: function(editor) { editor.getSelection().selectFileEnd(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "gotoend",
	    bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
	    exec: function(editor) { editor.navigateFileEnd(); },
	    multiSelectAction: "forEach",
	    readOnly: true,
	    scrollIntoView: "animate",
	    aceCommandGroup: "fileJump"
	}, {
	    name: "selectdown",
	    bindKey: bindKey("Shift-Down", "Shift-Down"),
	    exec: function(editor) { editor.getSelection().selectDown(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "golinedown",
	    bindKey: bindKey("Down", "Down|Ctrl-N"),
	    exec: function(editor, args) { editor.navigateDown(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectwordleft",
	    bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotowordleft",
	    bindKey: bindKey("Ctrl-Left", "Option-Left"),
	    exec: function(editor) { editor.navigateWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttolinestart",
	    bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotolinestart",
	    bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
	    exec: function(editor) { editor.navigateLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectleft",
	    bindKey: bindKey("Shift-Left", "Shift-Left"),
	    exec: function(editor) { editor.getSelection().selectLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotoleft",
	    bindKey: bindKey("Left", "Left|Ctrl-B"),
	    exec: function(editor, args) { editor.navigateLeft(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectwordright",
	    bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotowordright",
	    bindKey: bindKey("Ctrl-Right", "Option-Right"),
	    exec: function(editor) { editor.navigateWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selecttolineend",
	    bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotolineend",
	    bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
	    exec: function(editor) { editor.navigateLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectright",
	    bindKey: bindKey("Shift-Right", "Shift-Right"),
	    exec: function(editor) { editor.getSelection().selectRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "gotoright",
	    bindKey: bindKey("Right", "Right|Ctrl-F"),
	    exec: function(editor, args) { editor.navigateRight(args.times); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectpagedown",
	    bindKey: "Shift-PageDown",
	    exec: function(editor) { editor.selectPageDown(); },
	    readOnly: true
	}, {
	    name: "pagedown",
	    bindKey: bindKey(null, "Option-PageDown"),
	    exec: function(editor) { editor.scrollPageDown(); },
	    readOnly: true
	}, {
	    name: "gotopagedown",
	    bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
	    exec: function(editor) { editor.gotoPageDown(); },
	    readOnly: true
	}, {
	    name: "selectpageup",
	    bindKey: "Shift-PageUp",
	    exec: function(editor) { editor.selectPageUp(); },
	    readOnly: true
	}, {
	    name: "pageup",
	    bindKey: bindKey(null, "Option-PageUp"),
	    exec: function(editor) { editor.scrollPageUp(); },
	    readOnly: true
	}, {
	    name: "gotopageup",
	    bindKey: "PageUp",
	    exec: function(editor) { editor.gotoPageUp(); },
	    readOnly: true
	}, {
	    name: "scrollup",
	    bindKey: bindKey("Ctrl-Up", null),
	    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
	    readOnly: true
	}, {
	    name: "scrolldown",
	    bindKey: bindKey("Ctrl-Down", null),
	    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
	    readOnly: true
	}, {
	    name: "selectlinestart",
	    bindKey: "Shift-Home",
	    exec: function(editor) { editor.getSelection().selectLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "selectlineend",
	    bindKey: "Shift-End",
	    exec: function(editor) { editor.getSelection().selectLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "togglerecording",
	    bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
	    exec: function(editor) { editor.commands.toggleRecording(editor); },
	    readOnly: true
	}, {
	    name: "replaymacro",
	    bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
	    exec: function(editor) { editor.commands.replay(editor); },
	    readOnly: true
	}, {
	    name: "jumptomatching",
	    bindKey: bindKey("Ctrl-P", "Ctrl-P"),
	    exec: function(editor) { editor.jumpToMatching(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "selecttomatching",
	    bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
	    exec: function(editor) { editor.jumpToMatching(true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "expandToMatching",
	    bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
	    exec: function(editor) { editor.jumpToMatching(true, true); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "animate",
	    readOnly: true
	}, {
	    name: "passKeysToBrowser",
	    bindKey: bindKey(null, null),
	    exec: function() {},
	    passEvent: true,
	    readOnly: true
	},
	{
	    name: "cut",
	    exec: function(editor) {
	        var range = editor.getSelectionRange();
	        editor._emit("cut", range);

	        if (!editor.selection.isEmpty()) {
	            editor.session.remove(range);
	            editor.clearSelection();
	        }
	    },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "removeline",
	    bindKey: bindKey("Ctrl-D", "Command-D"),
	    exec: function(editor) { editor.removeLines(); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEachLine"
	}, {
	    name: "duplicateSelection",
	    bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
	    exec: function(editor) { editor.duplicateSelection(); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "sortlines",
	    bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
	    exec: function(editor) { editor.sortLines(); },
	    scrollIntoView: "selection",
	    multiSelectAction: "forEachLine"
	}, {
	    name: "togglecomment",
	    bindKey: bindKey("Ctrl-/", "Command-/"),
	    exec: function(editor) { editor.toggleCommentLines(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "toggleBlockComment",
	    bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
	    exec: function(editor) { editor.toggleBlockComment(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "modifyNumberUp",
	    bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
	    exec: function(editor) { editor.modifyNumber(1); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "modifyNumberDown",
	    bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
	    exec: function(editor) { editor.modifyNumber(-1); },
	    scrollIntoView: "cursor",
	    multiSelectAction: "forEach"
	}, {
	    name: "replace",
	    bindKey: bindKey("Ctrl-H", "Command-Option-F"),
	    exec: function(editor) {
	        config.loadModule("ace/ext/searchbox", function(e) {e.Search(editor, true)});
	    }
	}, {
	    name: "undo",
	    bindKey: bindKey("Ctrl-Z", "Command-Z"),
	    exec: function(editor) { editor.undo(); }
	}, {
	    name: "redo",
	    bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
	    exec: function(editor) { editor.redo(); }
	}, {
	    name: "copylinesup",
	    bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
	    exec: function(editor) { editor.copyLinesUp(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "movelinesup",
	    bindKey: bindKey("Alt-Up", "Option-Up"),
	    exec: function(editor) { editor.moveLinesUp(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "copylinesdown",
	    bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
	    exec: function(editor) { editor.copyLinesDown(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "movelinesdown",
	    bindKey: bindKey("Alt-Down", "Option-Down"),
	    exec: function(editor) { editor.moveLinesDown(); },
	    scrollIntoView: "cursor"
	}, {
	    name: "del",
	    bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
	    exec: function(editor) { editor.remove("right"); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "backspace",
	    bindKey: bindKey(
	        "Shift-Backspace|Backspace",
	        "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"
	    ),
	    exec: function(editor) { editor.remove("left"); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "cut_or_delete",
	    bindKey: bindKey("Shift-Delete", null),
	    exec: function(editor) { 
	        if (editor.selection.isEmpty()) {
	            editor.remove("left");
	        } else {
	            return false;
	        }
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removetolinestart",
	    bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
	    exec: function(editor) { editor.removeToLineStart(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removetolineend",
	    bindKey: bindKey("Alt-Delete", "Ctrl-K"),
	    exec: function(editor) { editor.removeToLineEnd(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removewordleft",
	    bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
	    exec: function(editor) { editor.removeWordLeft(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "removewordright",
	    bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
	    exec: function(editor) { editor.removeWordRight(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "outdent",
	    bindKey: bindKey("Shift-Tab", "Shift-Tab"),
	    exec: function(editor) { editor.blockOutdent(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "indent",
	    bindKey: bindKey("Tab", "Tab"),
	    exec: function(editor) { editor.indent(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "blockoutdent",
	    bindKey: bindKey("Ctrl-[", "Ctrl-["),
	    exec: function(editor) { editor.blockOutdent(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "blockindent",
	    bindKey: bindKey("Ctrl-]", "Ctrl-]"),
	    exec: function(editor) { editor.blockIndent(); },
	    multiSelectAction: "forEachLine",
	    scrollIntoView: "selectionPart"
	}, {
	    name: "insertstring",
	    exec: function(editor, str) { editor.insert(str); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "inserttext",
	    exec: function(editor, args) {
	        editor.insert(lang.stringRepeat(args.text  || "", args.times || 1));
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "splitline",
	    bindKey: bindKey(null, "Ctrl-O"),
	    exec: function(editor) { editor.splitLine(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "transposeletters",
	    bindKey: bindKey("Ctrl-T", "Ctrl-T"),
	    exec: function(editor) { editor.transposeLetters(); },
	    multiSelectAction: function(editor) {editor.transposeSelections(1); },
	    scrollIntoView: "cursor"
	}, {
	    name: "touppercase",
	    bindKey: bindKey("Ctrl-U", "Ctrl-U"),
	    exec: function(editor) { editor.toUpperCase(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "tolowercase",
	    bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
	    exec: function(editor) { editor.toLowerCase(); },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor"
	}, {
	    name: "expandtoline",
	    bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
	    exec: function(editor) {
	        var range = editor.selection.getRange();

	        range.start.column = range.end.column = 0;
	        range.end.row++;
	        editor.selection.setRange(range, false);
	    },
	    multiSelectAction: "forEach",
	    scrollIntoView: "cursor",
	    readOnly: true
	}, {
	    name: "joinlines",
	    bindKey: bindKey(null, null),
	    exec: function(editor) {
	        var isBackwards = editor.selection.isBackwards();
	        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
	        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
	        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
	        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
	        var selectedCount = selectedText.replace(/\n\s*/, " ").length;
	        var insertLine = editor.session.doc.getLine(selectionStart.row);

	        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
	            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
	            if (curLine.length !== 0) {
	                curLine = " " + curLine;
	            }
	            insertLine += curLine;
	        }

	        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
	            insertLine += editor.session.doc.getNewLineCharacter();
	        }

	        editor.clearSelection();
	        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);

	        if (selectedCount > 0) {
	            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
	            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
	        } else {
	            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
	            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
	        }
	    },
	    multiSelectAction: "forEach",
	    readOnly: true
	}, {
	    name: "invertSelection",
	    bindKey: bindKey(null, null),
	    exec: function(editor) {
	        var endRow = editor.session.doc.getLength() - 1;
	        var endCol = editor.session.doc.getLine(endRow).length;
	        var ranges = editor.selection.rangeList.ranges;
	        var newRanges = [];
	        if (ranges.length < 1) {
	            ranges = [editor.selection.getRange()];
	        }

	        for (var i = 0; i < ranges.length; i++) {
	            if (i == (ranges.length - 1)) {
	                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
	                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
	                }
	            }

	            if (i === 0) {
	                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
	                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
	                }
	            } else {
	                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));
	            }
	        }

	        editor.exitMultiSelectMode();
	        editor.clearSelection();

	        for(var i = 0; i < newRanges.length; i++) {
	            editor.selection.addRange(newRanges[i], false);
	        }
	    },
	    readOnly: true,
	    scrollIntoView: "none"
	}];

	});

	ace.define("ace/editor",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator"], function(acequire, exports, module) {
	"use strict";

	acequire("./lib/fixoldbrowsers");

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var lang = acequire("./lib/lang");
	var useragent = acequire("./lib/useragent");
	var TextInput = acequire("./keyboard/textinput").TextInput;
	var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
	var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
	var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
	var EditSession = acequire("./edit_session").EditSession;
	var Search = acequire("./search").Search;
	var Range = acequire("./range").Range;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var CommandManager = acequire("./commands/command_manager").CommandManager;
	var defaultCommands = acequire("./commands/default_commands").commands;
	var config = acequire("./config");
	var TokenIterator = acequire("./token_iterator").TokenIterator;
	var Editor = function(renderer, session) {
	    var container = renderer.getContainerElement();
	    this.container = container;
	    this.renderer = renderer;

	    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
	    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);
	    this.renderer.textarea = this.textInput.getElement();
	    this.keyBinding = new KeyBinding(this);
	    this.$mouseHandler = new MouseHandler(this);
	    new FoldHandler(this);

	    this.$blockScrolling = 0;
	    this.$search = new Search().set({
	        wrap: true
	    });

	    this.$historyTracker = this.$historyTracker.bind(this);
	    this.commands.on("exec", this.$historyTracker);

	    this.$initOperationListeners();
	    
	    this._$emitInputEvent = lang.delayedCall(function() {
	        this._signal("input", {});
	        if (this.session && this.session.bgTokenizer)
	            this.session.bgTokenizer.scheduleStart();
	    }.bind(this));
	    
	    this.on("change", function(_, _self) {
	        _self._$emitInputEvent.schedule(31);
	    });

	    this.setSession(session || new EditSession(""));
	    config.resetOptions(this);
	    config._signal("editor", this);
	};

	(function(){

	    oop.implement(this, EventEmitter);

	    this.$initOperationListeners = function() {
	        function last(a) {return a[a.length - 1]}

	        this.selections = [];
	        this.commands.on("exec", this.startOperation.bind(this), true);
	        this.commands.on("afterExec", this.endOperation.bind(this), true);

	        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));

	        this.on("change", function() {
	            this.curOp || this.startOperation();
	            this.curOp.docChanged = true;
	        }.bind(this), true);

	        this.on("changeSelection", function() {
	            this.curOp || this.startOperation();
	            this.curOp.selectionChanged = true;
	        }.bind(this), true);
	    };

	    this.curOp = null;
	    this.prevOp = {};
	    this.startOperation = function(commadEvent) {
	        if (this.curOp) {
	            if (!commadEvent || this.curOp.command)
	                return;
	            this.prevOp = this.curOp;
	        }
	        if (!commadEvent) {
	            this.previousCommand = null;
	            commadEvent = {};
	        }

	        this.$opResetTimer.schedule();
	        this.curOp = {
	            command: commadEvent.command || {},
	            args: commadEvent.args,
	            scrollTop: this.renderer.scrollTop
	        };
	        if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
	            this.$blockScrolling++;
	    };

	    this.endOperation = function(e) {
	        if (this.curOp) {
	            if (e && e.returnValue === false)
	                return this.curOp = null;
	            this._signal("beforeEndOperation");
	            var command = this.curOp.command;
	            if (command.name && this.$blockScrolling > 0)
	                this.$blockScrolling--;
	            if (command && command.scrollIntoView) {
	                switch (command.scrollIntoView) {
	                    case "center":
	                        this.renderer.scrollCursorIntoView(null, 0.5);
	                        break;
	                    case "animate":
	                    case "cursor":
	                        this.renderer.scrollCursorIntoView();
	                        break;
	                    case "selectionPart":
	                        var range = this.selection.getRange();
	                        var config = this.renderer.layerConfig;
	                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
	                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
	                        }
	                        break;
	                    default:
	                        break;
	                }
	                if (command.scrollIntoView == "animate")
	                    this.renderer.animateScrolling(this.curOp.scrollTop);
	            }
	            
	            this.prevOp = this.curOp;
	            this.curOp = null;
	        }
	    };
	    this.$mergeableCommands = ["backspace", "del", "insertstring"];
	    this.$historyTracker = function(e) {
	        if (!this.$mergeUndoDeltas)
	            return;

	        var prev = this.prevOp;
	        var mergeableCommands = this.$mergeableCommands;
	        var shouldMerge = prev.command && (e.command.name == prev.command.name);
	        if (e.command.name == "insertstring") {
	            var text = e.args;
	            if (this.mergeNextCommand === undefined)
	                this.mergeNextCommand = true;

	            shouldMerge = shouldMerge
	                && this.mergeNextCommand // previous command allows to coalesce with
	                && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

	            this.mergeNextCommand = true;
	        } else {
	            shouldMerge = shouldMerge
	                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
	        }

	        if (
	            this.$mergeUndoDeltas != "always"
	            && Date.now() - this.sequenceStartTime > 2000
	        ) {
	            shouldMerge = false; // the sequence is too long
	        }

	        if (shouldMerge)
	            this.session.mergeUndoDeltas = true;
	        else if (mergeableCommands.indexOf(e.command.name) !== -1)
	            this.sequenceStartTime = Date.now();
	    };
	    this.setKeyboardHandler = function(keyboardHandler, cb) {
	        if (keyboardHandler && typeof keyboardHandler === "string") {
	            this.$keybindingId = keyboardHandler;
	            var _self = this;
	            config.loadModule(["keybinding", keyboardHandler], function(module) {
	                if (_self.$keybindingId == keyboardHandler)
	                    _self.keyBinding.setKeyboardHandler(module && module.handler);
	                cb && cb();
	            });
	        } else {
	            this.$keybindingId = null;
	            this.keyBinding.setKeyboardHandler(keyboardHandler);
	            cb && cb();
	        }
	    };
	    this.getKeyboardHandler = function() {
	        return this.keyBinding.getKeyboardHandler();
	    };
	    this.setSession = function(session) {
	        if (this.session == session)
	            return;

	        var oldSession = this.session;
	        if (oldSession) {
	            this.session.removeEventListener("change", this.$onDocumentChange);
	            this.session.removeEventListener("changeMode", this.$onChangeMode);
	            this.session.removeEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
	            this.session.removeEventListener("changeTabSize", this.$onChangeTabSize);
	            this.session.removeEventListener("changeWrapLimit", this.$onChangeWrapLimit);
	            this.session.removeEventListener("changeWrapMode", this.$onChangeWrapMode);
	            this.session.removeEventListener("onChangeFold", this.$onChangeFold);
	            this.session.removeEventListener("changeFrontMarker", this.$onChangeFrontMarker);
	            this.session.removeEventListener("changeBackMarker", this.$onChangeBackMarker);
	            this.session.removeEventListener("changeBreakpoint", this.$onChangeBreakpoint);
	            this.session.removeEventListener("changeAnnotation", this.$onChangeAnnotation);
	            this.session.removeEventListener("changeOverwrite", this.$onCursorChange);
	            this.session.removeEventListener("changeScrollTop", this.$onScrollTopChange);
	            this.session.removeEventListener("changeScrollLeft", this.$onScrollLeftChange);

	            var selection = this.session.getSelection();
	            selection.removeEventListener("changeCursor", this.$onCursorChange);
	            selection.removeEventListener("changeSelection", this.$onSelectionChange);
	        }

	        this.session = session;
	        if (session) {
	            this.$onDocumentChange = this.onDocumentChange.bind(this);
	            session.addEventListener("change", this.$onDocumentChange);
	            this.renderer.setSession(session);
	    
	            this.$onChangeMode = this.onChangeMode.bind(this);
	            session.addEventListener("changeMode", this.$onChangeMode);
	    
	            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
	            session.addEventListener("tokenizerUpdate", this.$onTokenizerUpdate);
	    
	            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
	            session.addEventListener("changeTabSize", this.$onChangeTabSize);
	    
	            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
	            session.addEventListener("changeWrapLimit", this.$onChangeWrapLimit);
	    
	            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
	            session.addEventListener("changeWrapMode", this.$onChangeWrapMode);
	    
	            this.$onChangeFold = this.onChangeFold.bind(this);
	            session.addEventListener("changeFold", this.$onChangeFold);
	    
	            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
	            this.session.addEventListener("changeFrontMarker", this.$onChangeFrontMarker);
	    
	            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
	            this.session.addEventListener("changeBackMarker", this.$onChangeBackMarker);
	    
	            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
	            this.session.addEventListener("changeBreakpoint", this.$onChangeBreakpoint);
	    
	            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
	            this.session.addEventListener("changeAnnotation", this.$onChangeAnnotation);
	    
	            this.$onCursorChange = this.onCursorChange.bind(this);
	            this.session.addEventListener("changeOverwrite", this.$onCursorChange);
	    
	            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
	            this.session.addEventListener("changeScrollTop", this.$onScrollTopChange);
	    
	            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
	            this.session.addEventListener("changeScrollLeft", this.$onScrollLeftChange);
	    
	            this.selection = session.getSelection();
	            this.selection.addEventListener("changeCursor", this.$onCursorChange);
	    
	            this.$onSelectionChange = this.onSelectionChange.bind(this);
	            this.selection.addEventListener("changeSelection", this.$onSelectionChange);
	    
	            this.onChangeMode();
	    
	            this.$blockScrolling += 1;
	            this.onCursorChange();
	            this.$blockScrolling -= 1;
	    
	            this.onScrollTopChange();
	            this.onScrollLeftChange();
	            this.onSelectionChange();
	            this.onChangeFrontMarker();
	            this.onChangeBackMarker();
	            this.onChangeBreakpoint();
	            this.onChangeAnnotation();
	            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
	            this.renderer.updateFull();
	        } else {
	            this.selection = null;
	            this.renderer.setSession(session);
	        }

	        this._signal("changeSession", {
	            session: session,
	            oldSession: oldSession
	        });
	        
	        oldSession && oldSession._signal("changeEditor", {oldEditor: this});
	        session && session._signal("changeEditor", {editor: this});
	    };
	    this.getSession = function() {
	        return this.session;
	    };
	    this.setValue = function(val, cursorPos) {
	        this.session.doc.setValue(val);

	        if (!cursorPos)
	            this.selectAll();
	        else if (cursorPos == 1)
	            this.navigateFileEnd();
	        else if (cursorPos == -1)
	            this.navigateFileStart();

	        return val;
	    };
	    this.getValue = function() {
	        return this.session.getValue();
	    };
	    this.getSelection = function() {
	        return this.selection;
	    };
	    this.resize = function(force) {
	        this.renderer.onResize(force);
	    };
	    this.setTheme = function(theme, cb) {
	        this.renderer.setTheme(theme, cb);
	    };
	    this.getTheme = function() {
	        return this.renderer.getTheme();
	    };
	    this.setStyle = function(style) {
	        this.renderer.setStyle(style);
	    };
	    this.unsetStyle = function(style) {
	        this.renderer.unsetStyle(style);
	    };
	    this.getFontSize = function () {
	        return this.getOption("fontSize") ||
	           dom.computedStyle(this.container, "fontSize");
	    };
	    this.setFontSize = function(size) {
	        this.setOption("fontSize", size);
	    };

	    this.$highlightBrackets = function() {
	        if (this.session.$bracketHighlight) {
	            this.session.removeMarker(this.session.$bracketHighlight);
	            this.session.$bracketHighlight = null;
	        }

	        if (this.$highlightPending) {
	            return;
	        }
	        var self = this;
	        this.$highlightPending = true;
	        setTimeout(function() {
	            self.$highlightPending = false;
	            var session = self.session;
	            if (!session || !session.bgTokenizer) return;
	            var pos = session.findMatchingBracket(self.getCursorPosition());
	            if (pos) {
	                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
	            } else if (session.$mode.getMatching) {
	                var range = session.$mode.getMatching(self.session);
	            }
	            if (range)
	                session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
	        }, 50);
	    };
	    this.$highlightTags = function() {
	        if (this.$highlightTagPending)
	            return;
	        var self = this;
	        this.$highlightTagPending = true;
	        setTimeout(function() {
	            self.$highlightTagPending = false;
	            
	            var session = self.session;
	            if (!session || !session.bgTokenizer) return;
	            
	            var pos = self.getCursorPosition();
	            var iterator = new TokenIterator(self.session, pos.row, pos.column);
	            var token = iterator.getCurrentToken();
	            
	            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	                return;
	            }

	            if (token.type.indexOf("tag-open") != -1) {
	                token = iterator.stepForward();
	                if (!token)
	                    return;
	            }

	            var tag = token.value;
	            var depth = 0;
	            var prevToken = iterator.stepBackward();
	            
	            if (prevToken.value == '<'){
	                do {
	                    prevToken = token;
	                    token = iterator.stepForward();
	                    
	                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                        if (prevToken.value === '<'){
	                            depth++;
	                        } else if (prevToken.value === '</'){
	                            depth--;
	                        }
	                    }
	                    
	                } while (token && depth >= 0);
	            } else {
	                do {
	                    token = prevToken;
	                    prevToken = iterator.stepBackward();
	                    
	                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                        if (prevToken.value === '<') {
	                            depth++;
	                        } else if (prevToken.value === '</') {
	                            depth--;
	                        }
	                    }
	                } while (prevToken && depth <= 0);
	                iterator.stepForward();
	            }
	            
	            if (!token) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	                return;
	            }
	            
	            var row = iterator.getCurrentTokenRow();
	            var column = iterator.getCurrentTokenColumn();
	            var range = new Range(row, column, row, column+token.value.length);
	            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range)!==0) {
	                session.removeMarker(session.$tagHighlight);
	                session.$tagHighlight = null;
	            }
	            
	            if (range && !session.$tagHighlight)
	                session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
	        }, 50);
	    };
	    this.focus = function() {
	        var _self = this;
	        setTimeout(function() {
	            _self.textInput.focus();
	        });
	        this.textInput.focus();
	    };
	    this.isFocused = function() {
	        return this.textInput.isFocused();
	    };
	    this.blur = function() {
	        this.textInput.blur();
	    };
	    this.onFocus = function(e) {
	        if (this.$isFocused)
	            return;
	        this.$isFocused = true;
	        this.renderer.showCursor();
	        this.renderer.visualizeFocus();
	        this._emit("focus", e);
	    };
	    this.onBlur = function(e) {
	        if (!this.$isFocused)
	            return;
	        this.$isFocused = false;
	        this.renderer.hideCursor();
	        this.renderer.visualizeBlur();
	        this._emit("blur", e);
	    };

	    this.$cursorChange = function() {
	        this.renderer.updateCursor();
	    };
	    this.onDocumentChange = function(e) {
	        var delta = e.data;
	        var range = delta.range;
	        var lastRow;

	        if (range.start.row == range.end.row && delta.action != "insertLines" && delta.action != "removeLines")
	            lastRow = range.end.row;
	        else
	            lastRow = Infinity;
	        this.renderer.updateLines(range.start.row, lastRow, this.session.$useWrapMode);

	        this._signal("change", e);
	        this.$cursorChange();
	        this.$updateHighlightActiveLine();
	    };

	    this.onTokenizerUpdate = function(e) {
	        var rows = e.data;
	        this.renderer.updateLines(rows.first, rows.last);
	    };


	    this.onScrollTopChange = function() {
	        this.renderer.scrollToY(this.session.getScrollTop());
	    };

	    this.onScrollLeftChange = function() {
	        this.renderer.scrollToX(this.session.getScrollLeft());
	    };
	    this.onCursorChange = function() {
	        this.$cursorChange();

	        if (!this.$blockScrolling) {
	            config.warn("Automatically scrolling cursor into view after selection change",
	                "this will be disabled in the next version",
	                "set editor.$blockScrolling = Infinity to disable this message"
	            );
	            this.renderer.scrollCursorIntoView();
	        }

	        this.$highlightBrackets();
	        this.$highlightTags();
	        this.$updateHighlightActiveLine();
	        this._signal("changeSelection");
	    };

	    this.$updateHighlightActiveLine = function() {
	        var session = this.getSession();

	        var highlight;
	        if (this.$highlightActiveLine) {
	            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
	                highlight = this.getCursorPosition();
	            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
	                highlight = false;
	        }

	        if (session.$highlightLineMarker && !highlight) {
	            session.removeMarker(session.$highlightLineMarker.id);
	            session.$highlightLineMarker = null;
	        } else if (!session.$highlightLineMarker && highlight) {
	            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
	            range.id = session.addMarker(range, "ace_active-line", "screenLine");
	            session.$highlightLineMarker = range;
	        } else if (highlight) {
	            session.$highlightLineMarker.start.row = highlight.row;
	            session.$highlightLineMarker.end.row = highlight.row;
	            session.$highlightLineMarker.start.column = highlight.column;
	            session._signal("changeBackMarker");
	        }
	    };

	    this.onSelectionChange = function(e) {
	        var session = this.session;

	        if (session.$selectionMarker) {
	            session.removeMarker(session.$selectionMarker);
	        }
	        session.$selectionMarker = null;

	        if (!this.selection.isEmpty()) {
	            var range = this.selection.getRange();
	            var style = this.getSelectionStyle();
	            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
	        } else {
	            this.$updateHighlightActiveLine();
	        }

	        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
	        this.session.highlight(re);

	        this._signal("changeSelection");
	    };

	    this.$getSelectionHighLightRegexp = function() {
	        var session = this.session;

	        var selection = this.getSelectionRange();
	        if (selection.isEmpty() || selection.isMultiLine())
	            return;

	        var startOuter = selection.start.column - 1;
	        var endOuter = selection.end.column + 1;
	        var line = session.getLine(selection.start.row);
	        var lineCols = line.length;
	        var needle = line.substring(Math.max(startOuter, 0),
	                                    Math.min(endOuter, lineCols));
	        if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
	            (endOuter <= lineCols && /[\w\d]$/.test(needle)))
	            return;

	        needle = line.substring(selection.start.column, selection.end.column);
	        if (!/^[\w\d]+$/.test(needle))
	            return;

	        var re = this.$search.$assembleRegExp({
	            wholeWord: true,
	            caseSensitive: true,
	            needle: needle
	        });

	        return re;
	    };


	    this.onChangeFrontMarker = function() {
	        this.renderer.updateFrontMarkers();
	    };

	    this.onChangeBackMarker = function() {
	        this.renderer.updateBackMarkers();
	    };


	    this.onChangeBreakpoint = function() {
	        this.renderer.updateBreakpoints();
	    };

	    this.onChangeAnnotation = function() {
	        this.renderer.setAnnotations(this.session.getAnnotations());
	    };


	    this.onChangeMode = function(e) {
	        this.renderer.updateText();
	        this._emit("changeMode", e);
	    };


	    this.onChangeWrapLimit = function() {
	        this.renderer.updateFull();
	    };

	    this.onChangeWrapMode = function() {
	        this.renderer.onResize(true);
	    };


	    this.onChangeFold = function() {
	        this.$updateHighlightActiveLine();
	        this.renderer.updateFull();
	    };
	    this.getSelectedText = function() {
	        return this.session.getTextRange(this.getSelectionRange());
	    };
	    this.getCopyText = function() {
	        var text = this.getSelectedText();
	        this._signal("copy", text);
	        return text;
	    };
	    this.onCopy = function() {
	        this.commands.exec("copy", this);
	    };
	    this.onCut = function() {
	        this.commands.exec("cut", this);
	    };
	    this.onPaste = function(text) {
	        if (this.$readOnly)
	            return;

	        var e = {text: text};
	        this._signal("paste", e);
	        text = e.text;
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
	            this.insert(text);
	        } else {
	            var lines = text.split(/\r\n|\r|\n/);
	            var ranges = this.selection.rangeList.ranges;

	            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
	                return this.commands.exec("insertstring", this, text);

	            for (var i = ranges.length; i--;) {
	                var range = ranges[i];
	                if (!range.isEmpty())
	                    this.session.remove(range);

	                this.session.insert(range.start, lines[i]);
	            }
	        }
	        this.renderer.scrollCursorIntoView();
	    };

	    this.execCommand = function(command, args) {
	        return this.commands.exec(command, this, args);
	    };
	    this.insert = function(text, pasted) {
	        var session = this.session;
	        var mode = session.getMode();
	        var cursor = this.getCursorPosition();

	        if (this.getBehavioursEnabled() && !pasted) {
	            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
	            if (transform) {
	                if (text !== transform.text) {
	                    this.session.mergeUndoDeltas = false;
	                    this.$mergeNextCommand = false;
	                }
	                text = transform.text;

	            }
	        }
	        
	        if (text == "\t")
	            text = this.session.getTabString();
	        if (!this.selection.isEmpty()) {
	            var range = this.getSelectionRange();
	            cursor = this.session.remove(range);
	            this.clearSelection();
	        }
	        else if (this.session.getOverwrite()) {
	            var range = new Range.fromPoints(cursor, cursor);
	            range.end.column += text.length;
	            this.session.remove(range);
	        }

	        if (text == "\n" || text == "\r\n") {
	            var line = session.getLine(cursor.row);
	            if (cursor.column > line.search(/\S|$/)) {
	                var d = line.substr(cursor.column).search(/\S|$/);
	                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
	            }
	        }
	        this.clearSelection();

	        var start = cursor.column;
	        var lineState = session.getState(cursor.row);
	        var line = session.getLine(cursor.row);
	        var shouldOutdent = mode.checkOutdent(lineState, line, text);
	        var end = session.insert(cursor, text);

	        if (transform && transform.selection) {
	            if (transform.selection.length == 2) { // Transform relative to the current column
	                this.selection.setSelectionRange(
	                    new Range(cursor.row, start + transform.selection[0],
	                              cursor.row, start + transform.selection[1]));
	            } else { // Transform relative to the current row.
	                this.selection.setSelectionRange(
	                    new Range(cursor.row + transform.selection[0],
	                              transform.selection[1],
	                              cursor.row + transform.selection[2],
	                              transform.selection[3]));
	            }
	        }

	        if (session.getDocument().isNewLine(text)) {
	            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

	            session.insert({row: cursor.row+1, column: 0}, lineIndent);
	        }
	        if (shouldOutdent)
	            mode.autoOutdent(lineState, session, cursor.row);
	    };

	    this.onTextInput = function(text) {
	        this.keyBinding.onTextInput(text);
	    };

	    this.onCommandKey = function(e, hashId, keyCode) {
	        this.keyBinding.onCommandKey(e, hashId, keyCode);
	    };
	    this.setOverwrite = function(overwrite) {
	        this.session.setOverwrite(overwrite);
	    };
	    this.getOverwrite = function() {
	        return this.session.getOverwrite();
	    };
	    this.toggleOverwrite = function() {
	        this.session.toggleOverwrite();
	    };
	    this.setScrollSpeed = function(speed) {
	        this.setOption("scrollSpeed", speed);
	    };
	    this.getScrollSpeed = function() {
	        return this.getOption("scrollSpeed");
	    };
	    this.setDragDelay = function(dragDelay) {
	        this.setOption("dragDelay", dragDelay);
	    };
	    this.getDragDelay = function() {
	        return this.getOption("dragDelay");
	    };
	    this.setSelectionStyle = function(val) {
	        this.setOption("selectionStyle", val);
	    };
	    this.getSelectionStyle = function() {
	        return this.getOption("selectionStyle");
	    };
	    this.setHighlightActiveLine = function(shouldHighlight) {
	        this.setOption("highlightActiveLine", shouldHighlight);
	    };
	    this.getHighlightActiveLine = function() {
	        return this.getOption("highlightActiveLine");
	    };
	    this.setHighlightGutterLine = function(shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };

	    this.getHighlightGutterLine = function() {
	        return this.getOption("highlightGutterLine");
	    };
	    this.setHighlightSelectedWord = function(shouldHighlight) {
	        this.setOption("highlightSelectedWord", shouldHighlight);
	    };
	    this.getHighlightSelectedWord = function() {
	        return this.$highlightSelectedWord;
	    };

	    this.setAnimatedScroll = function(shouldAnimate){
	        this.renderer.setAnimatedScroll(shouldAnimate);
	    };

	    this.getAnimatedScroll = function(){
	        return this.renderer.getAnimatedScroll();
	    };
	    this.setShowInvisibles = function(showInvisibles) {
	        this.renderer.setShowInvisibles(showInvisibles);
	    };
	    this.getShowInvisibles = function() {
	        return this.renderer.getShowInvisibles();
	    };

	    this.setDisplayIndentGuides = function(display) {
	        this.renderer.setDisplayIndentGuides(display);
	    };

	    this.getDisplayIndentGuides = function() {
	        return this.renderer.getDisplayIndentGuides();
	    };
	    this.setShowPrintMargin = function(showPrintMargin) {
	        this.renderer.setShowPrintMargin(showPrintMargin);
	    };
	    this.getShowPrintMargin = function() {
	        return this.renderer.getShowPrintMargin();
	    };
	    this.setPrintMarginColumn = function(showPrintMargin) {
	        this.renderer.setPrintMarginColumn(showPrintMargin);
	    };
	    this.getPrintMarginColumn = function() {
	        return this.renderer.getPrintMarginColumn();
	    };
	    this.setReadOnly = function(readOnly) {
	        this.setOption("readOnly", readOnly);
	    };
	    this.getReadOnly = function() {
	        return this.getOption("readOnly");
	    };
	    this.setBehavioursEnabled = function (enabled) {
	        this.setOption("behavioursEnabled", enabled);
	    };
	    this.getBehavioursEnabled = function () {
	        return this.getOption("behavioursEnabled");
	    };
	    this.setWrapBehavioursEnabled = function (enabled) {
	        this.setOption("wrapBehavioursEnabled", enabled);
	    };
	    this.getWrapBehavioursEnabled = function () {
	        return this.getOption("wrapBehavioursEnabled");
	    };
	    this.setShowFoldWidgets = function(show) {
	        this.setOption("showFoldWidgets", show);

	    };
	    this.getShowFoldWidgets = function() {
	        return this.getOption("showFoldWidgets");
	    };

	    this.setFadeFoldWidgets = function(fade) {
	        this.setOption("fadeFoldWidgets", fade);
	    };

	    this.getFadeFoldWidgets = function() {
	        return this.getOption("fadeFoldWidgets");
	    };
	    this.remove = function(dir) {
	        if (this.selection.isEmpty()){
	            if (dir == "left")
	                this.selection.selectLeft();
	            else
	                this.selection.selectRight();
	        }

	        var range = this.getSelectionRange();
	        if (this.getBehavioursEnabled()) {
	            var session = this.session;
	            var state = session.getState(range.start.row);
	            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);

	            if (range.end.column === 0) {
	                var text = session.getTextRange(range);
	                if (text[text.length - 1] == "\n") {
	                    var line = session.getLine(range.end.row);
	                    if (/^\s+$/.test(line)) {
	                        range.end.column = line.length;
	                    }
	                }
	            }
	            if (new_range)
	                range = new_range;
	        }

	        this.session.remove(range);
	        this.clearSelection();
	    };
	    this.removeWordRight = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectWordRight();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeWordLeft = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectWordLeft();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeToLineStart = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectLineStart();

	        this.session.remove(this.getSelectionRange());
	        this.clearSelection();
	    };
	    this.removeToLineEnd = function() {
	        if (this.selection.isEmpty())
	            this.selection.selectLineEnd();

	        var range = this.getSelectionRange();
	        if (range.start.column == range.end.column && range.start.row == range.end.row) {
	            range.end.column = 0;
	            range.end.row++;
	        }

	        this.session.remove(range);
	        this.clearSelection();
	    };
	    this.splitLine = function() {
	        if (!this.selection.isEmpty()) {
	            this.session.remove(this.getSelectionRange());
	            this.clearSelection();
	        }

	        var cursor = this.getCursorPosition();
	        this.insert("\n");
	        this.moveCursorToPosition(cursor);
	    };
	    this.transposeLetters = function() {
	        if (!this.selection.isEmpty()) {
	            return;
	        }

	        var cursor = this.getCursorPosition();
	        var column = cursor.column;
	        if (column === 0)
	            return;

	        var line = this.session.getLine(cursor.row);
	        var swap, range;
	        if (column < line.length) {
	            swap = line.charAt(column) + line.charAt(column-1);
	            range = new Range(cursor.row, column-1, cursor.row, column+1);
	        }
	        else {
	            swap = line.charAt(column-1) + line.charAt(column-2);
	            range = new Range(cursor.row, column-2, cursor.row, column);
	        }
	        this.session.replace(range, swap);
	    };
	    this.toLowerCase = function() {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }

	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toLowerCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    this.toUpperCase = function() {
	        var originalRange = this.getSelectionRange();
	        if (this.selection.isEmpty()) {
	            this.selection.selectWord();
	        }

	        var range = this.getSelectionRange();
	        var text = this.session.getTextRange(range);
	        this.session.replace(range, text.toUpperCase());
	        this.selection.setSelectionRange(originalRange);
	    };
	    this.indent = function() {
	        var session = this.session;
	        var range = this.getSelectionRange();

	        if (range.start.row < range.end.row) {
	            var rows = this.$getSelectedRows();
	            session.indentRows(rows.first, rows.last, "\t");
	            return;
	        } else if (range.start.column < range.end.column) {
	            var text = session.getTextRange(range);
	            if (!/^\s+$/.test(text)) {
	                var rows = this.$getSelectedRows();
	                session.indentRows(rows.first, rows.last, "\t");
	                return;
	            }
	        }
	        
	        var line = session.getLine(range.start.row);
	        var position = range.start;
	        var size = session.getTabSize();
	        var column = session.documentToScreenColumn(position.row, position.column);

	        if (this.session.getUseSoftTabs()) {
	            var count = (size - column % size);
	            var indentString = lang.stringRepeat(" ", count);
	        } else {
	            var count = column % size;
	            while (line[range.start.column] == " " && count) {
	                range.start.column--;
	                count--;
	            }
	            this.selection.setSelectionRange(range);
	            indentString = "\t";
	        }
	        return this.insert(indentString);
	    };
	    this.blockIndent = function() {
	        var rows = this.$getSelectedRows();
	        this.session.indentRows(rows.first, rows.last, "\t");
	    };
	    this.blockOutdent = function() {
	        var selection = this.session.getSelection();
	        this.session.outdentRows(selection.getRange());
	    };
	    this.sortLines = function() {
	        var rows = this.$getSelectedRows();
	        var session = this.session;

	        var lines = [];
	        for (i = rows.first; i <= rows.last; i++)
	            lines.push(session.getLine(i));

	        lines.sort(function(a, b) {
	            if (a.toLowerCase() < b.toLowerCase()) return -1;
	            if (a.toLowerCase() > b.toLowerCase()) return 1;
	            return 0;
	        });

	        var deleteRange = new Range(0, 0, 0, 0);
	        for (var i = rows.first; i <= rows.last; i++) {
	            var line = session.getLine(i);
	            deleteRange.start.row = i;
	            deleteRange.end.row = i;
	            deleteRange.end.column = line.length;
	            session.replace(deleteRange, lines[i-rows.first]);
	        }
	    };
	    this.toggleCommentLines = function() {
	        var state = this.session.getState(this.getCursorPosition().row);
	        var rows = this.$getSelectedRows();
	        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
	    };

	    this.toggleBlockComment = function() {
	        var cursor = this.getCursorPosition();
	        var state = this.session.getState(cursor.row);
	        var range = this.getSelectionRange();
	        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
	    };
	    this.getNumberAt = function(row, column) {
	        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
	        _numberRx.lastIndex = 0;

	        var s = this.session.getLine(row);
	        while (_numberRx.lastIndex < column) {
	            var m = _numberRx.exec(s);
	            if(m.index <= column && m.index+m[0].length >= column){
	                var number = {
	                    value: m[0],
	                    start: m.index,
	                    end: m.index+m[0].length
	                };
	                return number;
	            }
	        }
	        return null;
	    };
	    this.modifyNumber = function(amount) {
	        var row = this.selection.getCursor().row;
	        var column = this.selection.getCursor().column;
	        var charRange = new Range(row, column-1, row, column);

	        var c = this.session.getTextRange(charRange);
	        if (!isNaN(parseFloat(c)) && isFinite(c)) {
	            var nr = this.getNumberAt(row, column);
	            if (nr) {
	                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
	                var decimals = nr.start + nr.value.length - fp;

	                var t = parseFloat(nr.value);
	                t *= Math.pow(10, decimals);


	                if(fp !== nr.end && column < fp){
	                    amount *= Math.pow(10, nr.end - column - 1);
	                } else {
	                    amount *= Math.pow(10, nr.end - column);
	                }

	                t += amount;
	                t /= Math.pow(10, decimals);
	                var nnr = t.toFixed(decimals);
	                var replaceRange = new Range(row, nr.start, row, nr.end);
	                this.session.replace(replaceRange, nnr);
	                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));

	            }
	        }
	    };
	    this.removeLines = function() {
	        var rows = this.$getSelectedRows();
	        var range;
	        if (rows.first === 0 || rows.last+1 < this.session.getLength())
	            range = new Range(rows.first, 0, rows.last+1, 0);
	        else
	            range = new Range(
	                rows.first-1, this.session.getLine(rows.first-1).length,
	                rows.last, this.session.getLine(rows.last).length
	            );
	        this.session.remove(range);
	        this.clearSelection();
	    };

	    this.duplicateSelection = function() {
	        var sel = this.selection;
	        var doc = this.session;
	        var range = sel.getRange();
	        var reverse = sel.isBackwards();
	        if (range.isEmpty()) {
	            var row = range.start.row;
	            doc.duplicateLines(row, row);
	        } else {
	            var point = reverse ? range.start : range.end;
	            var endPoint = doc.insert(point, doc.getTextRange(range), false);
	            range.start = point;
	            range.end = endPoint;

	            sel.setSelectionRange(range, reverse);
	        }
	    };
	    this.moveLinesDown = function() {
	        this.$moveLines(1, false);
	    };
	    this.moveLinesUp = function() {
	        this.$moveLines(-1, false);
	    };
	    this.moveText = function(range, toPosition, copy) {
	        return this.session.moveText(range, toPosition, copy);
	    };
	    this.copyLinesUp = function() {
	        this.$moveLines(-1, true);
	    };
	    this.copyLinesDown = function() {
	        this.$moveLines(1, true);
	    };
	    this.$moveLines = function(dir, copy) {
	        var rows, moved;
	        var selection = this.selection;
	        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
	            var range = selection.toOrientedRange();
	            rows = this.$getSelectedRows(range);
	            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
	            if (copy && dir == -1) moved = 0;
	            range.moveBy(moved, 0);
	            selection.fromOrientedRange(range);
	        } else {
	            var ranges = selection.rangeList.ranges;
	            selection.rangeList.detach(this.session);
	            this.inVirtualSelectionMode = true;

	            var diff = 0;
	            var totalDiff = 0;
	            var l = ranges.length;
	            for (var i = 0; i < l; i++) {
	                var rangeIndex = i;
	                ranges[i].moveBy(diff, 0);
	                rows = this.$getSelectedRows(ranges[i]);
	                var first = rows.first;
	                var last = rows.last;
	                while (++i < l) {
	                    if (totalDiff) ranges[i].moveBy(totalDiff, 0);
	                    var subRows = this.$getSelectedRows(ranges[i]);
	                    if (copy && subRows.first != last)
	                        break;
	                    else if (!copy && subRows.first > last + 1)
	                        break;
	                    last = subRows.last;
	                }
	                i--;
	                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
	                if (copy && dir == -1) rangeIndex = i + 1;
	                while (rangeIndex <= i) {
	                    ranges[rangeIndex].moveBy(diff, 0);
	                    rangeIndex++;
	                }
	                if (!copy) diff = 0;
	                totalDiff += diff;
	            }

	            selection.fromOrientedRange(selection.ranges[0]);
	            selection.rangeList.attach(this.session);
	            this.inVirtualSelectionMode = false;
	        }
	    };
	    this.$getSelectedRows = function(range) {
	        range = (range || this.getSelectionRange()).collapseRows();

	        return {
	            first: this.session.getRowFoldStart(range.start.row),
	            last: this.session.getRowFoldEnd(range.end.row)
	        };
	    };

	    this.onCompositionStart = function(text) {
	        this.renderer.showComposition(this.getCursorPosition());
	    };

	    this.onCompositionUpdate = function(text) {
	        this.renderer.setCompositionText(text);
	    };

	    this.onCompositionEnd = function() {
	        this.renderer.hideComposition();
	    };
	    this.getFirstVisibleRow = function() {
	        return this.renderer.getFirstVisibleRow();
	    };
	    this.getLastVisibleRow = function() {
	        return this.renderer.getLastVisibleRow();
	    };
	    this.isRowVisible = function(row) {
	        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
	    };
	    this.isRowFullyVisible = function(row) {
	        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
	    };
	    this.$getVisibleRowCount = function() {
	        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
	    };

	    this.$moveByPage = function(dir, select) {
	        var renderer = this.renderer;
	        var config = this.renderer.layerConfig;
	        var rows = dir * Math.floor(config.height / config.lineHeight);

	        this.$blockScrolling++;
	        if (select === true) {
	            this.selection.$moveSelection(function(){
	                this.moveCursorBy(rows, 0);
	            });
	        } else if (select === false) {
	            this.selection.moveCursorBy(rows, 0);
	            this.selection.clearSelection();
	        }
	        this.$blockScrolling--;

	        var scrollTop = renderer.scrollTop;

	        renderer.scrollBy(0, rows * config.lineHeight);
	        if (select != null)
	            renderer.scrollCursorIntoView(null, 0.5);

	        renderer.animateScrolling(scrollTop);
	    };
	    this.selectPageDown = function() {
	        this.$moveByPage(1, true);
	    };
	    this.selectPageUp = function() {
	        this.$moveByPage(-1, true);
	    };
	    this.gotoPageDown = function() {
	       this.$moveByPage(1, false);
	    };
	    this.gotoPageUp = function() {
	        this.$moveByPage(-1, false);
	    };
	    this.scrollPageDown = function() {
	        this.$moveByPage(1);
	    };
	    this.scrollPageUp = function() {
	        this.$moveByPage(-1);
	    };
	    this.scrollToRow = function(row) {
	        this.renderer.scrollToRow(row);
	    };
	    this.scrollToLine = function(line, center, animate, callback) {
	        this.renderer.scrollToLine(line, center, animate, callback);
	    };
	    this.centerSelection = function() {
	        var range = this.getSelectionRange();
	        var pos = {
	            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
	            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
	        };
	        this.renderer.alignCursor(pos, 0.5);
	    };
	    this.getCursorPosition = function() {
	        return this.selection.getCursor();
	    };
	    this.getCursorPositionScreen = function() {
	        return this.session.documentToScreenPosition(this.getCursorPosition());
	    };
	    this.getSelectionRange = function() {
	        return this.selection.getRange();
	    };
	    this.selectAll = function() {
	        this.$blockScrolling += 1;
	        this.selection.selectAll();
	        this.$blockScrolling -= 1;
	    };
	    this.clearSelection = function() {
	        this.selection.clearSelection();
	    };
	    this.moveCursorTo = function(row, column) {
	        this.selection.moveCursorTo(row, column);
	    };
	    this.moveCursorToPosition = function(pos) {
	        this.selection.moveCursorToPosition(pos);
	    };
	    this.jumpToMatching = function(select, expand) {
	        var cursor = this.getCursorPosition();
	        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
	        var prevToken = iterator.getCurrentToken();
	        var token = prevToken || iterator.stepForward();

	        if (!token) return;
	        var matchType;
	        var found = false;
	        var depth = {};
	        var i = cursor.column - token.start;
	        var bracketType;
	        var brackets = {
	            ")": "(",
	            "(": "(",
	            "]": "[",
	            "[": "[",
	            "{": "{",
	            "}": "{"
	        };
	        
	        do {
	            if (token.value.match(/[{}()\[\]]/g)) {
	                for (; i < token.value.length && !found; i++) {
	                    if (!brackets[token.value[i]]) {
	                        continue;
	                    }

	                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");

	                    if (isNaN(depth[bracketType])) {
	                        depth[bracketType] = 0;
	                    }

	                    switch (token.value[i]) {
	                        case '(':
	                        case '[':
	                        case '{':
	                            depth[bracketType]++;
	                            break;
	                        case ')':
	                        case ']':
	                        case '}':
	                            depth[bracketType]--;

	                            if (depth[bracketType] === -1) {
	                                matchType = 'bracket';
	                                found = true;
	                            }
	                        break;
	                    }
	                }
	            }
	            else if (token && token.type.indexOf('tag-name') !== -1) {
	                if (isNaN(depth[token.value])) {
	                    depth[token.value] = 0;
	                }
	                
	                if (prevToken.value === '<') {
	                    depth[token.value]++;
	                }
	                else if (prevToken.value === '</') {
	                    depth[token.value]--;
	                }
	                
	                if (depth[token.value] === -1) {
	                    matchType = 'tag';
	                    found = true;
	                }
	            }

	            if (!found) {
	                prevToken = token;
	                token = iterator.stepForward();
	                i = 0;
	            }
	        } while (token && !found);
	        if (!matchType)
	            return;

	        var range, pos;
	        if (matchType === 'bracket') {
	            range = this.session.getBracketRange(cursor);
	            if (!range) {
	                range = new Range(
	                    iterator.getCurrentTokenRow(),
	                    iterator.getCurrentTokenColumn() + i - 1,
	                    iterator.getCurrentTokenRow(),
	                    iterator.getCurrentTokenColumn() + i - 1
	                );
	                pos = range.start;
	                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
	                    range = this.session.getBracketRange(pos);
	            }
	        }
	        else if (matchType === 'tag') {
	            if (token && token.type.indexOf('tag-name') !== -1) 
	                var tag = token.value;
	            else
	                return;

	            range = new Range(
	                iterator.getCurrentTokenRow(),
	                iterator.getCurrentTokenColumn() - 2,
	                iterator.getCurrentTokenRow(),
	                iterator.getCurrentTokenColumn() - 2
	            );
	            if (range.compare(cursor.row, cursor.column) === 0) {
	                found = false;
	                do {
	                    token = prevToken;
	                    prevToken = iterator.stepBackward();
	                    
	                    if (prevToken) {
	                        if (prevToken.type.indexOf('tag-close') !== -1) {
	                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
	                        }

	                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
	                            if (prevToken.value === '<') {
	                                depth[tag]++;
	                            }
	                            else if (prevToken.value === '</') {
	                                depth[tag]--;
	                            }
	                            
	                            if (depth[tag] === 0)
	                                found = true;
	                        }
	                    }
	                } while (prevToken && !found);
	            }
	            if (token && token.type.indexOf('tag-name')) {
	                pos = range.start;
	                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
	                    pos = range.end;
	            }
	        }

	        pos = range && range.cursor || pos;
	        if (pos) {
	            if (select) {
	                if (range && expand) {
	                    this.selection.setRange(range);
	                } else if (range && range.isEqual(this.getSelectionRange())) {
	                    this.clearSelection();
	                } else {
	                    this.selection.selectTo(pos.row, pos.column);
	                }
	            } else {
	                this.selection.moveTo(pos.row, pos.column);
	            }
	        }
	    };
	    this.gotoLine = function(lineNumber, column, animate) {
	        this.selection.clearSelection();
	        this.session.unfold({row: lineNumber - 1, column: column || 0});

	        this.$blockScrolling += 1;
	        this.exitMultiSelectMode && this.exitMultiSelectMode();
	        this.moveCursorTo(lineNumber - 1, column || 0);
	        this.$blockScrolling -= 1;

	        if (!this.isRowFullyVisible(lineNumber - 1))
	            this.scrollToLine(lineNumber - 1, true, animate);
	    };
	    this.navigateTo = function(row, column) {
	        this.selection.moveTo(row, column);
	    };
	    this.navigateUp = function(times) {
	        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
	            var selectionStart = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionStart);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(-times || -1, 0);
	    };
	    this.navigateDown = function(times) {
	        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
	            var selectionEnd = this.selection.anchor.getPosition();
	            return this.moveCursorToPosition(selectionEnd);
	        }
	        this.selection.clearSelection();
	        this.selection.moveCursorBy(times || 1, 0);
	    };
	    this.navigateLeft = function(times) {
	        if (!this.selection.isEmpty()) {
	            var selectionStart = this.getSelectionRange().start;
	            this.moveCursorToPosition(selectionStart);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorLeft();
	            }
	        }
	        this.clearSelection();
	    };
	    this.navigateRight = function(times) {
	        if (!this.selection.isEmpty()) {
	            var selectionEnd = this.getSelectionRange().end;
	            this.moveCursorToPosition(selectionEnd);
	        }
	        else {
	            times = times || 1;
	            while (times--) {
	                this.selection.moveCursorRight();
	            }
	        }
	        this.clearSelection();
	    };
	    this.navigateLineStart = function() {
	        this.selection.moveCursorLineStart();
	        this.clearSelection();
	    };
	    this.navigateLineEnd = function() {
	        this.selection.moveCursorLineEnd();
	        this.clearSelection();
	    };
	    this.navigateFileEnd = function() {
	        this.selection.moveCursorFileEnd();
	        this.clearSelection();
	    };
	    this.navigateFileStart = function() {
	        this.selection.moveCursorFileStart();
	        this.clearSelection();
	    };
	    this.navigateWordRight = function() {
	        this.selection.moveCursorWordRight();
	        this.clearSelection();
	    };
	    this.navigateWordLeft = function() {
	        this.selection.moveCursorWordLeft();
	        this.clearSelection();
	    };
	    this.replace = function(replacement, options) {
	        if (options)
	            this.$search.set(options);

	        var range = this.$search.find(this.session);
	        var replaced = 0;
	        if (!range)
	            return replaced;

	        if (this.$tryReplace(range, replacement)) {
	            replaced = 1;
	        }
	        if (range !== null) {
	            this.selection.setSelectionRange(range);
	            this.renderer.scrollSelectionIntoView(range.start, range.end);
	        }

	        return replaced;
	    };
	    this.replaceAll = function(replacement, options) {
	        if (options) {
	            this.$search.set(options);
	        }

	        var ranges = this.$search.findAll(this.session);
	        var replaced = 0;
	        if (!ranges.length)
	            return replaced;

	        this.$blockScrolling += 1;

	        var selection = this.getSelectionRange();
	        this.selection.moveTo(0, 0);

	        for (var i = ranges.length - 1; i >= 0; --i) {
	            if(this.$tryReplace(ranges[i], replacement)) {
	                replaced++;
	            }
	        }

	        this.selection.setSelectionRange(selection);
	        this.$blockScrolling -= 1;

	        return replaced;
	    };

	    this.$tryReplace = function(range, replacement) {
	        var input = this.session.getTextRange(range);
	        replacement = this.$search.replace(input, replacement);
	        if (replacement !== null) {
	            range.end = this.session.replace(range, replacement);
	            return range;
	        } else {
	            return null;
	        }
	    };
	    this.getLastSearchOptions = function() {
	        return this.$search.getOptions();
	    };
	    this.find = function(needle, options, animate) {
	        if (!options)
	            options = {};

	        if (typeof needle == "string" || needle instanceof RegExp)
	            options.needle = needle;
	        else if (typeof needle == "object")
	            oop.mixin(options, needle);

	        var range = this.selection.getRange();
	        if (options.needle == null) {
	            needle = this.session.getTextRange(range)
	                || this.$search.$options.needle;
	            if (!needle) {
	                range = this.session.getWordRange(range.start.row, range.start.column);
	                needle = this.session.getTextRange(range);
	            }
	            this.$search.set({needle: needle});
	        }

	        this.$search.set(options);
	        if (!options.start)
	            this.$search.set({start: range});

	        var newRange = this.$search.find(this.session);
	        if (options.preventScroll)
	            return newRange;
	        if (newRange) {
	            this.revealRange(newRange, animate);
	            return newRange;
	        }
	        if (options.backwards)
	            range.start = range.end;
	        else
	            range.end = range.start;
	        this.selection.setRange(range);
	    };
	    this.findNext = function(options, animate) {
	        this.find({skipCurrent: true, backwards: false}, options, animate);
	    };
	    this.findPrevious = function(options, animate) {
	        this.find(options, {skipCurrent: true, backwards: true}, animate);
	    };

	    this.revealRange = function(range, animate) {
	        this.$blockScrolling += 1;
	        this.session.unfold(range);
	        this.selection.setSelectionRange(range);
	        this.$blockScrolling -= 1;

	        var scrollTop = this.renderer.scrollTop;
	        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
	        if (animate !== false)
	            this.renderer.animateScrolling(scrollTop);
	    };
	    this.undo = function() {
	        this.$blockScrolling++;
	        this.session.getUndoManager().undo();
	        this.$blockScrolling--;
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    this.redo = function() {
	        this.$blockScrolling++;
	        this.session.getUndoManager().redo();
	        this.$blockScrolling--;
	        this.renderer.scrollCursorIntoView(null, 0.5);
	    };
	    this.destroy = function() {
	        this.renderer.destroy();
	        this._signal("destroy", this);
	        if (this.session) {
	            this.session.destroy();
	        }
	    };
	    this.setAutoScrollEditorIntoView = function(enable) {
	        if (!enable)
	            return;
	        var rect;
	        var self = this;
	        var shouldScroll = false;
	        if (!this.$scrollAnchor)
	            this.$scrollAnchor = document.createElement("div");
	        var scrollAnchor = this.$scrollAnchor;
	        scrollAnchor.style.cssText = "position:absolute";
	        this.container.insertBefore(scrollAnchor, this.container.firstChild);
	        var onChangeSelection = this.on("changeSelection", function() {
	            shouldScroll = true;
	        });
	        var onBeforeRender = this.renderer.on("beforeRender", function() {
	            if (shouldScroll)
	                rect = self.renderer.container.getBoundingClientRect();
	        });
	        var onAfterRender = this.renderer.on("afterRender", function() {
	            if (shouldScroll && rect && (self.isFocused()
	                || self.searchBox && self.searchBox.isFocused())
	            ) {
	                var renderer = self.renderer;
	                var pos = renderer.$cursorLayer.$pixelPos;
	                var config = renderer.layerConfig;
	                var top = pos.top - config.offset;
	                if (pos.top >= 0 && top + rect.top < 0) {
	                    shouldScroll = true;
	                } else if (pos.top < config.height &&
	                    pos.top + rect.top + config.lineHeight > window.innerHeight) {
	                    shouldScroll = false;
	                } else {
	                    shouldScroll = null;
	                }
	                if (shouldScroll != null) {
	                    scrollAnchor.style.top = top + "px";
	                    scrollAnchor.style.left = pos.left + "px";
	                    scrollAnchor.style.height = config.lineHeight + "px";
	                    scrollAnchor.scrollIntoView(shouldScroll);
	                }
	                shouldScroll = rect = null;
	            }
	        });
	        this.setAutoScrollEditorIntoView = function(enable) {
	            if (enable)
	                return;
	            delete this.setAutoScrollEditorIntoView;
	            this.removeEventListener("changeSelection", onChangeSelection);
	            this.renderer.removeEventListener("afterRender", onAfterRender);
	            this.renderer.removeEventListener("beforeRender", onBeforeRender);
	        };
	    };


	    this.$resetCursorStyle = function() {
	        var style = this.$cursorStyle || "ace";
	        var cursorLayer = this.renderer.$cursorLayer;
	        if (!cursorLayer)
	            return;
	        cursorLayer.setSmoothBlinking(/smooth/.test(style));
	        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
	        dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
	    };

	}).call(Editor.prototype);



	config.defineOptions(Editor.prototype, "editor", {
	    selectionStyle: {
	        set: function(style) {
	            this.onSelectionChange();
	            this._signal("changeSelectionStyle", {data: style});
	        },
	        initialValue: "line"
	    },
	    highlightActiveLine: {
	        set: function() {this.$updateHighlightActiveLine();},
	        initialValue: true
	    },
	    highlightSelectedWord: {
	        set: function(shouldHighlight) {this.$onSelectionChange();},
	        initialValue: true
	    },
	    readOnly: {
	        set: function(readOnly) {
	            this.$resetCursorStyle(); 
	        },
	        initialValue: false
	    },
	    cursorStyle: {
	        set: function(val) { this.$resetCursorStyle(); },
	        values: ["ace", "slim", "smooth", "wide"],
	        initialValue: "ace"
	    },
	    mergeUndoDeltas: {
	        values: [false, true, "always"],
	        initialValue: true
	    },
	    behavioursEnabled: {initialValue: true},
	    wrapBehavioursEnabled: {initialValue: true},
	    autoScrollEditorIntoView: {
	        set: function(val) {this.setAutoScrollEditorIntoView(val)}
	    },

	    hScrollBarAlwaysVisible: "renderer",
	    vScrollBarAlwaysVisible: "renderer",
	    highlightGutterLine: "renderer",
	    animatedScroll: "renderer",
	    showInvisibles: "renderer",
	    showPrintMargin: "renderer",
	    printMarginColumn: "renderer",
	    printMargin: "renderer",
	    fadeFoldWidgets: "renderer",
	    showFoldWidgets: "renderer",
	    showLineNumbers: "renderer",
	    showGutter: "renderer",
	    displayIndentGuides: "renderer",
	    fontSize: "renderer",
	    fontFamily: "renderer",
	    maxLines: "renderer",
	    minLines: "renderer",
	    scrollPastEnd: "renderer",
	    fixedWidthGutter: "renderer",
	    theme: "renderer",

	    scrollSpeed: "$mouseHandler",
	    dragDelay: "$mouseHandler",
	    dragEnabled: "$mouseHandler",
	    focusTimout: "$mouseHandler",
	    tooltipFollowsMouse: "$mouseHandler",

	    firstLineNumber: "session",
	    overwrite: "session",
	    newLineMode: "session",
	    useWorker: "session",
	    useSoftTabs: "session",
	    tabSize: "session",
	    wrap: "session",
	    foldStyle: "session",
	    mode: "session"
	});

	exports.Editor = Editor;
	});

	ace.define("ace/undomanager",["require","exports","module"], function(acequire, exports, module) {
	"use strict";
	var UndoManager = function() {
	    this.reset();
	};

	(function() {
	    this.execute = function(options) {
	        var deltas = options.args[0];
	        this.$doc  = options.args[1];
	        if (options.merge && this.hasUndo()){
	            this.dirtyCounter--;
	            deltas = this.$undoStack.pop().concat(deltas);
	        }
	        this.$undoStack.push(deltas);
	        this.$redoStack = [];

	        if (this.dirtyCounter < 0) {
	            this.dirtyCounter = NaN;
	        }
	        this.dirtyCounter++;
	    };
	    this.undo = function(dontSelect) {
	        var deltas = this.$undoStack.pop();
	        var undoSelectionRange = null;
	        if (deltas) {
	            undoSelectionRange =
	                this.$doc.undoChanges(deltas, dontSelect);
	            this.$redoStack.push(deltas);
	            this.dirtyCounter--;
	        }

	        return undoSelectionRange;
	    };
	    this.redo = function(dontSelect) {
	        var deltas = this.$redoStack.pop();
	        var redoSelectionRange = null;
	        if (deltas) {
	            redoSelectionRange =
	                this.$doc.redoChanges(deltas, dontSelect);
	            this.$undoStack.push(deltas);
	            this.dirtyCounter++;
	        }

	        return redoSelectionRange;
	    };
	    this.reset = function() {
	        this.$undoStack = [];
	        this.$redoStack = [];
	        this.dirtyCounter = 0;
	    };
	    this.hasUndo = function() {
	        return this.$undoStack.length > 0;
	    };
	    this.hasRedo = function() {
	        return this.$redoStack.length > 0;
	    };
	    this.markClean = function() {
	        this.dirtyCounter = 0;
	    };
	    this.isClean = function() {
	        return this.dirtyCounter === 0;
	    };

	}).call(UndoManager.prototype);

	exports.UndoManager = UndoManager;
	});

	ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var oop = acequire("../lib/oop");
	var lang = acequire("../lib/lang");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var Gutter = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_gutter-layer";
	    parentEl.appendChild(this.element);
	    this.setShowFoldWidgets(this.$showFoldWidgets);
	    
	    this.gutterWidth = 0;

	    this.$annotations = [];
	    this.$updateAnnotations = this.$updateAnnotations.bind(this);

	    this.$cells = [];
	};

	(function() {

	    oop.implement(this, EventEmitter);

	    this.setSession = function(session) {
	        if (this.session)
	            this.session.removeEventListener("change", this.$updateAnnotations);
	        this.session = session;
	        if (session)
	            session.on("change", this.$updateAnnotations);
	    };

	    this.addGutterDecoration = function(row, className){
	        if (window.console)
	            console.warn && console.warn("deprecated use session.addGutterDecoration");
	        this.session.addGutterDecoration(row, className);
	    };

	    this.removeGutterDecoration = function(row, className){
	        if (window.console)
	            console.warn && console.warn("deprecated use session.removeGutterDecoration");
	        this.session.removeGutterDecoration(row, className);
	    };

	    this.setAnnotations = function(annotations) {
	        this.$annotations = [];
	        for (var i = 0; i < annotations.length; i++) {
	            var annotation = annotations[i];
	            var row = annotation.row;
	            var rowInfo = this.$annotations[row];
	            if (!rowInfo)
	                rowInfo = this.$annotations[row] = {text: []};
	           
	            var annoText = annotation.text;
	            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";

	            if (rowInfo.text.indexOf(annoText) === -1)
	                rowInfo.text.push(annoText);

	            var type = annotation.type;
	            if (type == "error")
	                rowInfo.className = " ace_error";
	            else if (type == "warning" && rowInfo.className != " ace_error")
	                rowInfo.className = " ace_warning";
	            else if (type == "info" && (!rowInfo.className))
	                rowInfo.className = " ace_info";
	        }
	    };

	    this.$updateAnnotations = function (e) {
	        if (!this.$annotations.length)
	            return;
	        var delta = e.data;
	        var range = delta.range;
	        var firstRow = range.start.row;
	        var len = range.end.row - firstRow;
	        if (len === 0) {
	        } else if (delta.action == "removeText" || delta.action == "removeLines") {
	            this.$annotations.splice(firstRow, len + 1, null);
	        } else {
	            var args = new Array(len + 1);
	            args.unshift(firstRow, 1);
	            this.$annotations.splice.apply(this.$annotations, args);
	        }
	    };

	    this.update = function(config) {
	        var session = this.session;
	        var firstRow = config.firstRow;
	        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
	            session.getLength() - 1);
	        var fold = session.getNextFoldLine(firstRow);
	        var foldStart = fold ? fold.start.row : Infinity;
	        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
	        var breakpoints = session.$breakpoints;
	        var decorations = session.$decorations;
	        var firstLineNumber = session.$firstLineNumber;
	        var lastLineNumber = 0;
	        
	        var gutterRenderer = session.gutterRenderer || this.$renderer;

	        var cell = null;
	        var index = -1;
	        var row = firstRow;
	        while (true) {
	            if (row > foldStart) {
	                row = fold.end.row + 1;
	                fold = session.getNextFoldLine(row, fold);
	                foldStart = fold ? fold.start.row : Infinity;
	            }
	            if (row > lastRow) {
	                while (this.$cells.length > index + 1) {
	                    cell = this.$cells.pop();
	                    this.element.removeChild(cell.element);
	                }
	                break;
	            }

	            cell = this.$cells[++index];
	            if (!cell) {
	                cell = {element: null, textNode: null, foldWidget: null};
	                cell.element = dom.createElement("div");
	                cell.textNode = document.createTextNode('');
	                cell.element.appendChild(cell.textNode);
	                this.element.appendChild(cell.element);
	                this.$cells[index] = cell;
	            }

	            var className = "ace_gutter-cell ";
	            if (breakpoints[row])
	                className += breakpoints[row];
	            if (decorations[row])
	                className += decorations[row];
	            if (this.$annotations[row])
	                className += this.$annotations[row].className;
	            if (cell.element.className != className)
	                cell.element.className = className;

	            var height = session.getRowLength(row) * config.lineHeight + "px";
	            if (height != cell.element.style.height)
	                cell.element.style.height = height;

	            if (foldWidgets) {
	                var c = foldWidgets[row];
	                if (c == null)
	                    c = foldWidgets[row] = session.getFoldWidget(row);
	            }

	            if (c) {
	                if (!cell.foldWidget) {
	                    cell.foldWidget = dom.createElement("span");
	                    cell.element.appendChild(cell.foldWidget);
	                }
	                var className = "ace_fold-widget ace_" + c;
	                if (c == "start" && row == foldStart && row < fold.end.row)
	                    className += " ace_closed";
	                else
	                    className += " ace_open";
	                if (cell.foldWidget.className != className)
	                    cell.foldWidget.className = className;

	                var height = config.lineHeight + "px";
	                if (cell.foldWidget.style.height != height)
	                    cell.foldWidget.style.height = height;
	            } else {
	                if (cell.foldWidget) {
	                    cell.element.removeChild(cell.foldWidget);
	                    cell.foldWidget = null;
	                }
	            }
	            
	            var text = lastLineNumber = gutterRenderer
	                ? gutterRenderer.getText(session, row)
	                : row + firstLineNumber;
	            if (text != cell.textNode.data)
	                cell.textNode.data = text;

	            row++;
	        }

	        this.element.style.height = config.minHeight + "px";

	        if (this.$fixedWidth || session.$useWrapMode)
	            lastLineNumber = session.getLength() + firstLineNumber;

	        var gutterWidth = gutterRenderer 
	            ? gutterRenderer.getWidth(session, lastLineNumber, config)
	            : lastLineNumber.toString().length * config.characterWidth;
	        
	        var padding = this.$padding || this.$computePadding();
	        gutterWidth += padding.left + padding.right;
	        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
	            this.gutterWidth = gutterWidth;
	            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
	            this._emit("changeGutterWidth", gutterWidth);
	        }
	    };

	    this.$fixedWidth = false;
	    
	    this.$showLineNumbers = true;
	    this.$renderer = "";
	    this.setShowLineNumbers = function(show) {
	        this.$renderer = !show && {
	            getWidth: function() {return ""},
	            getText: function() {return ""}
	        };
	    };
	    
	    this.getShowLineNumbers = function() {
	        return this.$showLineNumbers;
	    };
	    
	    this.$showFoldWidgets = true;
	    this.setShowFoldWidgets = function(show) {
	        if (show)
	            dom.addCssClass(this.element, "ace_folding-enabled");
	        else
	            dom.removeCssClass(this.element, "ace_folding-enabled");

	        this.$showFoldWidgets = show;
	        this.$padding = null;
	    };
	    
	    this.getShowFoldWidgets = function() {
	        return this.$showFoldWidgets;
	    };

	    this.$computePadding = function() {
	        if (!this.element.firstChild)
	            return {left: 0, right: 0};
	        var style = dom.computedStyle(this.element.firstChild);
	        this.$padding = {};
	        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
	        this.$padding.right = parseInt(style.paddingRight) || 0;
	        return this.$padding;
	    };

	    this.getRegion = function(point) {
	        var padding = this.$padding || this.$computePadding();
	        var rect = this.element.getBoundingClientRect();
	        if (point.x < padding.left + rect.left)
	            return "markers";
	        if (this.$showFoldWidgets && point.x > rect.right - padding.right)
	            return "foldWidgets";
	    };

	}).call(Gutter.prototype);

	exports.Gutter = Gutter;

	});

	ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;
	var dom = acequire("../lib/dom");

	var Marker = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_marker-layer";
	    parentEl.appendChild(this.element);
	};

	(function() {

	    this.$padding = 0;

	    this.setPadding = function(padding) {
	        this.$padding = padding;
	    };
	    this.setSession = function(session) {
	        this.session = session;
	    };
	    
	    this.setMarkers = function(markers) {
	        this.markers = markers;
	    };

	    this.update = function(config) {
	        var config = config || this.config;
	        if (!config)
	            return;

	        this.config = config;


	        var html = [];
	        for (var key in this.markers) {
	            var marker = this.markers[key];

	            if (!marker.range) {
	                marker.update(html, this, this.session, config);
	                continue;
	            }

	            var range = marker.range.clipRows(config.firstRow, config.lastRow);
	            if (range.isEmpty()) continue;

	            range = range.toScreenRange(this.session);
	            if (marker.renderer) {
	                var top = this.$getTop(range.start.row, config);
	                var left = this.$padding + range.start.column * config.characterWidth;
	                marker.renderer(html, range, left, top, config);
	            } else if (marker.type == "fullLine") {
	                this.drawFullLineMarker(html, range, marker.clazz, config);
	            } else if (marker.type == "screenLine") {
	                this.drawScreenLineMarker(html, range, marker.clazz, config);
	            } else if (range.isMultiLine()) {
	                if (marker.type == "text")
	                    this.drawTextMarker(html, range, marker.clazz, config);
	                else
	                    this.drawMultiLineMarker(html, range, marker.clazz, config);
	            } else {
	                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start", config);
	            }
	        }
	        this.element.innerHTML = html.join("");
	    };

	    this.$getTop = function(row, layerConfig) {
	        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
	    };
	    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
	        var row = range.start.row;

	        var lineRange = new Range(
	            row, range.start.column,
	            row, this.session.getScreenLastRowColumn(row)
	        );
	        this.drawSingleLineMarker(stringBuilder, lineRange, clazz + " ace_start", layerConfig, 1, extraStyle);
	        row = range.end.row;
	        lineRange = new Range(row, 0, row, range.end.column);
	        this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, extraStyle);

	        for (row = range.start.row + 1; row < range.end.row; row++) {
	            lineRange.start.row = row;
	            lineRange.end.row = row;
	            lineRange.end.column = this.session.getScreenLastRowColumn(row);
	            this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, extraStyle);
	        }
	    };
	    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var padding = this.$padding;
	        var height = config.lineHeight;
	        var top = this.$getTop(range.start.row, config);
	        var left = padding + range.start.column * config.characterWidth;
	        extraStyle = extraStyle || "";

	        stringBuilder.push(
	            "<div class='", clazz, " ace_start' style='",
	            "height:", height, "px;",
	            "right:0;",
	            "top:", top, "px;",
	            "left:", left, "px;", extraStyle, "'></div>"
	        );
	        top = this.$getTop(range.end.row, config);
	        var width = range.end.column * config.characterWidth;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "width:", width, "px;",
	            "top:", top, "px;",
	            "left:", padding, "px;", extraStyle, "'></div>"
	        );
	        height = (range.end.row - range.start.row - 1) * config.lineHeight;
	        if (height < 0)
	            return;
	        top = this.$getTop(range.start.row + 1, config);

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "right:0;",
	            "top:", top, "px;",
	            "left:", padding, "px;", extraStyle, "'></div>"
	        );
	    };
	    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
	        var height = config.lineHeight;
	        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;

	        var top = this.$getTop(range.start.row, config);
	        var left = this.$padding + range.start.column * config.characterWidth;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "width:", width, "px;",
	            "top:", top, "px;",
	            "left:", left, "px;", extraStyle || "", "'></div>"
	        );
	    };

	    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;
	        if (range.start.row != range.end.row)
	            height += this.$getTop(range.end.row, config) - top;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "top:", top, "px;",
	            "left:0;right:0;", extraStyle || "", "'></div>"
	        );
	    };
	    
	    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
	        var top = this.$getTop(range.start.row, config);
	        var height = config.lineHeight;

	        stringBuilder.push(
	            "<div class='", clazz, "' style='",
	            "height:", height, "px;",
	            "top:", top, "px;",
	            "left:0;right:0;", extraStyle || "", "'></div>"
	        );
	    };

	}).call(Marker.prototype);

	exports.Marker = Marker;

	});

	ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var useragent = acequire("../lib/useragent");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var Text = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_text-layer";
	    parentEl.appendChild(this.element);
	    this.$updateEolChar = this.$updateEolChar.bind(this);
	};

	(function() {

	    oop.implement(this, EventEmitter);

	    this.EOF_CHAR = "\xB6";
	    this.EOL_CHAR_LF = "\xAC";
	    this.EOL_CHAR_CRLF = "\xa4";
	    this.EOL_CHAR = this.EOL_CHAR_LF;
	    this.TAB_CHAR = "\u2192"; //"\u21E5";
	    this.SPACE_CHAR = "\xB7";
	    this.$padding = 0;

	    this.$updateEolChar = function() {
	        var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
	           ? this.EOL_CHAR_LF
	           : this.EOL_CHAR_CRLF;
	        if (this.EOL_CHAR != EOL_CHAR) {
	            this.EOL_CHAR = EOL_CHAR;
	            return true;
	        }
	    }

	    this.setPadding = function(padding) {
	        this.$padding = padding;
	        this.element.style.padding = "0 " + padding + "px";
	    };

	    this.getLineHeight = function() {
	        return this.$fontMetrics.$characterSize.height || 0;
	    };

	    this.getCharacterWidth = function() {
	        return this.$fontMetrics.$characterSize.width || 0;
	    };
	    
	    this.$setFontMetrics = function(measure) {
	        this.$fontMetrics = measure;
	        this.$fontMetrics.on("changeCharacterSize", function(e) {
	            this._signal("changeCharacterSize", e);
	        }.bind(this));
	        this.$pollSizeChanges();
	    }

	    this.checkForSizeChanges = function() {
	        this.$fontMetrics.checkForSizeChanges();
	    };
	    this.$pollSizeChanges = function() {
	        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
	    };
	    this.setSession = function(session) {
	        this.session = session;
	        if (session)
	            this.$computeTabString();
	    };

	    this.showInvisibles = false;
	    this.setShowInvisibles = function(showInvisibles) {
	        if (this.showInvisibles == showInvisibles)
	            return false;

	        this.showInvisibles = showInvisibles;
	        this.$computeTabString();
	        return true;
	    };

	    this.displayIndentGuides = true;
	    this.setDisplayIndentGuides = function(display) {
	        if (this.displayIndentGuides == display)
	            return false;

	        this.displayIndentGuides = display;
	        this.$computeTabString();
	        return true;
	    };

	    this.$tabStrings = [];
	    this.onChangeTabSize =
	    this.$computeTabString = function() {
	        var tabSize = this.session.getTabSize();
	        this.tabSize = tabSize;
	        var tabStr = this.$tabStrings = [0];
	        for (var i = 1; i < tabSize + 1; i++) {
	            if (this.showInvisibles) {
	                tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
	                    + this.TAB_CHAR
	                    + lang.stringRepeat(" ", i - 1)
	                    + "</span>");
	            } else {
	                tabStr.push(lang.stringRepeat(" ", i));
	            }
	        }
	        if (this.displayIndentGuides) {
	            this.$indentGuideRe =  /\s\S| \t|\t |\s$/;
	            var className = "ace_indent-guide";
	            var spaceClass = "";
	            var tabClass = "";
	            if (this.showInvisibles) {
	                className += " ace_invisible";
	                spaceClass = " ace_invisible_space";
	                tabClass = " ace_invisible_tab";
	                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
	                var tabContent = this.TAB_CHAR + lang.stringRepeat(" ", this.tabSize - 1);
	            } else{
	                var spaceContent = lang.stringRepeat(" ", this.tabSize);
	                var tabContent = spaceContent;
	            }

	            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
	            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
	        }
	    };

	    this.updateLines = function(config, firstRow, lastRow) {
	        if (this.config.lastRow != config.lastRow ||
	            this.config.firstRow != config.firstRow) {
	            this.scrollLines(config);
	        }
	        this.config = config;

	        var first = Math.max(firstRow, config.firstRow);
	        var last = Math.min(lastRow, config.lastRow);

	        var lineElements = this.element.childNodes;
	        var lineElementsIdx = 0;

	        for (var row = config.firstRow; row < first; row++) {
	            var foldLine = this.session.getFoldLine(row);
	            if (foldLine) {
	                if (foldLine.containsRow(first)) {
	                    first = foldLine.start.row;
	                    break;
	                } else {
	                    row = foldLine.end.row;
	                }
	            }
	            lineElementsIdx ++;
	        }

	        var row = first;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row :Infinity;
	            }
	            if (row > last)
	                break;

	            var lineElement = lineElements[lineElementsIdx++];
	            if (lineElement) {
	                var html = [];
	                this.$renderLine(
	                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false
	                );
	                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
	                lineElement.innerHTML = html.join("");
	            }
	            row++;
	        }
	    };

	    this.scrollLines = function(config) {
	        var oldConfig = this.config;
	        this.config = config;

	        if (!oldConfig || oldConfig.lastRow < config.firstRow)
	            return this.update(config);

	        if (config.lastRow < oldConfig.firstRow)
	            return this.update(config);

	        var el = this.element;
	        if (oldConfig.firstRow < config.firstRow)
	            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)
	                el.removeChild(el.firstChild);

	        if (oldConfig.lastRow > config.lastRow)
	            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)
	                el.removeChild(el.lastChild);

	        if (config.firstRow < oldConfig.firstRow) {
	            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
	            if (el.firstChild)
	                el.insertBefore(fragment, el.firstChild);
	            else
	                el.appendChild(fragment);
	        }

	        if (config.lastRow > oldConfig.lastRow) {
	            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
	            el.appendChild(fragment);
	        }
	    };

	    this.$renderLinesFragment = function(config, firstRow, lastRow) {
	        var fragment = this.element.ownerDocument.createDocumentFragment();
	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row : Infinity;
	            }
	            if (row > lastRow)
	                break;

	            var container = dom.createElement("div");

	            var html = [];
	            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
	            container.innerHTML = html.join("");
	            if (this.$useLineGroups()) {
	                container.className = 'ace_line_group';
	                fragment.appendChild(container);
	                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";

	            } else {
	                while(container.firstChild)
	                    fragment.appendChild(container.firstChild);
	            }

	            row++;
	        }
	        return fragment;
	    };

	    this.update = function(config) {
	        this.config = config;

	        var html = [];
	        var firstRow = config.firstRow, lastRow = config.lastRow;

	        var row = firstRow;
	        var foldLine = this.session.getNextFoldLine(row);
	        var foldStart = foldLine ? foldLine.start.row : Infinity;

	        while (true) {
	            if (row > foldStart) {
	                row = foldLine.end.row+1;
	                foldLine = this.session.getNextFoldLine(row, foldLine);
	                foldStart = foldLine ? foldLine.start.row :Infinity;
	            }
	            if (row > lastRow)
	                break;

	            if (this.$useLineGroups())
	                html.push("<div class='ace_line_group' style='height:", config.lineHeight*this.session.getRowLength(row), "px'>")

	            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);

	            if (this.$useLineGroups())
	                html.push("</div>"); // end the line group

	            row++;
	        }
	        this.element.innerHTML = html.join("");
	    };

	    this.$textToken = {
	        "text": true,
	        "rparen": true,
	        "lparen": true
	    };

	    this.$renderToken = function(stringBuilder, screenColumn, token, value) {
	        var self = this;
	        var replaceReg = /\t|&|<|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
	        var replaceFunc = function(c, a, b, tabIdx, idx4) {
	            if (a) {
	                return self.showInvisibles
	                    ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
	                    : c;
	            } else if (c == "&") {
	                return "&#38;";
	            } else if (c == "<") {
	                return "&#60;";
	            } else if (c == "\t") {
	                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
	                screenColumn += tabSize - 1;
	                return self.$tabStrings[tabSize];
	            } else if (c == "\u3000") {
	                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
	                var space = self.showInvisibles ? self.SPACE_CHAR : "";
	                screenColumn += 1;
	                return "<span class='" + classToUse + "' style='width:" +
	                    (self.config.characterWidth * 2) +
	                    "px'>" + space + "</span>";
	            } else if (b) {
	                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
	            } else {
	                screenColumn += 1;
	                return "<span class='ace_cjk' style='width:" +
	                    (self.config.characterWidth * 2) +
	                    "px'>" + c + "</span>";
	            }
	        };

	        var output = value.replace(replaceReg, replaceFunc);

	        if (!this.$textToken[token.type]) {
	            var classes = "ace_" + token.type.replace(/\./g, " ace_");
	            var style = "";
	            if (token.type == "fold")
	                style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
	            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
	        }
	        else {
	            stringBuilder.push(output);
	        }
	        return screenColumn + value.length;
	    };

	    this.renderIndentGuide = function(stringBuilder, value, max) {
	        var cols = value.search(this.$indentGuideRe);
	        if (cols <= 0 || cols >= max)
	            return value;
	        if (value[0] == " ") {
	            cols -= cols % this.tabSize;
	            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols/this.tabSize));
	            return value.substr(cols);
	        } else if (value[0] == "\t") {
	            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
	            return value.substr(cols);
	        }
	        return value;
	    };

	    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
	        var chars = 0;
	        var split = 0;
	        var splitChars = splits[0];
	        var screenColumn = 0;

	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            var value = token.value;
	            if (i == 0 && this.displayIndentGuides) {
	                chars = value.length;
	                value = this.renderIndentGuide(stringBuilder, value, splitChars);
	                if (!value)
	                    continue;
	                chars -= value.length;
	            }

	            if (chars + value.length < splitChars) {
	                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	                chars += value.length;
	            } else {
	                while (chars + value.length >= splitChars) {
	                    screenColumn = this.$renderToken(
	                        stringBuilder, screenColumn,
	                        token, value.substring(0, splitChars - chars)
	                    );
	                    value = value.substring(splitChars - chars);
	                    chars = splitChars;

	                    if (!onlyContents) {
	                        stringBuilder.push("</div>",
	                            "<div class='ace_line' style='height:",
	                            this.config.lineHeight, "px'>"
	                        );
	                    }

	                    split ++;
	                    screenColumn = 0;
	                    splitChars = splits[split] || Number.MAX_VALUE;
	                }
	                if (value.length != 0) {
	                    chars += value.length;
	                    screenColumn = this.$renderToken(
	                        stringBuilder, screenColumn, token, value
	                    );
	                }
	            }
	        }
	    };

	    this.$renderSimpleLine = function(stringBuilder, tokens) {
	        var screenColumn = 0;
	        var token = tokens[0];
	        var value = token.value;
	        if (this.displayIndentGuides)
	            value = this.renderIndentGuide(stringBuilder, value);
	        if (value)
	            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	        for (var i = 1; i < tokens.length; i++) {
	            token = tokens[i];
	            value = token.value;
	            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
	        }
	    };
	    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
	        if (!foldLine && foldLine != false)
	            foldLine = this.session.getFoldLine(row);

	        if (foldLine)
	            var tokens = this.$getFoldLineTokens(row, foldLine);
	        else
	            var tokens = this.session.getTokens(row);


	        if (!onlyContents) {
	            stringBuilder.push(
	                "<div class='ace_line' style='height:", 
	                    this.config.lineHeight * (
	                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)
	                    ), "px'>"
	            );
	        }

	        if (tokens.length) {
	            var splits = this.session.getRowSplitData(row);
	            if (splits && splits.length)
	                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
	            else
	                this.$renderSimpleLine(stringBuilder, tokens);
	        }

	        if (this.showInvisibles) {
	            if (foldLine)
	                row = foldLine.end.row

	            stringBuilder.push(
	                "<span class='ace_invisible ace_invisible_eol'>",
	                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,
	                "</span>"
	            );
	        }
	        if (!onlyContents)
	            stringBuilder.push("</div>");
	    };

	    this.$getFoldLineTokens = function(row, foldLine) {
	        var session = this.session;
	        var renderTokens = [];

	        function addTokens(tokens, from, to) {
	            var idx = 0, col = 0;
	            while ((col + tokens[idx].value.length) < from) {
	                col += tokens[idx].value.length;
	                idx++;

	                if (idx == tokens.length)
	                    return;
	            }
	            if (col != from) {
	                var value = tokens[idx].value.substring(from - col);
	                if (value.length > (to - from))
	                    value = value.substring(0, to - from);

	                renderTokens.push({
	                    type: tokens[idx].type,
	                    value: value
	                });

	                col = from + value.length;
	                idx += 1;
	            }

	            while (col < to && idx < tokens.length) {
	                var value = tokens[idx].value;
	                if (value.length + col > to) {
	                    renderTokens.push({
	                        type: tokens[idx].type,
	                        value: value.substring(0, to - col)
	                    });
	                } else
	                    renderTokens.push(tokens[idx]);
	                col += value.length;
	                idx += 1;
	            }
	        }

	        var tokens = session.getTokens(row);
	        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
	            if (placeholder != null) {
	                renderTokens.push({
	                    type: "fold",
	                    value: placeholder
	                });
	            } else {
	                if (isNewRow)
	                    tokens = session.getTokens(row);

	                if (tokens.length)
	                    addTokens(tokens, lastColumn, column);
	            }
	        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);

	        return renderTokens;
	    };

	    this.$useLineGroups = function() {
	        return this.session.getUseWrapMode();
	    };

	    this.destroy = function() {
	        clearInterval(this.$pollSizeChangesTimer);
	        if (this.$measureNode)
	            this.$measureNode.parentNode.removeChild(this.$measureNode);
	        delete this.$measureNode;
	    };

	}).call(Text.prototype);

	exports.Text = Text;

	});

	ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	var dom = acequire("../lib/dom");
	var IE8;

	var Cursor = function(parentEl) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_layer ace_cursor-layer";
	    parentEl.appendChild(this.element);
	    
	    if (IE8 === undefined)
	        IE8 = "opacity" in this.element;

	    this.isVisible = false;
	    this.isBlinking = true;
	    this.blinkInterval = 1000;
	    this.smoothBlinking = false;

	    this.cursors = [];
	    this.cursor = this.addCursor();
	    dom.addCssClass(this.element, "ace_hidden-cursors");
	    this.$updateCursors = this.$updateVisibility.bind(this);
	};

	(function() {
	    
	    this.$updateVisibility = function(val) {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--; )
	            cursors[i].style.visibility = val ? "" : "hidden";
	    };
	    this.$updateOpacity = function(val) {
	        var cursors = this.cursors;
	        for (var i = cursors.length; i--; )
	            cursors[i].style.opacity = val ? "" : "0";
	    };
	    

	    this.$padding = 0;
	    this.setPadding = function(padding) {
	        this.$padding = padding;
	    };

	    this.setSession = function(session) {
	        this.session = session;
	    };

	    this.setBlinking = function(blinking) {
	        if (blinking != this.isBlinking){
	            this.isBlinking = blinking;
	            this.restartTimer();
	        }
	    };

	    this.setBlinkInterval = function(blinkInterval) {
	        if (blinkInterval != this.blinkInterval){
	            this.blinkInterval = blinkInterval;
	            this.restartTimer();
	        }
	    };

	    this.setSmoothBlinking = function(smoothBlinking) {
	        if (smoothBlinking != this.smoothBlinking && !IE8) {
	            this.smoothBlinking = smoothBlinking;
	            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
	            this.$updateCursors(true);
	            this.$updateCursors = (smoothBlinking 
	                ? this.$updateOpacity
	                : this.$updateVisibility).bind(this);
	            this.restartTimer();
	        }
	    };

	    this.addCursor = function() {
	        var el = dom.createElement("div");
	        el.className = "ace_cursor";
	        this.element.appendChild(el);
	        this.cursors.push(el);
	        return el;
	    };

	    this.removeCursor = function() {
	        if (this.cursors.length > 1) {
	            var el = this.cursors.pop();
	            el.parentNode.removeChild(el);
	            return el;
	        }
	    };

	    this.hideCursor = function() {
	        this.isVisible = false;
	        dom.addCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };

	    this.showCursor = function() {
	        this.isVisible = true;
	        dom.removeCssClass(this.element, "ace_hidden-cursors");
	        this.restartTimer();
	    };

	    this.restartTimer = function() {
	        var update = this.$updateCursors;
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	        if (this.smoothBlinking) {
	            dom.removeCssClass(this.element, "ace_smooth-blinking");
	        }
	        
	        update(true);

	        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
	            return;

	        if (this.smoothBlinking) {
	            setTimeout(function(){
	                dom.addCssClass(this.element, "ace_smooth-blinking");
	            }.bind(this));
	        }
	        
	        var blink = function(){
	            this.timeoutId = setTimeout(function() {
	                update(false);
	            }, 0.6 * this.blinkInterval);
	        }.bind(this);

	        this.intervalId = setInterval(function() {
	            update(true);
	            blink();
	        }, this.blinkInterval);

	        blink();
	    };

	    this.getPixelPosition = function(position, onScreen) {
	        if (!this.config || !this.session)
	            return {left : 0, top : 0};

	        if (!position)
	            position = this.session.selection.getCursor();
	        var pos = this.session.documentToScreenPosition(position);
	        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
	        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
	            this.config.lineHeight;

	        return {left : cursorLeft, top : cursorTop};
	    };

	    this.update = function(config) {
	        this.config = config;

	        var selections = this.session.$selectionMarkers;
	        var i = 0, cursorIndex = 0;

	        if (selections === undefined || selections.length === 0){
	            selections = [{cursor: null}];
	        }

	        for (var i = 0, n = selections.length; i < n; i++) {
	            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
	            if ((pixelPos.top > config.height + config.offset ||
	                 pixelPos.top < 0) && i > 1) {
	                continue;
	            }

	            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;

	            if (!this.drawCursor) {
	                style.left = pixelPos.left + "px";
	                style.top = pixelPos.top + "px";
	                style.width = config.characterWidth + "px";
	                style.height = config.lineHeight + "px";
	            } else {
	                this.drawCursor(style, pixelPos, config, selections[i], this.session);
	            }
	        }
	        while (this.cursors.length > cursorIndex)
	            this.removeCursor();

	        var overwrite = this.session.getOverwrite();
	        this.$setOverwrite(overwrite);
	        this.$pixelPos = pixelPos;
	        this.restartTimer();
	    };

	    this.drawCursor = null;

	    this.$setOverwrite = function(overwrite) {
	        if (overwrite != this.overwrite) {
	            this.overwrite = overwrite;
	            if (overwrite)
	                dom.addCssClass(this.element, "ace_overwrite-cursors");
	            else
	                dom.removeCssClass(this.element, "ace_overwrite-cursors");
	        }
	    };

	    this.destroy = function() {
	        clearInterval(this.intervalId);
	        clearTimeout(this.timeoutId);
	    };

	}).call(Cursor.prototype);

	exports.Cursor = Cursor;

	});

	ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var event = acequire("./lib/event");
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var ScrollBar = function(parent) {
	    this.element = dom.createElement("div");
	    this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;

	    this.inner = dom.createElement("div");
	    this.inner.className = "ace_scrollbar-inner";
	    this.element.appendChild(this.inner);

	    parent.appendChild(this.element);

	    this.setVisible(false);
	    this.skipEvent = false;

	    event.addListener(this.element, "scroll", this.onScroll.bind(this));
	    event.addListener(this.element, "mousedown", event.preventDefault);
	};

	(function() {
	    oop.implement(this, EventEmitter);

	    this.setVisible = function(isVisible) {
	        this.element.style.display = isVisible ? "" : "none";
	        this.isVisible = isVisible;
	    };
	}).call(ScrollBar.prototype);
	var VScrollBar = function(parent, renderer) {
	    ScrollBar.call(this, parent);
	    this.scrollTop = 0;
	    renderer.$scrollbarWidth = 
	    this.width = dom.scrollbarWidth(parent.ownerDocument);
	    this.inner.style.width =
	    this.element.style.width = (this.width || 15) + 5 + "px";
	};

	oop.inherits(VScrollBar, ScrollBar);

	(function() {

	    this.classSuffix = '-v';
	    this.onScroll = function() {
	        if (!this.skipEvent) {
	            this.scrollTop = this.element.scrollTop;
	            this._emit("scroll", {data: this.scrollTop});
	        }
	        this.skipEvent = false;
	    };
	    this.getWidth = function() {
	        return this.isVisible ? this.width : 0;
	    };
	    this.setHeight = function(height) {
	        this.element.style.height = height + "px";
	    };
	    this.setInnerHeight = function(height) {
	        this.inner.style.height = height + "px";
	    };
	    this.setScrollHeight = function(height) {
	        this.inner.style.height = height + "px";
	    };
	    this.setScrollTop = function(scrollTop) {
	        if (this.scrollTop != scrollTop) {
	            this.skipEvent = true;
	            this.scrollTop = this.element.scrollTop = scrollTop;
	        }
	    };

	}).call(VScrollBar.prototype);
	var HScrollBar = function(parent, renderer) {
	    ScrollBar.call(this, parent);
	    this.scrollLeft = 0;
	    this.height = renderer.$scrollbarWidth;
	    this.inner.style.height =
	    this.element.style.height = (this.height || 15) + 5 + "px";
	};

	oop.inherits(HScrollBar, ScrollBar);

	(function() {

	    this.classSuffix = '-h';
	    this.onScroll = function() {
	        if (!this.skipEvent) {
	            this.scrollLeft = this.element.scrollLeft;
	            this._emit("scroll", {data: this.scrollLeft});
	        }
	        this.skipEvent = false;
	    };
	    this.getHeight = function() {
	        return this.isVisible ? this.height : 0;
	    };
	    this.setWidth = function(width) {
	        this.element.style.width = width + "px";
	    };
	    this.setInnerWidth = function(width) {
	        this.inner.style.width = width + "px";
	    };
	    this.setScrollWidth = function(width) {
	        this.inner.style.width = width + "px";
	    };
	    this.setScrollLeft = function(scrollLeft) {
	        if (this.scrollLeft != scrollLeft) {
	            this.skipEvent = true;
	            this.scrollLeft = this.element.scrollLeft = scrollLeft;
	        }
	    };

	}).call(HScrollBar.prototype);


	exports.ScrollBar = VScrollBar; // backward compatibility
	exports.ScrollBarV = VScrollBar; // backward compatibility
	exports.ScrollBarH = HScrollBar; // backward compatibility

	exports.VScrollBar = VScrollBar;
	exports.HScrollBar = HScrollBar;
	});

	ace.define("ace/renderloop",["require","exports","module","ace/lib/event"], function(acequire, exports, module) {
	"use strict";

	var event = acequire("./lib/event");


	var RenderLoop = function(onRender, win) {
	    this.onRender = onRender;
	    this.pending = false;
	    this.changes = 0;
	    this.window = win || window;
	};

	(function() {


	    this.schedule = function(change) {
	        this.changes = this.changes | change;
	        if (!this.pending && this.changes) {
	            this.pending = true;
	            var _self = this;
	            event.nextFrame(function() {
	                _self.pending = false;
	                var changes;
	                while (changes = _self.changes) {
	                    _self.changes = 0;
	                    _self.onRender(changes);
	                }
	            }, this.window);
	        }
	    };

	}).call(RenderLoop.prototype);

	exports.RenderLoop = RenderLoop;
	});

	ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/lib/event_emitter"], function(acequire, exports, module) {

	var oop = acequire("../lib/oop");
	var dom = acequire("../lib/dom");
	var lang = acequire("../lib/lang");
	var useragent = acequire("../lib/useragent");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;

	var CHAR_COUNT = 0;

	var FontMetrics = exports.FontMetrics = function(parentEl, interval) {
	    this.el = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.el.style, true);
	    
	    this.$main = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.$main.style);
	    
	    this.$measureNode = dom.createElement("div");
	    this.$setMeasureNodeStyles(this.$measureNode.style);
	    
	    
	    this.el.appendChild(this.$main);
	    this.el.appendChild(this.$measureNode);
	    parentEl.appendChild(this.el);
	    
	    if (!CHAR_COUNT)
	        this.$testFractionalRect();
	    this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
	    
	    this.$characterSize = {width: 0, height: 0};
	    this.checkForSizeChanges();
	};

	(function() {

	    oop.implement(this, EventEmitter);
	        
	    this.$characterSize = {width: 0, height: 0};
	    
	    this.$testFractionalRect = function() {
	        var el = dom.createElement("div");
	        this.$setMeasureNodeStyles(el.style);
	        el.style.width = "0.2px";
	        document.documentElement.appendChild(el);
	        var w = el.getBoundingClientRect().width;
	        if (w > 0 && w < 1)
	            CHAR_COUNT = 50;
	        else
	            CHAR_COUNT = 100;
	        el.parentNode.removeChild(el);
	    };
	    
	    this.$setMeasureNodeStyles = function(style, isRoot) {
	        style.width = style.height = "auto";
	        style.left = style.top = "0px";
	        style.visibility = "hidden";
	        style.position = "absolute";
	        style.whiteSpace = "pre";

	        if (useragent.isIE < 8) {
	            style["font-family"] = "inherit";
	        } else {
	            style.font = "inherit";
	        }
	        style.overflow = isRoot ? "hidden" : "visible";
	    };

	    this.checkForSizeChanges = function() {
	        var size = this.$measureSizes();
	        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
	            this.$measureNode.style.fontWeight = "bold";
	            var boldSize = this.$measureSizes();
	            this.$measureNode.style.fontWeight = "";
	            this.$characterSize = size;
	            this.charSizes = Object.create(null);
	            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
	            this._emit("changeCharacterSize", {data: size});
	        }
	    };

	    this.$pollSizeChanges = function() {
	        if (this.$pollSizeChangesTimer)
	            return this.$pollSizeChangesTimer;
	        var self = this;
	        return this.$pollSizeChangesTimer = setInterval(function() {
	            self.checkForSizeChanges();
	        }, 500);
	    };
	    
	    this.setPolling = function(val) {
	        if (val) {
	            this.$pollSizeChanges();
	        } else {
	            if (this.$pollSizeChangesTimer)
	                this.$pollSizeChangesTimer;
	        }
	    };

	    this.$measureSizes = function() {
	        if (CHAR_COUNT === 50) {
	            var rect = null;
	            try { 
	               rect = this.$measureNode.getBoundingClientRect();
	            } catch(e) {
	               rect = {width: 0, height:0 };
	            };
	            var size = {
	                height: rect.height,
	                width: rect.width / CHAR_COUNT
	            };
	        } else {
	            var size = {
	                height: this.$measureNode.clientHeight,
	                width: this.$measureNode.clientWidth / CHAR_COUNT
	            };
	        }
	        if (size.width === 0 || size.height === 0)
	            return null;
	        return size;
	    };

	    this.$measureCharWidth = function(ch) {
	        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
	        var rect = this.$main.getBoundingClientRect();
	        return rect.width / CHAR_COUNT;
	    };
	    
	    this.getCharacterWidth = function(ch) {
	        var w = this.charSizes[ch];
	        if (w === undefined) {
	            this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
	        }
	        return w;
	    };

	    this.destroy = function() {
	        clearInterval(this.$pollSizeChangesTimer);
	        if (this.el && this.el.parentNode)
	            this.el.parentNode.removeChild(this.el);
	    };

	}).call(FontMetrics.prototype);

	});

	ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/config","ace/lib/useragent","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var config = acequire("./config");
	var useragent = acequire("./lib/useragent");
	var GutterLayer = acequire("./layer/gutter").Gutter;
	var MarkerLayer = acequire("./layer/marker").Marker;
	var TextLayer = acequire("./layer/text").Text;
	var CursorLayer = acequire("./layer/cursor").Cursor;
	var HScrollBar = acequire("./scrollbar").HScrollBar;
	var VScrollBar = acequire("./scrollbar").VScrollBar;
	var RenderLoop = acequire("./renderloop").RenderLoop;
	var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var editorCss = ".ace_editor {\
	position: relative;\
	overflow: hidden;\
	font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
	direction: ltr;\
	}\
	.ace_scroller {\
	position: absolute;\
	overflow: hidden;\
	top: 0;\
	bottom: 0;\
	background-color: inherit;\
	-ms-user-select: none;\
	-moz-user-select: none;\
	-webkit-user-select: none;\
	user-select: none;\
	cursor: text;\
	}\
	.ace_content {\
	position: absolute;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	min-width: 100%;\
	}\
	.ace_dragging .ace_scroller:before{\
	position: absolute;\
	top: 0;\
	left: 0;\
	right: 0;\
	bottom: 0;\
	content: '';\
	background: rgba(250, 250, 250, 0.01);\
	z-index: 1000;\
	}\
	.ace_dragging.ace_dark .ace_scroller:before{\
	background: rgba(0, 0, 0, 0.01);\
	}\
	.ace_selecting, .ace_selecting * {\
	cursor: text !important;\
	}\
	.ace_gutter {\
	position: absolute;\
	overflow : hidden;\
	width: auto;\
	top: 0;\
	bottom: 0;\
	left: 0;\
	cursor: default;\
	z-index: 4;\
	-ms-user-select: none;\
	-moz-user-select: none;\
	-webkit-user-select: none;\
	user-select: none;\
	}\
	.ace_gutter-active-line {\
	position: absolute;\
	left: 0;\
	right: 0;\
	}\
	.ace_scroller.ace_scroll-left {\
	box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
	}\
	.ace_gutter-cell {\
	padding-left: 19px;\
	padding-right: 6px;\
	background-repeat: no-repeat;\
	}\
	.ace_gutter-cell.ace_error {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
	background-repeat: no-repeat;\
	background-position: 2px center;\
	}\
	.ace_gutter-cell.ace_warning {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
	background-position: 2px center;\
	}\
	.ace_gutter-cell.ace_info {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
	background-position: 2px center;\
	}\
	.ace_dark .ace_gutter-cell.ace_info {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
	}\
	.ace_scrollbar {\
	position: absolute;\
	right: 0;\
	bottom: 0;\
	z-index: 6;\
	}\
	.ace_scrollbar-inner {\
	position: absolute;\
	cursor: text;\
	left: 0;\
	top: 0;\
	}\
	.ace_scrollbar-v{\
	overflow-x: hidden;\
	overflow-y: scroll;\
	top: 0;\
	}\
	.ace_scrollbar-h {\
	overflow-x: scroll;\
	overflow-y: hidden;\
	left: 0;\
	}\
	.ace_print-margin {\
	position: absolute;\
	height: 100%;\
	}\
	.ace_text-input {\
	position: absolute;\
	z-index: 0;\
	width: 0.5em;\
	height: 1em;\
	opacity: 0;\
	background: transparent;\
	-moz-appearance: none;\
	appearance: none;\
	border: none;\
	resize: none;\
	outline: none;\
	overflow: hidden;\
	font: inherit;\
	padding: 0 1px;\
	margin: 0 -1px;\
	text-indent: -1em;\
	-ms-user-select: text;\
	-moz-user-select: text;\
	-webkit-user-select: text;\
	user-select: text;\
	}\
	.ace_text-input.ace_composition {\
	background: inherit;\
	color: inherit;\
	z-index: 1000;\
	opacity: 1;\
	text-indent: 0;\
	}\
	.ace_layer {\
	z-index: 1;\
	position: absolute;\
	overflow: hidden;\
	word-wrap: normal;\
	white-space: pre;\
	height: 100%;\
	width: 100%;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	pointer-events: none;\
	}\
	.ace_gutter-layer {\
	position: relative;\
	width: auto;\
	text-align: right;\
	pointer-events: auto;\
	}\
	.ace_text-layer {\
	font: inherit !important;\
	}\
	.ace_cjk {\
	display: inline-block;\
	text-align: center;\
	}\
	.ace_cursor-layer {\
	z-index: 4;\
	}\
	.ace_cursor {\
	z-index: 4;\
	position: absolute;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	border-left: 2px solid\
	}\
	.ace_slim-cursors .ace_cursor {\
	border-left-width: 1px;\
	}\
	.ace_overwrite-cursors .ace_cursor {\
	border-left-width: 0;\
	border-bottom: 1px solid;\
	}\
	.ace_hidden-cursors .ace_cursor {\
	opacity: 0.2;\
	}\
	.ace_smooth-blinking .ace_cursor {\
	-webkit-transition: opacity 0.18s;\
	transition: opacity 0.18s;\
	}\
	.ace_editor.ace_multiselect .ace_cursor {\
	border-left-width: 1px;\
	}\
	.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
	position: absolute;\
	z-index: 3;\
	}\
	.ace_marker-layer .ace_selection {\
	position: absolute;\
	z-index: 5;\
	}\
	.ace_marker-layer .ace_bracket {\
	position: absolute;\
	z-index: 6;\
	}\
	.ace_marker-layer .ace_active-line {\
	position: absolute;\
	z-index: 2;\
	}\
	.ace_marker-layer .ace_selected-word {\
	position: absolute;\
	z-index: 4;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	}\
	.ace_line .ace_fold {\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	display: inline-block;\
	height: 11px;\
	margin-top: -2px;\
	vertical-align: middle;\
	background-image:\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
	background-repeat: no-repeat, repeat-x;\
	background-position: center center, top left;\
	color: transparent;\
	border: 1px solid black;\
	border-radius: 2px;\
	cursor: pointer;\
	pointer-events: auto;\
	}\
	.ace_dark .ace_fold {\
	}\
	.ace_fold:hover{\
	background-image:\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
	url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
	}\
	.ace_tooltip {\
	background-color: #FFF;\
	background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
	background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
	border: 1px solid gray;\
	border-radius: 1px;\
	box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
	color: black;\
	max-width: 100%;\
	padding: 3px 4px;\
	position: fixed;\
	z-index: 999999;\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	cursor: default;\
	white-space: pre;\
	word-wrap: break-word;\
	line-height: normal;\
	font-style: normal;\
	font-weight: normal;\
	letter-spacing: normal;\
	pointer-events: none;\
	}\
	.ace_folding-enabled > .ace_gutter-cell {\
	padding-right: 13px;\
	}\
	.ace_fold-widget {\
	-moz-box-sizing: border-box;\
	-webkit-box-sizing: border-box;\
	box-sizing: border-box;\
	margin: 0 -12px 0 1px;\
	display: none;\
	width: 11px;\
	vertical-align: top;\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
	background-repeat: no-repeat;\
	background-position: center;\
	border-radius: 3px;\
	border: 1px solid transparent;\
	cursor: pointer;\
	}\
	.ace_folding-enabled .ace_fold-widget {\
	display: inline-block;   \
	}\
	.ace_fold-widget.ace_end {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
	}\
	.ace_fold-widget.ace_closed {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
	}\
	.ace_fold-widget:hover {\
	border: 1px solid rgba(0, 0, 0, 0.3);\
	background-color: rgba(255, 255, 255, 0.2);\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
	}\
	.ace_fold-widget:active {\
	border: 1px solid rgba(0, 0, 0, 0.4);\
	background-color: rgba(0, 0, 0, 0.05);\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
	}\
	.ace_dark .ace_fold-widget {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
	}\
	.ace_dark .ace_fold-widget.ace_end {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
	}\
	.ace_dark .ace_fold-widget.ace_closed {\
	background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
	}\
	.ace_dark .ace_fold-widget:hover {\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
	background-color: rgba(255, 255, 255, 0.1);\
	}\
	.ace_dark .ace_fold-widget:active {\
	box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
	}\
	.ace_fold-widget.ace_invalid {\
	background-color: #FFB4B4;\
	border-color: #DE5555;\
	}\
	.ace_fade-fold-widgets .ace_fold-widget {\
	-webkit-transition: opacity 0.4s ease 0.05s;\
	transition: opacity 0.4s ease 0.05s;\
	opacity: 0;\
	}\
	.ace_fade-fold-widgets:hover .ace_fold-widget {\
	-webkit-transition: opacity 0.05s ease 0.05s;\
	transition: opacity 0.05s ease 0.05s;\
	opacity:1;\
	}\
	.ace_underline {\
	text-decoration: underline;\
	}\
	.ace_bold {\
	font-weight: bold;\
	}\
	.ace_nobold .ace_bold {\
	font-weight: normal;\
	}\
	.ace_italic {\
	font-style: italic;\
	}\
	.ace_error-marker {\
	background-color: rgba(255, 0, 0,0.2);\
	position: absolute;\
	z-index: 9;\
	}\
	.ace_highlight-marker {\
	background-color: rgba(255, 255, 0,0.2);\
	position: absolute;\
	z-index: 8;\
	}\
	";

	dom.importCssString(editorCss, "ace_editor.css");

	var VirtualRenderer = function(container, theme) {
	    var _self = this;

	    this.container = container || dom.createElement("div");
	    this.$keepTextAreaAtCursor = !useragent.isOldIE;

	    dom.addCssClass(this.container, "ace_editor");

	    this.setTheme(theme);

	    this.$gutter = dom.createElement("div");
	    this.$gutter.className = "ace_gutter";
	    this.container.appendChild(this.$gutter);

	    this.scroller = dom.createElement("div");
	    this.scroller.className = "ace_scroller";
	    this.container.appendChild(this.scroller);

	    this.content = dom.createElement("div");
	    this.content.className = "ace_content";
	    this.scroller.appendChild(this.content);

	    this.$gutterLayer = new GutterLayer(this.$gutter);
	    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));

	    this.$markerBack = new MarkerLayer(this.content);

	    var textLayer = this.$textLayer = new TextLayer(this.content);
	    this.canvas = textLayer.element;

	    this.$markerFront = new MarkerLayer(this.content);

	    this.$cursorLayer = new CursorLayer(this.content);
	    this.$horizScroll = false;
	    this.$vScroll = false;

	    this.scrollBar = 
	    this.scrollBarV = new VScrollBar(this.container, this);
	    this.scrollBarH = new HScrollBar(this.container, this);
	    this.scrollBarV.addEventListener("scroll", function(e) {
	        if (!_self.$scrollAnimation)
	            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
	    });
	    this.scrollBarH.addEventListener("scroll", function(e) {
	        if (!_self.$scrollAnimation)
	            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
	    });

	    this.scrollTop = 0;
	    this.scrollLeft = 0;

	    this.cursorPos = {
	        row : 0,
	        column : 0
	    };

	    this.$fontMetrics = new FontMetrics(this.container, 500);
	    this.$textLayer.$setFontMetrics(this.$fontMetrics);
	    this.$textLayer.addEventListener("changeCharacterSize", function(e) {
	        _self.updateCharacterSize();
	        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
	        _self._signal("changeCharacterSize", e);
	    });

	    this.$size = {
	        width: 0,
	        height: 0,
	        scrollerHeight: 0,
	        scrollerWidth: 0,
	        $dirty: true
	    };

	    this.layerConfig = {
	        width : 1,
	        padding : 0,
	        firstRow : 0,
	        firstRowScreen: 0,
	        lastRow : 0,
	        lineHeight : 0,
	        characterWidth : 0,
	        minHeight : 1,
	        maxHeight : 1,
	        offset : 0,
	        height : 1,
	        gutterOffset: 1
	    };
	    
	    this.scrollMargin = {
	        left: 0,
	        right: 0,
	        top: 0,
	        bottom: 0,
	        v: 0,
	        h: 0
	    };

	    this.$loop = new RenderLoop(
	        this.$renderChanges.bind(this),
	        this.container.ownerDocument.defaultView
	    );
	    this.$loop.schedule(this.CHANGE_FULL);

	    this.updateCharacterSize();
	    this.setPadding(4);
	    config.resetOptions(this);
	    config._emit("renderer", this);
	};

	(function() {

	    this.CHANGE_CURSOR = 1;
	    this.CHANGE_MARKER = 2;
	    this.CHANGE_GUTTER = 4;
	    this.CHANGE_SCROLL = 8;
	    this.CHANGE_LINES = 16;
	    this.CHANGE_TEXT = 32;
	    this.CHANGE_SIZE = 64;
	    this.CHANGE_MARKER_BACK = 128;
	    this.CHANGE_MARKER_FRONT = 256;
	    this.CHANGE_FULL = 512;
	    this.CHANGE_H_SCROLL = 1024;

	    oop.implement(this, EventEmitter);

	    this.updateCharacterSize = function() {
	        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
	            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
	            this.setStyle("ace_nobold", !this.$allowBoldFonts);
	        }

	        this.layerConfig.characterWidth =
	        this.characterWidth = this.$textLayer.getCharacterWidth();
	        this.layerConfig.lineHeight =
	        this.lineHeight = this.$textLayer.getLineHeight();
	        this.$updatePrintMargin();
	    };
	    this.setSession = function(session) {
	        if (this.session)
	            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
	            
	        this.session = session;
	        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
	            session.setScrollTop(-this.scrollMargin.top);

	        this.$cursorLayer.setSession(session);
	        this.$markerBack.setSession(session);
	        this.$markerFront.setSession(session);
	        this.$gutterLayer.setSession(session);
	        this.$textLayer.setSession(session);
	        if (!session)
	            return;
	        
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.session.$setFontMetrics(this.$fontMetrics);
	        
	        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
	        this.onChangeNewLineMode()
	        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
	    };
	    this.updateLines = function(firstRow, lastRow, force) {
	        if (lastRow === undefined)
	            lastRow = Infinity;

	        if (!this.$changedLines) {
	            this.$changedLines = {
	                firstRow: firstRow,
	                lastRow: lastRow
	            };
	        }
	        else {
	            if (this.$changedLines.firstRow > firstRow)
	                this.$changedLines.firstRow = firstRow;

	            if (this.$changedLines.lastRow < lastRow)
	                this.$changedLines.lastRow = lastRow;
	        }
	        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
	            if (force)
	                this.$changedLines.lastRow = this.layerConfig.lastRow;
	            else
	                return;
	        }
	        if (this.$changedLines.firstRow > this.layerConfig.lastRow)
	            return;
	        this.$loop.schedule(this.CHANGE_LINES);
	    };

	    this.onChangeNewLineMode = function() {
	        this.$loop.schedule(this.CHANGE_TEXT);
	        this.$textLayer.$updateEolChar();
	    };
	    
	    this.onChangeTabSize = function() {
	        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
	        this.$textLayer.onChangeTabSize();
	    };
	    this.updateText = function() {
	        this.$loop.schedule(this.CHANGE_TEXT);
	    };
	    this.updateFull = function(force) {
	        if (force)
	            this.$renderChanges(this.CHANGE_FULL, true);
	        else
	            this.$loop.schedule(this.CHANGE_FULL);
	    };
	    this.updateFontSize = function() {
	        this.$textLayer.checkForSizeChanges();
	    };

	    this.$changes = 0;
	    this.$updateSizeAsync = function() {
	        if (this.$loop.pending)
	            this.$size.$dirty = true;
	        else
	            this.onResize();
	    };
	    this.onResize = function(force, gutterWidth, width, height) {
	        if (this.resizing > 2)
	            return;
	        else if (this.resizing > 0)
	            this.resizing++;
	        else
	            this.resizing = force ? 1 : 0;
	        var el = this.container;
	        if (!height)
	            height = el.clientHeight || el.scrollHeight;
	        if (!width)
	            width = el.clientWidth || el.scrollWidth;
	        var changes = this.$updateCachedSize(force, gutterWidth, width, height);

	        
	        if (!this.$size.scrollerHeight || (!width && !height))
	            return this.resizing = 0;

	        if (force)
	            this.$gutterLayer.$padding = null;

	        if (force)
	            this.$renderChanges(changes | this.$changes, true);
	        else
	            this.$loop.schedule(changes | this.$changes);

	        if (this.resizing)
	            this.resizing = 0;
	        this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
	    };
	    
	    this.$updateCachedSize = function(force, gutterWidth, width, height) {
	        height -= (this.$extraHeight || 0);
	        var changes = 0;
	        var size = this.$size;
	        var oldSize = {
	            width: size.width,
	            height: size.height,
	            scrollerHeight: size.scrollerHeight,
	            scrollerWidth: size.scrollerWidth
	        };
	        if (height && (force || size.height != height)) {
	            size.height = height;
	            changes |= this.CHANGE_SIZE;

	            size.scrollerHeight = size.height;
	            if (this.$horizScroll)
	                size.scrollerHeight -= this.scrollBarH.getHeight();
	            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";

	            changes = changes | this.CHANGE_SCROLL;
	        }

	        if (width && (force || size.width != width)) {
	            changes |= this.CHANGE_SIZE;
	            size.width = width;
	            
	            if (gutterWidth == null)
	                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
	            
	            this.gutterWidth = gutterWidth;
	            
	            this.scrollBarH.element.style.left = 
	            this.scroller.style.left = gutterWidth + "px";
	            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           
	            
	            this.scrollBarH.element.style.right = 
	            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
	            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";

	            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
	                changes |= this.CHANGE_FULL;
	        }
	        
	        size.$dirty = !width || !height;

	        if (changes)
	            this._signal("resize", oldSize);

	        return changes;
	    };

	    this.onGutterResize = function() {
	        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
	        if (gutterWidth != this.gutterWidth)
	            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);

	        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        } else if (this.$size.$dirty) {
	            this.$loop.schedule(this.CHANGE_FULL);
	        } else {
	            this.$computeLayerConfig();
	            this.$loop.schedule(this.CHANGE_MARKER);
	        }
	    };
	    this.adjustWrapLimit = function() {
	        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
	        var limit = Math.floor(availableWidth / this.characterWidth);
	        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
	    };
	    this.setAnimatedScroll = function(shouldAnimate){
	        this.setOption("animatedScroll", shouldAnimate);
	    };
	    this.getAnimatedScroll = function() {
	        return this.$animatedScroll;
	    };
	    this.setShowInvisibles = function(showInvisibles) {
	        this.setOption("showInvisibles", showInvisibles);
	    };
	    this.getShowInvisibles = function() {
	        return this.getOption("showInvisibles");
	    };
	    this.getDisplayIndentGuides = function() {
	        return this.getOption("displayIndentGuides");
	    };

	    this.setDisplayIndentGuides = function(display) {
	        this.setOption("displayIndentGuides", display);
	    };
	    this.setShowPrintMargin = function(showPrintMargin) {
	        this.setOption("showPrintMargin", showPrintMargin);
	    };
	    this.getShowPrintMargin = function() {
	        return this.getOption("showPrintMargin");
	    };
	    this.setPrintMarginColumn = function(showPrintMargin) {
	        this.setOption("printMarginColumn", showPrintMargin);
	    };
	    this.getPrintMarginColumn = function() {
	        return this.getOption("printMarginColumn");
	    };
	    this.getShowGutter = function(){
	        return this.getOption("showGutter");
	    };
	    this.setShowGutter = function(show){
	        return this.setOption("showGutter", show);
	    };

	    this.getFadeFoldWidgets = function(){
	        return this.getOption("fadeFoldWidgets")
	    };

	    this.setFadeFoldWidgets = function(show) {
	        this.setOption("fadeFoldWidgets", show);
	    };

	    this.setHighlightGutterLine = function(shouldHighlight) {
	        this.setOption("highlightGutterLine", shouldHighlight);
	    };

	    this.getHighlightGutterLine = function() {
	        return this.getOption("highlightGutterLine");
	    };

	    this.$updateGutterLineHighlight = function() {
	        var pos = this.$cursorLayer.$pixelPos;
	        var height = this.layerConfig.lineHeight;
	        if (this.session.getUseWrapMode()) {
	            var cursor = this.session.selection.getCursor();
	            cursor.column = 0;
	            pos = this.$cursorLayer.getPixelPosition(cursor, true);
	            height *= this.session.getRowLength(cursor.row);
	        }
	        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
	        this.$gutterLineHighlight.style.height = height + "px";
	    };

	    this.$updatePrintMargin = function() {
	        if (!this.$showPrintMargin && !this.$printMarginEl)
	            return;

	        if (!this.$printMarginEl) {
	            var containerEl = dom.createElement("div");
	            containerEl.className = "ace_layer ace_print-margin-layer";
	            this.$printMarginEl = dom.createElement("div");
	            this.$printMarginEl.className = "ace_print-margin";
	            containerEl.appendChild(this.$printMarginEl);
	            this.content.insertBefore(containerEl, this.content.firstChild);
	        }

	        var style = this.$printMarginEl.style;
	        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
	        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
	        
	        if (this.session && this.session.$wrap == -1)
	            this.adjustWrapLimit();
	    };
	    this.getContainerElement = function() {
	        return this.container;
	    };
	    this.getMouseEventTarget = function() {
	        return this.content;
	    };
	    this.getTextAreaContainer = function() {
	        return this.container;
	    };
	    this.$moveTextAreaToCursor = function() {
	        if (!this.$keepTextAreaAtCursor)
	            return;
	        var config = this.layerConfig;
	        var posTop = this.$cursorLayer.$pixelPos.top;
	        var posLeft = this.$cursorLayer.$pixelPos.left;
	        posTop -= config.offset;

	        var style = this.textarea.style;
	        var h = this.lineHeight;
	        if (posTop < 0 || posTop > config.height - h) {
	            style.top = style.left = "0";
	            return;
	        }

	        var w = this.characterWidth;
	        if (this.$composition) {
	            var val = this.textarea.value.replace(/^\x01+/, "");
	            w *= (this.session.$getStringScreenWidth(val)[0]+2);
	            h += 2;
	        }
	        posLeft -= this.scrollLeft;
	        if (posLeft > this.$size.scrollerWidth - w)
	            posLeft = this.$size.scrollerWidth - w;

	        posLeft += this.gutterWidth;
	        style.height = h + "px";
	        style.width = w + "px";
	        style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
	        style.top = Math.min(posTop, this.$size.height - h) + "px";
	    };
	    this.getFirstVisibleRow = function() {
	        return this.layerConfig.firstRow;
	    };
	    this.getFirstFullyVisibleRow = function() {
	        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
	    };
	    this.getLastFullyVisibleRow = function() {
	        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
	        return this.layerConfig.firstRow - 1 + flint;
	    };
	    this.getLastVisibleRow = function() {
	        return this.layerConfig.lastRow;
	    };

	    this.$padding = null;
	    this.setPadding = function(padding) {
	        this.$padding = padding;
	        this.$textLayer.setPadding(padding);
	        this.$cursorLayer.setPadding(padding);
	        this.$markerFront.setPadding(padding);
	        this.$markerBack.setPadding(padding);
	        this.$loop.schedule(this.CHANGE_FULL);
	        this.$updatePrintMargin();
	    };
	    
	    this.setScrollMargin = function(top, bottom, left, right) {
	        var sm = this.scrollMargin;
	        sm.top = top|0;
	        sm.bottom = bottom|0;
	        sm.right = right|0;
	        sm.left = left|0;
	        sm.v = sm.top + sm.bottom;
	        sm.h = sm.left + sm.right;
	        if (sm.top && this.scrollTop <= 0 && this.session)
	            this.session.setScrollTop(-sm.top);
	        this.updateFull();
	    };
	    this.getHScrollBarAlwaysVisible = function() {
	        return this.$hScrollBarAlwaysVisible;
	    };
	    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
	        this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
	    };
	    this.getVScrollBarAlwaysVisible = function() {
	        return this.$vScrollBarAlwaysVisible;
	    };
	    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
	        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
	    };

	    this.$updateScrollBarV = function() {
	        var scrollHeight = this.layerConfig.maxHeight;
	        var scrollerHeight = this.$size.scrollerHeight;
	        if (!this.$maxLines && this.$scrollPastEnd) {
	            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
	            if (this.scrollTop > scrollHeight - scrollerHeight) {
	                scrollHeight = this.scrollTop + scrollerHeight;
	                this.scrollBarV.scrollTop = null;
	            }
	        }
	        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
	        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
	    };
	    this.$updateScrollBarH = function() {
	        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
	        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
	    };
	    
	    this.$frozen = false;
	    this.freeze = function() {
	        this.$frozen = true;
	    };
	    
	    this.unfreeze = function() {
	        this.$frozen = false;
	    };

	    this.$renderChanges = function(changes, force) {
	        if (this.$changes) {
	            changes |= this.$changes;
	            this.$changes = 0;
	        }
	        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
	            this.$changes |= changes;
	            return; 
	        } 
	        if (this.$size.$dirty) {
	            this.$changes |= changes;
	            return this.onResize(true);
	        }
	        if (!this.lineHeight) {
	            this.$textLayer.checkForSizeChanges();
	        }
	        
	        this._signal("beforeRender");
	        var config = this.layerConfig;
	        if (changes & this.CHANGE_FULL ||
	            changes & this.CHANGE_SIZE ||
	            changes & this.CHANGE_TEXT ||
	            changes & this.CHANGE_LINES ||
	            changes & this.CHANGE_SCROLL ||
	            changes & this.CHANGE_H_SCROLL
	        ) {
	            changes |= this.$computeLayerConfig();
	            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
	                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
	                if (st > 0) {
	                    this.scrollTop = st;
	                    changes = changes | this.CHANGE_SCROLL;
	                    changes |= this.$computeLayerConfig();
	                }
	            }
	            config = this.layerConfig;
	            this.$updateScrollBarV();
	            if (changes & this.CHANGE_H_SCROLL)
	                this.$updateScrollBarH();
	            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
	            this.content.style.marginTop = (-config.offset) + "px";
	            this.content.style.width = config.width + 2 * this.$padding + "px";
	            this.content.style.height = config.minHeight + "px";
	        }
	        if (changes & this.CHANGE_H_SCROLL) {
	            this.content.style.marginLeft = -this.scrollLeft + "px";
	            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
	        }
	        if (changes & this.CHANGE_FULL) {
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	            this._signal("afterRender");
	            return;
	        }
	        if (changes & this.CHANGE_SCROLL) {
	            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
	                this.$textLayer.update(config);
	            else
	                this.$textLayer.scrollLines(config);

	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	            this.$markerBack.update(config);
	            this.$markerFront.update(config);
	            this.$cursorLayer.update(config);
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	            this.$moveTextAreaToCursor();
	            this._signal("afterRender");
	            return;
	        }

	        if (changes & this.CHANGE_TEXT) {
	            this.$textLayer.update(config);
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	        }
	        else if (changes & this.CHANGE_LINES) {
	            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
	                this.$gutterLayer.update(config);
	        }
	        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(config);
	        }

	        if (changes & this.CHANGE_CURSOR) {
	            this.$cursorLayer.update(config);
	            this.$moveTextAreaToCursor();
	            this.$highlightGutterLine && this.$updateGutterLineHighlight();
	        }

	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
	            this.$markerFront.update(config);
	        }

	        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
	            this.$markerBack.update(config);
	        }

	        this._signal("afterRender");
	    };

	    
	    this.$autosize = function() {
	        var height = this.session.getScreenLength() * this.lineHeight;
	        var maxHeight = this.$maxLines * this.lineHeight;
	        var desiredHeight = Math.max(
	            (this.$minLines||1) * this.lineHeight,
	            Math.min(maxHeight, height)
	        ) + this.scrollMargin.v + (this.$extraHeight || 0);
	        var vScroll = height > maxHeight;
	        
	        if (desiredHeight != this.desiredHeight ||
	            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
	            if (vScroll != this.$vScroll) {
	                this.$vScroll = vScroll;
	                this.scrollBarV.setVisible(vScroll);
	            }
	            
	            var w = this.container.clientWidth;
	            this.container.style.height = desiredHeight + "px";
	            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
	            this.desiredHeight = desiredHeight;
	            
	            this._signal("autosize");
	        }
	    };
	    
	    this.$computeLayerConfig = function() {
	        if (this.$maxLines && this.lineHeight > 1)
	            this.$autosize();

	        var session = this.session;
	        var size = this.$size;
	        
	        var hideScrollbars = size.height <= 2 * this.lineHeight;
	        var screenLines = this.session.getScreenLength();
	        var maxHeight = screenLines * this.lineHeight;

	        var offset = this.scrollTop % this.lineHeight;
	        var minHeight = size.scrollerHeight + this.lineHeight;

	        var longestLine = this.$getLongestLine();
	        
	        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
	            size.scrollerWidth - longestLine - 2 * this.$padding < 0);

	        var hScrollChanged = this.$horizScroll !== horizScroll;
	        if (hScrollChanged) {
	            this.$horizScroll = horizScroll;
	            this.scrollBarH.setVisible(horizScroll);
	        }
	        
	        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
	            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
	            : 0;
	        maxHeight += scrollPastEnd;

	        this.session.setScrollTop(Math.max(-this.scrollMargin.top,
	            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));

	        this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft,
	            longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));
	        
	        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
	            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop);
	        var vScrollChanged = this.$vScroll !== vScroll;
	        if (vScrollChanged) {
	            this.$vScroll = vScroll;
	            this.scrollBarV.setVisible(vScroll);
	        }

	        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
	        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
	        var lastRow = firstRow + lineCount;
	        var firstRowScreen, firstRowHeight;
	        var lineHeight = this.lineHeight;
	        firstRow = session.screenToDocumentRow(firstRow, 0);
	        var foldLine = session.getFoldLine(firstRow);
	        if (foldLine) {
	            firstRow = foldLine.start.row;
	        }

	        firstRowScreen = session.documentToScreenRow(firstRow, 0);
	        firstRowHeight = session.getRowLength(firstRow) * lineHeight;

	        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
	        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
	                                                firstRowHeight;

	        offset = this.scrollTop - firstRowScreen * lineHeight;

	        var changes = 0;
	        if (this.layerConfig.width != longestLine) 
	            changes = this.CHANGE_H_SCROLL;
	        if (hScrollChanged || vScrollChanged) {
	            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
	            this._signal("scrollbarVisibilityChanged");
	            if (vScrollChanged)
	                longestLine = this.$getLongestLine();
	        }
	        
	        this.layerConfig = {
	            width : longestLine,
	            padding : this.$padding,
	            firstRow : firstRow,
	            firstRowScreen: firstRowScreen,
	            lastRow : lastRow,
	            lineHeight : lineHeight,
	            characterWidth : this.characterWidth,
	            minHeight : minHeight,
	            maxHeight : maxHeight,
	            offset : offset,
	            gutterOffset : Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
	            height : this.$size.scrollerHeight
	        };

	        return changes;
	    };

	    this.$updateLines = function() {
	        var firstRow = this.$changedLines.firstRow;
	        var lastRow = this.$changedLines.lastRow;
	        this.$changedLines = null;

	        var layerConfig = this.layerConfig;

	        if (firstRow > layerConfig.lastRow + 1) { return; }
	        if (lastRow < layerConfig.firstRow) { return; }
	        if (lastRow === Infinity) {
	            if (this.$showGutter)
	                this.$gutterLayer.update(layerConfig);
	            this.$textLayer.update(layerConfig);
	            return;
	        }
	        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
	        return true;
	    };

	    this.$getLongestLine = function() {
	        var charCount = this.session.getScreenWidth();
	        if (this.showInvisibles && !this.session.$useWrapMode)
	            charCount += 1;

	        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
	    };
	    this.updateFrontMarkers = function() {
	        this.$markerFront.setMarkers(this.session.getMarkers(true));
	        this.$loop.schedule(this.CHANGE_MARKER_FRONT);
	    };
	    this.updateBackMarkers = function() {
	        this.$markerBack.setMarkers(this.session.getMarkers());
	        this.$loop.schedule(this.CHANGE_MARKER_BACK);
	    };
	    this.addGutterDecoration = function(row, className){
	        this.$gutterLayer.addGutterDecoration(row, className);
	    };
	    this.removeGutterDecoration = function(row, className){
	        this.$gutterLayer.removeGutterDecoration(row, className);
	    };
	    this.updateBreakpoints = function(rows) {
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    this.setAnnotations = function(annotations) {
	        this.$gutterLayer.setAnnotations(annotations);
	        this.$loop.schedule(this.CHANGE_GUTTER);
	    };
	    this.updateCursor = function() {
	        this.$loop.schedule(this.CHANGE_CURSOR);
	    };
	    this.hideCursor = function() {
	        this.$cursorLayer.hideCursor();
	    };
	    this.showCursor = function() {
	        this.$cursorLayer.showCursor();
	    };

	    this.scrollSelectionIntoView = function(anchor, lead, offset) {
	        this.scrollCursorIntoView(anchor, offset);
	        this.scrollCursorIntoView(lead, offset);
	    };
	    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
	        if (this.$size.scrollerHeight === 0)
	            return;

	        var pos = this.$cursorLayer.getPixelPosition(cursor);

	        var left = pos.left;
	        var top = pos.top;
	        
	        var topMargin = $viewMargin && $viewMargin.top || 0;
	        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
	        
	        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
	        
	        if (scrollTop + topMargin > top) {
	            if (offset)
	                top -= offset * this.$size.scrollerHeight;
	            if (top === 0)
	                top = -this.scrollMargin.top;
	            this.session.setScrollTop(top);
	        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
	            if (offset)
	                top += offset * this.$size.scrollerHeight;
	            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
	        }

	        var scrollLeft = this.scrollLeft;

	        if (scrollLeft > left) {
	            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
	                left = -this.scrollMargin.left;
	            this.session.setScrollLeft(left);
	        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
	            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
	        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
	            this.session.setScrollLeft(0);
	        }
	    };
	    this.getScrollTop = function() {
	        return this.session.getScrollTop();
	    };
	    this.getScrollLeft = function() {
	        return this.session.getScrollLeft();
	    };
	    this.getScrollTopRow = function() {
	        return this.scrollTop / this.lineHeight;
	    };
	    this.getScrollBottomRow = function() {
	        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
	    };
	    this.scrollToRow = function(row) {
	        this.session.setScrollTop(row * this.lineHeight);
	    };

	    this.alignCursor = function(cursor, alignment) {
	        if (typeof cursor == "number")
	            cursor = {row: cursor, column: 0};

	        var pos = this.$cursorLayer.getPixelPosition(cursor);
	        var h = this.$size.scrollerHeight - this.lineHeight;
	        var offset = pos.top - h * (alignment || 0);

	        this.session.setScrollTop(offset);
	        return offset;
	    };

	    this.STEPS = 8;
	    this.$calcSteps = function(fromValue, toValue){
	        var i = 0;
	        var l = this.STEPS;
	        var steps = [];

	        var func  = function(t, x_min, dx) {
	            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
	        };

	        for (i = 0; i < l; ++i)
	            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

	        return steps;
	    };
	    this.scrollToLine = function(line, center, animate, callback) {
	        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});
	        var offset = pos.top;
	        if (center)
	            offset -= this.$size.scrollerHeight / 2;

	        var initialScroll = this.scrollTop;
	        this.session.setScrollTop(offset);
	        if (animate !== false)
	            this.animateScrolling(initialScroll, callback);
	    };

	    this.animateScrolling = function(fromValue, callback) {
	        var toValue = this.scrollTop;
	        if (!this.$animatedScroll)
	            return;
	        var _self = this;
	        
	        if (fromValue == toValue)
	            return;
	        
	        if (this.$scrollAnimation) {
	            var oldSteps = this.$scrollAnimation.steps;
	            if (oldSteps.length) {
	                fromValue = oldSteps[0];
	                if (fromValue == toValue)
	                    return;
	            }
	        }
	        
	        var steps = _self.$calcSteps(fromValue, toValue);
	        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};

	        clearInterval(this.$timer);

	        _self.session.setScrollTop(steps.shift());
	        _self.session.$scrollTop = toValue;
	        this.$timer = setInterval(function() {
	            if (steps.length) {
	                _self.session.setScrollTop(steps.shift());
	                _self.session.$scrollTop = toValue;
	            } else if (toValue != null) {
	                _self.session.$scrollTop = -1;
	                _self.session.setScrollTop(toValue);
	                toValue = null;
	            } else {
	                _self.$timer = clearInterval(_self.$timer);
	                _self.$scrollAnimation = null;
	                callback && callback();
	            }
	        }, 10);
	    };
	    this.scrollToY = function(scrollTop) {
	        if (this.scrollTop !== scrollTop) {
	            this.$loop.schedule(this.CHANGE_SCROLL);
	            this.scrollTop = scrollTop;
	        }
	    };
	    this.scrollToX = function(scrollLeft) {
	        if (this.scrollLeft !== scrollLeft)
	            this.scrollLeft = scrollLeft;
	        this.$loop.schedule(this.CHANGE_H_SCROLL);
	    };
	    this.scrollTo = function(x, y) {
	        this.session.setScrollTop(y);
	        this.session.setScrollLeft(y);
	    };
	    this.scrollBy = function(deltaX, deltaY) {
	        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
	        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
	    };
	    this.isScrollableBy = function(deltaX, deltaY) {
	        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
	           return true;
	        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
	            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
	           return true;
	        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
	            return true;
	        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
	            - this.layerConfig.width < -1 + this.scrollMargin.right)
	           return true;
	    };

	    this.pixelToScreenCoordinates = function(x, y) {
	        var canvasPos = this.scroller.getBoundingClientRect();

	        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
	        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
	        var col = Math.round(offset);

	        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};
	    };

	    this.screenToTextCoordinates = function(x, y) {
	        var canvasPos = this.scroller.getBoundingClientRect();

	        var col = Math.round(
	            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth
	        );

	        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;

	        return this.session.screenToDocumentPosition(row, Math.max(col, 0));
	    };
	    this.textToScreenCoordinates = function(row, column) {
	        var canvasPos = this.scroller.getBoundingClientRect();
	        var pos = this.session.documentToScreenPosition(row, column);

	        var x = this.$padding + Math.round(pos.column * this.characterWidth);
	        var y = pos.row * this.lineHeight;

	        return {
	            pageX: canvasPos.left + x - this.scrollLeft,
	            pageY: canvasPos.top + y - this.scrollTop
	        };
	    };
	    this.visualizeFocus = function() {
	        dom.addCssClass(this.container, "ace_focus");
	    };
	    this.visualizeBlur = function() {
	        dom.removeCssClass(this.container, "ace_focus");
	    };
	    this.showComposition = function(position) {
	        if (!this.$composition)
	            this.$composition = {
	                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
	                cssText: this.textarea.style.cssText
	            };

	        this.$keepTextAreaAtCursor = true;
	        dom.addCssClass(this.textarea, "ace_composition");
	        this.textarea.style.cssText = "";
	        this.$moveTextAreaToCursor();
	    };
	    this.setCompositionText = function(text) {
	        this.$moveTextAreaToCursor();
	    };
	    this.hideComposition = function() {
	        if (!this.$composition)
	            return;

	        dom.removeCssClass(this.textarea, "ace_composition");
	        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
	        this.textarea.style.cssText = this.$composition.cssText;
	        this.$composition = null;
	    };
	    this.setTheme = function(theme, cb) {
	        var _self = this;
	        this.$themeId = theme;
	        _self._dispatchEvent('themeChange',{theme:theme});

	        if (!theme || typeof theme == "string") {
	            var moduleName = theme || this.$options.theme.initialValue;
	            config.loadModule(["theme", moduleName], afterLoad);
	        } else {
	            afterLoad(theme);
	        }

	        function afterLoad(module) {
	            if (_self.$themeId != theme)
	                return cb && cb();
	            if (!module.cssClass)
	                return;
	            dom.importCssString(
	                module.cssText,
	                module.cssClass,
	                _self.container.ownerDocument
	            );

	            if (_self.theme)
	                dom.removeCssClass(_self.container, _self.theme.cssClass);

	            var padding = "padding" in module ? module.padding 
	                : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
	            if (_self.$padding && padding != _self.$padding)
	                _self.setPadding(padding);
	            _self.$theme = module.cssClass;

	            _self.theme = module;
	            dom.addCssClass(_self.container, module.cssClass);
	            dom.setCssClass(_self.container, "ace_dark", module.isDark);
	            if (_self.$size) {
	                _self.$size.width = 0;
	                _self.$updateSizeAsync();
	            }

	            _self._dispatchEvent('themeLoaded', {theme:module});
	            cb && cb();
	        }
	    };
	    this.getTheme = function() {
	        return this.$themeId;
	    };
	    this.setStyle = function(style, include) {
	        dom.setCssClass(this.container, style, include !== false);
	    };
	    this.unsetStyle = function(style) {
	        dom.removeCssClass(this.container, style);
	    };
	    
	    this.setCursorStyle = function(style) {
	        if (this.scroller.style.cursor != style)
	            this.scroller.style.cursor = style;
	    };
	    this.setMouseCursor = function(cursorStyle) {
	        this.scroller.style.cursor = cursorStyle;
	    };
	    this.destroy = function() {
	        this.$textLayer.destroy();
	        this.$cursorLayer.destroy();
	    };

	}).call(VirtualRenderer.prototype);


	config.defineOptions(VirtualRenderer.prototype, "renderer", {
	    animatedScroll: {initialValue: false},
	    showInvisibles: {
	        set: function(value) {
	            if (this.$textLayer.setShowInvisibles(value))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: false
	    },
	    showPrintMargin: {
	        set: function() { this.$updatePrintMargin(); },
	        initialValue: true
	    },
	    printMarginColumn: {
	        set: function() { this.$updatePrintMargin(); },
	        initialValue: 80
	    },
	    printMargin: {
	        set: function(val) {
	            if (typeof val == "number")
	                this.$printMarginColumn = val;
	            this.$showPrintMargin = !!val;
	            this.$updatePrintMargin();
	        },
	        get: function() {
	            return this.$showPrintMargin && this.$printMarginColumn; 
	        }
	    },
	    showGutter: {
	        set: function(show){
	            this.$gutter.style.display = show ? "block" : "none";
	            this.$loop.schedule(this.CHANGE_FULL);
	            this.onGutterResize();
	        },
	        initialValue: true
	    },
	    fadeFoldWidgets: {
	        set: function(show) {
	            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
	        },
	        initialValue: false
	    },
	    showFoldWidgets: {
	        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
	        initialValue: true
	    },
	    showLineNumbers: {
	        set: function(show) {
	            this.$gutterLayer.setShowLineNumbers(show);
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        },
	        initialValue: true
	    },
	    displayIndentGuides: {
	        set: function(show) {
	            if (this.$textLayer.setDisplayIndentGuides(show))
	                this.$loop.schedule(this.CHANGE_TEXT);
	        },
	        initialValue: true
	    },
	    highlightGutterLine: {
	        set: function(shouldHighlight) {
	            if (!this.$gutterLineHighlight) {
	                this.$gutterLineHighlight = dom.createElement("div");
	                this.$gutterLineHighlight.className = "ace_gutter-active-line";
	                this.$gutter.appendChild(this.$gutterLineHighlight);
	                return;
	            }

	            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
	            if (this.$cursorLayer.$pixelPos)
	                this.$updateGutterLineHighlight();
	        },
	        initialValue: false,
	        value: true
	    },
	    hScrollBarAlwaysVisible: {
	        set: function(val) {
	            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    vScrollBarAlwaysVisible: {
	        set: function(val) {
	            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
	                this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: false
	    },
	    fontSize:  {
	        set: function(size) {
	            if (typeof size == "number")
	                size = size + "px";
	            this.container.style.fontSize = size;
	            this.updateFontSize();
	        },
	        initialValue: 12
	    },
	    fontFamily: {
	        set: function(name) {
	            this.container.style.fontFamily = name;
	            this.updateFontSize();
	        }
	    },
	    maxLines: {
	        set: function(val) {
	            this.updateFull();
	        }
	    },
	    minLines: {
	        set: function(val) {
	            this.updateFull();
	        }
	    },
	    scrollPastEnd: {
	        set: function(val) {
	            val = +val || 0;
	            if (this.$scrollPastEnd == val)
	                return;
	            this.$scrollPastEnd = val;
	            this.$loop.schedule(this.CHANGE_SCROLL);
	        },
	        initialValue: 0,
	        handlesSet: true
	    },
	    fixedWidthGutter: {
	        set: function(val) {
	            this.$gutterLayer.$fixedWidth = !!val;
	            this.$loop.schedule(this.CHANGE_GUTTER);
	        }
	    },
	    theme: {
	        set: function(val) { this.setTheme(val) },
	        get: function() { return this.$themeId || this.theme; },
	        initialValue: "./theme/textmate",
	        handlesSet: true
	    }
	});

	exports.VirtualRenderer = VirtualRenderer;
	});

	ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var net = acequire("../lib/net");
	var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
	var config = acequire("../config");

	var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
	    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
	    this.changeListener = this.changeListener.bind(this);
	    this.onMessage = this.onMessage.bind(this);
	    if (acequire.nameToUrl && !acequire.toUrl)
	        acequire.toUrl = acequire.nameToUrl;
	    
	    if (config.get("packaged") || !acequire.toUrl) {
	        workerUrl = workerUrl || config.moduleUrl(mod.id, "worker")
	    } else {
	        var normalizePath = this.$normalizePath;
	        workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));

	        var tlns = {};
	        topLevelNamespaces.forEach(function(ns) {
	            tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
	        });
	    }

	    try {
	            var workerSrc = mod.src;
	    var Blob = __webpack_require__(462);
	    var blob = new Blob([ workerSrc ], { type: 'application/javascript' });
	    var blobUrl = (window.URL || window.webkitURL).createObjectURL(blob);

	    this.$worker = new Worker(blobUrl);

	    } catch(e) {
	        if (e instanceof window.DOMException) {
	            var blob = this.$workerBlob(workerUrl);
	            var URL = window.URL || window.webkitURL;
	            var blobURL = URL.createObjectURL(blob);

	            this.$worker = new Worker(blobURL);
	            URL.revokeObjectURL(blobURL);
	        } else {
	            throw e;
	        }
	    }
	    this.$worker.postMessage({
	        init : true,
	        tlns : tlns,
	        module : mod.id,
	        classname : classname
	    });

	    this.callbackId = 1;
	    this.callbacks = {};

	    this.$worker.onmessage = this.onMessage;
	};

	(function(){

	    oop.implement(this, EventEmitter);

	    this.onMessage = function(e) {
	        var msg = e.data;
	        switch(msg.type) {
	            case "event":
	                this._signal(msg.name, {data: msg.data});
	                break;
	            case "call":
	                var callback = this.callbacks[msg.id];
	                if (callback) {
	                    callback(msg.data);
	                    delete this.callbacks[msg.id];
	                }
	                break;
	            case "error":
	                this.reportError(msg.data);
	                break;
	            case "log":
	                window.console && console.log && console.log.apply(console, msg.data);
	                break;
	        }
	    };

	    this.reportError = function(err) {
	        window.console && console.error && console.error(err);
	    };

	    this.$normalizePath = function(path) {
	        return net.qualifyURL(path);
	    };

	    this.terminate = function() {
	        this._signal("terminate", {});
	        this.deltaQueue = null;
	        this.$worker.terminate();
	        this.$worker = null;
	        if (this.$doc)
	            this.$doc.off("change", this.changeListener);
	        this.$doc = null;
	    };

	    this.send = function(cmd, args) {
	        this.$worker.postMessage({command: cmd, args: args});
	    };

	    this.call = function(cmd, args, callback) {
	        if (callback) {
	            var id = this.callbackId++;
	            this.callbacks[id] = callback;
	            args.push(id);
	        }
	        this.send(cmd, args);
	    };

	    this.emit = function(event, data) {
	        try {
	            this.$worker.postMessage({event: event, data: {data: data.data}});
	        }
	        catch(ex) {
	            console.error(ex.stack);
	        }
	    };

	    this.attachToDocument = function(doc) {
	        if(this.$doc)
	            this.terminate();

	        this.$doc = doc;
	        this.call("setValue", [doc.getValue()]);
	        doc.on("change", this.changeListener);
	    };

	    this.changeListener = function(e) {
	        if (!this.deltaQueue) {
	            this.deltaQueue = [e.data];
	            setTimeout(this.$sendDeltaQueue, 0);
	        } else
	            this.deltaQueue.push(e.data);
	    };

	    this.$sendDeltaQueue = function() {
	        var q = this.deltaQueue;
	        if (!q) return;
	        this.deltaQueue = null;
	        if (q.length > 20 && q.length > this.$doc.getLength() >> 1) {
	            this.call("setValue", [this.$doc.getValue()]);
	        } else
	            this.emit("change", {data: q});
	    };

	    this.$workerBlob = function(workerUrl) {
	        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
	        try {
	            return new Blob([script], {"type": "application/javascript"});
	        } catch (e) { // Backwards-compatibility
	            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
	            var blobBuilder = new BlobBuilder();
	            blobBuilder.append(script);
	            return blobBuilder.getBlob("application/javascript");
	        }
	    };

	}).call(WorkerClient.prototype);


	var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
	    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
	    this.changeListener = this.changeListener.bind(this);
	    this.callbackId = 1;
	    this.callbacks = {};
	    this.messageBuffer = [];

	    var main = null;
	    var emitSync = false;
	    var sender = Object.create(EventEmitter);
	    var _self = this;

	    this.$worker = {};
	    this.$worker.terminate = function() {};
	    this.$worker.postMessage = function(e) {
	        _self.messageBuffer.push(e);
	        if (main) {
	            if (emitSync)
	                setTimeout(processNext);
	            else
	                processNext();
	        }
	    };
	    this.setEmitSync = function(val) { emitSync = val };

	    var processNext = function() {
	        var msg = _self.messageBuffer.shift();
	        if (msg.command)
	            main[msg.command].apply(main, msg.args);
	        else if (msg.event)
	            sender._signal(msg.event, msg.data);
	    };

	    sender.postMessage = function(msg) {
	        _self.onMessage({data: msg});
	    };
	    sender.callback = function(data, callbackId) {
	        this.postMessage({type: "call", id: callbackId, data: data});
	    };
	    sender.emit = function(name, data) {
	        this.postMessage({type: "event", name: name, data: data});
	    };

	    config.loadModule(["worker", mod], function(Main) {
	        main = new Main[classname](sender);
	        while (_self.messageBuffer.length)
	            processNext();
	    });
	};

	UIWorkerClient.prototype = WorkerClient.prototype;

	exports.UIWorkerClient = UIWorkerClient;
	exports.WorkerClient = WorkerClient;

	});

	ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("./range").Range;
	var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
	var oop = acequire("./lib/oop");

	var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
	    var _self = this;
	    this.length = length;
	    this.session = session;
	    this.doc = session.getDocument();
	    this.mainClass = mainClass;
	    this.othersClass = othersClass;
	    this.$onUpdate = this.onUpdate.bind(this);
	    this.doc.on("change", this.$onUpdate);
	    this.$others = others;
	    
	    this.$onCursorChange = function() {
	        setTimeout(function() {
	            _self.onCursorChange();
	        });
	    };
	    
	    this.$pos = pos;
	    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
	    this.$undoStackDepth =  undoStack.length;
	    this.setup();

	    session.selection.on("changeCursor", this.$onCursorChange);
	};

	(function() {

	    oop.implement(this, EventEmitter);
	    this.setup = function() {
	        var _self = this;
	        var doc = this.doc;
	        var session = this.session;
	        var pos = this.$pos;
	        
	        this.selectionBefore = session.selection.toJSON();
	        if (session.selection.inMultiSelectMode)
	            session.selection.toSingleRange();

	        this.pos = doc.createAnchor(pos.row, pos.column);
	        this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
	        this.pos.on("change", function(event) {
	            session.removeMarker(_self.markerId);
	            _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.mainClass, null, false);
	        });
	        this.others = [];
	        this.$others.forEach(function(other) {
	            var anchor = doc.createAnchor(other.row, other.column);
	            _self.others.push(anchor);
	        });
	        session.setUndoSelect(false);
	    };
	    this.showOtherMarkers = function() {
	        if(this.othersActive) return;
	        var session = this.session;
	        var _self = this;
	        this.othersActive = true;
	        this.others.forEach(function(anchor) {
	            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);
	            anchor.on("change", function(event) {
	                session.removeMarker(anchor.markerId);
	                anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.othersClass, null, false);
	            });
	        });
	    };
	    this.hideOtherMarkers = function() {
	        if(!this.othersActive) return;
	        this.othersActive = false;
	        for (var i = 0; i < this.others.length; i++) {
	            this.session.removeMarker(this.others[i].markerId);
	        }
	    };
	    this.onUpdate = function(event) {
	        var delta = event.data;
	        var range = delta.range;
	        if(range.start.row !== range.end.row) return;
	        if(range.start.row !== this.pos.row) return;
	        if (this.$updating) return;
	        this.$updating = true;
	        var lengthDiff = delta.action === "insertText" ? range.end.column - range.start.column : range.start.column - range.end.column;
	        
	        if(range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {
	            var distanceFromStart = range.start.column - this.pos.column;
	            this.length += lengthDiff;
	            if(!this.session.$fromUndo) {
	                if(delta.action === "insertText") {
	                    for (var i = this.others.length - 1; i >= 0; i--) {
	                        var otherPos = this.others[i];
	                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
	                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
	                            newPos.column += lengthDiff;
	                        this.doc.insert(newPos, delta.text);
	                    }
	                } else if(delta.action === "removeText") {
	                    for (var i = this.others.length - 1; i >= 0; i--) {
	                        var otherPos = this.others[i];
	                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};
	                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)
	                            newPos.column += lengthDiff;
	                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
	                    }
	                }
	                if(range.start.column === this.pos.column && delta.action === "insertText") {
	                    setTimeout(function() {
	                        this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);
	                        for (var i = 0; i < this.others.length; i++) {
	                            var other = this.others[i];
	                            var newPos = {row: other.row, column: other.column - lengthDiff};
	                            if(other.row === range.start.row && range.start.column < other.column)
	                                newPos.column += lengthDiff;
	                            other.setPosition(newPos.row, newPos.column);
	                        }
	                    }.bind(this), 0);
	                }
	                else if(range.start.column === this.pos.column && delta.action === "removeText") {
	                    setTimeout(function() {
	                        for (var i = 0; i < this.others.length; i++) {
	                            var other = this.others[i];
	                            if(other.row === range.start.row && range.start.column < other.column) {
	                                other.setPosition(other.row, other.column - lengthDiff);
	                            }
	                        }
	                    }.bind(this), 0);
	                }
	            }
	            this.pos._emit("change", {value: this.pos});
	            for (var i = 0; i < this.others.length; i++) {
	                this.others[i]._emit("change", {value: this.others[i]});
	            }
	        }
	        this.$updating = false;
	    };

	    this.onCursorChange = function(event) {
	        if (this.$updating || !this.session) return;
	        var pos = this.session.selection.getCursor();
	        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
	            this.showOtherMarkers();
	            this._emit("cursorEnter", event);
	        } else {
	            this.hideOtherMarkers();
	            this._emit("cursorLeave", event);
	        }
	    };    
	    this.detach = function() {
	        this.session.removeMarker(this.markerId);
	        this.hideOtherMarkers();
	        this.doc.removeEventListener("change", this.$onUpdate);
	        this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
	        this.pos.detach();
	        for (var i = 0; i < this.others.length; i++) {
	            this.others[i].detach();
	        }
	        this.session.setUndoSelect(true);
	        this.session = null;
	    };
	    this.cancel = function() {
	        if(this.$undoStackDepth === -1)
	            throw Error("Canceling placeholders only supported with undo manager attached to session.");
	        var undoManager = this.session.getUndoManager();
	        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
	        for (var i = 0; i < undosRequired; i++) {
	            undoManager.undo(true);
	        }
	        if (this.selectionBefore)
	            this.session.selection.fromJSON(this.selectionBefore);
	    };
	}).call(PlaceHolder.prototype);


	exports.PlaceHolder = PlaceHolder;
	});

	ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"], function(acequire, exports, module) {

	var event = acequire("../lib/event");
	var useragent = acequire("../lib/useragent");
	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}

	function onMouseDown(e) {
	    var ev = e.domEvent;
	    var alt = ev.altKey;
	    var shift = ev.shiftKey;
	    var ctrl = ev.ctrlKey;
	    var accel = e.getAccelKey();
	    var button = e.getButton();
	    
	    if (ctrl && useragent.isMac)
	        button = ev.button;

	    if (e.editor.inMultiSelectMode && button == 2) {
	        e.editor.textInput.onContextMenu(e.domEvent);
	        return;
	    }
	    
	    if (!ctrl && !alt && !accel) {
	        if (button === 0 && e.editor.inMultiSelectMode)
	            e.editor.exitMultiSelectMode();
	        return;
	    }
	    
	    if (button !== 0)
	        return;

	    var editor = e.editor;
	    var selection = editor.selection;
	    var isMultiSelect = editor.inMultiSelectMode;
	    var pos = e.getDocumentPosition();
	    var cursor = selection.getCursor();
	    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));

	    var mouseX = e.x, mouseY = e.y;
	    var onMouseSelection = function(e) {
	        mouseX = e.clientX;
	        mouseY = e.clientY;
	    };
	    
	    var session = editor.session;
	    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	    var screenCursor = screenAnchor;
	    
	    var selectionMode;
	    if (editor.$mouseHandler.$enableJumpToDef) {
	        if (ctrl && alt || accel && alt)
	            selectionMode = "add";
	        else if (alt)
	            selectionMode = "block";
	    } else {
	        if (accel && !alt) {
	            selectionMode = "add";
	            if (!isMultiSelect && shift)
	                return;
	        } else if (alt) {
	            selectionMode = "block";
	        }
	    }
	    
	    if (selectionMode && useragent.isMac && ev.ctrlKey) {
	        editor.$mouseHandler.cancelContextMenu();
	    }

	    if (selectionMode == "add") {
	        if (!isMultiSelect && inSelection)
	            return; // dragging

	        if (!isMultiSelect) {
	            var range = selection.toOrientedRange();
	            editor.addSelectionMarker(range);
	        }

	        var oldRange = selection.rangeList.rangeAtPoint(pos);
	        
	        
	        editor.$blockScrolling++;
	        editor.inVirtualSelectionMode = true;
	        
	        if (shift) {
	            oldRange = null;
	            range = selection.ranges[0];
	            editor.removeSelectionMarker(range);
	        }
	        editor.once("mouseup", function() {
	            var tmpSel = selection.toOrientedRange();

	            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
	                selection.substractPoint(tmpSel.cursor);
	            else {
	                if (shift) {
	                    selection.substractPoint(range.cursor);
	                } else if (range) {
	                    editor.removeSelectionMarker(range);
	                    selection.addRange(range);
	                }
	                selection.addRange(tmpSel);
	            }
	            editor.$blockScrolling--;
	            editor.inVirtualSelectionMode = false;
	        });

	    } else if (selectionMode == "block") {
	        e.stop();
	        editor.inVirtualSelectionMode = true;        
	        var initialRange;
	        var rectSel = [];
	        var blockSelect = function() {
	            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
	            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);

	            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
	                return;
	            screenCursor = newCursor;

	            editor.$blockScrolling++;
	            editor.selection.moveToPosition(cursor);
	            editor.renderer.scrollCursorIntoView();

	            editor.removeSelectionMarkers(rectSel);
	            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
	            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
	                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
	            rectSel.forEach(editor.addSelectionMarker, editor);
	            editor.updateSelectionMarkers();
	            editor.$blockScrolling--;
	        };
	        editor.$blockScrolling++;
	        if (isMultiSelect && !accel) {
	            selection.toSingleRange();
	        } else if (!isMultiSelect && accel) {
	            initialRange = selection.toOrientedRange();
	            editor.addSelectionMarker(initialRange);
	        }
	        
	        if (shift)
	            screenAnchor = session.documentToScreenPosition(selection.lead);            
	        else
	            selection.moveToPosition(pos);
	        editor.$blockScrolling--;
	        
	        screenCursor = {row: -1, column: -1};

	        var onMouseSelectionEnd = function(e) {
	            clearInterval(timerId);
	            editor.removeSelectionMarkers(rectSel);
	            if (!rectSel.length)
	                rectSel = [selection.toOrientedRange()];
	            editor.$blockScrolling++;
	            if (initialRange) {
	                editor.removeSelectionMarker(initialRange);
	                selection.toSingleRange(initialRange);
	            }
	            for (var i = 0; i < rectSel.length; i++)
	                selection.addRange(rectSel[i]);
	            editor.inVirtualSelectionMode = false;
	            editor.$mouseHandler.$clickSelection = null;
	            editor.$blockScrolling--;
	        };

	        var onSelectionInterval = blockSelect;

	        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
	        var timerId = setInterval(function() {onSelectionInterval();}, 20);

	        return e.preventDefault();
	    }
	}


	exports.onMouseDown = onMouseDown;

	});

	ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"], function(acequire, exports, module) {
	exports.defaultCommands = [{
	    name: "addCursorAbove",
	    exec: function(editor) { editor.selectMoreLines(-1); },
	    bindKey: {win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "addCursorBelow",
	    exec: function(editor) { editor.selectMoreLines(1); },
	    bindKey: {win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "addCursorAboveSkipCurrent",
	    exec: function(editor) { editor.selectMoreLines(-1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "addCursorBelowSkipCurrent",
	    exec: function(editor) { editor.selectMoreLines(1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "selectMoreBefore",
	    exec: function(editor) { editor.selectMore(-1); },
	    bindKey: {win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "selectMoreAfter",
	    exec: function(editor) { editor.selectMore(1); },
	    bindKey: {win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "selectNextBefore",
	    exec: function(editor) { editor.selectMore(-1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "selectNextAfter",
	    exec: function(editor) { editor.selectMore(1, true); },
	    bindKey: {win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right"},
	    scrollIntoView: "cursor",
	    readonly: true
	}, {
	    name: "splitIntoLines",
	    exec: function(editor) { editor.multiSelect.splitIntoLines(); },
	    bindKey: {win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L"},
	    readonly: true
	}, {
	    name: "alignCursors",
	    exec: function(editor) { editor.alignCursors(); },
	    bindKey: {win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A"},
	    scrollIntoView: "cursor"
	}, {
	    name: "findAll",
	    exec: function(editor) { editor.findAll(); },
	    bindKey: {win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G"},
	    scrollIntoView: "cursor",
	    readonly: true
	}];
	exports.multiSelectCommands = [{
	    name: "singleSelection",
	    bindKey: "esc",
	    exec: function(editor) { editor.exitMultiSelectMode(); },
	    scrollIntoView: "cursor",
	    readonly: true,
	    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}
	}];

	var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
	exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);

	});

	ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"], function(acequire, exports, module) {

	var RangeList = acequire("./range_list").RangeList;
	var Range = acequire("./range").Range;
	var Selection = acequire("./selection").Selection;
	var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
	var event = acequire("./lib/event");
	var lang = acequire("./lib/lang");
	var commands = acequire("./commands/multi_select_commands");
	exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
	var Search = acequire("./search").Search;
	var search = new Search();

	function find(session, needle, dir) {
	    search.$options.wrap = true;
	    search.$options.needle = needle;
	    search.$options.backwards = dir == -1;
	    return search.find(session);
	}
	var EditSession = acequire("./edit_session").EditSession;
	(function() {
	    this.getSelectionMarkers = function() {
	        return this.$selectionMarkers;
	    };
	}).call(EditSession.prototype);
	(function() {
	    this.ranges = null;
	    this.rangeList = null;
	    this.addRange = function(range, $blockChangeEvents) {
	        if (!range)
	            return;

	        if (!this.inMultiSelectMode && this.rangeCount === 0) {
	            var oldRange = this.toOrientedRange();
	            this.rangeList.add(oldRange);
	            this.rangeList.add(range);
	            if (this.rangeList.ranges.length != 2) {
	                this.rangeList.removeAll();
	                return $blockChangeEvents || this.fromOrientedRange(range);
	            }
	            this.rangeList.removeAll();
	            this.rangeList.add(oldRange);
	            this.$onAddRange(oldRange);
	        }

	        if (!range.cursor)
	            range.cursor = range.end;

	        var removed = this.rangeList.add(range);

	        this.$onAddRange(range);

	        if (removed.length)
	            this.$onRemoveRange(removed);

	        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
	            this._signal("multiSelect");
	            this.inMultiSelectMode = true;
	            this.session.$undoSelect = false;
	            this.rangeList.attach(this.session);
	        }

	        return $blockChangeEvents || this.fromOrientedRange(range);
	    };

	    this.toSingleRange = function(range) {
	        range = range || this.ranges[0];
	        var removed = this.rangeList.removeAll();
	        if (removed.length)
	            this.$onRemoveRange(removed);

	        range && this.fromOrientedRange(range);
	    };
	    this.substractPoint = function(pos) {
	        var removed = this.rangeList.substractPoint(pos);
	        if (removed) {
	            this.$onRemoveRange(removed);
	            return removed[0];
	        }
	    };
	    this.mergeOverlappingRanges = function() {
	        var removed = this.rangeList.merge();
	        if (removed.length)
	            this.$onRemoveRange(removed);
	        else if(this.ranges[0])
	            this.fromOrientedRange(this.ranges[0]);
	    };

	    this.$onAddRange = function(range) {
	        this.rangeCount = this.rangeList.ranges.length;
	        this.ranges.unshift(range);
	        this._signal("addRange", {range: range});
	    };

	    this.$onRemoveRange = function(removed) {
	        this.rangeCount = this.rangeList.ranges.length;
	        if (this.rangeCount == 1 && this.inMultiSelectMode) {
	            var lastRange = this.rangeList.ranges.pop();
	            removed.push(lastRange);
	            this.rangeCount = 0;
	        }

	        for (var i = removed.length; i--; ) {
	            var index = this.ranges.indexOf(removed[i]);
	            this.ranges.splice(index, 1);
	        }

	        this._signal("removeRange", {ranges: removed});

	        if (this.rangeCount === 0 && this.inMultiSelectMode) {
	            this.inMultiSelectMode = false;
	            this._signal("singleSelect");
	            this.session.$undoSelect = true;
	            this.rangeList.detach(this.session);
	        }

	        lastRange = lastRange || this.ranges[0];
	        if (lastRange && !lastRange.isEqual(this.getRange()))
	            this.fromOrientedRange(lastRange);
	    };
	    this.$initRangeList = function() {
	        if (this.rangeList)
	            return;

	        this.rangeList = new RangeList();
	        this.ranges = [];
	        this.rangeCount = 0;
	    };
	    this.getAllRanges = function() {
	        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
	    };

	    this.splitIntoLines = function () {
	        if (this.rangeCount > 1) {
	            var ranges = this.rangeList.ranges;
	            var lastRange = ranges[ranges.length - 1];
	            var range = Range.fromPoints(ranges[0].start, lastRange.end);

	            this.toSingleRange();
	            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	        } else {
	            var range = this.getRange();
	            var isBackwards = this.isBackwards();
	            var startRow = range.start.row;
	            var endRow = range.end.row;
	            if (startRow == endRow) {
	                if (isBackwards)
	                    var start = range.end, end = range.start;
	                else
	                    var start = range.start, end = range.end;
	                
	                this.addRange(Range.fromPoints(end, end));
	                this.addRange(Range.fromPoints(start, start));
	                return;
	            }

	            var rectSel = [];
	            var r = this.getLineRange(startRow, true);
	            r.start.column = range.start.column;
	            rectSel.push(r);

	            for (var i = startRow + 1; i < endRow; i++)
	                rectSel.push(this.getLineRange(i, true));

	            r = this.getLineRange(endRow, true);
	            r.end.column = range.end.column;
	            rectSel.push(r);

	            rectSel.forEach(this.addRange, this);
	        }
	    };
	    this.toggleBlockSelection = function () {
	        if (this.rangeCount > 1) {
	            var ranges = this.rangeList.ranges;
	            var lastRange = ranges[ranges.length - 1];
	            var range = Range.fromPoints(ranges[0].start, lastRange.end);

	            this.toSingleRange();
	            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
	        } else {
	            var cursor = this.session.documentToScreenPosition(this.selectionLead);
	            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);

	            var rectSel = this.rectangularRangeBlock(cursor, anchor);
	            rectSel.forEach(this.addRange, this);
	        }
	    };
	    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
	        var rectSel = [];

	        var xBackwards = screenCursor.column < screenAnchor.column;
	        if (xBackwards) {
	            var startColumn = screenCursor.column;
	            var endColumn = screenAnchor.column;
	        } else {
	            var startColumn = screenAnchor.column;
	            var endColumn = screenCursor.column;
	        }

	        var yBackwards = screenCursor.row < screenAnchor.row;
	        if (yBackwards) {
	            var startRow = screenCursor.row;
	            var endRow = screenAnchor.row;
	        } else {
	            var startRow = screenAnchor.row;
	            var endRow = screenCursor.row;
	        }

	        if (startColumn < 0)
	            startColumn = 0;
	        if (startRow < 0)
	            startRow = 0;

	        if (startRow == endRow)
	            includeEmptyLines = true;

	        for (var row = startRow; row <= endRow; row++) {
	            var range = Range.fromPoints(
	                this.session.screenToDocumentPosition(row, startColumn),
	                this.session.screenToDocumentPosition(row, endColumn)
	            );
	            if (range.isEmpty()) {
	                if (docEnd && isSamePoint(range.end, docEnd))
	                    break;
	                var docEnd = range.end;
	            }
	            range.cursor = xBackwards ? range.start : range.end;
	            rectSel.push(range);
	        }

	        if (yBackwards)
	            rectSel.reverse();

	        if (!includeEmptyLines) {
	            var end = rectSel.length - 1;
	            while (rectSel[end].isEmpty() && end > 0)
	                end--;
	            if (end > 0) {
	                var start = 0;
	                while (rectSel[start].isEmpty())
	                    start++;
	            }
	            for (var i = end; i >= start; i--) {
	                if (rectSel[i].isEmpty())
	                    rectSel.splice(i, 1);
	            }
	        }

	        return rectSel;
	    };
	}).call(Selection.prototype);
	var Editor = acequire("./editor").Editor;
	(function() {
	    this.updateSelectionMarkers = function() {
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };
	    this.addSelectionMarker = function(orientedRange) {
	        if (!orientedRange.cursor)
	            orientedRange.cursor = orientedRange.end;

	        var style = this.getSelectionStyle();
	        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);

	        this.session.$selectionMarkers.push(orientedRange);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	        return orientedRange;
	    };
	    this.removeSelectionMarker = function(range) {
	        if (!range.marker)
	            return;
	        this.session.removeMarker(range.marker);
	        var index = this.session.$selectionMarkers.indexOf(range);
	        if (index != -1)
	            this.session.$selectionMarkers.splice(index, 1);
	        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
	    };

	    this.removeSelectionMarkers = function(ranges) {
	        var markerList = this.session.$selectionMarkers;
	        for (var i = ranges.length; i--; ) {
	            var range = ranges[i];
	            if (!range.marker)
	                continue;
	            this.session.removeMarker(range.marker);
	            var index = markerList.indexOf(range);
	            if (index != -1)
	                markerList.splice(index, 1);
	        }
	        this.session.selectionMarkerCount = markerList.length;
	    };

	    this.$onAddRange = function(e) {
	        this.addSelectionMarker(e.range);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onRemoveRange = function(e) {
	        this.removeSelectionMarkers(e.ranges);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onMultiSelect = function(e) {
	        if (this.inMultiSelectMode)
	            return;
	        this.inMultiSelectMode = true;

	        this.setStyle("ace_multiselect");
	        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
	        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);

	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	    };

	    this.$onSingleSelect = function(e) {
	        if (this.session.multiSelect.inVirtualMode)
	            return;
	        this.inMultiSelectMode = false;

	        this.unsetStyle("ace_multiselect");
	        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);

	        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
	        this.renderer.updateCursor();
	        this.renderer.updateBackMarkers();
	        this._emit("changeSelection");
	    };

	    this.$onMultiSelectExec = function(e) {
	        var command = e.command;
	        var editor = e.editor;
	        if (!editor.multiSelect)
	            return;
	        if (!command.multiSelectAction) {
	            var result = command.exec(editor, e.args || {});
	            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
	            editor.multiSelect.mergeOverlappingRanges();
	        } else if (command.multiSelectAction == "forEach") {
	            result = editor.forEachSelection(command, e.args);
	        } else if (command.multiSelectAction == "forEachLine") {
	            result = editor.forEachSelection(command, e.args, true);
	        } else if (command.multiSelectAction == "single") {
	            editor.exitMultiSelectMode();
	            result = command.exec(editor, e.args || {});
	        } else {
	            result = command.multiSelectAction(editor, e.args || {});
	        }
	        return result;
	    }; 
	    this.forEachSelection = function(cmd, args, options) {
	        if (this.inVirtualSelectionMode)
	            return;
	        var keepOrder = options && options.keepOrder;
	        var $byLines = options == true || options && options.$byLines
	        var session = this.session;
	        var selection = this.selection;
	        var rangeList = selection.rangeList;
	        var ranges = (keepOrder ? selection : rangeList).ranges;
	        var result;
	        
	        if (!ranges.length)
	            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	        
	        var reg = selection._eventRegistry;
	        selection._eventRegistry = {};

	        var tmpSel = new Selection(session);
	        this.inVirtualSelectionMode = true;
	        for (var i = ranges.length; i--;) {
	            if ($byLines) {
	                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
	                    i--;
	            }
	            tmpSel.fromOrientedRange(ranges[i]);
	            tmpSel.index = i;
	            this.selection = session.selection = tmpSel;
	            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
	            if (!result && cmdResult !== undefined)
	                result = cmdResult;
	            tmpSel.toOrientedRange(ranges[i]);
	        }
	        tmpSel.detach();

	        this.selection = session.selection = selection;
	        this.inVirtualSelectionMode = false;
	        selection._eventRegistry = reg;
	        selection.mergeOverlappingRanges();
	        
	        var anim = this.renderer.$scrollAnimation;
	        this.onCursorChange();
	        this.onSelectionChange();
	        if (anim && anim.from == anim.to)
	            this.renderer.animateScrolling(anim.from);
	        
	        return result;
	    };
	    this.exitMultiSelectMode = function() {
	        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
	            return;
	        this.multiSelect.toSingleRange();
	    };

	    this.getSelectedText = function() {
	        var text = "";
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var ranges = this.multiSelect.rangeList.ranges;
	            var buf = [];
	            for (var i = 0; i < ranges.length; i++) {
	                buf.push(this.session.getTextRange(ranges[i]));
	            }
	            var nl = this.session.getDocument().getNewLineCharacter();
	            text = buf.join(nl);
	            if (text.length == (buf.length - 1) * nl.length)
	                text = "";
	        } else if (!this.selection.isEmpty()) {
	            text = this.session.getTextRange(this.getSelectionRange());
	        }
	        return text;
	    };
	    
	    this.$checkMultiselectChange = function(e, anchor) {
	        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
	            var range = this.multiSelect.ranges[0];
	            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
	                return;
	            var pos = anchor == this.multiSelect.anchor
	                ? range.cursor == range.start ? range.end : range.start
	                : range.cursor;
	            if (pos.row != anchor.row
	                || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
	                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
	        }
	    };
	    this.findAll = function(needle, options, additive) {
	        options = options || {};
	        options.needle = needle || options.needle;
	        if (options.needle == undefined) {
	            var range = this.selection.isEmpty()
	                ? this.selection.getWordRange()
	                : this.selection.getRange();
	            options.needle = this.session.getTextRange(range);
	        }    
	        this.$search.set(options);
	        
	        var ranges = this.$search.findAll(this.session);
	        if (!ranges.length)
	            return 0;

	        this.$blockScrolling += 1;
	        var selection = this.multiSelect;

	        if (!additive)
	            selection.toSingleRange(ranges[0]);

	        for (var i = ranges.length; i--; )
	            selection.addRange(ranges[i], true);
	        if (range && selection.rangeList.rangeAtPoint(range.start))
	            selection.addRange(range, true);
	        
	        this.$blockScrolling -= 1;

	        return ranges.length;
	    };
	    this.selectMoreLines = function(dir, skip) {
	        var range = this.selection.toOrientedRange();
	        var isBackwards = range.cursor == range.end;

	        var screenLead = this.session.documentToScreenPosition(range.cursor);
	        if (this.selection.$desiredColumn)
	            screenLead.column = this.selection.$desiredColumn;

	        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);

	        if (!range.isEmpty()) {
	            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
	            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
	        } else {
	            var anchor = lead;
	        }

	        if (isBackwards) {
	            var newRange = Range.fromPoints(lead, anchor);
	            newRange.cursor = newRange.start;
	        } else {
	            var newRange = Range.fromPoints(anchor, lead);
	            newRange.cursor = newRange.end;
	        }

	        newRange.desiredColumn = screenLead.column;
	        if (!this.selection.inMultiSelectMode) {
	            this.selection.addRange(range);
	        } else {
	            if (skip)
	                var toRemove = range.cursor;
	        }

	        this.selection.addRange(newRange);
	        if (toRemove)
	            this.selection.substractPoint(toRemove);
	    };
	    this.transposeSelections = function(dir) {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var all = sel.ranges;

	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            if (range.isEmpty()) {
	                var tmp = session.getWordRange(range.start.row, range.start.column);
	                range.start.row = tmp.start.row;
	                range.start.column = tmp.start.column;
	                range.end.row = tmp.end.row;
	                range.end.column = tmp.end.column;
	            }
	        }
	        sel.mergeOverlappingRanges();

	        var words = [];
	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            words.unshift(session.getTextRange(range));
	        }

	        if (dir < 0)
	            words.unshift(words.pop());
	        else
	            words.push(words.shift());

	        for (var i = all.length; i--; ) {
	            var range = all[i];
	            var tmp = range.clone();
	            session.replace(range, words[i]);
	            range.start.row = tmp.start.row;
	            range.start.column = tmp.start.column;
	        }
	    };
	    this.selectMore = function(dir, skip, stopAtFirst) {
	        var session = this.session;
	        var sel = session.multiSelect;

	        var range = sel.toOrientedRange();
	        if (range.isEmpty()) {
	            range = session.getWordRange(range.start.row, range.start.column);
	            range.cursor = dir == -1 ? range.start : range.end;
	            this.multiSelect.addRange(range);
	            if (stopAtFirst)
	                return;
	        }
	        var needle = session.getTextRange(range);

	        var newRange = find(session, needle, dir);
	        if (newRange) {
	            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
	            this.$blockScrolling += 1;
	            this.session.unfold(newRange);
	            this.multiSelect.addRange(newRange);
	            this.$blockScrolling -= 1;
	            this.renderer.scrollCursorIntoView(null, 0.5);
	        }
	        if (skip)
	            this.multiSelect.substractPoint(range.cursor);
	    };
	    this.alignCursors = function() {
	        var session = this.session;
	        var sel = session.multiSelect;
	        var ranges = sel.ranges;
	        var row = -1;
	        var sameRowRanges = ranges.filter(function(r) {
	            if (r.cursor.row == row)
	                return true;
	            row = r.cursor.row;
	        });
	        
	        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
	            var range = this.selection.getRange();
	            var fr = range.start.row, lr = range.end.row;
	            var guessRange = fr == lr;
	            if (guessRange) {
	                var max = this.session.getLength();
	                var line;
	                do {
	                    line = this.session.getLine(lr);
	                } while (/[=:]/.test(line) && ++lr < max);
	                do {
	                    line = this.session.getLine(fr);
	                } while (/[=:]/.test(line) && --fr > 0);
	                
	                if (fr < 0) fr = 0;
	                if (lr >= max) lr = max - 1;
	            }
	            var lines = this.session.doc.removeLines(fr, lr);
	            lines = this.$reAlignText(lines, guessRange);
	            this.session.doc.insert({row: fr, column: 0}, lines.join("\n") + "\n");
	            if (!guessRange) {
	                range.start.column = 0;
	                range.end.column = lines[lines.length - 1].length;
	            }
	            this.selection.setRange(range);
	        } else {
	            sameRowRanges.forEach(function(r) {
	                sel.substractPoint(r.cursor);
	            });

	            var maxCol = 0;
	            var minSpace = Infinity;
	            var spaceOffsets = ranges.map(function(r) {
	                var p = r.cursor;
	                var line = session.getLine(p.row);
	                var spaceOffset = line.substr(p.column).search(/\S/g);
	                if (spaceOffset == -1)
	                    spaceOffset = 0;

	                if (p.column > maxCol)
	                    maxCol = p.column;
	                if (spaceOffset < minSpace)
	                    minSpace = spaceOffset;
	                return spaceOffset;
	            });
	            ranges.forEach(function(r, i) {
	                var p = r.cursor;
	                var l = maxCol - p.column;
	                var d = spaceOffsets[i] - minSpace;
	                if (l > d)
	                    session.insert(p, lang.stringRepeat(" ", l - d));
	                else
	                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));

	                r.start.column = r.end.column = maxCol;
	                r.start.row = r.end.row = p.row;
	                r.cursor = r.end;
	            });
	            sel.fromOrientedRange(ranges[0]);
	            this.renderer.updateCursor();
	            this.renderer.updateBackMarkers();
	        }
	    };

	    this.$reAlignText = function(lines, forceLeft) {
	        var isLeftAligned = true, isRightAligned = true;
	        var startW, textW, endW;

	        return lines.map(function(line) {
	            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
	            if (!m)
	                return [line];

	            if (startW == null) {
	                startW = m[1].length;
	                textW = m[2].length;
	                endW = m[3].length;
	                return m;
	            }

	            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
	                isRightAligned = false;
	            if (startW != m[1].length)
	                isLeftAligned = false;

	            if (startW > m[1].length)
	                startW = m[1].length;
	            if (textW < m[2].length)
	                textW = m[2].length;
	            if (endW > m[3].length)
	                endW = m[3].length;

	            return m;
	        }).map(forceLeft ? alignLeft :
	            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);

	        function spaces(n) {
	            return lang.stringRepeat(" ", n);
	        }

	        function alignLeft(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(textW - m[2].length + endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function alignRight(m) {
	            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
	                + spaces(endW, " ")
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	        function unAlign(m) {
	            return !m[2] ? m[0] : spaces(startW) + m[2]
	                + spaces(endW)
	                + m[4].replace(/^([=:])\s+/, "$1 ");
	        }
	    };
	}).call(Editor.prototype);


	function isSamePoint(p1, p2) {
	    return p1.row == p2.row && p1.column == p2.column;
	}
	exports.onSessionChange = function(e) {
	    var session = e.session;
	    if (session && !session.multiSelect) {
	        session.$selectionMarkers = [];
	        session.selection.$initRangeList();
	        session.multiSelect = session.selection;
	    }
	    this.multiSelect = session && session.multiSelect;

	    var oldSession = e.oldSession;
	    if (oldSession) {
	        oldSession.multiSelect.off("addRange", this.$onAddRange);
	        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
	        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
	        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
	        oldSession.multiSelect.lead.off("change",  this.$checkMultiselectChange);
	        oldSession.multiSelect.anchor.off("change",  this.$checkMultiselectChange);
	    }

	    if (session) {
	        session.multiSelect.on("addRange", this.$onAddRange);
	        session.multiSelect.on("removeRange", this.$onRemoveRange);
	        session.multiSelect.on("multiSelect", this.$onMultiSelect);
	        session.multiSelect.on("singleSelect", this.$onSingleSelect);
	        session.multiSelect.lead.on("change",  this.$checkMultiselectChange);
	        session.multiSelect.anchor.on("change",  this.$checkMultiselectChange);
	    }

	    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
	        if (session.selection.inMultiSelectMode)
	            this.$onMultiSelect();
	        else
	            this.$onSingleSelect();
	    }
	};
	function MultiSelect(editor) {
	    if (editor.$multiselectOnSessionChange)
	        return;
	    editor.$onAddRange = editor.$onAddRange.bind(editor);
	    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
	    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
	    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
	    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
	    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);

	    editor.$multiselectOnSessionChange(editor);
	    editor.on("changeSession", editor.$multiselectOnSessionChange);

	    editor.on("mousedown", onMouseDown);
	    editor.commands.addCommands(commands.defaultCommands);

	    addAltCursorListeners(editor);
	}

	function addAltCursorListeners(editor){
	    var el = editor.textInput.getElement();
	    var altCursor = false;
	    event.addListener(el, "keydown", function(e) {
	        if (e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey)) {
	            if (!altCursor) {
	                editor.renderer.setMouseCursor("crosshair");
	                altCursor = true;
	            }
	        } else if (altCursor) {
	            reset();
	        }
	    });

	    event.addListener(el, "keyup", reset);
	    event.addListener(el, "blur", reset);
	    function reset(e) {
	        if (altCursor) {
	            editor.renderer.setMouseCursor("");
	            altCursor = false;
	        }
	    }
	}

	exports.MultiSelect = MultiSelect;


	acequire("./config").defineOptions(Editor.prototype, "editor", {
	    enableMultiselect: {
	        set: function(val) {
	            MultiSelect(this);
	            if (val) {
	                this.on("changeSession", this.$multiselectOnSessionChange);
	                this.on("mousedown", onMouseDown);
	            } else {
	                this.off("changeSession", this.$multiselectOnSessionChange);
	                this.off("mousedown", onMouseDown);
	            }
	        },
	        value: true
	    }
	});



	});

	ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../../range").Range;

	var FoldMode = exports.FoldMode = function() {};

	(function() {

	    this.foldingStartMarker = null;
	    this.foldingStopMarker = null;
	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);
	        if (this.foldingStartMarker.test(line))
	            return "start";
	        if (foldStyle == "markbeginend"
	                && this.foldingStopMarker
	                && this.foldingStopMarker.test(line))
	            return "end";
	        return "";
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row) {
	        return null;
	    };

	    this.indentationBlock = function(session, row, column) {
	        var re = /\S/;
	        var line = session.getLine(row);
	        var startLevel = line.search(re);
	        if (startLevel == -1)
	            return;

	        var startColumn = column || line.length;
	        var maxRow = session.getLength();
	        var startRow = row;
	        var endRow = row;

	        while (++row < maxRow) {
	            var level = session.getLine(row).search(re);

	            if (level == -1)
	                continue;

	            if (level <= startLevel)
	                break;

	            endRow = row;
	        }

	        if (endRow > startRow) {
	            var endColumn = session.getLine(endRow).length;
	            return new Range(startRow, startColumn, endRow, endColumn);
	        }
	    };

	    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
	        var start = {row: row, column: column + 1};
	        var end = session.$findClosingBracket(bracket, start, typeRe);
	        if (!end)
	            return;

	        var fw = session.foldWidgets[end.row];
	        if (fw == null)
	            fw = session.getFoldWidget(end.row);

	        if (fw == "start" && end.row > start.row) {
	            end.row --;
	            end.column = session.getLine(end.row).length;
	        }
	        return Range.fromPoints(start, end);
	    };

	    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
	        var end = {row: row, column: column};
	        var start = session.$findOpeningBracket(bracket, end);

	        if (!start)
	            return;

	        start.column++;
	        end.column--;

	        return  Range.fromPoints(start, end);
	    };
	}).call(FoldMode.prototype);

	});

	ace.define("ace/theme/textmate",["require","exports","module","ace/lib/dom"], function(acequire, exports, module) {
	"use strict";

	exports.isDark = false;
	exports.cssClass = "ace-tm";
	exports.cssText = ".ace-tm .ace_gutter {\
	background: #f0f0f0;\
	color: #333;\
	}\
	.ace-tm .ace_print-margin {\
	width: 1px;\
	background: #e8e8e8;\
	}\
	.ace-tm .ace_fold {\
	background-color: #6B72E6;\
	}\
	.ace-tm {\
	background-color: #FFFFFF;\
	color: black;\
	}\
	.ace-tm .ace_cursor {\
	color: black;\
	}\
	.ace-tm .ace_invisible {\
	color: rgb(191, 191, 191);\
	}\
	.ace-tm .ace_storage,\
	.ace-tm .ace_keyword {\
	color: blue;\
	}\
	.ace-tm .ace_constant {\
	color: rgb(197, 6, 11);\
	}\
	.ace-tm .ace_constant.ace_buildin {\
	color: rgb(88, 72, 246);\
	}\
	.ace-tm .ace_constant.ace_language {\
	color: rgb(88, 92, 246);\
	}\
	.ace-tm .ace_constant.ace_library {\
	color: rgb(6, 150, 14);\
	}\
	.ace-tm .ace_invalid {\
	background-color: rgba(255, 0, 0, 0.1);\
	color: red;\
	}\
	.ace-tm .ace_support.ace_function {\
	color: rgb(60, 76, 114);\
	}\
	.ace-tm .ace_support.ace_constant {\
	color: rgb(6, 150, 14);\
	}\
	.ace-tm .ace_support.ace_type,\
	.ace-tm .ace_support.ace_class {\
	color: rgb(109, 121, 222);\
	}\
	.ace-tm .ace_keyword.ace_operator {\
	color: rgb(104, 118, 135);\
	}\
	.ace-tm .ace_string {\
	color: rgb(3, 106, 7);\
	}\
	.ace-tm .ace_comment {\
	color: rgb(76, 136, 107);\
	}\
	.ace-tm .ace_comment.ace_doc {\
	color: rgb(0, 102, 255);\
	}\
	.ace-tm .ace_comment.ace_doc.ace_tag {\
	color: rgb(128, 159, 191);\
	}\
	.ace-tm .ace_constant.ace_numeric {\
	color: rgb(0, 0, 205);\
	}\
	.ace-tm .ace_variable {\
	color: rgb(49, 132, 149);\
	}\
	.ace-tm .ace_xml-pe {\
	color: rgb(104, 104, 91);\
	}\
	.ace-tm .ace_entity.ace_name.ace_function {\
	color: #0000A2;\
	}\
	.ace-tm .ace_heading {\
	color: rgb(12, 7, 255);\
	}\
	.ace-tm .ace_list {\
	color:rgb(185, 6, 144);\
	}\
	.ace-tm .ace_meta.ace_tag {\
	color:rgb(0, 22, 142);\
	}\
	.ace-tm .ace_string.ace_regex {\
	color: rgb(255, 0, 0)\
	}\
	.ace-tm .ace_marker-layer .ace_selection {\
	background: rgb(181, 213, 255);\
	}\
	.ace-tm.ace_multiselect .ace_selection.ace_start {\
	box-shadow: 0 0 3px 0px white;\
	border-radius: 2px;\
	}\
	.ace-tm .ace_marker-layer .ace_step {\
	background: rgb(252, 255, 0);\
	}\
	.ace-tm .ace_marker-layer .ace_stack {\
	background: rgb(164, 229, 101);\
	}\
	.ace-tm .ace_marker-layer .ace_bracket {\
	margin: -1px 0 0 -1px;\
	border: 1px solid rgb(192, 192, 192);\
	}\
	.ace-tm .ace_marker-layer .ace_active-line {\
	background: rgba(0, 0, 0, 0.07);\
	}\
	.ace-tm .ace_gutter-active-line {\
	background-color : #dcdcdc;\
	}\
	.ace-tm .ace_marker-layer .ace_selected-word {\
	background: rgb(250, 250, 255);\
	border: 1px solid rgb(200, 200, 250);\
	}\
	.ace-tm .ace_indent-guide {\
	background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
	}\
	";

	var dom = acequire("../lib/dom");
	dom.importCssString(exports.cssText, exports.cssClass);
	});

	ace.define("ace/line_widgets",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/range"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("./lib/oop");
	var dom = acequire("./lib/dom");
	var Range = acequire("./range").Range;


	function LineWidgets(session) {
	    this.session = session;
	    this.session.widgetManager = this;
	    this.session.getRowLength = this.getRowLength;
	    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
	    this.updateOnChange = this.updateOnChange.bind(this);
	    this.renderWidgets = this.renderWidgets.bind(this);
	    this.measureWidgets = this.measureWidgets.bind(this);
	    this.session._changedWidgets = [];
	    this.$onChangeEditor = this.$onChangeEditor.bind(this);
	    
	    this.session.on("change", this.updateOnChange);
	    this.session.on("changeEditor", this.$onChangeEditor);
	}

	(function() {
	    this.getRowLength = function(row) {
	        var h;
	        if (this.lineWidgets)
	            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
	        else 
	            h = 0;
	        if (!this.$useWrapMode || !this.$wrapData[row]) {
	            return 1 + h;
	        } else {
	            return this.$wrapData[row].length + 1 + h;
	        }
	    };

	    this.$getWidgetScreenLength = function() {
	        var screenRows = 0;
	        this.lineWidgets.forEach(function(w){
	            if (w && w.rowCount)
	                screenRows +=w.rowCount;
	        });
	        return screenRows;
	    };    
	    
	    this.$onChangeEditor = function(e) {
	        this.attach(e.editor);
	    };

	    this.attach = function(editor) {
	        if (editor  && editor.widgetManager && editor.widgetManager != this)
	            editor.widgetManager.detach();

	        if (this.editor == editor)
	            return;

	        this.detach();
	        this.editor = editor;
	        
	        if (editor) {
	            editor.widgetManager = this;
	            editor.renderer.on("beforeRender", this.measureWidgets);
	            editor.renderer.on("afterRender", this.renderWidgets);
	        }
	    };
	    this.detach = function(e) {
	        var editor = this.editor;
	        if (!editor)
	            return;
	        
	        this.editor = null;
	        editor.widgetManager = null;
	        
	        editor.renderer.off("beforeRender", this.measureWidgets);
	        editor.renderer.off("afterRender", this.renderWidgets);
	        var lineWidgets = this.session.lineWidgets;
	        lineWidgets && lineWidgets.forEach(function(w) {
	            if (w && w.el && w.el.parentNode) {
	                w._inDocument = false;
	                w.el.parentNode.removeChild(w.el);
	            }
	        });
	    };

	    this.updateOnChange = function(e) {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets) return;
	            
	        var delta = e.data;
	        var range = delta.range;
	        var startRow = range.start.row;
	        var len = range.end.row - startRow;

	        if (len === 0) {
	        } else if (delta.action == "removeText" || delta.action == "removeLines") {
	            var removed = lineWidgets.splice(startRow + 1, len);
	            removed.forEach(function(w) {
	                w && this.removeLineWidget(w);
	            }, this);
	            this.$updateRows();
	        } else {
	            var args = new Array(len);
	            args.unshift(startRow, 0);
	            lineWidgets.splice.apply(lineWidgets, args);
	            this.$updateRows();
	        }
	    };
	    
	    this.$updateRows = function() {
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets) return;
	        var noWidgets = true;
	        lineWidgets.forEach(function(w, i) {
	            if (w) {
	                noWidgets = false;
	                w.row = i;
	            }
	        });
	        if (noWidgets)
	            this.session.lineWidgets = null;
	    };

	    this.addLineWidget = function(w) {
	        if (!this.session.lineWidgets)
	            this.session.lineWidgets = new Array(this.session.getLength());
	        
	        this.session.lineWidgets[w.row] = w;
	        
	        var renderer = this.editor.renderer;
	        if (w.html && !w.el) {
	            w.el = dom.createElement("div");
	            w.el.innerHTML = w.html;
	        }
	        if (w.el) {
	            dom.addCssClass(w.el, "ace_lineWidgetContainer");
	            w.el.style.position = "absolute";
	            w.el.style.zIndex = 5;
	            renderer.container.appendChild(w.el);
	            w._inDocument = true;
	        }
	        
	        if (!w.coverGutter) {
	            w.el.style.zIndex = 3;
	        }
	        if (!w.pixelHeight) {
	            w.pixelHeight = w.el.offsetHeight;
	        }
	        if (w.rowCount == null)
	            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
	        
	        this.session._emit("changeFold", {data:{start:{row: w.row}}});
	        
	        this.$updateRows();
	        this.renderWidgets(null, renderer);
	        return w;
	    };
	    
	    this.removeLineWidget = function(w) {
	        w._inDocument = false;
	        if (w.el && w.el.parentNode)
	            w.el.parentNode.removeChild(w.el);
	        if (w.editor && w.editor.destroy) try {
	            w.editor.destroy();
	        } catch(e){}
	        if (this.session.lineWidgets)
	            this.session.lineWidgets[w.row] = undefined;
	        this.session._emit("changeFold", {data:{start:{row: w.row}}});
	        this.$updateRows();
	    };
	    
	    this.onWidgetChanged = function(w) {
	        this.session._changedWidgets.push(w);
	        this.editor && this.editor.renderer.updateFull();
	    };
	    
	    this.measureWidgets = function(e, renderer) {
	        var changedWidgets = this.session._changedWidgets;
	        var config = renderer.layerConfig;
	        
	        if (!changedWidgets || !changedWidgets.length) return;
	        var min = Infinity;
	        for (var i = 0; i < changedWidgets.length; i++) {
	            var w = changedWidgets[i];
	            if (!w._inDocument) {
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            
	            w.h = w.el.offsetHeight;
	            
	            if (!w.fixedWidth) {
	                w.w = w.el.offsetWidth;
	                w.screenWidth = Math.ceil(w.w / config.characterWidth);
	            }
	            
	            var rowCount = w.h / config.lineHeight;
	            if (w.coverLine) {
	                rowCount -= this.session.getRowLineCount(w.row);
	                if (rowCount < 0)
	                    rowCount = 0;
	            }
	            if (w.rowCount != rowCount) {
	                w.rowCount = rowCount;
	                if (w.row < min)
	                    min = w.row;
	            }
	        }
	        if (min != Infinity) {
	            this.session._emit("changeFold", {data:{start:{row: min}}});
	            this.session.lineWidgetWidth = null;
	        }
	        this.session._changedWidgets = [];
	    };
	    
	    this.renderWidgets = function(e, renderer) {
	        var config = renderer.layerConfig;
	        var lineWidgets = this.session.lineWidgets;
	        if (!lineWidgets)
	            return;
	        var first = Math.min(this.firstRow, config.firstRow);
	        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
	        
	        while (first > 0 && !lineWidgets[first])
	            first--;
	        
	        this.firstRow = config.firstRow;
	        this.lastRow = config.lastRow;

	        renderer.$cursorLayer.config = config;
	        for (var i = first; i <= last; i++) {
	            var w = lineWidgets[i];
	            if (!w || !w.el) continue;

	            if (!w._inDocument) {
	                w._inDocument = true;
	                renderer.container.appendChild(w.el);
	            }
	            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;
	            if (!w.coverLine)
	                top += config.lineHeight * this.session.getRowLineCount(w.row);
	            w.el.style.top = top - config.offset + "px";
	            
	            var left = w.coverGutter ? 0 : renderer.gutterWidth;
	            if (!w.fixedWidth)
	                left -= renderer.scrollLeft;
	            w.el.style.left = left + "px";

	            if (w.fixedWidth) {
	                w.el.style.right = renderer.scrollBar.getWidth() + "px";
	            } else {
	                w.el.style.right = "";
	            }
	        }
	    };
	    
	}).call(LineWidgets.prototype);


	exports.LineWidgets = LineWidgets;

	});

	ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"], function(acequire, exports, module) {
	"use strict";
	var LineWidgets = acequire("../line_widgets").LineWidgets;
	var dom = acequire("../lib/dom");
	var Range = acequire("../range").Range;

	function binarySearch(array, needle, comparator) {
	    var first = 0;
	    var last = array.length - 1;

	    while (first <= last) {
	        var mid = (first + last) >> 1;
	        var c = comparator(needle, array[mid]);
	        if (c > 0)
	            first = mid + 1;
	        else if (c < 0)
	            last = mid - 1;
	        else
	            return mid;
	    }
	    return -(first + 1);
	}

	function findAnnotations(session, row, dir) {
	    var annotations = session.getAnnotations().sort(Range.comparePoints);
	    if (!annotations.length)
	        return;
	    
	    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);
	    if (i < 0)
	        i = -i - 1;
	    
	    if (i >= annotations.length)
	        i = dir > 0 ? 0 : annotations.length - 1;
	    else if (i === 0 && dir < 0)
	        i = annotations.length - 1;
	    
	    var annotation = annotations[i];
	    if (!annotation || !dir)
	        return;

	    if (annotation.row === row) {
	        do {
	            annotation = annotations[i += dir];
	        } while (annotation && annotation.row === row);
	        if (!annotation)
	            return annotations.slice();
	    }
	    
	    
	    var matched = [];
	    row = annotation.row;
	    do {
	        matched[dir < 0 ? "unshift" : "push"](annotation);
	        annotation = annotations[i += dir];
	    } while (annotation && annotation.row == row);
	    return matched.length && matched;
	}

	exports.showErrorMarker = function(editor, dir) {
	    var session = editor.session;
	    if (!session.widgetManager) {
	        session.widgetManager = new LineWidgets(session);
	        session.widgetManager.attach(editor);
	    }
	    
	    var pos = editor.getCursorPosition();
	    var row = pos.row;
	    var oldWidget = session.lineWidgets && session.lineWidgets[row];
	    if (oldWidget) {
	        oldWidget.destroy();
	    } else {
	        row -= dir;
	    }
	    var annotations = findAnnotations(session, row, dir);
	    var gutterAnno;
	    if (annotations) {
	        var annotation = annotations[0];
	        pos.column = (annotation.pos && typeof annotation.column != "number"
	            ? annotation.pos.sc
	            : annotation.column) || 0;
	        pos.row = annotation.row;
	        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
	    } else if (oldWidget) {
	        return;
	    } else {
	        gutterAnno = {
	            text: ["Looks good!"],
	            className: "ace_ok"
	        };
	    }
	    editor.session.unfold(pos.row);
	    editor.selection.moveToPosition(pos);
	    
	    var w = {
	        row: pos.row, 
	        fixedWidth: true,
	        coverGutter: true,
	        el: dom.createElement("div")
	    };
	    var el = w.el.appendChild(dom.createElement("div"));
	    var arrow = w.el.appendChild(dom.createElement("div"));
	    arrow.className = "error_widget_arrow " + gutterAnno.className;
	    
	    var left = editor.renderer.$cursorLayer
	        .getPixelPosition(pos).left;
	    arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
	    
	    w.el.className = "error_widget_wrapper";
	    el.className = "error_widget " + gutterAnno.className;
	    el.innerHTML = gutterAnno.text.join("<br>");
	    
	    el.appendChild(dom.createElement("div"));
	    
	    var kb = function(_, hashId, keyString) {
	        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
	            w.destroy();
	            return {command: "null"};
	        }
	    };
	    
	    w.destroy = function() {
	        if (editor.$mouseHandler.isMousePressed)
	            return;
	        editor.keyBinding.removeKeyboardHandler(kb);
	        session.widgetManager.removeLineWidget(w);
	        editor.off("changeSelection", w.destroy);
	        editor.off("changeSession", w.destroy);
	        editor.off("mouseup", w.destroy);
	        editor.off("change", w.destroy);
	    };
	    
	    editor.keyBinding.addKeyboardHandler(kb);
	    editor.on("changeSelection", w.destroy);
	    editor.on("changeSession", w.destroy);
	    editor.on("mouseup", w.destroy);
	    editor.on("change", w.destroy);
	    
	    editor.session.widgetManager.addLineWidget(w);
	    
	    w.el.onmousedown = editor.focus.bind(editor);
	    
	    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
	};


	dom.importCssString("\
	    .error_widget_wrapper {\
	        background: inherit;\
	        color: inherit;\
	        border:none\
	    }\
	    .error_widget {\
	        border-top: solid 2px;\
	        border-bottom: solid 2px;\
	        margin: 5px 0;\
	        padding: 10px 40px;\
	        white-space: pre-wrap;\
	    }\
	    .error_widget.ace_error, .error_widget_arrow.ace_error{\
	        border-color: #ff5a5a\
	    }\
	    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
	        border-color: #F1D817\
	    }\
	    .error_widget.ace_info, .error_widget_arrow.ace_info{\
	        border-color: #5a5a5a\
	    }\
	    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
	        border-color: #5aaa5a\
	    }\
	    .error_widget_arrow {\
	        position: absolute;\
	        border: solid 5px;\
	        border-top-color: transparent!important;\
	        border-right-color: transparent!important;\
	        border-left-color: transparent!important;\
	        top: -5px;\
	    }\
	", "");

	});

	ace.define("ace/ace",["require","exports","module","ace/lib/fixoldbrowsers","ace/lib/dom","ace/lib/event","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config"], function(acequire, exports, module) {
	"use strict";

	acequire("./lib/fixoldbrowsers");

	var dom = acequire("./lib/dom");
	var event = acequire("./lib/event");

	var Editor = acequire("./editor").Editor;
	var EditSession = acequire("./edit_session").EditSession;
	var UndoManager = acequire("./undomanager").UndoManager;
	var Renderer = acequire("./virtual_renderer").VirtualRenderer;
	acequire("./worker/worker_client");
	acequire("./keyboard/hash_handler");
	acequire("./placeholder");
	acequire("./multi_select");
	acequire("./mode/folding/fold_mode");
	acequire("./theme/textmate");
	acequire("./ext/error_marker");

	exports.config = acequire("./config");
	exports.acequire = acequire;
	exports.edit = function(el) {
	    if (typeof(el) == "string") {
	        var _id = el;
	        el = document.getElementById(_id);
	        if (!el)
	            throw new Error("ace.edit can't find div #" + _id);
	    }

	    if (el && el.env && el.env.editor instanceof Editor)
	        return el.env.editor;

	    var value = "";
	    if (el && /input|textarea/i.test(el.tagName)) {
	        var oldNode = el;
	        value = oldNode.value;
	        el = dom.createElement("pre");
	        oldNode.parentNode.replaceChild(el, oldNode);
	    } else {
	        value = dom.getInnerText(el);
	        el.innerHTML = '';
	    }

	    var doc = exports.createEditSession(value);

	    var editor = new Editor(new Renderer(el));
	    editor.setSession(doc);

	    var env = {
	        document: doc,
	        editor: editor,
	        onResize: editor.resize.bind(editor, null)
	    };
	    if (oldNode) env.textarea = oldNode;
	    event.addListener(window, "resize", env.onResize);
	    editor.on("destroy", function() {
	        event.removeListener(window, "resize", env.onResize);
	        env.editor.container.env = null; // prevent memory leak on old ie
	    });
	    editor.container.env = editor.env = env;
	    return editor;
	};
	exports.createEditSession = function(text, mode) {
	    var doc = new EditSession(text, mode);
	    doc.setUndoManager(new UndoManager());
	    return doc;
	}
	exports.EditSession = EditSession;
	exports.UndoManager = UndoManager;
	});
	            (function() {
	                ace.acequire(["ace/ace"], function(a) {
	                    a && a.config.init(true);
	                    if (!window.ace)
	                        window.ace = a;
	                    for (var key in a) if (a.hasOwnProperty(key))
	                        window.ace[key] = a[key];
	                });
	            })();
	        
	module.exports = window.ace.acequire("ace/ace");

/***/ },
/* 461 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 462 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = get_blob()

	function get_blob() {
	  if(global.Blob) {
	    try {
	      new Blob(['asdf'], {type: 'text/plain'})
	      return Blob
	    } catch(err) {}
	  }

	  var Builder = global.WebKitBlobBuilder ||
	                global.MozBlobBuilder ||
	                global.MSBlobBuilder

	  return function(parts, bag) {
	    var builder = new Builder
	      , endings = bag.endings
	      , type = bag.type

	    if(endings) for(var i = 0, len = parts.length; i < len; ++i) {
	      builder.append(parts[i], endings)
	    } else for(var i = 0, len = parts.length; i < len; ++i) {
	      builder.append(parts[i])
	    }

	    return type ? builder.getBlob(type) : builder.getBlob()
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	ace.define("ace/mode/json_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;

	var JsonHighlightRules = function() {
	    this.$rules = {
	        "start" : [
	            {
	                token : "variable", // single line
	                regex : '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
	            }, {
	                token : "string", // single line
	                regex : '"',
	                next  : "string"
	            }, {
	                token : "constant.numeric", // hex
	                regex : "0[xX][0-9a-fA-F]+\\b"
	            }, {
	                token : "constant.numeric", // float
	                regex : "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
	            }, {
	                token : "constant.language.boolean",
	                regex : "(?:true|false)\\b"
	            }, {
	                token : "invalid.illegal", // single quoted strings are not allowed
	                regex : "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
	            }, {
	                token : "invalid.illegal", // comments are not allowed
	                regex : "\\/\\/.*$"
	            }, {
	                token : "paren.lparen",
	                regex : "[[({]"
	            }, {
	                token : "paren.rparen",
	                regex : "[\\])}]"
	            }, {
	                token : "text",
	                regex : "\\s+"
	            }
	        ],
	        "string" : [
	            {
	                token : "constant.language.escape",
	                regex : /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
	            }, {
	                token : "string",
	                regex : '[^"\\\\]+'
	            }, {
	                token : "string",
	                regex : '"',
	                next  : "start"
	            }, {
	                token : "string",
	                regex : "",
	                next  : "start"
	            }
	        ]
	    };
	    
	};

	oop.inherits(JsonHighlightRules, TextHighlightRules);

	exports.JsonHighlightRules = JsonHighlightRules;
	});

	ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(acequire, exports, module) {
	"use strict";

	var Range = acequire("../range").Range;

	var MatchingBraceOutdent = function() {};

	(function() {

	    this.checkOutdent = function(line, input) {
	        if (! /^\s+$/.test(line))
	            return false;

	        return /^\s*\}/.test(input);
	    };

	    this.autoOutdent = function(doc, row) {
	        var line = doc.getLine(row);
	        var match = line.match(/^(\s*\})/);

	        if (!match) return 0;

	        var column = match[1].length;
	        var openBracePos = doc.findMatchingBracket({row: row, column: column});

	        if (!openBracePos || openBracePos.row == row) return 0;

	        var indent = this.$getIndent(doc.getLine(openBracePos.row));
	        doc.replace(new Range(row, 0, row, column-1), indent);
	    };

	    this.$getIndent = function(line) {
	        return line.match(/^\s*/)[0];
	    };

	}).call(MatchingBraceOutdent.prototype);

	exports.MatchingBraceOutdent = MatchingBraceOutdent;
	});

	ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Behaviour = acequire("../behaviour").Behaviour;
	var TokenIterator = acequire("../../token_iterator").TokenIterator;
	var lang = acequire("../../lib/lang");

	var SAFE_INSERT_IN_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator"];
	var SAFE_INSERT_BEFORE_TOKENS =
	    ["text", "paren.rparen", "punctuation.operator", "comment"];

	var context;
	var contextCache = {};
	var initContext = function(editor) {
	    var id = -1;
	    if (editor.multiSelect) {
	        id = editor.selection.index;
	        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
	            contextCache = {rangeCount: editor.multiSelect.rangeCount};
	    }
	    if (contextCache[id])
	        return context = contextCache[id];
	    context = contextCache[id] = {
	        autoInsertedBrackets: 0,
	        autoInsertedRow: -1,
	        autoInsertedLineEnd: "",
	        maybeInsertedBrackets: 0,
	        maybeInsertedRow: -1,
	        maybeInsertedLineStart: "",
	        maybeInsertedLineEnd: ""
	    };
	};

	var getWrapped = function(selection, selected, opening, closing) {
	    var rowDiff = selection.end.row - selection.start.row;
	    return {
	        text: opening + selected + closing,
	        selection: [
	                0,
	                selection.start.column + 1,
	                rowDiff,
	                selection.end.column + (rowDiff ? 0 : 1)
	            ]
	    };
	};

	var CstyleBehaviour = function() {
	    this.add("braces", "insertion", function(state, action, editor, session, text) {
	        var cursor = editor.getCursorPosition();
	        var line = session.doc.getLine(cursor.row);
	        if (text == '{') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '{', '}');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
	                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
	                    return {
	                        text: '{}',
	                        selection: [1, 1]
	                    };
	                } else {
	                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
	                    return {
	                        text: '{',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == '}') {
	            initContext(editor);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == '}') {
	                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        } else if (text == "\n" || text == "\r\n") {
	            initContext(editor);
	            var closing = "";
	            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
	                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
	                CstyleBehaviour.clearMaybeInsertedClosing();
	            }
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar === '}') {
	                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
	                if (!openBracePos)
	                     return null;
	                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
	            } else if (closing) {
	                var next_indent = this.$getIndent(line);
	            } else {
	                CstyleBehaviour.clearMaybeInsertedClosing();
	                return;
	            }
	            var indent = next_indent + session.getTabString();

	            return {
	                text: '\n' + indent + '\n' + next_indent + closing,
	                selection: [1, indent.length, 1, indent.length]
	            };
	        } else {
	            CstyleBehaviour.clearMaybeInsertedClosing();
	        }
	    });

	    this.add("braces", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '{') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.end.column, range.end.column + 1);
	            if (rightChar == '}') {
	                range.end.column++;
	                return range;
	            } else {
	                context.maybeInsertedBrackets--;
	            }
	        }
	    });

	    this.add("parens", "insertion", function(state, action, editor, session, text) {
	        if (text == '(') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '(', ')');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, ")");
	                return {
	                    text: '()',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ')') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ')') {
	                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("parens", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '(') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ')') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("brackets", "insertion", function(state, action, editor, session, text) {
	        if (text == '[') {
	            initContext(editor);
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, '[', ']');
	            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
	                CstyleBehaviour.recordAutoInsert(editor, session, "]");
	                return {
	                    text: '[]',
	                    selection: [1, 1]
	                };
	            }
	        } else if (text == ']') {
	            initContext(editor);
	            var cursor = editor.getCursorPosition();
	            var line = session.doc.getLine(cursor.row);
	            var rightChar = line.substring(cursor.column, cursor.column + 1);
	            if (rightChar == ']') {
	                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
	                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
	                    CstyleBehaviour.popAutoInsertedClosing();
	                    return {
	                        text: '',
	                        selection: [1, 1]
	                    };
	                }
	            }
	        }
	    });

	    this.add("brackets", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && selected == '[') {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == ']') {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
	        if (text == '"' || text == "'") {
	            initContext(editor);
	            var quote = text;
	            var selection = editor.getSelectionRange();
	            var selected = session.doc.getTextRange(selection);
	            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
	                return getWrapped(selection, selected, quote, quote);
	            } else if (!selected) {
	                var cursor = editor.getCursorPosition();
	                var line = session.doc.getLine(cursor.row);
	                var leftChar = line.substring(cursor.column-1, cursor.column);
	                var rightChar = line.substring(cursor.column, cursor.column + 1);

	                var token = session.getTokenAt(cursor.row, cursor.column);
	                var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
	                if (leftChar == "\\" && token && /escape/.test(token.type))
	                    return null;

	                var stringBefore = token && /string/.test(token.type);
	                var stringAfter = !rightToken || /string/.test(rightToken.type);

	                var pair;
	                if (rightChar == quote) {
	                    pair = stringBefore !== stringAfter;
	                } else {
	                    if (stringBefore && !stringAfter)
	                        return null; // wrap string with different quote
	                    if (stringBefore && stringAfter)
	                        return null; // do not pair quotes inside strings
	                    var wordRe = session.$mode.tokenRe;
	                    wordRe.lastIndex = 0;
	                    var isWordBefore = wordRe.test(leftChar);
	                    wordRe.lastIndex = 0;
	                    var isWordAfter = wordRe.test(leftChar);
	                    if (isWordBefore || isWordAfter)
	                        return null; // before or after alphanumeric
	                    if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
	                        return null; // there is rightChar and it isn't closing
	                    pair = true;
	                }
	                return {
	                    text: pair ? quote + quote : "",
	                    selection: [1,1]
	                };
	            }
	        }
	    });

	    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
	        var selected = session.doc.getTextRange(range);
	        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
	            initContext(editor);
	            var line = session.doc.getLine(range.start.row);
	            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
	            if (rightChar == selected) {
	                range.end.column++;
	                return range;
	            }
	        }
	    });

	};

	    
	CstyleBehaviour.isSaneInsertion = function(editor, session) {
	    var cursor = editor.getCursorPosition();
	    var iterator = new TokenIterator(session, cursor.row, cursor.column);
	    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
	        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
	        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
	            return false;
	    }
	    iterator.stepForward();
	    return iterator.getCurrentTokenRow() !== cursor.row ||
	        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
	};

	CstyleBehaviour.$matchTokenType = function(token, types) {
	    return types.indexOf(token.type || token) > -1;
	};

	CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
	        context.autoInsertedBrackets = 0;
	    context.autoInsertedRow = cursor.row;
	    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
	    context.autoInsertedBrackets++;
	};

	CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
	    var cursor = editor.getCursorPosition();
	    var line = session.doc.getLine(cursor.row);
	    if (!this.isMaybeInsertedClosing(cursor, line))
	        context.maybeInsertedBrackets = 0;
	    context.maybeInsertedRow = cursor.row;
	    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
	    context.maybeInsertedLineEnd = line.substr(cursor.column);
	    context.maybeInsertedBrackets++;
	};

	CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
	    return context.autoInsertedBrackets > 0 &&
	        cursor.row === context.autoInsertedRow &&
	        bracket === context.autoInsertedLineEnd[0] &&
	        line.substr(cursor.column) === context.autoInsertedLineEnd;
	};

	CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
	    return context.maybeInsertedBrackets > 0 &&
	        cursor.row === context.maybeInsertedRow &&
	        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
	        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
	};

	CstyleBehaviour.popAutoInsertedClosing = function() {
	    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
	    context.autoInsertedBrackets--;
	};

	CstyleBehaviour.clearMaybeInsertedClosing = function() {
	    if (context) {
	        context.maybeInsertedBrackets = 0;
	        context.maybeInsertedRow = -1;
	    }
	};



	oop.inherits(CstyleBehaviour, Behaviour);

	exports.CstyleBehaviour = CstyleBehaviour;
	});

	ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../../lib/oop");
	var Range = acequire("../../range").Range;
	var BaseFoldMode = acequire("./fold_mode").FoldMode;

	var FoldMode = exports.FoldMode = function(commentRegex) {
	    if (commentRegex) {
	        this.foldingStartMarker = new RegExp(
	            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
	        );
	        this.foldingStopMarker = new RegExp(
	            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
	        );
	    }
	};
	oop.inherits(FoldMode, BaseFoldMode);

	(function() {

	    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
	    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
	    this.singleLineBlockCommentRe= /^\s*(\/\*).*\*\/\s*$/;
	    this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
	    this.startRegionRe = /^\s*(\/\*|\/\/)#region\b/;
	    this._getFoldWidgetBase = this.getFoldWidget;
	    this.getFoldWidget = function(session, foldStyle, row) {
	        var line = session.getLine(row);

	        if (this.singleLineBlockCommentRe.test(line)) {
	            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
	                return "";
	        }

	        var fw = this._getFoldWidgetBase(session, foldStyle, row);

	        if (!fw && this.startRegionRe.test(line))
	            return "start"; // lineCommentRegionStart

	        return fw;
	    };

	    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
	        var line = session.getLine(row);

	        if (this.startRegionRe.test(line))
	            return this.getCommentRegionBlock(session, line, row);

	        var match = line.match(this.foldingStartMarker);
	        if (match) {
	            var i = match.index;

	            if (match[1])
	                return this.openingBracketBlock(session, match[1], row, i);
	                
	            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
	            
	            if (range && !range.isMultiLine()) {
	                if (forceMultiline) {
	                    range = this.getSectionRange(session, row);
	                } else if (foldStyle != "all")
	                    range = null;
	            }
	            
	            return range;
	        }

	        if (foldStyle === "markbegin")
	            return;

	        var match = line.match(this.foldingStopMarker);
	        if (match) {
	            var i = match.index + match[0].length;

	            if (match[1])
	                return this.closingBracketBlock(session, match[1], row, i);

	            return session.getCommentFoldRange(row, i, -1);
	        }
	    };
	    
	    this.getSectionRange = function(session, row) {
	        var line = session.getLine(row);
	        var startIndent = line.search(/\S/);
	        var startRow = row;
	        var startColumn = line.length;
	        row = row + 1;
	        var endRow = row;
	        var maxRow = session.getLength();
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var indent = line.search(/\S/);
	            if (indent === -1)
	                continue;
	            if  (startIndent > indent)
	                break;
	            var subRange = this.getFoldWidgetRange(session, "all", row);
	            
	            if (subRange) {
	                if (subRange.start.row <= startRow) {
	                    break;
	                } else if (subRange.isMultiLine()) {
	                    row = subRange.end.row;
	                } else if (startIndent == indent) {
	                    break;
	                }
	            }
	            endRow = row;
	        }
	        
	        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
	    };

	    this.getCommentRegionBlock = function(session, line, row) {
	        var startColumn = line.search(/\s*$/);
	        var maxRow = session.getLength();
	        var startRow = row;

	        var re = /^\s*(?:\/\*|\/\/)#(end)?region\b/;
	        var depth = 1;
	        while (++row < maxRow) {
	            line = session.getLine(row);
	            var m = re.exec(line);
	            if (!m) continue;
	            if (m[1]) depth--;
	            else depth++;

	            if (!depth) break;
	        }

	        var endRow = row;
	        if (endRow > startRow) {
	            return new Range(startRow, startColumn, endRow, line.length);
	        }
	    };

	}).call(FoldMode.prototype);

	});

	ace.define("ace/mode/json",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/json_highlight_rules","ace/mode/matching_brace_outdent","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle","ace/worker/worker_client"], function(acequire, exports, module) {
	"use strict";

	var oop = acequire("../lib/oop");
	var TextMode = acequire("./text").Mode;
	var HighlightRules = acequire("./json_highlight_rules").JsonHighlightRules;
	var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
	var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
	var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;
	var WorkerClient = acequire("../worker/worker_client").WorkerClient;

	var Mode = function() {
	    this.HighlightRules = HighlightRules;
	    this.$outdent = new MatchingBraceOutdent();
	    this.$behaviour = new CstyleBehaviour();
	    this.foldingRules = new CStyleFoldMode();
	};
	oop.inherits(Mode, TextMode);

	(function() {

	    this.getNextLineIndent = function(state, line, tab) {
	        var indent = this.$getIndent(line);

	        if (state == "start") {
	            var match = line.match(/^.*[\{\(\[]\s*$/);
	            if (match) {
	                indent += tab;
	            }
	        }

	        return indent;
	    };

	    this.checkOutdent = function(state, line, input) {
	        return this.$outdent.checkOutdent(line, input);
	    };

	    this.autoOutdent = function(state, doc, row) {
	        this.$outdent.autoOutdent(doc, row);
	    };

	    this.createWorker = function(session) {
	        var worker = new WorkerClient(["ace"], __webpack_require__(464), "JsonWorker");
	        worker.attachToDocument(session.getDocument());

	        worker.on("annotate", function(e) {
	            session.setAnnotations(e.data);
	        });

	        worker.on("terminate", function() {
	            session.clearAnnotations();
	        });

	        return worker;
	    };


	    this.$id = "ace/mode/json";
	}).call(Mode.prototype);

	exports.Mode = Mode;
	});


/***/ },
/* 464 */
/***/ function(module, exports) {

	module.exports.id = 'ace/mode/json_worker';
	module.exports.src = "\"no use strict\";(function(window){if(void 0===window.window||!window.document){window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console,window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;var chunks=id.split(\"/\");if(!window.acequire.tlns)return console.log(\"unable to load \"+id);chunks[0]=window.acequire.tlns[chunks[0]]||chunks[0];var path=chunks.join(\"/\")+\".js\";return window.acequire.id=id,importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},window.initBaseUrls=function initBaseUrls(topLevelNamespaces){acequire.tlns=topLevelNamespaces},window.initSender=function initSender(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.command){if(!main[msg.command])throw Error(\"Unknown command:\"+msg.command);main[msg.command].apply(main,msg.args)}else if(msg.init){initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}else msg.event&&sender&&sender._signal(msg.event,msg.data)}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(e){var delta=e.data,range=delta.range;if(!(range.start.row==range.end.row&&range.start.row!=this.row||range.start.row>this.row||range.start.row==this.row&&range.start.column>this.column)){var row=this.row,column=this.column,start=range.start,end=range.end;\"insertText\"===delta.action?start.row===row&&column>=start.column?start.column===column&&this.$insertRight||(start.row===end.row?column+=end.column-start.column:(column-=start.column,row+=end.row-start.row)):start.row!==end.row&&row>start.row&&(row+=end.row-start.row):\"insertLines\"===delta.action?start.row===row&&0===column&&this.$insertRight||row>=start.row&&(row+=end.row-start.row):\"removeText\"===delta.action?start.row===row&&column>start.column?column=end.column>=column?start.column:Math.max(0,column-(end.column-start.column)):start.row!==end.row&&row>start.row?(end.row===row&&(column=Math.max(0,column-end.column)+start.column),row-=end.row-start.row):end.row===row&&(row-=end.row-start.row,column=Math.max(0,column-end.column)+start.column):\"removeLines\"==delta.action&&row>=start.row&&(row>=end.row?row-=end.row-start.row:(row=start.row,column=0)),this.setPosition(row,column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(text){this.$lines=[],0===text.length?this.$lines=[\"\"]:Array.isArray(text)?this._insertLines(0,text):this.insert({row:0,column:0},text)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength();this.remove(new Range(0,0,len,this.getLine(len-1).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){if(range.start.row==range.end.row)return this.getLine(range.start.row).substring(range.start.column,range.end.column);var lines=this.getLines(range.start.row,range.end.row);lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;return range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column)),lines.join(this.getNewLineCharacter())},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):0>position.row&&(position.row=0),position},this.insert=function(position,text){if(!text||0===text.length)return position;position=this.$clipPosition(position),1>=this.getLength()&&this.$detectNewLine(text);var lines=this.$split(text),firstLine=lines.splice(0,1)[0],lastLine=0==lines.length?null:lines.splice(lines.length-1,1)[0];return position=this.insertInLine(position,firstLine),null!==lastLine&&(position=this.insertNewLine(position),position=this._insertLines(position.row,lines),position=this.insertInLine(position,lastLine||\"\")),position},this.insertLines=function(row,lines){return row>=this.getLength()?this.insert({row:row,column:0},\"\\n\"+lines.join(\"\\n\")):this._insertLines(Math.max(row,0),lines)},this._insertLines=function(row,lines){if(0==lines.length)return{row:row,column:0};for(;lines.length>2e4;){var end=this._insertLines(row,lines.slice(0,2e4));lines=lines.slice(2e4),row=end.row}var args=[row,0];args.push.apply(args,lines),this.$lines.splice.apply(this.$lines,args);var range=new Range(row,0,row+lines.length,0),delta={action:\"insertLines\",range:range,lines:lines};return this._signal(\"change\",{data:delta}),range.end},this.insertNewLine=function(position){position=this.$clipPosition(position);var line=this.$lines[position.row]||\"\";this.$lines[position.row]=line.substring(0,position.column),this.$lines.splice(position.row+1,0,line.substring(position.column,line.length));var end={row:position.row+1,column:0},delta={action:\"insertText\",range:Range.fromPoints(position,end),text:this.getNewLineCharacter()};return this._signal(\"change\",{data:delta}),end},this.insertInLine=function(position,text){if(0==text.length)return position;var line=this.$lines[position.row]||\"\";this.$lines[position.row]=line.substring(0,position.column)+text+line.substring(position.column);var end={row:position.row,column:position.column+text.length},delta={action:\"insertText\",range:Range.fromPoints(position,end),text:text};return this._signal(\"change\",{data:delta}),end},this.remove=function(range){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),range.start=this.$clipPosition(range.start),range.end=this.$clipPosition(range.end),range.isEmpty())return range.start;var firstRow=range.start.row,lastRow=range.end.row;if(range.isMultiLine()){var firstFullRow=0==range.start.column?firstRow:firstRow+1,lastFullRow=lastRow-1;range.end.column>0&&this.removeInLine(lastRow,0,range.end.column),lastFullRow>=firstFullRow&&this._removeLines(firstFullRow,lastFullRow),firstFullRow!=firstRow&&(this.removeInLine(firstRow,range.start.column,this.getLine(firstRow).length),this.removeNewLine(range.start.row))}else this.removeInLine(firstRow,range.start.column,range.end.column);return range.start},this.removeInLine=function(row,startColumn,endColumn){if(startColumn!=endColumn){var range=new Range(row,startColumn,row,endColumn),line=this.getLine(row),removed=line.substring(startColumn,endColumn),newLine=line.substring(0,startColumn)+line.substring(endColumn,line.length);this.$lines.splice(row,1,newLine);var delta={action:\"removeText\",range:range,text:removed};return this._signal(\"change\",{data:delta}),range.start}},this.removeLines=function(firstRow,lastRow){return 0>firstRow||lastRow>=this.getLength()?this.remove(new Range(firstRow,0,lastRow+1,0)):this._removeLines(firstRow,lastRow)},this._removeLines=function(firstRow,lastRow){var range=new Range(firstRow,0,lastRow+1,0),removed=this.$lines.splice(firstRow,lastRow-firstRow+1),delta={action:\"removeLines\",range:range,nl:this.getNewLineCharacter(),lines:removed};return this._signal(\"change\",{data:delta}),removed},this.removeNewLine=function(row){var firstLine=this.getLine(row),secondLine=this.getLine(row+1),range=new Range(row,firstLine.length,row+1,0),line=firstLine+secondLine;this.$lines.splice(row,2,line);var delta={action:\"removeText\",range:range,text:this.getNewLineCharacter()};this._signal(\"change\",{data:delta})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0==text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;if(this.remove(range),text)var end=this.insert(range.start,text);else end=range.start;return end},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\"insertLines\"==delta.action?this.insertLines(range.start.row,delta.lines):\"insertText\"==delta.action?this.insert(range.start,delta.text):\"removeLines\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\"removeText\"==delta.action&&this.remove(range)}},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\"insertLines\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\"insertText\"==delta.action?this.remove(range):\"removeLines\"==delta.action?this._insertLines(range.start.row,delta.lines):\"removeText\"==delta.action&&this.insert(range.start,delta.text)}},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function(obj){if(\"object\"!=typeof obj||!obj)return obj;var cons=obj.constructor;if(cons===RegExp)return obj;var copy=cons();for(var key in obj)copy[key]=\"object\"==typeof obj[key]?exports.deepCopy(obj[key]):obj[key];return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){return doc.applyDeltas(e.data),_self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/json/json_parse\",[\"require\",\"exports\",\"module\"],function(){\"use strict\";var at,ch,text,value,escapee={'\"':'\"',\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\t\"},error=function(m){throw{name:\"SyntaxError\",message:m,at:at,text:text}},next=function(c){return c&&c!==ch&&error(\"Expected '\"+c+\"' instead of '\"+ch+\"'\"),ch=text.charAt(at),at+=1,ch},number=function(){var number,string=\"\";for(\"-\"===ch&&(string=\"-\",next(\"-\"));ch>=\"0\"&&\"9\">=ch;)string+=ch,next();if(\".\"===ch)for(string+=\".\";next()&&ch>=\"0\"&&\"9\">=ch;)string+=ch;if(\"e\"===ch||\"E\"===ch)for(string+=ch,next(),(\"-\"===ch||\"+\"===ch)&&(string+=ch,next());ch>=\"0\"&&\"9\">=ch;)string+=ch,next();return number=+string,isNaN(number)?(error(\"Bad number\"),void 0):number},string=function(){var hex,i,uffff,string=\"\";if('\"'===ch)for(;next();){if('\"'===ch)return next(),string;if(\"\\\\\"===ch)if(next(),\"u\"===ch){for(uffff=0,i=0;4>i&&(hex=parseInt(next(),16),isFinite(hex));i+=1)uffff=16*uffff+hex;string+=String.fromCharCode(uffff)}else{if(\"string\"!=typeof escapee[ch])break;string+=escapee[ch]}else string+=ch}error(\"Bad string\")},white=function(){for(;ch&&\" \">=ch;)next()},word=function(){switch(ch){case\"t\":return next(\"t\"),next(\"r\"),next(\"u\"),next(\"e\"),!0;case\"f\":return next(\"f\"),next(\"a\"),next(\"l\"),next(\"s\"),next(\"e\"),!1;case\"n\":return next(\"n\"),next(\"u\"),next(\"l\"),next(\"l\"),null}error(\"Unexpected '\"+ch+\"'\")},array=function(){var array=[];if(\"[\"===ch){if(next(\"[\"),white(),\"]\"===ch)return next(\"]\"),array;for(;ch;){if(array.push(value()),white(),\"]\"===ch)return next(\"]\"),array;next(\",\"),white()}}error(\"Bad array\")},object=function(){var key,object={};if(\"{\"===ch){if(next(\"{\"),white(),\"}\"===ch)return next(\"}\"),object;for(;ch;){if(key=string(),white(),next(\":\"),Object.hasOwnProperty.call(object,key)&&error('Duplicate key \"'+key+'\"'),object[key]=value(),white(),\"}\"===ch)return next(\"}\"),object;next(\",\"),white()}}error(\"Bad object\")};return value=function(){switch(white(),ch){case\"{\":return object();case\"[\":return array();case'\"':return string();case\"-\":return number();default:return ch>=\"0\"&&\"9\">=ch?number():word()}},function(source,reviver){var result;return text=source,at=0,ch=\" \",result=value(),white(),ch&&error(\"Syntax error\"),\"function\"==typeof reviver?function walk(holder,key){var k,v,value=holder[key];if(value&&\"object\"==typeof value)for(k in value)Object.hasOwnProperty.call(value,k)&&(v=walk(value,k),void 0!==v?value[k]=v:delete value[k]);return reviver.call(holder,key,value)}({\"\":result},\"\"):result}}),ace.define(\"ace/mode/json_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\",\"ace/mode/json/json_parse\"],function(acequire,exports){\"use strict\";var oop=acequire(\"../lib/oop\"),Mirror=acequire(\"../worker/mirror\").Mirror,parse=acequire(\"./json/json_parse\"),JsonWorker=exports.JsonWorker=function(sender){Mirror.call(this,sender),this.setTimeout(200)};oop.inherits(JsonWorker,Mirror),function(){this.onUpdate=function(){var value=this.doc.getValue(),errors=[];try{value&&parse(value)}catch(e){var pos=this.doc.indexToPosition(e.at-1);errors.push({row:pos.row,column:pos.column,text:e.message,type:\"error\"})}this.sender.emit(\"annotate\",errors)}}.call(JsonWorker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;\nfor(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r \\u2028\\u2029\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";

/***/ },
/* 465 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Binds a ACE Editor widget
	 */
	angular.module('ui.ace', [])
	  .constant('uiAceConfig', {})
	  .directive('uiAce', ['uiAceConfig', function (uiAceConfig) {

	    if (angular.isUndefined(window.ace)) {
	      throw new Error('ui-ace need ace to work... (o rly?)');
	    }

	    /**
	     * Sets editor options such as the wrapping mode or the syntax checker.
	     *
	     * The supported options are:
	     *
	     *   <ul>
	     *     <li>showGutter</li>
	     *     <li>useWrapMode</li>
	     *     <li>onLoad</li>
	     *     <li>theme</li>
	     *     <li>mode</li>
	     *   </ul>
	     *
	     * @param acee
	     * @param session ACE editor session
	     * @param {object} opts Options to be set
	     */
	    var setOptions = function(acee, session, opts) {

	      // sets the ace worker path, if running from concatenated
	      // or minified source
	      if (angular.isDefined(opts.workerPath)) {
	        var config = window.ace.require('ace/config');
	        config.set('workerPath', opts.workerPath);
	      }
	      // ace requires loading
	      if (angular.isDefined(opts.require)) {
	        opts.require.forEach(function (n) {
	            window.ace.require(n);
	        });
	      }
	      // Boolean options
	      if (angular.isDefined(opts.showGutter)) {
	        acee.renderer.setShowGutter(opts.showGutter);
	      }
	      if (angular.isDefined(opts.useWrapMode)) {
	        session.setUseWrapMode(opts.useWrapMode);
	      }
	      if (angular.isDefined(opts.showInvisibles)) {
	        acee.renderer.setShowInvisibles(opts.showInvisibles);
	      }
	      if (angular.isDefined(opts.showIndentGuides)) {
	        acee.renderer.setDisplayIndentGuides(opts.showIndentGuides);
	      }
	      if (angular.isDefined(opts.useSoftTabs)) {
	        session.setUseSoftTabs(opts.useSoftTabs);
	      }
	      if (angular.isDefined(opts.showPrintMargin)) {
	        acee.setShowPrintMargin(opts.showPrintMargin);
	      }

	      // commands
	      if (angular.isDefined(opts.disableSearch) && opts.disableSearch) {
	        acee.commands.addCommands([
	          {
	            name: 'unfind',
	            bindKey: {
	              win: 'Ctrl-F',
	              mac: 'Command-F'
	            },
	            exec: function () {
	              return false;
	            },
	            readOnly: true
	          }
	        ]);
	      }

	      // Basic options
	      if (angular.isString(opts.theme)) {
	        acee.setTheme('ace/theme/' + opts.theme);
	      }
	      if (angular.isString(opts.mode)) {
	        session.setMode('ace/mode/' + opts.mode);
	      }
	      // Advanced options
	      if (angular.isDefined(opts.firstLineNumber)) {
	        if (angular.isNumber(opts.firstLineNumber)) {
	          session.setOption('firstLineNumber', opts.firstLineNumber);
	        } else if (angular.isFunction(opts.firstLineNumber)) {
	          session.setOption('firstLineNumber', opts.firstLineNumber());
	        }
	      }

	      // advanced options
	      var key, obj;
	      if (angular.isDefined(opts.advanced)) {
	          for (key in opts.advanced) {
	              // create a javascript object with the key and value
	              obj = { name: key, value: opts.advanced[key] };
	              // try to assign the option to the ace editor
	              acee.setOption(obj.name, obj.value);
	          }
	      }

	      // advanced options for the renderer
	      if (angular.isDefined(opts.rendererOptions)) {
	          for (key in opts.rendererOptions) {
	              // create a javascript object with the key and value
	              obj = { name: key, value: opts.rendererOptions[key] };
	              // try to assign the option to the ace editor
	              acee.renderer.setOption(obj.name, obj.value);
	          }
	      }

	      // onLoad callbacks
	      angular.forEach(opts.callbacks, function (cb) {
	        if (angular.isFunction(cb)) {
	          cb(acee);
	        }
	      });
	    };

	    return {
	      restrict: 'EA',
	      require: '?ngModel',
	      link: function (scope, elm, attrs, ngModel) {

	        /**
	         * Corresponds the uiAceConfig ACE configuration.
	         * @type object
	         */
	        var options = uiAceConfig.ace || {};

	        /**
	         * uiAceConfig merged with user options via json in attribute or data binding
	         * @type object
	         */
	        var opts = angular.extend({}, options, scope.$eval(attrs.uiAce));

	        /**
	         * ACE editor
	         * @type object
	         */
	        var acee = window.ace.edit(elm[0]);

	        /**
	         * ACE editor session.
	         * @type object
	         * @see [EditSession]{@link http://ace.c9.io/#nav=api&api=edit_session}
	         */
	        var session = acee.getSession();

	        /**
	         * Reference to a change listener created by the listener factory.
	         * @function
	         * @see listenerFactory.onChange
	         */
	        var onChangeListener;

	        /**
	         * Reference to a blur listener created by the listener factory.
	         * @function
	         * @see listenerFactory.onBlur
	         */
	        var onBlurListener;

	        /**
	         * Calls a callback by checking its existing. The argument list
	         * is variable and thus this function is relying on the arguments
	         * object.
	         * @throws {Error} If the callback isn't a function
	         */
	        var executeUserCallback = function () {

	          /**
	           * The callback function grabbed from the array-like arguments
	           * object. The first argument should always be the callback.
	           *
	           * @see [arguments]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments}
	           * @type {*}
	           */
	          var callback = arguments[0];

	          /**
	           * Arguments to be passed to the callback. These are taken
	           * from the array-like arguments object. The first argument
	           * is stripped because that should be the callback function.
	           *
	           * @see [arguments]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments}
	           * @type {Array}
	           */
	          var args = Array.prototype.slice.call(arguments, 1);

	          if (angular.isDefined(callback)) {
	            scope.$evalAsync(function () {
	              if (angular.isFunction(callback)) {
	                callback(args);
	              } else {
	                throw new Error('ui-ace use a function as callback.');
	              }
	            });
	          }
	        };

	        /**
	         * Listener factory. Until now only change listeners can be created.
	         * @type object
	         */
	        var listenerFactory = {
	          /**
	           * Creates a change listener which propagates the change event
	           * and the editor session to the callback from the user option
	           * onChange. It might be exchanged during runtime, if this
	           * happens the old listener will be unbound.
	           *
	           * @param callback callback function defined in the user options
	           * @see onChangeListener
	           */
	          onChange: function (callback) {
	            return function (e) {
	              var newValue = session.getValue();

	              if (ngModel && newValue !== ngModel.$viewValue &&
	                  // HACK make sure to only trigger the apply outside of the
	                  // digest loop 'cause ACE is actually using this callback
	                  // for any text transformation !
	                  !scope.$$phase && !scope.$root.$$phase) {
	                scope.$evalAsync(function () {
	                  ngModel.$setViewValue(newValue);
	                });
	              }

	              executeUserCallback(callback, e, acee);
	            };
	          },
	          /**
	           * Creates a blur listener which propagates the editor session
	           * to the callback from the user option onBlur. It might be
	           * exchanged during runtime, if this happens the old listener
	           * will be unbound.
	           *
	           * @param callback callback function defined in the user options
	           * @see onBlurListener
	           */
	          onBlur: function (callback) {
	            return function () {
	              executeUserCallback(callback, acee);
	            };
	          }
	        };

	        attrs.$observe('readonly', function (value) {
	          acee.setReadOnly(!!value || value === '');
	        });

	        // Value Blind
	        if (ngModel) {
	          ngModel.$formatters.push(function (value) {
	            if (angular.isUndefined(value) || value === null) {
	              return '';
	            }
	            else if (angular.isObject(value) || angular.isArray(value)) {
	              throw new Error('ui-ace cannot use an object or an array as a model');
	            }
	            return value;
	          });

	          ngModel.$render = function () {
	            session.setValue(ngModel.$viewValue);
	          };
	        }

	        // Listen for option updates
	        var updateOptions = function (current, previous) {
	          if (current === previous) return;
	          opts = angular.extend({}, options, scope.$eval(attrs.uiAce));

	          opts.callbacks = [ opts.onLoad ];
	          if (opts.onLoad !== options.onLoad) {
	            // also call the global onLoad handler
	            opts.callbacks.unshift(options.onLoad);
	          }

	          // EVENTS

	          // unbind old change listener
	          session.removeListener('change', onChangeListener);

	          // bind new change listener
	          onChangeListener = listenerFactory.onChange(opts.onChange);
	          session.on('change', onChangeListener);

	          // unbind old blur listener
	          //session.removeListener('blur', onBlurListener);
	          acee.removeListener('blur', onBlurListener);

	          // bind new blur listener
	          onBlurListener = listenerFactory.onBlur(opts.onBlur);
	          acee.on('blur', onBlurListener);

	          setOptions(acee, session, opts);
	        };

	        scope.$watch(attrs.uiAce, updateOptions, /* deep watch */ true);

	        // set the options here, even if we try to watch later, if this
	        // line is missing things go wrong (and the tests will also fail)
	        updateOptions(options);

	        elm.on('$destroy', function () {
	          acee.session.$stopWorker();
	          acee.destroy();
	        });

	        scope.$watch(function() {
	          return [elm[0].offsetWidth, elm[0].offsetHeight];
	        }, function() {
	          acee.resize();
	          acee.renderer.updateFull();
	        }, true);

	      }
	    };
	  }]);


/***/ },
/* 466 */
/***/ function(module, exports) {

	module.exports = "<div class=\"doc-viewer\">\n  <ul class=\"nav nav-tabs\">\n    <li ng-class=\"{active: mode == 'table'}\"><a ng-click=\"mode='table'\">Table</a></li>\n    <li ng-class=\"{active: mode == 'json'}\"><a ng-click=\"mode='json'\">JSON</a></li>\n  </ul>\n\n  <div class=\"doc-viewer-content\">\n    <table class=\"table table-condensed\" ng-show=\"mode == 'table'\">\n      <tbody>\n        <tr ng-repeat=\"field in fields\">\n          <td field-name=\"field\"\n              field-type=\"mapping[field].type\"\n              width=\"1%\"\n              class=\"doc-viewer-field\">\n          </td>\n          <td width=\"1%\" class=\"doc-viewer-buttons\" ng-if=\"filter\">\n            <span ng-if=\"mapping[field].filterable\">\n              <i ng-click=\"filter(mapping[field], flattened[field], '+')\"\n                tooltip=\"Filter for value\"\n                tooltip-append-to-body=\"1\"\n                class=\"fa fa-search-plus\"></i>\n              <i ng-click=\"filter(mapping[field], flattened[field],'-')\"\n                tooltip=\"Filter out value\"\n                tooltip-append-to-body=\"1\"\n                class=\"fa fa-search-minus\"></i>\n            </span>\n            <span ng-if=\"!mapping[field].filterable\" tooltip=\"Unindexed fields can not be searched\">\n              <i class=\"fa fa-search-plus text-muted\"></i>\n              <i class=\"fa fa-search-minus text-muted\"></i>\n            </span>\n            <span ng-if=\"columns\">\n              <i ng-click=\"toggleColumn(field)\"\n                tooltip=\"Toggle column in table\"\n                tooltip-append-to-body=\"1\"\n                class=\"fa fa-columns\"></i>\n            </span>\n          </td>\n\n          <td>\n            <i ng-if=\"!mapping[field] && field[0] === '_'\"\n              tooltip-placement=\"top\"\n              tooltip=\"Field names beginning with _ are not supported\"\n              class=\"fa fa-warning text-color-warning ng-scope doc-viewer-underscore\"></i>\n            <i ng-if=\"!mapping[field] && field[0] !== '_' && !showArrayInObjectsWarning(doc, field)\"\n              tooltip-placement=\"top\"\n              tooltip=\"No cached mapping for this field. Refresh your mapping from the Settings > Indices page\"\n              class=\"fa fa-warning text-color-warning ng-scope doc-viewer-no-mapping\"></i>\n            <i ng-if=\"showArrayInObjectsWarning(doc, field)\"\n              tooltip-placement=\"top\"\n              tooltip=\"Objects in arrays are not well supported.\"\n              class=\"fa fa-warning text-color-warning ng-scope doc-viewer-object-array\"></i>\n            <div class=\"doc-viewer-value\" ng-bind-html=\"typeof(formatted[field]) === 'undefined' ? hit[field] : formatted[field] | trustAsHtml\"></div>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n\n    <div\n      id=\"json-ace\"\n      ng-show=\"mode == 'json'\"\n      ng-model=\"hitJson\"\n      readonly\n      ui-ace=\"{\n        useWrapMode: true,\n        onLoad: aceLoaded,\n        advanced: {\n          highlightActiveLine: false\n        },\n        rendererOptions: {\n          showPrintMargin: false,\n          maxLines: 4294967296\n        },\n        mode: 'json'\n      }\"></div>\n  </div>\n</div>\n"

/***/ },
/* 467 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(209);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var angular = __webpack_require__(209);
	  var module = __webpack_require__(214).get('kibana');

	  // Simple filter to allow using ng-bind-html without explicitly calling $sce.trustAsHtml in a controller
	  // (See http://goo.gl/mpj9o2)
	  module.filter('trustAsHtml', function ($sce) {
	    return $sce.trustAsHtml;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var TAGS_WITH_WS = />\s+</g;

	  /**
	   * Remove all of the whitespace between html tags
	   * so that inline elements don't have extra spaces.
	   *
	   * If you have inline elements (span, a, em, etc.) and any
	   * amount of whitespace around them in your markup, then the
	   * browser will push them appart. This is ugly in certain
	   * senarios and is only fixed by removing the whitespace
	   * from the html in the first place (or ugly css hacks).
	   *
	   * @param  {string} html - the html to modify
	   * @return {string} - modified html
	   */
	  return function noWhiteSpace(html) {
	    return html.replace(TAGS_WITH_WS, '><');
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 470 */
/***/ function(module, exports) {

	module.exports = "<td ng-click=\"toggleRow()\">\n  <i\n    class=\"fa discover-table-open-icon\"\n    ng-class=\"{ 'fa-caret-down': open, 'fa-caret-right': !open }\">\n  </i>\n</td>"

/***/ },
/* 471 */
/***/ function(module, exports) {

	module.exports = "<td colspan=\"{{ columns.length + 2 }}\">\n  <a class=\"pull-right\" ng-href=\"#/doc/{{indexPattern.id}}/{{row._index}}/{{row._type}}/?id={{row._id | uriescape}}\">\n    <small>Link to /{{row._index}}/{{row._type}}/{{row._id | uriescape}}</small></i>\n  </a>\n  <doc-viewer hit=\"row\" filter=\"filter\" columns=\"columns\" index-pattern=\"indexPattern\"></doc-viewer>\n</td>"

/***/ },
/* 472 */
/***/ function(module, exports) {

	module.exports = "<%\nvar attributes = '';\nif (timefield) {\n  attributes='class=\"discover-table-timefield\" width=\"1%\"';\n} else if (sourcefield) {\n  attributes='class=\"discover-table-sourcefield\"';\n} else {\n  attributes='class=\"discover-table-datafield\"';\n}\n%>\n<td <%= attributes %>>\n  <%= formatted %>\n</td>\n"

/***/ },
/* 473 */
/***/ function(module, exports) {

	module.exports = "<div class=\"truncate-by-height\">\n  <%= body %>\n</div>"

/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(475);
	__webpack_require__(478);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(479);
	__webpack_require__(480);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana/directive').directive('visualize', function (Notifier, SavedVis, indexPatterns, Private) {

	    __webpack_require__(475);
	    __webpack_require__(478);
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);
	    var visTypes = Private(__webpack_require__(479));

	    var notify = new Notifier({
	      location: 'Visualize'
	    });

	    return {
	      restrict: 'E',
	      scope: {
	        vis: '=',
	        editableVis: '=?',
	        esResp: '=?',
	        searchSource: '=?'
	      },
	      template: __webpack_require__(480),
	      link: function link($scope, $el, attr) {
	        var chart; // set in "vis" watcher
	        var minVisChartHeight = 180;

	        function getter(selector) {
	          return function () {
	            var $sel = $el.find(selector);
	            if ($sel.size()) return $sel;
	          };
	        }

	        var getVisEl = getter('.visualize-chart');
	        var getSpyEl = getter('visualize-spy');

	        $scope.spy = { mode: false };
	        $scope.fullScreenSpy = false;

	        var applyClassNames = function applyClassNames() {
	          var $spyEl = getSpyEl();
	          var $visEl = getVisEl();
	          var fullSpy = $scope.spy.mode && ($scope.spy.mode.fill || $scope.fullScreenSpy);

	          // external
	          $el.toggleClass('only-visualization', !$scope.spy.mode);
	          $el.toggleClass('visualization-and-spy', $scope.spy.mode && !fullSpy);
	          $el.toggleClass('only-spy', Boolean(fullSpy));
	          if ($spyEl) $spyEl.toggleClass('only', Boolean(fullSpy));

	          // internal
	          $visEl.toggleClass('spy-visible', Boolean($scope.spy.mode));
	          $visEl.toggleClass('spy-only', Boolean(fullSpy));
	        };

	        // we need to wait for some watchers to fire at least once
	        // before we are "ready", this manages that
	        var prereq = (function () {
	          var fns = [];

	          return function register(fn) {
	            fns.push(fn);

	            return function () {
	              fn.apply(this, arguments);

	              if (fns.length) {
	                _.pull(fns, fn);
	                if (!fns.length) {
	                  $scope.$root.$broadcast('ready:vis');
	                }
	              }
	            };
	          };
	        })();

	        $scope.$watch('fullScreenSpy', applyClassNames);
	        $scope.$watchCollection('spy.mode', function (spyMode, oldSpyMode) {
	          var $visEl = getVisEl();
	          if (!$visEl) return;

	          // if the spy has been opened, check chart height
	          if (spyMode && !oldSpyMode) {
	            $scope.fullScreenSpy = $visEl.height() < minVisChartHeight;
	          }
	          applyClassNames();
	        });

	        $scope.$watch('vis', prereq(function (vis, oldVis) {
	          var $visEl = getVisEl();
	          if (!$visEl) return;

	          if (!attr.editableVis) {
	            $scope.editableVis = vis;
	          }

	          if (oldVis) $scope.renderbot = null;
	          if (vis) $scope.renderbot = vis.type.createRenderbot(vis, $visEl);
	        }));

	        $scope.$watchCollection('vis.params', prereq(function () {
	          if ($scope.renderbot) $scope.renderbot.updateParams();
	        }));

	        $scope.$watch('searchSource', prereq(function (searchSource) {
	          if (!searchSource || attr.esResp) return;

	          // TODO: we need to have some way to clean up result requests
	          searchSource.onResults().then(function onResults(resp) {
	            if ($scope.searchSource !== searchSource) return;

	            $scope.esResp = resp;

	            return searchSource.onResults().then(onResults);
	          })['catch'](notify.fatal);

	          searchSource.onError(notify.error)['catch'](notify.fatal);
	        }));

	        $scope.$watch('esResp', prereq(function (resp, prevResp) {
	          if (!resp) return;
	          $scope.renderbot.render(resp);
	        }));

	        $scope.$watch('renderbot', function (newRenderbot, oldRenderbot) {
	          if (oldRenderbot && newRenderbot !== oldRenderbot) {
	            oldRenderbot.destroy();
	          }
	        });

	        $scope.$on('$destroy', function () {
	          if ($scope.renderbot) {
	            $scope.renderbot.destroy();
	          }
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(476);
	__webpack_require__(477);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('app/visualize').directive('visualizeSpy', function (Private, $compile) {
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);

	    var modes = Private(__webpack_require__(476));
	    var defaultMode = modes.inOrder[0];

	    return {
	      restrict: 'E',
	      template: __webpack_require__(477),
	      link: function link($scope, $el) {
	        var $container = $el.find('.visualize-spy-container');
	        var fullPageSpy = false;
	        $scope.modes = modes;

	        $scope.toggleDisplay = function () {
	          $scope.setSpyMode($scope.spy.mode ? null : defaultMode);
	        };

	        $scope.toggleFullPage = function () {
	          fullPageSpy = $scope.spy.mode.fill = !fullPageSpy;
	        };

	        $scope.setSpyMode = function (newMode) {
	          // allow passing in a mode name
	          if (_.isString(newMode)) newMode = modes.byName[newMode];

	          var current = $scope.spy.mode;
	          var change = false;

	          // no change
	          if (current && newMode && newMode.name === current.name) return;

	          // clear the current value
	          if (current) {
	            current.$container.remove();
	            current.$scope.$destroy();
	            delete $scope.spy.mode;
	          }

	          // no further changes
	          if (!newMode) return;

	          current = $scope.spy.mode = {
	            // copy a couple values over
	            name: newMode.name,
	            display: newMode.display,
	            fill: fullPageSpy,
	            $scope: $scope.$new(),
	            $container: $('<div class="visualize-spy-content">').appendTo($container)
	          };

	          current.$container.append($compile(newMode.template)(current.$scope));
	          newMode.link && newMode.link(current.$scope, current.$container);
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(444);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return __webpack_require__(444)({
	    name: 'visTypes',
	    index: ['name'],
	    order: ['order']
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 477 */
/***/ function(module, exports) {

	module.exports = "<div ng-click=\"toggleDisplay()\" class=\"visualize-show-spy\">\n  <div class=\"visualize-show-spy-tab\">\n    <i class=\"fa\" ng-class=\"spy.mode ? 'fa-chevron-down' : 'fa-chevron-up'\"></i>\n  </div>\n</div>\n<div ng-show=\"spy.mode\" class=\"visualize-spy-container\">\n  <header class=\"control-group\">\n    <div class=\"fill visualize-spy-nav\">\n      <a\n        class=\"btn btn-default\"\n        ng-repeat=\"mode in modes.inOrder\"\n        ng-class=\"{ active: spy.mode.name === mode.name }\"\n        ng-click=\"setSpyMode(mode)\">\n        {{mode.display}}\n      </a>\n    </div>\n    <div class=\"button-group visualize-spy-fill\">\n      <a ng-if=\"!fullScreenSpy\" ng-click=\"toggleFullPage()\">\n        <i ng-if=\"!spy.mode.fill\" class=\"fa fa-expand\"></i>\n        <i ng-if=\"spy.mode.fill\" class=\"fa fa-compress\"></i>\n      </a>\n    </div>\n  </header>\n</div>"

/***/ },
/* 478 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(444);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return __webpack_require__(444)({
	    name: 'visTypes',
	    index: ['name'],
	    order: ['title']
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 480 */
/***/ function(module, exports) {

	module.exports = "<div ng-if=\"vis.type.requiresSearch && esResp.hits.total === 0\"\n  class=\"text-center visualize-error visualize-chart\">\n  <div class=\"item top\"></div>\n  <div class=\"item\">\n    <h2 aria-hidden=\"true\"><i aria-hidden=\"true\" class=\"fa fa-meh-o\"></i></h2>\n    <h4>No results found</h4>\n  </div>\n  <div class=\"item bottom\"></div>\n</div>\n<div ng-hide=\"vis.type.requiresSearch && esResp.hits.total === 0\"\n  ng-class=\"{ loading: vis.type.requiresSearch && searchSource.activeFetchCount > 0 }\"\n  class=\"visualize-chart\"></div>\n<!-- <pre>{{chartData | json}}</pre> -->\n<visualize-spy ng-if=\"vis.type.requiresSearch\"></visualize-spy>"

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(482);
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(228);
	__webpack_require__(226);
	__webpack_require__(483);
	__webpack_require__(484);
	__webpack_require__(485);
	__webpack_require__(486);
	__webpack_require__(487);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var html = __webpack_require__(482);
	  var module = __webpack_require__(214).get('ui/timepicker');
	  var _ = __webpack_require__(192);
	  var dateMath = __webpack_require__(228);
	  var moment = __webpack_require__(226);

	  __webpack_require__(483);
	  __webpack_require__(484);
	  __webpack_require__(485);
	  __webpack_require__(486);
	  __webpack_require__(487);

	  module.directive('kbnTimepicker', function (quickRanges, timeUnits, refreshIntervals) {
	    return {
	      restrict: 'E',
	      scope: {
	        from: '=',
	        to: '=',
	        mode: '=',
	        interval: '=',
	        activeTab: '='
	      },
	      template: html,
	      controller: function controller($scope) {
	        var init = function init() {
	          $scope.setMode($scope.mode);
	        };

	        $scope.format = 'MMMM Do YYYY, HH:mm:ss.SSS';
	        $scope.modes = ['quick', 'relative', 'absolute'];
	        $scope.activeTab = $scope.activeTab || 'filter';

	        if (_.isUndefined($scope.mode)) $scope.mode = 'quick';

	        $scope.quickLists = _(quickRanges).groupBy('section').values().value();
	        $scope.refreshLists = _(refreshIntervals).groupBy('section').values().value();

	        $scope.relative = {
	          count: 1,
	          unit: 'm',
	          preview: undefined,
	          round: false
	        };

	        $scope.absolute = {
	          from: moment(),
	          to: moment()
	        };

	        $scope.units = timeUnits;

	        $scope.relativeOptions = [{ text: 'Seconds ago', value: 's' }, { text: 'Minutes ago', value: 'm' }, { text: 'Hours ago', value: 'h' }, { text: 'Days ago', value: 'd' }, { text: 'Weeks ago', value: 'w' }, { text: 'Months ago', value: 'M' }, { text: 'Years ago', value: 'y' }];

	        $scope.$watch('absolute.from', function (date) {
	          if (_.isDate(date)) $scope.absolute.from = moment(date);
	        });

	        $scope.$watch('absolute.to', function (date) {
	          if (_.isDate(date)) $scope.absolute.to = moment(date);
	        });

	        $scope.setMode = function (thisMode) {
	          switch (thisMode) {
	            case 'quick':
	              break;
	            case 'relative':
	              var fromParts = $scope.from.toString().split('-');
	              var relativeParts = [];

	              // Try to parse the relative time, if we can't use moment duration to guestimate
	              if ($scope.to.toString() === 'now' && fromParts[0] === 'now' && fromParts[1]) {
	                relativeParts = fromParts[1].match(/([0-9]+)([smhdwMy]).*/);
	              }
	              if (relativeParts[1] && relativeParts[2]) {
	                $scope.relative.count = parseInt(relativeParts[1], 10);
	                $scope.relative.unit = relativeParts[2];
	              } else {
	                var duration = moment.duration(moment().diff(dateMath.parse($scope.from)));
	                var units = _.pluck(_.clone($scope.relativeOptions).reverse(), 'value');
	                if ($scope.from.toString().split('/')[1]) $scope.relative.round = true;
	                for (var i = 0; i < units.length; i++) {
	                  var as = duration.as(units[i]);
	                  if (as > 1) {
	                    $scope.relative.count = Math.round(as);
	                    $scope.relative.unit = units[i];
	                    break;
	                  }
	                }
	              }

	              if ($scope.from.toString().split('/')[1]) $scope.relative.round = true;
	              $scope.formatRelative();

	              break;
	            case 'absolute':
	              $scope.absolute.from = dateMath.parse($scope.from || moment().subtract('minutes', 15));
	              $scope.absolute.to = dateMath.parse($scope.to || moment(), true);
	              break;
	          }

	          $scope.mode = thisMode;
	        };

	        $scope.setQuick = function (from, to, description) {
	          $scope.from = from;
	          $scope.to = to;
	        };

	        $scope.setToNow = function () {
	          $scope.absolute.to = moment();
	        };

	        $scope.formatRelative = function () {
	          var parsed = dateMath.parse(getRelativeString());
	          $scope.relative.preview = parsed ? parsed.format($scope.format) : undefined;
	          return parsed;
	        };

	        $scope.applyRelative = function () {
	          $scope.from = getRelativeString();
	          $scope.to = 'now';
	        };

	        function getRelativeString() {
	          return 'now-' + $scope.relative.count + $scope.relative.unit + ($scope.relative.round ? '/' + $scope.relative.unit : '');
	        }

	        $scope.applyAbsolute = function () {
	          $scope.from = moment($scope.absolute.from);
	          $scope.to = moment($scope.absolute.to);
	        };

	        $scope.setRefreshInterval = function (interval) {
	          interval = _.clone(interval);
	          console.log('before: ' + interval.pause);
	          interval.pause = interval.pause == null || interval.pause === false ? false : true;

	          console.log('after: ' + interval.pause);
	          $scope.interval = interval;
	        };

	        init();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 482 */
/***/ function(module, exports) {

	module.exports = "<div class=\"kbn-timepicker\">\n  <style>\n    .kbn-timepicker [kbn-time-input] {\n      text-align: center;\n    }\n    .kbn-timepicker-modes {\n      text-transform: capitalize;\n    }\n    .kbn-timepicker-section {\n      float: left;\n      padding: 0px 15px;\n    }\n    .kbn-refresh-section {\n      float: left;\n      padding: 0px 15px;\n    }\n    .kbn-timepicket-alert {\n      width: 100px;\n    }\n  </style>\n\n  <div class=\"tab-content\">\n\n    <!-- Filters -->\n    <div ng-show=\"activeTab === 'filter'\" role=\"tabpanel\" class=\"tab-pane active\">\n      <br>\n      <div class=\"row\">\n        <div class=\"col-md-2\">\n          <ul class=\"nav nav-pills nav-stacked kbn-timepicker-modes\">\n            <li ng-class=\"{active: mode === 'quick' }\">\n              <a ng-click=\"setMode('quick')\">quick</a>\n            </li>\n            <li ng-class=\"{active: mode === 'relative' }\">\n              <a ng-click=\"setMode('relative')\">relative</a>\n            </li>\n            <li ng-class=\"{active: mode === 'absolute' }\">\n              <a ng-click=\"setMode('absolute')\">absolute</a>\n            </li>\n          </ul>\n        </div>\n\n        <div class=\"col-md-10\">\n          <div ng-switch on=\"mode\" class=\"container-fluid\">\n            <div ng-switch-when=\"quick\" bindonce>\n\n              <div ng-repeat=\"list in quickLists\" class=\"kbn-timepicker-section\">\n                <ul class=\"list-unstyled\">\n                  <li ng-repeat=\"option in list\">\n                    <a ng-click=\"setQuick(option.from, option.to)\" bo-text=\"option.display\"></a>\n                  </li>\n                </ul>\n              </div>\n\n              <!-- TODO: Add a section for custom intervals -->\n            </div>\n\n            <div ng-switch-when=\"relative\">\n              <form role=\"form\" ng-submit=\"applyRelative()\" class=\"form-inline\" name=\"relativeTime\">\n                <div class=\"kbn-timepicker-section\">\n                  <label>\n                    From:\n                    <span ng-show=\"relative.preview\">{{relative.preview}}</span>\n                    <span ng-hide=\"relative.preview\"><i>Invalid Expression</i></span>\n                  </label>\n                  <br>\n                  <div class=\"form-group\">\n                    <input\n                      required\n                      ng-model=\"relative.count\"\n                      ng-change=\"formatRelative()\"\n                      greater-than=\"-1\"\n                      type=\"number\"\n                      class=\"form-control\">\n                  </div>\n                  <div class=\"form-group\">\n                    <select\n                      ng-model=\"relative.unit\"\n                      ng-options=\"opt.value as opt.text for opt in relativeOptions\"\n                      ng-change=\"formatRelative()\"\n                      class=\"form-control col-xs-2\">\n                    </select>\n                  </div>\n                  <br>\n                  <div class=\"small\">\n                    <label>\n                      <input\n                        ng-model=\"relative.round\"\n                        ng-checked=\"relative.round\"\n                        ng-change=\"formatRelative()\"\n                        type=\"checkbox\">\n                      round to the {{units[relative.unit]}}\n                    </label>\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section\">\n                  <label>\n                    To: Now\n                  </label>\n                  <br>\n                  <div class=\"form-group\">\n                    <input type=\"text\" disabled class=\"form-control\" value=\"Now\">\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section\">\n                  <label>&nbsp;</label>\n                  <br>\n                  <div class=\"form-group\">\n                    <button type=\"submit\" class=\"btn btn-primary kbn-timepicker-go\" ng-disabled=\"!relative.preview\">\n                      Go\n                    </button>\n                  </div>\n                </div>\n              </form>\n            </div>\n\n            <div ng-switch-when=\"absolute\">\n              <form name=\"absoluteTime\" ng-submit=\"applyAbsolute()\">\n                <div class=\"kbn-timepicker-section\">\n                  <div>\n                    <label class=\"small\">From: <span ng-show=\"!absolute.from\"><i>Invalid Date</i></span>\n                    </label>\n                    <input type=\"text\" required class=\"form-control\" input-datetime=\"{{format}}\" ng-model=\"absolute.from\">\n                  </div>\n                  <div>\n                    <datepicker ng-model=\"absolute.from\" max=\"absolute.to\" show-weeks=\"false\"></datepicker>\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section\">\n                  <div>\n                    <label class=\"small\">To:\n                      <a class=\"label label-default\" ng-click=\"setToNow()\">Set To Now</a>\n                    </label>\n                    <span ng-show=\"!absolute.to\"><i>Invalid Date</i></span>\n                    <input type=\"text\" required class=\"form-control\" input-datetime=\"{{format}}\" ng-model=\"absolute.to\">\n                  </div>\n                  <div>\n                    <datepicker ng-model=\"absolute.to\" min=\"absolute.from\" show-weeks=\"false\"></datepicker>\n                  </div>\n                </div>\n\n                <div class=\"kbn-timepicker-section kbn-timepicker-alert\">\n                  <label>&nbsp;</label>\n                  <div class=\"form-group\">\n                    <button class=\"btn btn-primary kbn-timepicker-go\" ng-disabled=\"absolute.from > absolute.to || !absolute.from || !absolute.to\" type=\"submit\">\n                      Go\n                    </button>\n                    <span class=\"small\" ng-show=\"absolute.from > absolute.to\"><strong>From</strong> must occur before <strong>To</strong></span>\n                  </div>\n                </div>\n              </form>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Refresh Intervals -->\n    <div ng-show=\"activeTab === 'interval'\" role=\"tabpanel\" class=\"tab-pane active\">\n      <br>\n      <div ng-repeat=\"list in refreshLists\" class=\"kbn-refresh-section\">\n        <ul class=\"list-unstyled\">\n          <li ng-repeat=\"inter in list\">\n            <a class=\"refresh-interval\" ng-class=\"{ 'refresh-interval-active': interval.value === inter.value }\" ng-click=\"setRefreshInterval(inter)\">\n              {{inter.display}}\n            </a>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(226);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var $ = __webpack_require__(206);
	  var _ = __webpack_require__(192);
	  var moment = __webpack_require__(226);

	  module.directive('inputDatetime', function () {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      link: function link($scope, $elem, attrs, ngModel) {

	        var format = 'YYYY-MM-DD HH:mm:ss.SSS';

	        $elem.after('<div class="input-datetime-format">' + format + '</div>');

	        // What should I make with the input from the user?
	        var fromUser = function fromUser(text) {
	          var parsed = moment(text, format);
	          return parsed.isValid() ? parsed : undefined;
	        };

	        // How should I present the data back to the user in the input field?
	        var toUser = function toUser(datetime) {
	          return moment(datetime).format(format);
	        };

	        ngModel.$parsers.push(fromUser);
	        ngModel.$formatters.push(toUser);
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

	  function makeDirectiveDef(id, compare) {
	    return function ($parse) {
	      return {
	        require: 'ngModel',
	        link: function link($scope, $el, $attr, ngModel) {
	          var getBound = function getBound() {
	            return $parse($attr[id])();
	          };
	          var defaultVal = ({
	            'greaterThan': -Infinity,
	            'lessThan': Infinity
	          })[id];

	          ngModel.$parsers.push(validate);
	          ngModel.$formatters.push(validate);

	          $scope.$watch(getBound, function () {
	            validate(ngModel.$viewValue);
	          });

	          function validate(val) {
	            var bound = !isNaN(getBound()) ? +getBound() : defaultVal;
	            var valid = !isNaN(bound) && !isNaN(val) && compare(val, bound);
	            ngModel.$setValidity(id, valid);
	            return val;
	          }
	        }
	      };
	    };
	  }

	  __webpack_require__(214).get('kibana').directive('greaterThan', makeDirectiveDef('greaterThan', function (a, b) {
	    return a > b;
	  })).directive('lessThan', makeDirectiveDef('lessThan', function (a, b) {
	    return a < b;
	  }));
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');

	  module.constant('quickRanges', [{ from: 'now/d', to: 'now/d', display: 'Today', section: 0 }, { from: 'now/w', to: 'now/w', display: 'This week', section: 0 }, { from: 'now/M', to: 'now/M', display: 'This month', section: 0 }, { from: 'now/y', to: 'now/y', display: 'This year', section: 0 }, { from: 'now/d', to: 'now', display: 'The day so far', section: 0 }, { from: 'now/w', to: 'now', display: 'Week to date', section: 0 }, { from: 'now/M', to: 'now', display: 'Month to date', section: 0 }, { from: 'now/y', to: 'now', display: 'Year to date', section: 0 }, { from: 'now-1d/d', to: 'now-1d/d', display: 'Yesterday', section: 1 }, { from: 'now-2d/d', to: 'now-2d/d', display: 'Day before yesterday', section: 1 }, { from: 'now-7d/d', to: 'now-7d/d', display: 'This day last week', section: 1 }, { from: 'now-1w/w', to: 'now-1w/w', display: 'Previous week', section: 1 }, { from: 'now-1M/M', to: 'now-1M/M', display: 'Previous month', section: 1 }, { from: 'now-1y/y', to: 'now-1y/y', display: 'Previous year', section: 1 }, { from: 'now-15m', to: 'now', display: 'Last 15 minutes', section: 2 }, { from: 'now-30m', to: 'now', display: 'Last 30 minutes', section: 2 }, { from: 'now-1h', to: 'now', display: 'Last 1 hour', section: 2 }, { from: 'now-4h', to: 'now', display: 'Last 4 hours', section: 2 }, { from: 'now-12h', to: 'now', display: 'Last 12 hours', section: 2 }, { from: 'now-24h', to: 'now', display: 'Last 24 hours', section: 2 }, { from: 'now-7d', to: 'now', display: 'Last 7 days', section: 2 }, { from: 'now-30d', to: 'now', display: 'Last 30 days', section: 3 }, { from: 'now-60d', to: 'now', display: 'Last 60 days', section: 3 }, { from: 'now-90d', to: 'now', display: 'Last 90 days', section: 3 }, { from: 'now-6M', to: 'now', display: 'Last 6 months', section: 3 }, { from: 'now-1y', to: 'now', display: 'Last 1 year', section: 3 }, { from: 'now-2y', to: 'now', display: 'Last 2 years', section: 3 }, { from: 'now-5y', to: 'now', display: 'Last 5 years', section: 3 }]);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');

	  module.constant('refreshIntervals', [{ value: 0, display: 'Off', section: 0 }, { value: 5000, display: '5 seconds', section: 1 }, { value: 10000, display: '10 seconds', section: 1 }, { value: 30000, display: '30 seconds', section: 1 }, { value: 45000, display: '45 seconds', section: 1 }, { value: 60000, display: '1 minute', section: 2 }, { value: 300000, display: '5 minutes', section: 2 }, { value: 900000, display: '15 minutes', section: 2 }, { value: 1800000, display: '30 minutes', section: 2 }, { value: 3600000, display: '1 hour', section: 3 }, { value: 7200000, display: '2 hour', section: 3 }, { value: 43200000, display: '12 hour', section: 3 }, { value: 86400000, display: '1 day', section: 3 }]);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');

	  module.constant('timeUnits', {
	    s: 'second',
	    m: 'minute',
	    h: 'hour',
	    d: 'day',
	    w: 'week',
	    M: 'month',
	    y: 'year'
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var $ = __webpack_require__(206);
	  var _ = __webpack_require__(192);

	  var SCROLLER_HEIGHT = 20;

	  __webpack_require__(214).get('kibana').directive('fixedScroll', function ($timeout) {
	    return {
	      restrict: 'A',
	      link: function link($scope, $el) {
	        var $window = $(window);
	        var $scroller = $('<div class="fixed-scroll-scroller">').height(SCROLLER_HEIGHT);

	        /**
	         * Remove the listeners bound in listen()
	         * @type {function}
	         */
	        var unlisten = _.noop;

	        /**
	         * Listen for scroll events on the $scroller and the $el, sets unlisten()
	         *
	         * unlisten must be called before calling or listen() will throw an Error
	         *
	         * Since the browser emits "scroll" events after setting scrollLeft
	         * the listeners also prevent tug-of-war
	         *
	         * @throws {Error} If unlisten was not called first
	         * @return {undefined}
	         */
	        function listen() {
	          if (unlisten !== _.noop) {
	            throw new Error('fixedScroll listeners were not cleaned up properly before re-listening!');
	          }

	          var blockTo;
	          function bind($from, $to) {
	            function handler() {
	              if (blockTo === $to) return blockTo = null;
	              $to.scrollLeft((blockTo = $from).scrollLeft());
	            }

	            $from.on('scroll', handler);
	            return function () {
	              $from.off('scroll', handler);
	            };
	          }

	          unlisten = _.flow(bind($el, $scroller), bind($scroller, $el), function () {
	            unlisten = _.noop;
	          });
	        }

	        /**
	         * Revert DOM changes and event listeners
	         * @return {undefined}
	         */
	        function cleanUp() {
	          unlisten();
	          $scroller.detach();
	          $el.css('padding-bottom', 0);
	        }

	        /**
	         * Modify the DOM and attach event listeners based on need.
	         * Is called many times to re-setup, must be idempotent
	         * @return {undefined}
	         */
	        function setup() {
	          cleanUp();

	          var containerWidth = $el.width();
	          var contentWidth = $el.prop('scrollWidth');
	          var containerHorizOverflow = contentWidth - containerWidth;

	          var elTop = $el.offset().top - $window.scrollTop();
	          var elBottom = elTop + $el.height();
	          var windowVertOverflow = elBottom - $window.height();

	          var requireScroller = containerHorizOverflow > 0 && windowVertOverflow > 0;
	          if (!requireScroller) return;

	          // push the content away from the scroller
	          $el.css('padding-bottom', SCROLLER_HEIGHT);

	          // fill the scroller with a dummy element that mimics the content
	          $scroller.width(containerWidth).html($('<div>').css({ width: contentWidth, height: SCROLLER_HEIGHT })).insertAfter($el);

	          // listen for scroll events
	          listen();
	        }

	        // reset when the width or scrollWidth of the $el changes
	        $scope.$watchMulti([function () {
	          return $el.prop('scrollWidth');
	        }, function () {
	          return $el.width();
	        }], setup);

	        // cleanup when the scope is destroyed
	        $scope.$on('$destroy', function () {
	          cleanUp();
	          $scroller = $window = null;
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);

	  var module = __webpack_require__(214).get('kibana');

	  module.directive('validateJson', function ($compile) {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      scope: {
	        'ngModel': '=',
	        'queryInput': '=?'
	      },
	      link: function link($scope, $elem, attr, ngModel) {
	        $scope.$watch('ngModel', validator);

	        function validator(newValue, oldValue) {
	          if (!newValue || newValue.length === 0) {
	            setValid();
	            return;
	          }

	          // We actually need a proper object in all JSON inputs
	          newValue = (newValue || '').trim();
	          if (newValue[0] === '{' || '[') {
	            try {
	              JSON.parse(newValue);
	              setValid();
	            } catch (e) {
	              setInvalid();
	            }
	          } else {
	            setInvalid();
	          }
	        }

	        function setValid() {
	          ngModel.$setValidity('jsonInput', true);
	        }

	        function setInvalid() {
	          ngModel.$setValidity('jsonInput', false);
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(491);
	__webpack_require__(214);
	__webpack_require__(492);
	__webpack_require__(494);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);

	  __webpack_require__(491);

	  __webpack_require__(214).get('kibana').directive('validateQuery', function (es, $compile, timefilter, kbnIndex, debounce, Private) {
	    var fromUser = Private(__webpack_require__(492));
	    var toUser = __webpack_require__(494);

	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      scope: {
	        'ngModel': '=',
	        'queryInput': '=?'
	      },
	      link: function link($scope, elem, attr, ngModel) {

	        // track request so we can abort it if needed
	        var request = {};

	        var errorElem = $('<i tooltip={{tooltipMsg}} class="fa fa-ban input-error"></i>').hide();
	        $compile(errorElem)($scope);

	        var init = function init() {
	          elem.after(errorElem);
	          $scope.ngModel = fromUser($scope.ngModel);
	          validator($scope.ngModel);
	        };

	        function validator(query) {
	          var index;
	          var type;
	          if (request.abort) request.abort();

	          if ($scope.queryInput) {
	            useSearchSource();
	          } else {
	            useDefaults();
	          }

	          return sendRequest();

	          function useSearchSource() {
	            var pattern = $scope.queryInput.get('index');
	            if (!pattern) return useDefaults();

	            if (_.isString(pattern)) {
	              index = pattern;
	            } else if (_.isFunction(pattern.toIndexList)) {
	              index = pattern.toIndexList();
	            } else {
	              useDefaults();
	            }
	          }

	          function useDefaults() {
	            index = kbnIndex;
	            type = '__kibanaQueryValidator';
	          }

	          function sendRequest() {
	            request = es.indices.validateQuery({
	              index: index,
	              type: type,
	              explain: true,
	              ignoreUnavailable: true,
	              body: {
	                query: query || { match_all: {} }
	              }
	            }).then(success, error);
	          }

	          function error(resp) {
	            var msg;

	            ngModel.$setValidity('queryInput', false);

	            if (resp.explanations && resp.explanations[0]) {
	              msg = resp.explanations[0].error;
	            } else {
	              msg = resp.body.error;
	            }

	            $scope.tooltipMsg = msg;
	            errorElem.show();

	            return undefined;
	          }

	          function success(resp) {
	            if (resp.valid) {
	              ngModel.$setValidity('queryInput', true);
	              errorElem.hide();
	              return query;
	            } else {
	              return error(resp);
	            }
	          }
	        }

	        var debouncedValidator = debounce(validator, 300, {
	          leading: true,
	          trailing: true
	        });

	        ngModel.$parsers.push(fromUser);
	        ngModel.$formatters.push(toUser);

	        // Use a model watch instead of parser/formatter. Parsers require the
	        // user to actually enter input, which may not happen if the back button is clicked
	        $scope.$watch('ngModel', function (newValue, oldValue) {
	          if (newValue === oldValue) return;
	          debouncedValidator(newValue);
	        });

	        init();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	// Debounce service, angularized version of lodash debounce
	// borrowed heavily from https://github.com/shahata/angular-debounce

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var module = __webpack_require__(214).get('kibana');

	  module.service('debounce', ['$timeout', function ($timeout) {
	    return function (func, wait, options) {
	      var timeout;
	      var args;
	      var self;
	      var result;
	      options = _.defaults(options || {}, {
	        leading: false,
	        trailing: true
	      });

	      function debounce() {
	        self = this;
	        args = arguments;

	        var later = function later() {
	          timeout = null;
	          if (!options.leading || options.trailing) {
	            result = func.apply(self, args);
	          }
	        };

	        var callNow = options.leading && !timeout;

	        if (timeout) {
	          $timeout.cancel(timeout);
	        }
	        timeout = $timeout(later, wait);

	        if (callNow) {
	          result = func.apply(self, args);
	        }

	        return result;
	      }

	      debounce.cancel = function () {
	        $timeout.cancel(timeout);
	        timeout = null;
	      };

	      return debounce;
	    };
	  }]);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);
	__webpack_require__(493);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function GetQueryFromUser(es, Private) {
	    var decorateQuery = Private(__webpack_require__(493));

	    /**
	     * Take text from the user and make it into a query object
	     * @param {text} user's query input
	     * @returns {object}
	     */
	    return function (text) {
	      function getQueryStringQuery(text) {
	        return decorateQuery({ query_string: { query: text } });
	      }

	      var matchAll = getQueryStringQuery('*');

	      // If we get an empty object, treat it as a *
	      if (_.isObject(text)) {
	        if (_Object$keys(text).length) {
	          return text;
	        } else {
	          return matchAll;
	        }
	      }

	      // Nope, not an object.
	      text = (text || '').trim();
	      if (text.length === 0) return matchAll;

	      if (text[0] === '{') {
	        try {
	          return JSON.parse(text);
	        } catch (e) {
	          return getQueryStringQuery(text);
	        }
	      } else {
	        return getQueryStringQuery(text);
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function DecorateQuery(config) {
	    /**
	     * Decorate queries with default parameters
	     * @param {query} query object
	     * @returns {object}
	     */
	    return function (query) {
	      var queryOptions = config.get('query:queryString:options');

	      if (_.has(query, 'query_string.query')) {
	        _.extend(query.query_string, queryOptions);
	      }

	      return query;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);

	  /**
	   * Take text from the model and present it to the user as a string
	   * @param {text} model value
	   * @returns {string}
	   */
	  return function toUser(_x) {
	    var _again = true;

	    _function: while (_again) {
	      var text = _x;
	      _again = false;

	      if (text == null) return '';
	      if (_.isObject(text)) {
	        if (text.query_string) {
	          _x = text.query_string.query;
	          _again = true;
	          continue _function;
	        }
	        return angular.toJson(text);
	      }
	      return '' + text;
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var moment = __webpack_require__(226);
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').filter('moment', function (config) {
	    return function (datetime) {
	      var format = config.get('dateFormat');
	      if (moment.isMoment(datetime)) return datetime.format(format);
	      if (_.isDate(datetime)) return moment(datetime).format(format);
	      return datetime;
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(220);
	__webpack_require__(192);
	__webpack_require__(497);
	__webpack_require__(259);
	__webpack_require__(499);
	__webpack_require__(500);
	__webpack_require__(214);
	__webpack_require__(511);
	__webpack_require__(534);
	__webpack_require__(536);
	__webpack_require__(513);
	__webpack_require__(522);
	__webpack_require__(514);
	__webpack_require__(541);
	__webpack_require__(543);
	__webpack_require__(540);
	__webpack_require__(544);
	__webpack_require__(546);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var errors = __webpack_require__(220);
	  var _ = __webpack_require__(192);

	  __webpack_require__(497);
	  __webpack_require__(259);
	  __webpack_require__(499);
	  __webpack_require__(500);

	  __webpack_require__(214).get('kibana/courier').service('courier', function ($rootScope, Private, Promise, indexPatterns, Notifier) {
	    function Courier() {
	      var self = this;

	      var DocSource = Private(__webpack_require__(511));
	      var SearchSource = Private(__webpack_require__(534));
	      var searchStrategy = Private(__webpack_require__(536));

	      var requestQueue = Private(__webpack_require__(513));
	      var errorHandlers = Private(__webpack_require__(522));

	      var fetch = Private(__webpack_require__(514));
	      var docLooper = self.docLooper = Private(__webpack_require__(541));
	      var searchLooper = self.searchLooper = Private(__webpack_require__(543));

	      // expose some internal modules
	      self.setRootSearchSource = Private(__webpack_require__(540)).set;

	      self.SavedObject = Private(__webpack_require__(544));
	      self.indexPatterns = indexPatterns;
	      self.redirectWhenMissing = Private(__webpack_require__(546));

	      self.DocSource = DocSource;
	      self.SearchSource = SearchSource;

	      var HastyRefresh = errors.HastyRefresh;

	      /**
	       * update the time between automatic search requests
	       *
	       * @chainable
	       */
	      self.fetchInterval = function (ms) {
	        searchLooper.ms(ms);
	        return this;
	      };

	      /**
	       * Start fetching search requests on an interval
	       * @chainable
	       */
	      self.start = function () {
	        searchLooper.start();
	        docLooper.start();
	        return this;
	      };

	      /**
	       * Process the pending request queue right now, returns
	       * a promise that resembles the success of the fetch completing,
	       * individual errors are routed to their respective requests.
	       */
	      self.fetch = function () {
	        fetch.fetchQueued(searchStrategy).then(function () {
	          searchLooper.restart();
	        });
	      };

	      /**
	       * is the currior currently fetching search
	       * results automatically?
	       *
	       * @return {boolean}
	       */
	      self.started = function () {
	        return searchLooper.started();
	      };

	      /**
	       * stop the courier from fetching more search
	       * results, does not stop vaidating docs.
	       *
	       * @chainable
	       */
	      self.stop = function () {
	        searchLooper.stop();
	        return this;
	      };

	      /**
	       * create a source object that is a child of this courier
	       *
	       * @param {string} type - the type of Source to create
	       */
	      self.createSource = function (type) {
	        switch (type) {
	          case 'doc':
	            return new DocSource();
	          case 'search':
	            return new SearchSource();
	        }
	      };

	      /**
	       * Abort all pending requests
	       * @return {[type]} [description]
	       */
	      self.close = function () {
	        searchLooper.stop();
	        docLooper.stop();

	        _.invoke(requestQueue, 'abort');

	        if (requestQueue.length) {
	          throw new Error('Aborting all pending requests failed.');
	        }
	      };

	      // Listen for refreshInterval changes
	      $rootScope.$watchCollection('timefilter.refreshInterval', function () {
	        var refreshValue = _.get($rootScope, 'timefilter.refreshInterval.value');
	        var refreshPause = _.get($rootScope, 'timefilter.refreshInterval.pause');
	        if (_.isNumber(refreshValue) && !refreshPause) {
	          self.fetchInterval(refreshValue);
	        } else {
	          self.fetchInterval(0);
	        }
	      });

	      var onFatalDefer = Promise.defer();
	      onFatalDefer.promise.then(self.close);
	      Notifier.fatalCallbacks.push(onFatalDefer.resolve);
	    }

	    return new Courier();
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(498);
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(498);
	  var _ = __webpack_require__(192);

	  var es; // share the client amoungst all apps
	  __webpack_require__(214).get('kibana', ['elasticsearch', 'kibana/config']).service('es', function (esFactory, esUrl, $q, esApiVersion) {
	    if (es) return es;

	    es = esFactory({
	      host: esUrl,
	      log: 'info',
	      requestTimeout: 0,
	      apiVersion: esApiVersion,
	      plugins: [function (Client, config) {

	        // esFactory automatically injects the AngularConnector to the config
	        // https://github.com/elastic/elasticsearch-js/blob/master/src/lib/connectors/angular.js
	        _['class'](CustomAngularConnector).inherits(config.connectionClass);
	        function CustomAngularConnector(host, config) {
	          CustomAngularConnector.Super.call(this, host, config);

	          this.request = _.wrap(this.request, function (request, params, cb) {
	            if (String(params.method).toUpperCase() === 'GET') {
	              params.query = _.defaults({ _: Date.now() }, params.query);
	            }

	            return request.call(this, params, cb);
	          });
	        }

	        config.connectionClass = CustomAngularConnector;
	      }]
	    });

	    return es;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 498 */
/***/ function(module, exports) {

	/*! elasticsearch - v8.0.1 - 2015-08-26
	 * http://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html
	 * Copyright (c) 2015 Elasticsearch BV; Licensed Apache-2.0 */

	;(function () {
	/* prevent lodash from detecting external amd loaders */var define; 
	;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

	},{}],2:[function(require,module,exports){


	//
	// The shims in this file are not fully implemented shims for the ES5
	// features, but do work for the particular usecases there is in
	// the other modules.
	//

	var toString = Object.prototype.toString;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	// Array.isArray is supported in IE9
	function isArray(xs) {
	  return toString.call(xs) === '[object Array]';
	}
	exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

	// Array.prototype.indexOf is supported in IE9
	exports.indexOf = function indexOf(xs, x) {
	  if (xs.indexOf) return xs.indexOf(x);
	  for (var i = 0; i < xs.length; i++) {
	    if (x === xs[i]) return i;
	  }
	  return -1;
	};

	// Array.prototype.filter is supported in IE9
	exports.filter = function filter(xs, fn) {
	  if (xs.filter) return xs.filter(fn);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    if (fn(xs[i], i, xs)) res.push(xs[i]);
	  }
	  return res;
	};

	// Array.prototype.forEach is supported in IE9
	exports.forEach = function forEach(xs, fn, self) {
	  if (xs.forEach) return xs.forEach(fn, self);
	  for (var i = 0; i < xs.length; i++) {
	    fn.call(self, xs[i], i, xs);
	  }
	};

	// Array.prototype.map is supported in IE9
	exports.map = function map(xs, fn) {
	  if (xs.map) return xs.map(fn);
	  var out = new Array(xs.length);
	  for (var i = 0; i < xs.length; i++) {
	    out[i] = fn(xs[i], i, xs);
	  }
	  return out;
	};

	// Array.prototype.reduce is supported in IE9
	exports.reduce = function reduce(array, callback, opt_initialValue) {
	  if (array.reduce) return array.reduce(callback, opt_initialValue);
	  var value, isValueSet = false;

	  if (2 < arguments.length) {
	    value = opt_initialValue;
	    isValueSet = true;
	  }
	  for (var i = 0, l = array.length; l > i; ++i) {
	    if (array.hasOwnProperty(i)) {
	      if (isValueSet) {
	        value = callback(value, array[i], i, array);
	      }
	      else {
	        value = array[i];
	        isValueSet = true;
	      }
	    }
	  }

	  return value;
	};

	// String.prototype.substr - negative index don't work in IE8
	if ('ab'.substr(-1) !== 'b') {
	  exports.substr = function (str, start, length) {
	    // did we get a negative start, calculate how much it is from the beginning of the string
	    if (start < 0) start = str.length + start;

	    // call the original function
	    return str.substr(start, length);
	  };
	} else {
	  exports.substr = function (str, start, length) {
	    return str.substr(start, length);
	  };
	}

	// String.prototype.trim is supported in IE9
	exports.trim = function (str) {
	  if (str.trim) return str.trim();
	  return str.replace(/^\s+|\s+$/g, '');
	};

	// Function.prototype.bind is supported in IE9
	exports.bind = function () {
	  var args = Array.prototype.slice.call(arguments);
	  var fn = args.shift();
	  if (fn.bind) return fn.bind.apply(fn, args);
	  var self = args.shift();
	  return function () {
	    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
	  };
	};

	// Object.create is supported in IE9
	function create(prototype, properties) {
	  var object;
	  if (prototype === null) {
	    object = { '__proto__' : null };
	  }
	  else {
	    if (typeof prototype !== 'object') {
	      throw new TypeError(
	        'typeof prototype[' + (typeof prototype) + '] != \'object\''
	      );
	    }
	    var Type = function () {};
	    Type.prototype = prototype;
	    object = new Type();
	    object.__proto__ = prototype;
	  }
	  if (typeof properties !== 'undefined' && Object.defineProperties) {
	    Object.defineProperties(object, properties);
	  }
	  return object;
	}
	exports.create = typeof Object.create === 'function' ? Object.create : create;

	// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
	// they do show a description and number property on Error objects
	function notObject(object) {
	  return ((typeof object != "object" && typeof object != "function") || object === null);
	}

	function keysShim(object) {
	  if (notObject(object)) {
	    throw new TypeError("Object.keys called on a non-object");
	  }

	  var result = [];
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result.push(name);
	    }
	  }
	  return result;
	}

	// getOwnPropertyNames is almost the same as Object.keys one key feature
	//  is that it returns hidden properties, since that can't be implemented,
	//  this feature gets reduced so it just shows the length property on arrays
	function propertyShim(object) {
	  if (notObject(object)) {
	    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
	  }

	  var result = keysShim(object);
	  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
	    result.push('length');
	  }
	  return result;
	}

	var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
	var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
	  Object.getOwnPropertyNames : propertyShim;

	if (new Error().hasOwnProperty('description')) {
	  var ERROR_PROPERTY_FILTER = function (obj, array) {
	    if (toString.call(obj) === '[object Error]') {
	      array = exports.filter(array, function (name) {
	        return name !== 'description' && name !== 'number' && name !== 'message';
	      });
	    }
	    return array;
	  };

	  exports.keys = function (object) {
	    return ERROR_PROPERTY_FILTER(object, keys(object));
	  };
	  exports.getOwnPropertyNames = function (object) {
	    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
	  };
	} else {
	  exports.keys = keys;
	  exports.getOwnPropertyNames = getOwnPropertyNames;
	}

	// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
	function valueObject(value, key) {
	  return { value: value[key] };
	}

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
	  try {
	    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
	    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	  } catch (e) {
	    // IE8 dom element issue - use a try catch and default to valueObject
	    exports.getOwnPropertyDescriptor = function (value, key) {
	      try {
	        return Object.getOwnPropertyDescriptor(value, key);
	      } catch (e) {
	        return valueObject(value, key);
	      }
	    };
	  }
	} else {
	  exports.getOwnPropertyDescriptor = valueObject;
	}

	},{}],3:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// UTILITY
	var util = require('util');
	var shims = require('_shims');
	var pSlice = Array.prototype.slice;

	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  this.message = options.message || getMessage(this);
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}

	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}

	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;

	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }

	    return true;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  try {
	    var ka = shims.keys(a),
	        kb = shims.keys(b),
	        key, i;
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }

	  return false;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }

	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};

	assert.ifError = function(err) { if (err) {throw err;}};
	},{"_shims":2,"util":8}],4:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = require('util');

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!util.isNumber(n) || n < 0)
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (util.isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        throw TypeError('Uncaught, unspecified "error" event.');
	      }
	      return false;
	    }
	  }

	  handler = this._events[type];

	  if (util.isUndefined(handler))
	    return false;

	  if (util.isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (util.isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!util.isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              util.isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (util.isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (util.isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!util.isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      console.trace();
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!util.isFunction(listener))
	    throw TypeError('listener must be a function');

	  function g() {
	    this.removeListener(type, g);
	    listener.apply(this, arguments);
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!util.isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (util.isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (util.isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (util.isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (util.isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (util.isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};
	},{"util":8}],5:[function(require,module,exports){
	var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = require('util');
	var shims = require('_shims');

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (!util.isString(path)) {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(shims.filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = shims.substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(shims.filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(shims.filter(paths, function(p, index) {
	    if (!util.isString(p)) {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	},{"__browserify_process":13,"_shims":2,"util":8}],6:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// Query String Utilities

	var QueryString = exports;
	var util = require('util');
	var shims = require('_shims');
	var Buffer = require('buffer').Buffer;

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}


	function charCode(c) {
	  return c.charCodeAt(0);
	}


	// a safe fast alternative to decodeURIComponent
	QueryString.unescapeBuffer = function(s, decodeSpaces) {
	  var out = new Buffer(s.length);
	  var state = 'CHAR'; // states: CHAR, HEX0, HEX1
	  var n, m, hexchar;

	  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {
	    var c = s.charCodeAt(inIndex);
	    switch (state) {
	      case 'CHAR':
	        switch (c) {
	          case charCode('%'):
	            n = 0;
	            m = 0;
	            state = 'HEX0';
	            break;
	          case charCode('+'):
	            if (decodeSpaces) c = charCode(' ');
	            // pass thru
	          default:
	            out[outIndex++] = c;
	            break;
	        }
	        break;

	      case 'HEX0':
	        state = 'HEX1';
	        hexchar = c;
	        if (charCode('0') <= c && c <= charCode('9')) {
	          n = c - charCode('0');
	        } else if (charCode('a') <= c && c <= charCode('f')) {
	          n = c - charCode('a') + 10;
	        } else if (charCode('A') <= c && c <= charCode('F')) {
	          n = c - charCode('A') + 10;
	        } else {
	          out[outIndex++] = charCode('%');
	          out[outIndex++] = c;
	          state = 'CHAR';
	          break;
	        }
	        break;

	      case 'HEX1':
	        state = 'CHAR';
	        if (charCode('0') <= c && c <= charCode('9')) {
	          m = c - charCode('0');
	        } else if (charCode('a') <= c && c <= charCode('f')) {
	          m = c - charCode('a') + 10;
	        } else if (charCode('A') <= c && c <= charCode('F')) {
	          m = c - charCode('A') + 10;
	        } else {
	          out[outIndex++] = charCode('%');
	          out[outIndex++] = hexchar;
	          out[outIndex++] = c;
	          break;
	        }
	        out[outIndex++] = 16 * n + m;
	        break;
	    }
	  }

	  // TODO support returning arbitrary buffers.

	  return out.slice(0, outIndex - 1);
	};


	QueryString.unescape = function(s, decodeSpaces) {
	  return QueryString.unescapeBuffer(s, decodeSpaces).toString();
	};


	QueryString.escape = function(str) {
	  return encodeURIComponent(str);
	};

	var stringifyPrimitive = function(v) {
	  if (util.isString(v))
	    return v;
	  if (util.isBoolean(v))
	    return v ? 'true' : 'false';
	  if (util.isNumber(v))
	    return isFinite(v) ? v : '';
	  return '';
	};


	QueryString.stringify = QueryString.encode = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (util.isNull(obj)) {
	    obj = undefined;
	  }

	  if (util.isObject(obj)) {
	    return shims.map(shims.keys(obj), function(k) {
	      var ks = QueryString.escape(stringifyPrimitive(k)) + eq;
	      if (util.isArray(obj[k])) {
	        return shims.map(obj[k], function(v) {
	          return ks + QueryString.escape(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + QueryString.escape(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return QueryString.escape(stringifyPrimitive(name)) + eq +
	         QueryString.escape(stringifyPrimitive(obj));
	};

	// Parse a key=val string.
	QueryString.parse = QueryString.decode = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (!util.isString(qs) || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && util.isNumber(options.maxKeys)) {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    try {
	      k = decodeURIComponent(kstr);
	      v = decodeURIComponent(vstr);
	    } catch (e) {
	      k = QueryString.unescape(kstr, true);
	      v = QueryString.unescape(vstr, true);
	    }

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (util.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};
	},{"_shims":2,"buffer":10,"util":8}],7:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = { encode : function (s) { return s } };
	var util = require('util');
	var shims = require('_shims');

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = require('querystring');

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = shims.trim(rest);

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      util.isObject(this.query) &&
	      shims.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && shims.substr(protocol, -1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  shims.forEach(shims.keys(this), function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    shims.forEach(shims.keys(relative), function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      shims.forEach(shims.keys(relative), function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (shims.substr(srcPath.join('/'), -1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	},{"_shims":2,"querystring":6,"util":8}],8:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var shims = require('_shims');

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  shims.forEach(array, function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = shims.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = shims.getOwnPropertyNames(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }

	  shims.forEach(keys, function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }

	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (shims.indexOf(ctx.seen, desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = shims.reduce(output, function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return shims.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) && objectToString(e) === '[object Error]';
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.binarySlice === 'function'
	  ;
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = function(ctor, superCtor) {
	  ctor.super_ = superCtor;
	  ctor.prototype = shims.create(superCtor.prototype, {
	    constructor: {
	      value: ctor,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	};

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = shims.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	},{"_shims":2}],9:[function(require,module,exports){
	exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
	  var e, m,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = isBE ? 0 : (nBytes - 1),
	      d = isBE ? 1 : -1,
	      s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity);
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};

	exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
	  var e, m, c,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = isBE ? (nBytes - 1) : 0,
	      d = isBE ? -1 : 1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

	  buffer[offset + i - d] |= s * 128;
	};

	},{}],10:[function(require,module,exports){
	var assert;
	exports.Buffer = Buffer;
	exports.SlowBuffer = Buffer;
	Buffer.poolSize = 8192;
	exports.INSPECT_MAX_BYTES = 50;

	function stringtrim(str) {
	  if (str.trim) return str.trim();
	  return str.replace(/^\s+|\s+$/g, '');
	}

	function Buffer(subject, encoding, offset) {
	  if(!assert) assert= require('assert');
	  if (!(this instanceof Buffer)) {
	    return new Buffer(subject, encoding, offset);
	  }
	  this.parent = this;
	  this.offset = 0;

	  // Work-around: node's base64 implementation
	  // allows for non-padded strings while base64-js
	  // does not..
	  if (encoding == "base64" && typeof subject == "string") {
	    subject = stringtrim(subject);
	    while (subject.length % 4 != 0) {
	      subject = subject + "="; 
	    }
	  }

	  var type;

	  // Are we slicing?
	  if (typeof offset === 'number') {
	    this.length = coerce(encoding);
	    // slicing works, with limitations (no parent tracking/update)
	    // check https://github.com/toots/buffer-browserify/issues/19
	    for (var i = 0; i < this.length; i++) {
	        this[i] = subject.get(i+offset);
	    }
	  } else {
	    // Find the length
	    switch (type = typeof subject) {
	      case 'number':
	        this.length = coerce(subject);
	        break;

	      case 'string':
	        this.length = Buffer.byteLength(subject, encoding);
	        break;

	      case 'object': // Assume object is an array
	        this.length = coerce(subject.length);
	        break;

	      default:
	        throw new TypeError('First argument needs to be a number, ' +
	                            'array or string.');
	    }

	    // Treat array-ish objects as a byte array.
	    if (isArrayIsh(subject)) {
	      for (var i = 0; i < this.length; i++) {
	        if (subject instanceof Buffer) {
	          this[i] = subject.readUInt8(i);
	        }
	        else {
	          // Round-up subject[i] to a UInt8.
	          // e.g.: ((-432 % 256) + 256) % 256 = (-176 + 256) % 256
	          //                                  = 80
	          this[i] = ((subject[i] % 256) + 256) % 256;
	        }
	      }
	    } else if (type == 'string') {
	      // We are a string
	      this.length = this.write(subject, 0, encoding);
	    } else if (type === 'number') {
	      for (var i = 0; i < this.length; i++) {
	        this[i] = 0;
	      }
	    }
	  }
	}

	Buffer.prototype.get = function get(i) {
	  if (i < 0 || i >= this.length) throw new Error('oob');
	  return this[i];
	};

	Buffer.prototype.set = function set(i, v) {
	  if (i < 0 || i >= this.length) throw new Error('oob');
	  return this[i] = v;
	};

	Buffer.byteLength = function (str, encoding) {
	  switch (encoding || "utf8") {
	    case 'hex':
	      return str.length / 2;

	    case 'utf8':
	    case 'utf-8':
	      return utf8ToBytes(str).length;

	    case 'ascii':
	    case 'binary':
	      return str.length;

	    case 'base64':
	      return base64ToBytes(str).length;

	    default:
	      throw new Error('Unknown encoding');
	  }
	};

	Buffer.prototype.utf8Write = function (string, offset, length) {
	  var bytes, pos;
	  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
	};

	Buffer.prototype.asciiWrite = function (string, offset, length) {
	  var bytes, pos;
	  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
	};

	Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

	Buffer.prototype.base64Write = function (string, offset, length) {
	  var bytes, pos;
	  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
	};

	Buffer.prototype.base64Slice = function (start, end) {
	  var bytes = Array.prototype.slice.apply(this, arguments)
	  return require("base64-js").fromByteArray(bytes);
	};

	Buffer.prototype.utf8Slice = function () {
	  var bytes = Array.prototype.slice.apply(this, arguments);
	  var res = "";
	  var tmp = "";
	  var i = 0;
	  while (i < bytes.length) {
	    if (bytes[i] <= 0x7F) {
	      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
	      tmp = "";
	    } else
	      tmp += "%" + bytes[i].toString(16);

	    i++;
	  }

	  return res + decodeUtf8Char(tmp);
	}

	Buffer.prototype.asciiSlice = function () {
	  var bytes = Array.prototype.slice.apply(this, arguments);
	  var ret = "";
	  for (var i = 0; i < bytes.length; i++)
	    ret += String.fromCharCode(bytes[i]);
	  return ret;
	}

	Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

	Buffer.prototype.inspect = function() {
	  var out = [],
	      len = this.length;
	  for (var i = 0; i < len; i++) {
	    out[i] = toHex(this[i]);
	    if (i == exports.INSPECT_MAX_BYTES) {
	      out[i + 1] = '...';
	      break;
	    }
	  }
	  return '<Buffer ' + out.join(' ') + '>';
	};


	Buffer.prototype.hexSlice = function(start, end) {
	  var len = this.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; i++) {
	    out += toHex(this[i]);
	  }
	  return out;
	};


	Buffer.prototype.toString = function(encoding, start, end) {
	  encoding = String(encoding || 'utf8').toLowerCase();
	  start = +start || 0;
	  if (typeof end == 'undefined') end = this.length;

	  // Fastpath empty strings
	  if (+end == start) {
	    return '';
	  }

	  switch (encoding) {
	    case 'hex':
	      return this.hexSlice(start, end);

	    case 'utf8':
	    case 'utf-8':
	      return this.utf8Slice(start, end);

	    case 'ascii':
	      return this.asciiSlice(start, end);

	    case 'binary':
	      return this.binarySlice(start, end);

	    case 'base64':
	      return this.base64Slice(start, end);

	    case 'ucs2':
	    case 'ucs-2':
	      return this.ucs2Slice(start, end);

	    default:
	      throw new Error('Unknown encoding');
	  }
	};


	Buffer.prototype.hexWrite = function(string, offset, length) {
	  offset = +offset || 0;
	  var remaining = this.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = +length;
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2) {
	    throw new Error('Invalid hex string');
	  }
	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; i++) {
	    var b = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(b)) throw new Error('Invalid hex string');
	    this[offset + i] = b;
	  }
	  Buffer._charsWritten = i * 2;
	  return i;
	};


	Buffer.prototype.write = function(string, offset, length, encoding) {
	  // Support both (string, offset, length, encoding)
	  // and the legacy (string, encoding, offset, length)
	  if (isFinite(offset)) {
	    if (!isFinite(length)) {
	      encoding = length;
	      length = undefined;
	    }
	  } else {  // legacy
	    var swap = encoding;
	    encoding = offset;
	    offset = length;
	    length = swap;
	  }

	  offset = +offset || 0;
	  var remaining = this.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = +length;
	    if (length > remaining) {
	      length = remaining;
	    }
	  }
	  encoding = String(encoding || 'utf8').toLowerCase();

	  switch (encoding) {
	    case 'hex':
	      return this.hexWrite(string, offset, length);

	    case 'utf8':
	    case 'utf-8':
	      return this.utf8Write(string, offset, length);

	    case 'ascii':
	      return this.asciiWrite(string, offset, length);

	    case 'binary':
	      return this.binaryWrite(string, offset, length);

	    case 'base64':
	      return this.base64Write(string, offset, length);

	    case 'ucs2':
	    case 'ucs-2':
	      return this.ucs2Write(string, offset, length);

	    default:
	      throw new Error('Unknown encoding');
	  }
	};

	// slice(start, end)
	function clamp(index, len, defaultValue) {
	  if (typeof index !== 'number') return defaultValue;
	  index = ~~index;  // Coerce to integer.
	  if (index >= len) return len;
	  if (index >= 0) return index;
	  index += len;
	  if (index >= 0) return index;
	  return 0;
	}

	Buffer.prototype.slice = function(start, end) {
	  var len = this.length;
	  start = clamp(start, len, 0);
	  end = clamp(end, len, len);
	  return new Buffer(this, end - start, +start);
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function(target, target_start, start, end) {
	  var source = this;
	  start || (start = 0);
	  if (end === undefined || isNaN(end)) {
	    end = this.length;
	  }
	  target_start || (target_start = 0);

	  if (end < start) throw new Error('sourceEnd < sourceStart');

	  // Copy 0 bytes; we're done
	  if (end === start) return 0;
	  if (target.length == 0 || source.length == 0) return 0;

	  if (target_start < 0 || target_start >= target.length) {
	    throw new Error('targetStart out of bounds');
	  }

	  if (start < 0 || start >= source.length) {
	    throw new Error('sourceStart out of bounds');
	  }

	  if (end < 0 || end > source.length) {
	    throw new Error('sourceEnd out of bounds');
	  }

	  // Are we oob?
	  if (end > this.length) {
	    end = this.length;
	  }

	  if (target.length - target_start < end - start) {
	    end = target.length - target_start + start;
	  }

	  var temp = [];
	  for (var i=start; i<end; i++) {
	    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
	    temp.push(this[i]);
	  }

	  for (var i=target_start; i<target_start+temp.length; i++) {
	    target[i] = temp[i-target_start];
	  }
	};

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill(value, start, end) {
	  value || (value = 0);
	  start || (start = 0);
	  end || (end = this.length);

	  if (typeof value === 'string') {
	    value = value.charCodeAt(0);
	  }
	  if (!(typeof value === 'number') || isNaN(value)) {
	    throw new Error('value is not a number');
	  }

	  if (end < start) throw new Error('end < start');

	  // Fill 0 bytes; we're done
	  if (end === start) return 0;
	  if (this.length == 0) return 0;

	  if (start < 0 || start >= this.length) {
	    throw new Error('start out of bounds');
	  }

	  if (end < 0 || end > this.length) {
	    throw new Error('end out of bounds');
	  }

	  for (var i = start; i < end; i++) {
	    this[i] = value;
	  }
	}

	// Static methods
	Buffer.isBuffer = function isBuffer(b) {
	  return b instanceof Buffer;
	};

	Buffer.concat = function (list, totalLength) {
	  if (!isArray(list)) {
	    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
	      list should be an Array.");
	  }

	  if (list.length === 0) {
	    return new Buffer(0);
	  } else if (list.length === 1) {
	    return list[0];
	  }

	  if (typeof totalLength !== 'number') {
	    totalLength = 0;
	    for (var i = 0; i < list.length; i++) {
	      var buf = list[i];
	      totalLength += buf.length;
	    }
	  }

	  var buffer = new Buffer(totalLength);
	  var pos = 0;
	  for (var i = 0; i < list.length; i++) {
	    var buf = list[i];
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer;
	};

	Buffer.isEncoding = function(encoding) {
	  switch ((encoding + '').toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	    case 'raw':
	      return true;

	    default:
	      return false;
	  }
	};

	// helpers

	function coerce(length) {
	  // Coerce length to a number (possibly NaN), round up
	  // in case it's fractional (e.g. 123.456) then do a
	  // double negate to coerce a NaN to 0. Easy, right?
	  length = ~~Math.ceil(+length);
	  return length < 0 ? 0 : length;
	}

	function isArray(subject) {
	  return (Array.isArray ||
	    function(subject){
	      return {}.toString.apply(subject) == '[object Array]'
	    })
	    (subject)
	}

	function isArrayIsh(subject) {
	  return isArray(subject) || Buffer.isBuffer(subject) ||
	         subject && typeof subject === 'object' &&
	         typeof subject.length === 'number';
	}

	function toHex(n) {
	  if (n < 16) return '0' + n.toString(16);
	  return n.toString(16);
	}

	function utf8ToBytes(str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; i++)
	    if (str.charCodeAt(i) <= 0x7F)
	      byteArray.push(str.charCodeAt(i));
	    else {
	      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
	      for (var j = 0; j < h.length; j++)
	        byteArray.push(parseInt(h[j], 16));
	    }

	  return byteArray;
	}

	function asciiToBytes(str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++ )
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push( str.charCodeAt(i) & 0xFF );

	  return byteArray;
	}

	function base64ToBytes(str) {
	  return require("base64-js").toByteArray(str);
	}

	function blitBuffer(src, dst, offset, length) {
	  var pos, i = 0;
	  while (i < length) {
	    if ((i+offset >= dst.length) || (i >= src.length))
	      break;

	    dst[i + offset] = src[i];
	    i++;
	  }
	  return i;
	}

	function decodeUtf8Char(str) {
	  try {
	    return decodeURIComponent(str);
	  } catch (err) {
	    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
	  }
	}

	// read/write bit-twiddling

	Buffer.prototype.readUInt8 = function(offset, noAssert) {
	  var buffer = this;

	  if (!noAssert) {
	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return;

	  return buffer[offset];
	};

	function readUInt16(buffer, offset, isBigEndian, noAssert) {
	  var val = 0;


	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return 0;

	  if (isBigEndian) {
	    val = buffer[offset] << 8;
	    if (offset + 1 < buffer.length) {
	      val |= buffer[offset + 1];
	    }
	  } else {
	    val = buffer[offset];
	    if (offset + 1 < buffer.length) {
	      val |= buffer[offset + 1] << 8;
	    }
	  }

	  return val;
	}

	Buffer.prototype.readUInt16LE = function(offset, noAssert) {
	  return readUInt16(this, offset, false, noAssert);
	};

	Buffer.prototype.readUInt16BE = function(offset, noAssert) {
	  return readUInt16(this, offset, true, noAssert);
	};

	function readUInt32(buffer, offset, isBigEndian, noAssert) {
	  var val = 0;

	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return 0;

	  if (isBigEndian) {
	    if (offset + 1 < buffer.length)
	      val = buffer[offset + 1] << 16;
	    if (offset + 2 < buffer.length)
	      val |= buffer[offset + 2] << 8;
	    if (offset + 3 < buffer.length)
	      val |= buffer[offset + 3];
	    val = val + (buffer[offset] << 24 >>> 0);
	  } else {
	    if (offset + 2 < buffer.length)
	      val = buffer[offset + 2] << 16;
	    if (offset + 1 < buffer.length)
	      val |= buffer[offset + 1] << 8;
	    val |= buffer[offset];
	    if (offset + 3 < buffer.length)
	      val = val + (buffer[offset + 3] << 24 >>> 0);
	  }

	  return val;
	}

	Buffer.prototype.readUInt32LE = function(offset, noAssert) {
	  return readUInt32(this, offset, false, noAssert);
	};

	Buffer.prototype.readUInt32BE = function(offset, noAssert) {
	  return readUInt32(this, offset, true, noAssert);
	};


	/*
	 * Signed integer types, yay team! A reminder on how two's complement actually
	 * works. The first bit is the signed bit, i.e. tells us whether or not the
	 * number should be positive or negative. If the two's complement value is
	 * positive, then we're done, as it's equivalent to the unsigned representation.
	 *
	 * Now if the number is positive, you're pretty much done, you can just leverage
	 * the unsigned translations and return those. Unfortunately, negative numbers
	 * aren't quite that straightforward.
	 *
	 * At first glance, one might be inclined to use the traditional formula to
	 * translate binary numbers between the positive and negative values in two's
	 * complement. (Though it doesn't quite work for the most negative value)
	 * Mainly:
	 *  - invert all the bits
	 *  - add one to the result
	 *
	 * Of course, this doesn't quite work in Javascript. Take for example the value
	 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
	 * course, Javascript will do the following:
	 *
	 * > ~0xff80
	 * -65409
	 *
	 * Whoh there, Javascript, that's not quite right. But wait, according to
	 * Javascript that's perfectly correct. When Javascript ends up seeing the
	 * constant 0xff80, it has no notion that it is actually a signed number. It
	 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
	 * binary negation, it casts it into a signed value, (positive 0xff80). Then
	 * when you perform binary negation on that, it turns it into a negative number.
	 *
	 * Instead, we're going to have to use the following general formula, that works
	 * in a rather Javascript friendly way. I'm glad we don't support this kind of
	 * weird numbering scheme in the kernel.
	 *
	 * (BIT-MAX - (unsigned)val + 1) * -1
	 *
	 * The astute observer, may think that this doesn't make sense for 8-bit numbers
	 * (really it isn't necessary for them). However, when you get 16-bit numbers,
	 * you do. Let's go back to our prior example and see how this will look:
	 *
	 * (0xffff - 0xff80 + 1) * -1
	 * (0x007f + 1) * -1
	 * (0x0080) * -1
	 */
	Buffer.prototype.readInt8 = function(offset, noAssert) {
	  var buffer = this;
	  var neg;

	  if (!noAssert) {
	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return;

	  neg = buffer[offset] & 0x80;
	  if (!neg) {
	    return (buffer[offset]);
	  }

	  return ((0xff - buffer[offset] + 1) * -1);
	};

	function readInt16(buffer, offset, isBigEndian, noAssert) {
	  var neg, val;

	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  val = readUInt16(buffer, offset, isBigEndian, noAssert);
	  neg = val & 0x8000;
	  if (!neg) {
	    return val;
	  }

	  return (0xffff - val + 1) * -1;
	}

	Buffer.prototype.readInt16LE = function(offset, noAssert) {
	  return readInt16(this, offset, false, noAssert);
	};

	Buffer.prototype.readInt16BE = function(offset, noAssert) {
	  return readInt16(this, offset, true, noAssert);
	};

	function readInt32(buffer, offset, isBigEndian, noAssert) {
	  var neg, val;

	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  val = readUInt32(buffer, offset, isBigEndian, noAssert);
	  neg = val & 0x80000000;
	  if (!neg) {
	    return (val);
	  }

	  return (0xffffffff - val + 1) * -1;
	}

	Buffer.prototype.readInt32LE = function(offset, noAssert) {
	  return readInt32(this, offset, false, noAssert);
	};

	Buffer.prototype.readInt32BE = function(offset, noAssert) {
	  return readInt32(this, offset, true, noAssert);
	};

	function readFloat(buffer, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
	      23, 4);
	}

	Buffer.prototype.readFloatLE = function(offset, noAssert) {
	  return readFloat(this, offset, false, noAssert);
	};

	Buffer.prototype.readFloatBE = function(offset, noAssert) {
	  return readFloat(this, offset, true, noAssert);
	};

	function readDouble(buffer, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset + 7 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
	      52, 8);
	}

	Buffer.prototype.readDoubleLE = function(offset, noAssert) {
	  return readDouble(this, offset, false, noAssert);
	};

	Buffer.prototype.readDoubleBE = function(offset, noAssert) {
	  return readDouble(this, offset, true, noAssert);
	};


	/*
	 * We have to make sure that the value is a valid integer. This means that it is
	 * non-negative. It has no fractional component and that it does not exceed the
	 * maximum allowed value.
	 *
	 *      value           The number to check for validity
	 *
	 *      max             The maximum value
	 */
	function verifuint(value, max) {
	  assert.ok(typeof (value) == 'number',
	      'cannot write a non-number as a number');

	  assert.ok(value >= 0,
	      'specified a negative value for writing an unsigned value');

	  assert.ok(value <= max, 'value is larger than maximum value for type');

	  assert.ok(Math.floor(value) === value, 'value has a fractional component');
	}

	Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
	  var buffer = this;

	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'trying to write beyond buffer length');

	    verifuint(value, 0xff);
	  }

	  if (offset < buffer.length) {
	    buffer[offset] = value;
	  }
	};

	function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'trying to write beyond buffer length');

	    verifuint(value, 0xffff);
	  }

	  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
	    buffer[offset + i] =
	        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
	            (isBigEndian ? 1 - i : i) * 8;
	  }

	}

	Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
	  writeUInt16(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
	  writeUInt16(this, value, offset, true, noAssert);
	};

	function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'trying to write beyond buffer length');

	    verifuint(value, 0xffffffff);
	  }

	  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
	    buffer[offset + i] =
	        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
	  }
	}

	Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
	  writeUInt32(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
	  writeUInt32(this, value, offset, true, noAssert);
	};


	/*
	 * We now move onto our friends in the signed number category. Unlike unsigned
	 * numbers, we're going to have to worry a bit more about how we put values into
	 * arrays. Since we are only worrying about signed 32-bit values, we're in
	 * slightly better shape. Unfortunately, we really can't do our favorite binary
	 * & in this system. It really seems to do the wrong thing. For example:
	 *
	 * > -32 & 0xff
	 * 224
	 *
	 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
	 * this aren't treated as a signed number. Ultimately a bad thing.
	 *
	 * What we're going to want to do is basically create the unsigned equivalent of
	 * our representation and pass that off to the wuint* functions. To do that
	 * we're going to do the following:
	 *
	 *  - if the value is positive
	 *      we can pass it directly off to the equivalent wuint
	 *  - if the value is negative
	 *      we do the following computation:
	 *         mb + val + 1, where
	 *         mb   is the maximum unsigned value in that byte size
	 *         val  is the Javascript negative integer
	 *
	 *
	 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
	 * you do out the computations:
	 *
	 * 0xffff - 128 + 1
	 * 0xffff - 127
	 * 0xff80
	 *
	 * You can then encode this value as the signed version. This is really rather
	 * hacky, but it should work and get the job done which is our goal here.
	 */

	/*
	 * A series of checks to make sure we actually have a signed 32-bit number
	 */
	function verifsint(value, max, min) {
	  assert.ok(typeof (value) == 'number',
	      'cannot write a non-number as a number');

	  assert.ok(value <= max, 'value larger than maximum allowed value');

	  assert.ok(value >= min, 'value smaller than minimum allowed value');

	  assert.ok(Math.floor(value) === value, 'value has a fractional component');
	}

	function verifIEEE754(value, max, min) {
	  assert.ok(typeof (value) == 'number',
	      'cannot write a non-number as a number');

	  assert.ok(value <= max, 'value larger than maximum allowed value');

	  assert.ok(value >= min, 'value smaller than minimum allowed value');
	}

	Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
	  var buffer = this;

	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'Trying to write beyond buffer length');

	    verifsint(value, 0x7f, -0x80);
	  }

	  if (value >= 0) {
	    buffer.writeUInt8(value, offset, noAssert);
	  } else {
	    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
	  }
	};

	function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifsint(value, 0x7fff, -0x8000);
	  }

	  if (value >= 0) {
	    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
	  } else {
	    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
	  }
	}

	Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
	  writeInt16(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
	  writeInt16(this, value, offset, true, noAssert);
	};

	function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifsint(value, 0x7fffffff, -0x80000000);
	  }

	  if (value >= 0) {
	    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
	  } else {
	    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
	  }
	}

	Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
	  writeInt32(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
	  writeInt32(this, value, offset, true, noAssert);
	};

	function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
	  }

	  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
	      23, 4);
	}

	Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
	  writeFloat(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
	  writeFloat(this, value, offset, true, noAssert);
	};

	function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 7 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
	  }

	  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
	      52, 8);
	}

	Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
	  writeDouble(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
	  writeDouble(this, value, offset, true, noAssert);
	};

	},{"./buffer_ieee754":9,"assert":3,"base64-js":11}],11:[function(require,module,exports){
	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

	},{}],12:[function(require,module,exports){
	require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
	  var e, m,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = isBE ? 0 : (nBytes - 1),
	      d = isBE ? 1 : -1,
	      s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity);
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};

	exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
	  var e, m, c,
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = isBE ? (nBytes - 1) : 0,
	      d = isBE ? -1 : 1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

	  buffer[offset + i - d] |= s * 128;
	};

	},{}],"q9TxCC":[function(require,module,exports){
	var assert;
	exports.Buffer = Buffer;
	exports.SlowBuffer = Buffer;
	Buffer.poolSize = 8192;
	exports.INSPECT_MAX_BYTES = 50;

	function stringtrim(str) {
	  if (str.trim) return str.trim();
	  return str.replace(/^\s+|\s+$/g, '');
	}

	function Buffer(subject, encoding, offset) {
	  if(!assert) assert= require('assert');
	  if (!(this instanceof Buffer)) {
	    return new Buffer(subject, encoding, offset);
	  }
	  this.parent = this;
	  this.offset = 0;

	  // Work-around: node's base64 implementation
	  // allows for non-padded strings while base64-js
	  // does not..
	  if (encoding == "base64" && typeof subject == "string") {
	    subject = stringtrim(subject);
	    while (subject.length % 4 != 0) {
	      subject = subject + "="; 
	    }
	  }

	  var type;

	  // Are we slicing?
	  if (typeof offset === 'number') {
	    this.length = coerce(encoding);
	    // slicing works, with limitations (no parent tracking/update)
	    // check https://github.com/toots/buffer-browserify/issues/19
	    for (var i = 0; i < this.length; i++) {
	        this[i] = subject.get(i+offset);
	    }
	  } else {
	    // Find the length
	    switch (type = typeof subject) {
	      case 'number':
	        this.length = coerce(subject);
	        break;

	      case 'string':
	        this.length = Buffer.byteLength(subject, encoding);
	        break;

	      case 'object': // Assume object is an array
	        this.length = coerce(subject.length);
	        break;

	      default:
	        throw new Error('First argument needs to be a number, ' +
	                        'array or string.');
	    }

	    // Treat array-ish objects as a byte array.
	    if (isArrayIsh(subject)) {
	      for (var i = 0; i < this.length; i++) {
	        if (subject instanceof Buffer) {
	          this[i] = subject.readUInt8(i);
	        }
	        else {
	          this[i] = subject[i];
	        }
	      }
	    } else if (type == 'string') {
	      // We are a string
	      this.length = this.write(subject, 0, encoding);
	    } else if (type === 'number') {
	      for (var i = 0; i < this.length; i++) {
	        this[i] = 0;
	      }
	    }
	  }
	}

	Buffer.prototype.get = function get(i) {
	  if (i < 0 || i >= this.length) throw new Error('oob');
	  return this[i];
	};

	Buffer.prototype.set = function set(i, v) {
	  if (i < 0 || i >= this.length) throw new Error('oob');
	  return this[i] = v;
	};

	Buffer.byteLength = function (str, encoding) {
	  switch (encoding || "utf8") {
	    case 'hex':
	      return str.length / 2;

	    case 'utf8':
	    case 'utf-8':
	      return utf8ToBytes(str).length;

	    case 'ascii':
	    case 'binary':
	      return str.length;

	    case 'base64':
	      return base64ToBytes(str).length;

	    default:
	      throw new Error('Unknown encoding');
	  }
	};

	Buffer.prototype.utf8Write = function (string, offset, length) {
	  var bytes, pos;
	  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
	};

	Buffer.prototype.asciiWrite = function (string, offset, length) {
	  var bytes, pos;
	  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
	};

	Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

	Buffer.prototype.base64Write = function (string, offset, length) {
	  var bytes, pos;
	  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
	};

	Buffer.prototype.base64Slice = function (start, end) {
	  var bytes = Array.prototype.slice.apply(this, arguments)
	  return require("base64-js").fromByteArray(bytes);
	};

	Buffer.prototype.utf8Slice = function () {
	  var bytes = Array.prototype.slice.apply(this, arguments);
	  var res = "";
	  var tmp = "";
	  var i = 0;
	  while (i < bytes.length) {
	    if (bytes[i] <= 0x7F) {
	      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
	      tmp = "";
	    } else
	      tmp += "%" + bytes[i].toString(16);

	    i++;
	  }

	  return res + decodeUtf8Char(tmp);
	}

	Buffer.prototype.asciiSlice = function () {
	  var bytes = Array.prototype.slice.apply(this, arguments);
	  var ret = "";
	  for (var i = 0; i < bytes.length; i++)
	    ret += String.fromCharCode(bytes[i]);
	  return ret;
	}

	Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

	Buffer.prototype.inspect = function() {
	  var out = [],
	      len = this.length;
	  for (var i = 0; i < len; i++) {
	    out[i] = toHex(this[i]);
	    if (i == exports.INSPECT_MAX_BYTES) {
	      out[i + 1] = '...';
	      break;
	    }
	  }
	  return '<Buffer ' + out.join(' ') + '>';
	};


	Buffer.prototype.hexSlice = function(start, end) {
	  var len = this.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; i++) {
	    out += toHex(this[i]);
	  }
	  return out;
	};


	Buffer.prototype.toString = function(encoding, start, end) {
	  encoding = String(encoding || 'utf8').toLowerCase();
	  start = +start || 0;
	  if (typeof end == 'undefined') end = this.length;

	  // Fastpath empty strings
	  if (+end == start) {
	    return '';
	  }

	  switch (encoding) {
	    case 'hex':
	      return this.hexSlice(start, end);

	    case 'utf8':
	    case 'utf-8':
	      return this.utf8Slice(start, end);

	    case 'ascii':
	      return this.asciiSlice(start, end);

	    case 'binary':
	      return this.binarySlice(start, end);

	    case 'base64':
	      return this.base64Slice(start, end);

	    case 'ucs2':
	    case 'ucs-2':
	      return this.ucs2Slice(start, end);

	    default:
	      throw new Error('Unknown encoding');
	  }
	};


	Buffer.prototype.hexWrite = function(string, offset, length) {
	  offset = +offset || 0;
	  var remaining = this.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = +length;
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2) {
	    throw new Error('Invalid hex string');
	  }
	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; i++) {
	    var byte = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(byte)) throw new Error('Invalid hex string');
	    this[offset + i] = byte;
	  }
	  Buffer._charsWritten = i * 2;
	  return i;
	};


	Buffer.prototype.write = function(string, offset, length, encoding) {
	  // Support both (string, offset, length, encoding)
	  // and the legacy (string, encoding, offset, length)
	  if (isFinite(offset)) {
	    if (!isFinite(length)) {
	      encoding = length;
	      length = undefined;
	    }
	  } else {  // legacy
	    var swap = encoding;
	    encoding = offset;
	    offset = length;
	    length = swap;
	  }

	  offset = +offset || 0;
	  var remaining = this.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = +length;
	    if (length > remaining) {
	      length = remaining;
	    }
	  }
	  encoding = String(encoding || 'utf8').toLowerCase();

	  switch (encoding) {
	    case 'hex':
	      return this.hexWrite(string, offset, length);

	    case 'utf8':
	    case 'utf-8':
	      return this.utf8Write(string, offset, length);

	    case 'ascii':
	      return this.asciiWrite(string, offset, length);

	    case 'binary':
	      return this.binaryWrite(string, offset, length);

	    case 'base64':
	      return this.base64Write(string, offset, length);

	    case 'ucs2':
	    case 'ucs-2':
	      return this.ucs2Write(string, offset, length);

	    default:
	      throw new Error('Unknown encoding');
	  }
	};

	// slice(start, end)
	function clamp(index, len, defaultValue) {
	  if (typeof index !== 'number') return defaultValue;
	  index = ~~index;  // Coerce to integer.
	  if (index >= len) return len;
	  if (index >= 0) return index;
	  index += len;
	  if (index >= 0) return index;
	  return 0;
	}

	Buffer.prototype.slice = function(start, end) {
	  var len = this.length;
	  start = clamp(start, len, 0);
	  end = clamp(end, len, len);
	  return new Buffer(this, end - start, +start);
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function(target, target_start, start, end) {
	  var source = this;
	  start || (start = 0);
	  if (end === undefined || isNaN(end)) {
	    end = this.length;
	  }
	  target_start || (target_start = 0);

	  if (end < start) throw new Error('sourceEnd < sourceStart');

	  // Copy 0 bytes; we're done
	  if (end === start) return 0;
	  if (target.length == 0 || source.length == 0) return 0;

	  if (target_start < 0 || target_start >= target.length) {
	    throw new Error('targetStart out of bounds');
	  }

	  if (start < 0 || start >= source.length) {
	    throw new Error('sourceStart out of bounds');
	  }

	  if (end < 0 || end > source.length) {
	    throw new Error('sourceEnd out of bounds');
	  }

	  // Are we oob?
	  if (end > this.length) {
	    end = this.length;
	  }

	  if (target.length - target_start < end - start) {
	    end = target.length - target_start + start;
	  }

	  var temp = [];
	  for (var i=start; i<end; i++) {
	    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
	    temp.push(this[i]);
	  }

	  for (var i=target_start; i<target_start+temp.length; i++) {
	    target[i] = temp[i-target_start];
	  }
	};

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill(value, start, end) {
	  value || (value = 0);
	  start || (start = 0);
	  end || (end = this.length);

	  if (typeof value === 'string') {
	    value = value.charCodeAt(0);
	  }
	  if (!(typeof value === 'number') || isNaN(value)) {
	    throw new Error('value is not a number');
	  }

	  if (end < start) throw new Error('end < start');

	  // Fill 0 bytes; we're done
	  if (end === start) return 0;
	  if (this.length == 0) return 0;

	  if (start < 0 || start >= this.length) {
	    throw new Error('start out of bounds');
	  }

	  if (end < 0 || end > this.length) {
	    throw new Error('end out of bounds');
	  }

	  for (var i = start; i < end; i++) {
	    this[i] = value;
	  }
	}

	// Static methods
	Buffer.isBuffer = function isBuffer(b) {
	  return b instanceof Buffer || b instanceof Buffer;
	};

	Buffer.concat = function (list, totalLength) {
	  if (!isArray(list)) {
	    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
	      list should be an Array.");
	  }

	  if (list.length === 0) {
	    return new Buffer(0);
	  } else if (list.length === 1) {
	    return list[0];
	  }

	  if (typeof totalLength !== 'number') {
	    totalLength = 0;
	    for (var i = 0; i < list.length; i++) {
	      var buf = list[i];
	      totalLength += buf.length;
	    }
	  }

	  var buffer = new Buffer(totalLength);
	  var pos = 0;
	  for (var i = 0; i < list.length; i++) {
	    var buf = list[i];
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer;
	};

	Buffer.isEncoding = function(encoding) {
	  switch ((encoding + '').toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	    case 'raw':
	      return true;

	    default:
	      return false;
	  }
	};

	// helpers

	function coerce(length) {
	  // Coerce length to a number (possibly NaN), round up
	  // in case it's fractional (e.g. 123.456) then do a
	  // double negate to coerce a NaN to 0. Easy, right?
	  length = ~~Math.ceil(+length);
	  return length < 0 ? 0 : length;
	}

	function isArray(subject) {
	  return (Array.isArray ||
	    function(subject){
	      return {}.toString.apply(subject) == '[object Array]'
	    })
	    (subject)
	}

	function isArrayIsh(subject) {
	  return isArray(subject) || Buffer.isBuffer(subject) ||
	         subject && typeof subject === 'object' &&
	         typeof subject.length === 'number';
	}

	function toHex(n) {
	  if (n < 16) return '0' + n.toString(16);
	  return n.toString(16);
	}

	function utf8ToBytes(str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; i++)
	    if (str.charCodeAt(i) <= 0x7F)
	      byteArray.push(str.charCodeAt(i));
	    else {
	      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
	      for (var j = 0; j < h.length; j++)
	        byteArray.push(parseInt(h[j], 16));
	    }

	  return byteArray;
	}

	function asciiToBytes(str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++ )
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push( str.charCodeAt(i) & 0xFF );

	  return byteArray;
	}

	function base64ToBytes(str) {
	  return require("base64-js").toByteArray(str);
	}

	function blitBuffer(src, dst, offset, length) {
	  var pos, i = 0;
	  while (i < length) {
	    if ((i+offset >= dst.length) || (i >= src.length))
	      break;

	    dst[i + offset] = src[i];
	    i++;
	  }
	  return i;
	}

	function decodeUtf8Char(str) {
	  try {
	    return decodeURIComponent(str);
	  } catch (err) {
	    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
	  }
	}

	// read/write bit-twiddling

	Buffer.prototype.readUInt8 = function(offset, noAssert) {
	  var buffer = this;

	  if (!noAssert) {
	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return;

	  return buffer[offset];
	};

	function readUInt16(buffer, offset, isBigEndian, noAssert) {
	  var val = 0;


	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return 0;

	  if (isBigEndian) {
	    val = buffer[offset] << 8;
	    if (offset + 1 < buffer.length) {
	      val |= buffer[offset + 1];
	    }
	  } else {
	    val = buffer[offset];
	    if (offset + 1 < buffer.length) {
	      val |= buffer[offset + 1] << 8;
	    }
	  }

	  return val;
	}

	Buffer.prototype.readUInt16LE = function(offset, noAssert) {
	  return readUInt16(this, offset, false, noAssert);
	};

	Buffer.prototype.readUInt16BE = function(offset, noAssert) {
	  return readUInt16(this, offset, true, noAssert);
	};

	function readUInt32(buffer, offset, isBigEndian, noAssert) {
	  var val = 0;

	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return 0;

	  if (isBigEndian) {
	    if (offset + 1 < buffer.length)
	      val = buffer[offset + 1] << 16;
	    if (offset + 2 < buffer.length)
	      val |= buffer[offset + 2] << 8;
	    if (offset + 3 < buffer.length)
	      val |= buffer[offset + 3];
	    val = val + (buffer[offset] << 24 >>> 0);
	  } else {
	    if (offset + 2 < buffer.length)
	      val = buffer[offset + 2] << 16;
	    if (offset + 1 < buffer.length)
	      val |= buffer[offset + 1] << 8;
	    val |= buffer[offset];
	    if (offset + 3 < buffer.length)
	      val = val + (buffer[offset + 3] << 24 >>> 0);
	  }

	  return val;
	}

	Buffer.prototype.readUInt32LE = function(offset, noAssert) {
	  return readUInt32(this, offset, false, noAssert);
	};

	Buffer.prototype.readUInt32BE = function(offset, noAssert) {
	  return readUInt32(this, offset, true, noAssert);
	};


	/*
	 * Signed integer types, yay team! A reminder on how two's complement actually
	 * works. The first bit is the signed bit, i.e. tells us whether or not the
	 * number should be positive or negative. If the two's complement value is
	 * positive, then we're done, as it's equivalent to the unsigned representation.
	 *
	 * Now if the number is positive, you're pretty much done, you can just leverage
	 * the unsigned translations and return those. Unfortunately, negative numbers
	 * aren't quite that straightforward.
	 *
	 * At first glance, one might be inclined to use the traditional formula to
	 * translate binary numbers between the positive and negative values in two's
	 * complement. (Though it doesn't quite work for the most negative value)
	 * Mainly:
	 *  - invert all the bits
	 *  - add one to the result
	 *
	 * Of course, this doesn't quite work in Javascript. Take for example the value
	 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
	 * course, Javascript will do the following:
	 *
	 * > ~0xff80
	 * -65409
	 *
	 * Whoh there, Javascript, that's not quite right. But wait, according to
	 * Javascript that's perfectly correct. When Javascript ends up seeing the
	 * constant 0xff80, it has no notion that it is actually a signed number. It
	 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
	 * binary negation, it casts it into a signed value, (positive 0xff80). Then
	 * when you perform binary negation on that, it turns it into a negative number.
	 *
	 * Instead, we're going to have to use the following general formula, that works
	 * in a rather Javascript friendly way. I'm glad we don't support this kind of
	 * weird numbering scheme in the kernel.
	 *
	 * (BIT-MAX - (unsigned)val + 1) * -1
	 *
	 * The astute observer, may think that this doesn't make sense for 8-bit numbers
	 * (really it isn't necessary for them). However, when you get 16-bit numbers,
	 * you do. Let's go back to our prior example and see how this will look:
	 *
	 * (0xffff - 0xff80 + 1) * -1
	 * (0x007f + 1) * -1
	 * (0x0080) * -1
	 */
	Buffer.prototype.readInt8 = function(offset, noAssert) {
	  var buffer = this;
	  var neg;

	  if (!noAssert) {
	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  if (offset >= buffer.length) return;

	  neg = buffer[offset] & 0x80;
	  if (!neg) {
	    return (buffer[offset]);
	  }

	  return ((0xff - buffer[offset] + 1) * -1);
	};

	function readInt16(buffer, offset, isBigEndian, noAssert) {
	  var neg, val;

	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  val = readUInt16(buffer, offset, isBigEndian, noAssert);
	  neg = val & 0x8000;
	  if (!neg) {
	    return val;
	  }

	  return (0xffff - val + 1) * -1;
	}

	Buffer.prototype.readInt16LE = function(offset, noAssert) {
	  return readInt16(this, offset, false, noAssert);
	};

	Buffer.prototype.readInt16BE = function(offset, noAssert) {
	  return readInt16(this, offset, true, noAssert);
	};

	function readInt32(buffer, offset, isBigEndian, noAssert) {
	  var neg, val;

	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  val = readUInt32(buffer, offset, isBigEndian, noAssert);
	  neg = val & 0x80000000;
	  if (!neg) {
	    return (val);
	  }

	  return (0xffffffff - val + 1) * -1;
	}

	Buffer.prototype.readInt32LE = function(offset, noAssert) {
	  return readInt32(this, offset, false, noAssert);
	};

	Buffer.prototype.readInt32BE = function(offset, noAssert) {
	  return readInt32(this, offset, true, noAssert);
	};

	function readFloat(buffer, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
	      23, 4);
	}

	Buffer.prototype.readFloatLE = function(offset, noAssert) {
	  return readFloat(this, offset, false, noAssert);
	};

	Buffer.prototype.readFloatBE = function(offset, noAssert) {
	  return readFloat(this, offset, true, noAssert);
	};

	function readDouble(buffer, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset + 7 < buffer.length,
	        'Trying to read beyond buffer length');
	  }

	  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
	      52, 8);
	}

	Buffer.prototype.readDoubleLE = function(offset, noAssert) {
	  return readDouble(this, offset, false, noAssert);
	};

	Buffer.prototype.readDoubleBE = function(offset, noAssert) {
	  return readDouble(this, offset, true, noAssert);
	};


	/*
	 * We have to make sure that the value is a valid integer. This means that it is
	 * non-negative. It has no fractional component and that it does not exceed the
	 * maximum allowed value.
	 *
	 *      value           The number to check for validity
	 *
	 *      max             The maximum value
	 */
	function verifuint(value, max) {
	  assert.ok(typeof (value) == 'number',
	      'cannot write a non-number as a number');

	  assert.ok(value >= 0,
	      'specified a negative value for writing an unsigned value');

	  assert.ok(value <= max, 'value is larger than maximum value for type');

	  assert.ok(Math.floor(value) === value, 'value has a fractional component');
	}

	Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
	  var buffer = this;

	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'trying to write beyond buffer length');

	    verifuint(value, 0xff);
	  }

	  if (offset < buffer.length) {
	    buffer[offset] = value;
	  }
	};

	function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'trying to write beyond buffer length');

	    verifuint(value, 0xffff);
	  }

	  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
	    buffer[offset + i] =
	        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
	            (isBigEndian ? 1 - i : i) * 8;
	  }

	}

	Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
	  writeUInt16(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
	  writeUInt16(this, value, offset, true, noAssert);
	};

	function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'trying to write beyond buffer length');

	    verifuint(value, 0xffffffff);
	  }

	  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
	    buffer[offset + i] =
	        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
	  }
	}

	Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
	  writeUInt32(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
	  writeUInt32(this, value, offset, true, noAssert);
	};


	/*
	 * We now move onto our friends in the signed number category. Unlike unsigned
	 * numbers, we're going to have to worry a bit more about how we put values into
	 * arrays. Since we are only worrying about signed 32-bit values, we're in
	 * slightly better shape. Unfortunately, we really can't do our favorite binary
	 * & in this system. It really seems to do the wrong thing. For example:
	 *
	 * > -32 & 0xff
	 * 224
	 *
	 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
	 * this aren't treated as a signed number. Ultimately a bad thing.
	 *
	 * What we're going to want to do is basically create the unsigned equivalent of
	 * our representation and pass that off to the wuint* functions. To do that
	 * we're going to do the following:
	 *
	 *  - if the value is positive
	 *      we can pass it directly off to the equivalent wuint
	 *  - if the value is negative
	 *      we do the following computation:
	 *         mb + val + 1, where
	 *         mb   is the maximum unsigned value in that byte size
	 *         val  is the Javascript negative integer
	 *
	 *
	 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
	 * you do out the computations:
	 *
	 * 0xffff - 128 + 1
	 * 0xffff - 127
	 * 0xff80
	 *
	 * You can then encode this value as the signed version. This is really rather
	 * hacky, but it should work and get the job done which is our goal here.
	 */

	/*
	 * A series of checks to make sure we actually have a signed 32-bit number
	 */
	function verifsint(value, max, min) {
	  assert.ok(typeof (value) == 'number',
	      'cannot write a non-number as a number');

	  assert.ok(value <= max, 'value larger than maximum allowed value');

	  assert.ok(value >= min, 'value smaller than minimum allowed value');

	  assert.ok(Math.floor(value) === value, 'value has a fractional component');
	}

	function verifIEEE754(value, max, min) {
	  assert.ok(typeof (value) == 'number',
	      'cannot write a non-number as a number');

	  assert.ok(value <= max, 'value larger than maximum allowed value');

	  assert.ok(value >= min, 'value smaller than minimum allowed value');
	}

	Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
	  var buffer = this;

	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset < buffer.length,
	        'Trying to write beyond buffer length');

	    verifsint(value, 0x7f, -0x80);
	  }

	  if (value >= 0) {
	    buffer.writeUInt8(value, offset, noAssert);
	  } else {
	    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
	  }
	};

	function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 1 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifsint(value, 0x7fff, -0x8000);
	  }

	  if (value >= 0) {
	    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
	  } else {
	    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
	  }
	}

	Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
	  writeInt16(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
	  writeInt16(this, value, offset, true, noAssert);
	};

	function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifsint(value, 0x7fffffff, -0x80000000);
	  }

	  if (value >= 0) {
	    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
	  } else {
	    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
	  }
	}

	Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
	  writeInt32(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
	  writeInt32(this, value, offset, true, noAssert);
	};

	function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 3 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
	  }

	  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
	      23, 4);
	}

	Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
	  writeFloat(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
	  writeFloat(this, value, offset, true, noAssert);
	};

	function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
	  if (!noAssert) {
	    assert.ok(value !== undefined && value !== null,
	        'missing value');

	    assert.ok(typeof (isBigEndian) === 'boolean',
	        'missing or invalid endian');

	    assert.ok(offset !== undefined && offset !== null,
	        'missing offset');

	    assert.ok(offset + 7 < buffer.length,
	        'Trying to write beyond buffer length');

	    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
	  }

	  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
	      52, 8);
	}

	Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
	  writeDouble(this, value, offset, false, noAssert);
	};

	Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
	  writeDouble(this, value, offset, true, noAssert);
	};

	},{"./buffer_ieee754":1,"assert":6,"base64-js":4}],"buffer-browserify":[function(require,module,exports){
	module.exports=require('q9TxCC');
	},{}],4:[function(require,module,exports){
	(function (exports) {
		'use strict';

		var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

		function b64ToByteArray(b64) {
			var i, j, l, tmp, placeHolders, arr;
		
			if (b64.length % 4 > 0) {
				throw 'Invalid string. Length must be a multiple of 4';
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			placeHolders = b64.indexOf('=');
			placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

			// base64 is 4/3 + up to two characters of the original data
			arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length;

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
				arr.push((tmp & 0xFF0000) >> 16);
				arr.push((tmp & 0xFF00) >> 8);
				arr.push(tmp & 0xFF);
			}

			if (placeHolders === 2) {
				tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
				arr.push(tmp & 0xFF);
			} else if (placeHolders === 1) {
				tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
				arr.push((tmp >> 8) & 0xFF);
				arr.push(tmp & 0xFF);
			}

			return arr;
		}

		function uint8ToBase64(uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length;

			function tripletToBase64 (num) {
				return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
			};

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
				output += tripletToBase64(temp);
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1];
					output += lookup[temp >> 2];
					output += lookup[(temp << 4) & 0x3F];
					output += '==';
					break;
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
					output += lookup[temp >> 10];
					output += lookup[(temp >> 4) & 0x3F];
					output += lookup[(temp << 2) & 0x3F];
					output += '=';
					break;
			}

			return output;
		}

		module.exports.toByteArray = b64ToByteArray;
		module.exports.fromByteArray = uint8ToBase64;
	}());

	},{}],5:[function(require,module,exports){


	//
	// The shims in this file are not fully implemented shims for the ES5
	// features, but do work for the particular usecases there is in
	// the other modules.
	//

	var toString = Object.prototype.toString;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	// Array.isArray is supported in IE9
	function isArray(xs) {
	  return toString.call(xs) === '[object Array]';
	}
	exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

	// Array.prototype.indexOf is supported in IE9
	exports.indexOf = function indexOf(xs, x) {
	  if (xs.indexOf) return xs.indexOf(x);
	  for (var i = 0; i < xs.length; i++) {
	    if (x === xs[i]) return i;
	  }
	  return -1;
	};

	// Array.prototype.filter is supported in IE9
	exports.filter = function filter(xs, fn) {
	  if (xs.filter) return xs.filter(fn);
	  var res = [];
	  for (var i = 0; i < xs.length; i++) {
	    if (fn(xs[i], i, xs)) res.push(xs[i]);
	  }
	  return res;
	};

	// Array.prototype.forEach is supported in IE9
	exports.forEach = function forEach(xs, fn, self) {
	  if (xs.forEach) return xs.forEach(fn, self);
	  for (var i = 0; i < xs.length; i++) {
	    fn.call(self, xs[i], i, xs);
	  }
	};

	// Array.prototype.map is supported in IE9
	exports.map = function map(xs, fn) {
	  if (xs.map) return xs.map(fn);
	  var out = new Array(xs.length);
	  for (var i = 0; i < xs.length; i++) {
	    out[i] = fn(xs[i], i, xs);
	  }
	  return out;
	};

	// Array.prototype.reduce is supported in IE9
	exports.reduce = function reduce(array, callback, opt_initialValue) {
	  if (array.reduce) return array.reduce(callback, opt_initialValue);
	  var value, isValueSet = false;

	  if (2 < arguments.length) {
	    value = opt_initialValue;
	    isValueSet = true;
	  }
	  for (var i = 0, l = array.length; l > i; ++i) {
	    if (array.hasOwnProperty(i)) {
	      if (isValueSet) {
	        value = callback(value, array[i], i, array);
	      }
	      else {
	        value = array[i];
	        isValueSet = true;
	      }
	    }
	  }

	  return value;
	};

	// String.prototype.substr - negative index don't work in IE8
	if ('ab'.substr(-1) !== 'b') {
	  exports.substr = function (str, start, length) {
	    // did we get a negative start, calculate how much it is from the beginning of the string
	    if (start < 0) start = str.length + start;

	    // call the original function
	    return str.substr(start, length);
	  };
	} else {
	  exports.substr = function (str, start, length) {
	    return str.substr(start, length);
	  };
	}

	// String.prototype.trim is supported in IE9
	exports.trim = function (str) {
	  if (str.trim) return str.trim();
	  return str.replace(/^\s+|\s+$/g, '');
	};

	// Function.prototype.bind is supported in IE9
	exports.bind = function () {
	  var args = Array.prototype.slice.call(arguments);
	  var fn = args.shift();
	  if (fn.bind) return fn.bind.apply(fn, args);
	  var self = args.shift();
	  return function () {
	    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
	  };
	};

	// Object.create is supported in IE9
	function create(prototype, properties) {
	  var object;
	  if (prototype === null) {
	    object = { '__proto__' : null };
	  }
	  else {
	    if (typeof prototype !== 'object') {
	      throw new TypeError(
	        'typeof prototype[' + (typeof prototype) + '] != \'object\''
	      );
	    }
	    var Type = function () {};
	    Type.prototype = prototype;
	    object = new Type();
	    object.__proto__ = prototype;
	  }
	  if (typeof properties !== 'undefined' && Object.defineProperties) {
	    Object.defineProperties(object, properties);
	  }
	  return object;
	}
	exports.create = typeof Object.create === 'function' ? Object.create : create;

	// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
	// they do show a description and number property on Error objects
	function notObject(object) {
	  return ((typeof object != "object" && typeof object != "function") || object === null);
	}

	function keysShim(object) {
	  if (notObject(object)) {
	    throw new TypeError("Object.keys called on a non-object");
	  }

	  var result = [];
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result.push(name);
	    }
	  }
	  return result;
	}

	// getOwnPropertyNames is almost the same as Object.keys one key feature
	//  is that it returns hidden properties, since that can't be implemented,
	//  this feature gets reduced so it just shows the length property on arrays
	function propertyShim(object) {
	  if (notObject(object)) {
	    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
	  }

	  var result = keysShim(object);
	  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
	    result.push('length');
	  }
	  return result;
	}

	var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
	var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
	  Object.getOwnPropertyNames : propertyShim;

	if (new Error().hasOwnProperty('description')) {
	  var ERROR_PROPERTY_FILTER = function (obj, array) {
	    if (toString.call(obj) === '[object Error]') {
	      array = exports.filter(array, function (name) {
	        return name !== 'description' && name !== 'number' && name !== 'message';
	      });
	    }
	    return array;
	  };

	  exports.keys = function (object) {
	    return ERROR_PROPERTY_FILTER(object, keys(object));
	  };
	  exports.getOwnPropertyNames = function (object) {
	    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
	  };
	} else {
	  exports.keys = keys;
	  exports.getOwnPropertyNames = getOwnPropertyNames;
	}

	// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
	function valueObject(value, key) {
	  return { value: value[key] };
	}

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
	  try {
	    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
	    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	  } catch (e) {
	    // IE8 dom element issue - use a try catch and default to valueObject
	    exports.getOwnPropertyDescriptor = function (value, key) {
	      try {
	        return Object.getOwnPropertyDescriptor(value, key);
	      } catch (e) {
	        return valueObject(value, key);
	      }
	    };
	  }
	} else {
	  exports.getOwnPropertyDescriptor = valueObject;
	}

	},{}],6:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// UTILITY
	var util = require('util');
	var shims = require('_shims');
	var pSlice = Array.prototype.slice;

	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  this.message = options.message || getMessage(this);
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function replacer(key, value) {
	  if (util.isUndefined(value)) {
	    return '' + value;
	  }
	  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
	    return value.toString();
	  }
	  if (util.isFunction(value) || util.isRegExp(value)) {
	    return value.toString();
	  }
	  return value;
	}

	function truncate(s, n) {
	  if (util.isString(s)) {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}

	function getMessage(self) {
	  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(JSON.stringify(self.expected, replacer), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	function _deepEqual(actual, expected) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
	    if (actual.length != expected.length) return false;

	    for (var i = 0; i < actual.length; i++) {
	      if (actual[i] !== expected[i]) return false;
	    }

	    return true;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!util.isObject(actual) && !util.isObject(expected)) {
	    return actual == expected;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b) {
	  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b);
	  }
	  try {
	    var ka = shims.keys(a),
	        kb = shims.keys(b),
	        key, i;
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key])) return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  } else if (actual instanceof expected) {
	    return true;
	  } else if (expected.call({}, actual) === true) {
	    return true;
	  }

	  return false;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (util.isString(expected)) {
	    message = expected;
	    expected = null;
	  }

	  try {
	    block();
	  } catch (e) {
	    actual = e;
	  }

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  if (!shouldThrow && expectedException(actual, expected)) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws.apply(this, [true].concat(pSlice.call(arguments)));
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/message) {
	  _throws.apply(this, [false].concat(pSlice.call(arguments)));
	};

	assert.ifError = function(err) { if (err) {throw err;}};
	},{"_shims":5,"util":7}],7:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var shims = require('_shims');

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  shims.forEach(array, function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = shims.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = shims.getOwnPropertyNames(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }

	  shims.forEach(keys, function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }

	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (shims.indexOf(ctx.seen, desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = shims.reduce(output, function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return shims.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) && objectToString(e) === '[object Error]';
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	function isBuffer(arg) {
	  return arg instanceof Buffer;
	}
	exports.isBuffer = isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = function(ctor, superCtor) {
	  ctor.super_ = superCtor;
	  ctor.prototype = shims.create(superCtor.prototype, {
	    constructor: {
	      value: ctor,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	};

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = shims.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	},{"_shims":5}]},{},[])
	;;module.exports=require("buffer-browserify")

	},{}],13:[function(require,module,exports){
	// shim for using process in browser

	var process = module.exports = {};

	process.nextTick = (function () {
	    var canSetImmediate = typeof window !== 'undefined'
	    && window.setImmediate;
	    var canPost = typeof window !== 'undefined'
	    && window.postMessage && window.addEventListener
	    ;

	    if (canSetImmediate) {
	        return function (f) { return window.setImmediate(f) };
	    }

	    if (canPost) {
	        var queue = [];
	        window.addEventListener('message', function (ev) {
	            var source = ev.source;
	            if ((source === window || source === null) && ev.data === 'process-tick') {
	                ev.stopPropagation();
	                if (queue.length > 0) {
	                    var fn = queue.shift();
	                    fn();
	                }
	            }
	        }, true);

	        return function nextTick(fn) {
	            queue.push(fn);
	            window.postMessage('process-tick', '*');
	        };
	    }

	    return function nextTick(fn) {
	        setTimeout(fn, 0);
	    };
	})();

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	}

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};

	},{}],14:[function(require,module,exports){
	var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};/**
	 * @license
	 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash compat -d -o ./index.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '3.10.1';

	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256;

	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2;

	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	  /**
	   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
	   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
	   */
	  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);

	  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
	  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect hexadecimal string values. */
	  var reHasHexPrefix = /^0[xX]/;

	  /** Used to detect host constructors (Safari > 5). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^\d+$/;

	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

	    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
	    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
	  ];

	  /** Used to fix the JScript `[[DontEnum]]` bug. */
	  var shadowProps = [
	    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
	    'toLocaleString', 'toString', 'valueOf'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used to escape characters for inclusion in compiled regexes. */
	  var regexpEscapes = {
	    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
	    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
	    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
	    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
	    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

	  /** Detect free variable `self`. */
	  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

	  /** Detect free variable `window`. */
	  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it's the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsNull = value === null,
	          valIsUndef = value === undefined,
	          valIsReflexive = value === value;

	      var othIsNull = other === null,
	          othIsUndef = other === undefined,
	          othIsReflexive = other === other;

	      if ((value > other && !othIsNull) || !valIsReflexive ||
	          (valIsNull && !othIsUndef && othIsReflexive) ||
	          (valIsUndef && othIsReflexive)) {
	        return 1;
	      }
	      if ((value < other && !valIsNull) || !othIsReflexive ||
	          (othIsNull && !valIsUndef && valIsReflexive) ||
	          (othIsUndef && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromRight) {
	    var length = array.length,
	        index = fromRight ? length : -1;

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isFunction` without support for environments
	   * with incorrect `typeof` results.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	   */
	  function baseIsFunction(value) {
	    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	    return typeof value == 'function' || false;
	  }

	  /**
	   * Converts `value` to a string if it's not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    return value == null ? '' : (value + '');
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;

	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }

	  /**
	   * Used by `_.sortByOrder` to compare multiple properties of a value to another
	   * and stable sort them.
	   *
	   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
	   * a value is sorted in ascending order if its corresponding order is "asc", and
	   * descending if "desc".
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {boolean[]} orders The order to sort by for each property.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultiple(object, other, orders) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length,
	        ordersLength = orders.length;

	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        if (index >= ordersLength) {
	          return result;
	        }
	        var order = orders[index];
	        return result * ((order === 'asc' || order === true) ? 1 : -1);
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }

	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }

	  /**
	   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @param {string} leadingChar The capture group for a leading character.
	   * @param {string} whitespaceChar The capture group for a whitespace character.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
	    if (leadingChar) {
	      chr = regexpEscapes[chr];
	    } else if (whitespaceChar) {
	      chr = stringEscapes[chr];
	    }
	    return '\\' + chr;
	  }

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 0 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Checks if `value` is a host object in IE < 9.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	   */
	  var isHostObject = (function() {
	    try {
	      Object({ 'toString': 0 } + '');
	    } catch(e) {
	      return function() { return false; };
	    }
	    return function(value) {
	      // IE < 9 presents many host objects as `Object` objects that can coerce
	      // to strings despite having improperly defined `toString` methods.
	      return typeof value.toString != 'function' && typeof (value + '') == 'string';
	    };
	  }());

	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return !!value && typeof value == 'object';
	  }

	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;

	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;

	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        errorProto = Error.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;

	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /**
	     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var objToString = objectProto.toString;

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Native method references. */
	    var ArrayBuffer = context.ArrayBuffer,
	        clearTimeout = context.clearTimeout,
	        parseFloat = context.parseFloat,
	        pow = Math.pow,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = getNative(context, 'Set'),
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = context.Uint8Array,
	        WeakMap = getNative(context, 'WeakMap');

	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeCreate = getNative(Object, 'create'),
	        nativeFloor = Math.floor,
	        nativeIsArray = getNative(Array, 'isArray'),
	        nativeIsFinite = context.isFinite,
	        nativeKeys = getNative(Object, 'keys'),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = getNative(Date, 'now'),
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = 4294967295,
	        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	    /**
	     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	     * of an array-like value.
	     */
	    var MAX_SAFE_INTEGER = 9007199254740991;

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /** Used to lookup a type array constructors by `toStringTag`. */
	    var ctorByTag = {};
	    ctorByTag[float32Tag] = context.Float32Array;
	    ctorByTag[float64Tag] = context.Float64Array;
	    ctorByTag[int8Tag] = context.Int8Array;
	    ctorByTag[int16Tag] = context.Int16Array;
	    ctorByTag[int32Tag] = context.Int32Array;
	    ctorByTag[uint8Tag] = Uint8Array;
	    ctorByTag[uint8ClampedTag] = context.Uint8ClampedArray;
	    ctorByTag[uint16Tag] = context.Uint16Array;
	    ctorByTag[uint32Tag] = context.Uint32Array;

	    /** Used to avoid iterating over non-enumerable properties in IE < 9. */
	    var nonEnumProps = {};
	    nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };
	    nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };
	    nonEnumProps[objectTag] = { 'constructor': true };

	    arrayEach(shadowProps, function(key) {
	      for (var tag in nonEnumProps) {
	        if (hasOwnProperty.call(nonEnumProps, tag)) {
	          var props = nonEnumProps[tag];
	          props[key] = hasOwnProperty.call(props, key);
	        }
	      }
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that retrieve a single value or may return a
	     * primitive value will automatically end the chain returning the unwrapped
	     * value. Explicit chaining may be enabled using `_.chain`. The execution of
	     * chained methods is lazy, that is, execution is deferred until `_#value`
	     * is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization strategy which merge iteratee calls; this can help
	     * to avoid the creation of intermediate data structures and greatly reduce the
	     * number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
	     * `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
	     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
	     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
	     * and `where`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
	     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
	     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
	     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
	     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
	     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
	     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
	     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
	     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
	     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
	     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
	     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
	     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
	     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
	     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
	     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
	     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
	     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
	     * `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper method `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(total, n) {
	     *   return total + n;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) {
	     *   return n * n;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The function whose prototype all chaining wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }

	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    (function(x) {
	      var Ctor = function() { this.x = x; },
	          object = { '0': x, 'length': x },
	          props = [];

	      Ctor.prototype = { 'valueOf': x, 'y': x };
	      for (var key in new Ctor) { props.push(key); }

	      /**
	       * Detect if `name` or `message` properties of `Error.prototype` are
	       * enumerable by default (IE < 9, Safari < 5.1).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||
	        propertyIsEnumerable.call(errorProto, 'name');

	      /**
	       * Detect if `prototype` properties are enumerable by default.
	       *
	       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
	       * (if the prototype or a property on the prototype has been set)
	       * incorrectly set the `[[Enumerable]]` value of a function's `prototype`
	       * property to `true`.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');

	      /**
	       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
	       *
	       * In IE < 9 an object's own properties, shadowing non-enumerable ones,
	       * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.nonEnumShadows = !/valueOf/.test(props);

	      /**
	       * Detect if own properties are iterated after inherited properties (IE < 9).
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.ownLast = props[0] != 'x';

	      /**
	       * Detect if `Array#shift` and `Array#splice` augment array-like objects
	       * correctly.
	       *
	       * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array
	       * `shift()` and `splice()` functions that fail to remove the last element,
	       * `value[0]`, of array-like objects even though the "length" property is
	       * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,
	       * while `splice()` is buggy regardless of mode in IE < 9.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.spliceObjects = (splice.call(object, 0, 1), !object[0]);

	      /**
	       * Detect lack of support for accessing string characters by index.
	       *
	       * IE < 8 can't access characters by index. IE 8 can only access characters
	       * by index on string literals, not string objects.
	       *
	       * @memberOf _.support
	       * @type boolean
	       */
	      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
	    }(1, 0));

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = arrayCopy(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = arrayCopy(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = arrayCopy(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }

	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }

	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }

	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }

	    /**
	     * Sets `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;

	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }

	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	      return result ? 0 : -1;
	    }

	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a new array joining `array` with `other`.
	     *
	     * @private
	     * @param {Array} array The array to join.
	     * @param {Array} other The other array to join.
	     * @returns {Array} Returns the new concatenated array.
	     */
	    function arrayConcat(array, other) {
	      var index = -1,
	          length = array.length,
	          othIndex = -1,
	          othLength = other.length,
	          result = Array(length + othLength);

	      while (++index < length) {
	        result[index] = array[index];
	      }
	      while (++othIndex < othLength) {
	        result[index++] = other[othIndex];
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;

	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
	     * with one argument: (value).
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function arrayExtremum(array, iteratee, comparator, exValue) {
	      var index = -1,
	          length = array.length,
	          computed = exValue,
	          result = computed;

	      while (++index < length) {
	        var value = array[index],
	            current = +iteratee(value);

	        if (comparator(current, computed)) {
	          computed = current;
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }

	    /**
	     * Appends the elements of `values` to `array`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to append.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayPush(array, values) {
	      var index = -1,
	          length = values.length,
	          offset = array.length;

	      while (++index < length) {
	        array[offset + index] = values[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;

	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `_.sum` for arrays without support for callback
	     * shorthands and `this` binding..
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function arraySum(array, iteratee) {
	      var length = array.length,
	          result = 0;

	      while (length--) {
	        result += +iteratee(array[length]) || 0;
	      }
	      return result;
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : objectValue;
	    }

	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This function is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (objectValue === undefined || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }

	    /**
	     * A specialized version of `_.assign` for customizing assigned values without
	     * support for argument juggling, multiple sources, and `this` binding `customizer`
	     * functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     */
	    function assignWith(object, source, customizer) {
	      var index = -1,
	          props = keys(source),
	          length = props.length;

	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);

	        if ((result === result ? (result !== value) : (value === value)) ||
	            (value === undefined && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return source == null
	        ? object
	        : baseCopy(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.at` without support for string collections
	     * and individual key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} props The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          isNil = collection == null,
	          isArr = !isNil && isArrayLike(collection),
	          length = isArr ? collection.length : 0,
	          propsLength = props.length,
	          result = Array(propsLength);

	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = isNil ? undefined : collection[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, props, object) {
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return thisArg === undefined
	          ? func
	          : bindCallback(func, thisArg, argCount);
	      }
	      if (func == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return baseMatches(func);
	      }
	      return thisArg === undefined
	        ? property(func)
	        : baseMatchesProperty(func, thisArg);
	    }

	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;

	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          if (isHostObject(value)) {
	            return object ? value : {};
	          }
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseAssign(result, value);
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);

	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          object.prototype = prototype;
	          var result = new object;
	          object.prototype = undefined;
	        }
	        return result || {};
	      };
	    }());

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];

	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf === baseIndexOf,
	          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
	          valuesLength = values.length;

	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];

	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value, 0) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(collection, iteratee, comparator, exValue) {
	      var computed = exValue,
	          result = computed;

	      baseEach(collection, function(value, index, collection) {
	        var current = +iteratee(value, index, collection);
	        if (comparator(current, computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end >>> 0);
	      start >>>= 0;

	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, result) {
	      result || (result = []);

	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index];
	        if (isObjectLike(value) && isArrayLike(value) &&
	            (isStrict || isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, isDeep, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `get` without support for string paths
	     * and default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path of the property to get.
	     * @param {string} [pathKey] The key representation of path.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path, pathKey) {
	      if (object == null) {
	        return;
	      }
	      object = toObject(object);
	      if (pathKey !== undefined && pathKey in object) {
	        path = [pathKey];
	      }
	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = toObject(object)[path[index++]];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag && !isHostObject(object),
	          othIsObj = othTag == objectTag && !isHostObject(other),
	          isSameTag = objTag == othTag;

	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      if (!isLoose) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);

	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

	      stackA.pop();
	      stackB.pop();

	      return result;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} matchData The propery names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = toObject(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which does not clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        var key = matchData[0][0],
	            value = matchData[0][1];

	        return function(object) {
	          if (object == null) {
	            return false;
	          }
	          object = toObject(object);
	          return object[key] === value && (value !== undefined || (key in object));
	        };
	      }
	      return function(object) {
	        return baseIsMatch(object, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to compare.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      var isArr = isArray(path),
	          isCommon = isKey(path) && isStrictComparable(srcValue),
	          pathKey = (path + '');

	      path = toPath(path);
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        var key = pathKey;
	        object = toObject(object);
	        if ((isArr || !isCommon) && !(key in object)) {
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          if (object == null) {
	            return false;
	          }
	          key = last(path);
	          object = toObject(object);
	        }
	        return object[key] === srcValue
	          ? (srcValue !== undefined || (key in object))
	          : baseIsEqual(srcValue, object[key], undefined, true);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns `object`.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      if (!isObject(object)) {
	        return object;
	      }
	      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
	          props = isSrcArr ? undefined : keys(source);

	      arrayEach(props || source, function(srcValue, key) {
	        if (props) {
	          key = srcValue;
	          srcValue = source[key];
	        }
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        else {
	          var value = object[key],
	              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	              isCommon = result === undefined;

	          if (isCommon) {
	            result = srcValue;
	          }
	          if ((result !== undefined || (isSrcArr && !(key in object))) &&
	              (isCommon || (result === result ? (result !== value) : (value === value)))) {
	            object[key] = result;
	          }
	        }
	      });
	      return object;
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];

	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = result === undefined;

	      if (isCommon) {
	        result = srcValue;
	        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (isArrayLike(value) ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);

	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? (result !== value) : (value === value)) {
	        object[key] = result;
	      }
	    }

	    /**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : toObject(object)[key];
	      };
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function basePropertyDeep(path) {
	      var pathKey = (path + '');
	      path = toPath(path);
	      return function(object) {
	        return baseGet(object, path, pathKey);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments and capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0;
	      while (length--) {
	        var index = indexes[length];
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + nativeFloor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands and `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortBy` which uses `comparer` to define
	     * the sort order of `array` and replaces criteria objects with their
	     * corresponding values.
	     *
	     * @private
	     * @param {Array} array The array to sort.
	     * @param {Function} comparer The function to define sort order.
	     * @returns {Array} Returns `array`.
	     */
	    function baseSortBy(array, comparer) {
	      var length = array.length;

	      array.sort(comparer);
	      while (length--) {
	        array[length] = array[length].value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.sortByOrder` without param guards.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseSortByOrder(collection, iteratees, orders) {
	      var callback = getCallback(),
	          index = -1;

	      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

	      var result = baseMap(collection, function(value) {
	        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.sum` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function baseSum(collection, iteratee) {
	      var result = 0;
	      baseEach(collection, function(value, index, collection) {
	        result += +iteratee(value, index, collection) || 0;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf === baseIndexOf,
	          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	          seen = isLarge ? createCache() : null,
	          result = [];

	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;

	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed, 0) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * of `props`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
	     * and `_.takeWhile` without support for callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;

	      while (++index < length) {
	        var action = actions[index];
	        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }
	      return result;
	    }

	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsUndef = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isDef = computed !== undefined,
	            isReflexive = computed === computed;

	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsNull) {
	          setLow = isReflexive && isDef && (retHighest || computed != null);
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || isDef);
	        } else if (computed == null) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (thisArg === undefined) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }

	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      var result = new ArrayBuffer(buffer.byteLength),
	          view = new Uint8Array(result);

	      view.set(new Uint8Array(buffer));
	      return result;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(leftLength + argsLength);

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);

	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[offset + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return restParam(function(object, sources) {
	        var index = -1,
	            length = object == null ? 0 : sources.length,
	            customizer = length > 2 ? sources[length - 2] : undefined,
	            guard = length > 2 ? sources[2] : undefined,
	            thisArg = length > 1 ? sources[length - 1] : undefined;

	        if (typeof customizer == 'function') {
	          customizer = bindCallback(customizer, thisArg, 5);
	          length -= 2;
	        } else {
	          customizer = typeof thisArg == 'function' ? thisArg : undefined;
	          length -= (customizer ? 1 : 0);
	        }
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        var length = collection ? getLength(collection) : 0;
	        if (!isLength(length)) {
	          return eachFunc(collection, iteratee);
	        }
	        var index = fromRight ? length : -1,
	            iterable = toObject(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var iterable = toObject(object),
	            props = keysFunc(object),
	            length = props.length,
	            index = fromRight ? length : -1;

	        while ((fromRight ? index-- : ++index < length)) {
	          var key = props[index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(thisArg, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    function createCache(values) {
	      return (nativeCreate && Set) ? new SetCache(values) : null;
	    }

	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';

	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors.
	        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a `_.curry` or `_.curryRight` function.
	     *
	     * @private
	     * @param {boolean} flag The curry bit flag.
	     * @returns {Function} Returns the new curry function.
	     */
	    function createCurry(flag) {
	      function curryFunc(func, arity, guard) {
	        if (guard && isIterateeCall(func, arity, guard)) {
	          arity = undefined;
	        }
	        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
	        result.placeholder = curryFunc.placeholder;
	        return result;
	      }
	      return curryFunc;
	    }

	    /**
	     * Creates a `_.defaults` or `_.defaultsDeep` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Function} Returns the new defaults function.
	     */
	    function createDefaults(assigner, customizer) {
	      return restParam(function(args) {
	        var object = args[0];
	        if (object == null) {
	          return object;
	        }
	        args.push(customizer);
	        return assigner.apply(undefined, args);
	      });
	    }

	    /**
	     * Creates a `_.max` or `_.min` function.
	     *
	     * @private
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(comparator, exValue) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = undefined;
	        }
	        iteratee = getCallback(iteratee, thisArg, 3);
	        if (iteratee.length == 1) {
	          collection = isArray(collection) ? collection : toIterable(collection);
	          var result = arrayExtremum(collection, iteratee, comparator, exValue);
	          if (!(collection.length && result === exValue)) {
	            return result;
	          }
	        }
	        return baseExtremum(collection, iteratee, comparator, exValue);
	      };
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(eachFunc, fromRight) {
	      return function(collection, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        if (isArray(collection)) {
	          var index = baseFindIndex(collection, predicate, fromRight);
	          return index > -1 ? collection[index] : undefined;
	        }
	        return baseFind(collection, predicate, eachFunc);
	      };
	    }

	    /**
	     * Creates a `_.findIndex` or `_.findLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindIndex(fromRight) {
	      return function(array, predicate, thisArg) {
	        if (!(array && array.length)) {
	          return -1;
	        }
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFindIndex(array, predicate, fromRight);
	      };
	    }

	    /**
	     * Creates a `_.findKey` or `_.findLastKey` function.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindKey(objectFunc) {
	      return function(object, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFind(object, predicate, objectFunc, true);
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return function() {
	        var wrapper,
	            length = arguments.length,
	            index = fromRight ? length : -1,
	            leftIndex = 0,
	            funcs = Array(length);

	        while ((fromRight ? index-- : ++index < length)) {
	          var func = funcs[leftIndex++] = arguments[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
	            wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? -1 : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      };
	    }

	    /**
	     * Creates a function for `_.forEach` or `_.forEachRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForEach(arrayFunc, eachFunc) {
	      return function(collection, iteratee, thisArg) {
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee)
	          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	      };
	    }

	    /**
	     * Creates a function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForIn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee, keysIn);
	      };
	    }

	    /**
	     * Creates a function for `_.forOwn` or `_.forOwnRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForOwn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee);
	      };
	    }

	    /**
	     * Creates a function for `_.mapKeys` or `_.mapValues`.
	     *
	     * @private
	     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
	     * @returns {Function} Returns the new map function.
	     */
	    function createObjectMapper(isMapKeys) {
	      return function(object, iteratee, thisArg) {
	        var result = {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        baseForOwn(object, function(value, key, object) {
	          var mapped = iteratee(value, key, object);
	          key = isMapKeys ? mapped : key;
	          value = isMapKeys ? value : mapped;
	          result[key] = value;
	        });
	        return result;
	      };
	    }

	    /**
	     * Creates a function for `_.padLeft` or `_.padRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify padding from the right.
	     * @returns {Function} Returns the new pad function.
	     */
	    function createPadDir(fromRight) {
	      return function(string, length, chars) {
	        string = baseToString(string);
	        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
	      };
	    }

	    /**
	     * Creates a `_.partial` or `_.partialRight` function.
	     *
	     * @private
	     * @param {boolean} flag The partial bit flag.
	     * @returns {Function} Returns the new partial function.
	     */
	    function createPartial(flag) {
	      var partialFunc = restParam(function(func, partials) {
	        var holders = replaceHolders(partials, partialFunc.placeholder);
	        return createWrapper(func, flag, undefined, partials, holders);
	      });
	      return partialFunc;
	    }

	    /**
	     * Creates a function for `_.reduce` or `_.reduceRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createReduce(arrayFunc, eachFunc) {
	      return function(collection, iteratee, accumulator, thisArg) {
	        var initFromArray = arguments.length < 3;
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
	          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
	          Ctor = isBindKey ? undefined : createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);

	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : undefined,
	                newHoldersRight = isCurry ? undefined : argsHolders,
	                newPartials = isCurry ? args : undefined,
	                newPartialsRight = isCurry ? undefined : args;

	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
	                result = createHybridWrapper.apply(undefined, newData);

	            if (isLaziable(func)) {
	              setData(result, newData);
	            }
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtorWrapper(func);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates the padding required for `string` based on the given `length`.
	     * The `chars` string is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPadding(string, length, chars) {
	      var strLength = string.length;
	      length = +length;

	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength);

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        precision = precision === undefined ? 0 : (+precision || 0);
	        if (precision) {
	          precision = pow(10, precision);
	          return func(number * precision) / precision;
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {Function} Returns the new index function.
	     */
	    function createSortedIndex(retHighest) {
	      return function(array, value, iteratee, thisArg) {
	        var callback = getCallback(iteratee);
	        return (iteratee == null && callback === baseCallback)
	          ? binaryIndex(array, value, retHighest)
	          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

	      if (data) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);

	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	        return false;
	      }
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index],
	            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

	        if (result !== undefined) {
	          if (result) {
	            continue;
	          }
	          return false;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (isLoose) {
	          if (!arraySome(other, function(othValue) {
	                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	              })) {
	            return false;
	          }
	        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            : object == +other;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isLoose) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      var skipCtor = isLoose;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key],
	            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	          return false;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (!skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = array ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }

	    /**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	     * that affects Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */
	    var getLength = baseProperty('length');

	    /**
	     * Gets the propery names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = pairs(object),
	          length = result.length;

	      while (length--) {
	        result[length][2] = isStrictComparable(result[length][1]);
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = object == null ? undefined : object[key];
	      return isNative(value) ? value : undefined;
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          // Safari 5 mobile incorrectly has `Object` as the constructor of typed arrays.
	          if (Ctor instanceof Ctor) {
	            Ctor = ctorByTag[tag];
	          }
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }

	    /**
	     * Invokes the method at `path` on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function invokePath(object, path, args) {
	      if (object != null && !isKey(path, object)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        path = last(path);
	      }
	      var func = object == null ? object : object[path];
	      return func == null ? undefined : func.apply(object, args);
	    }

	    /**
	     * Checks if `value` is array-like.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(getLength(value));
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }

	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	          ? (isArrayLike(object) && isIndex(index, object.length))
	          : (type == 'string' && index in object)) {
	        var other = object[index];
	        return value === value ? (value === other) : (other !== other);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      var type = typeof value;
	      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	        return true;
	      }
	      if (isArray(value)) {
	        return false;
	      }
	      var result = !reIsDeepProp.test(value);
	      return result || (object != null && value in toObject(object));
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];

	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < ARY_FLAG;

	      var isCombo =
	        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
	        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
	        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function mergeDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties specified
	     * by `props`.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);

	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;

	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());

	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length;

	      var allowIndexes = !!length && isLength(length) &&
	        (isArray(object) || isArguments(object) || isString(object));

	      var index = -1,
	          result = [];

	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to an array-like object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isArrayLike(value)) {
	        return values(value);
	      }
	      if (lodash.support.unindexedChars && isString(value)) {
	        return value.split('');
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to an object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      if (lodash.support.unindexedChars && isString(value)) {
	        var index = -1,
	            length = value.length,
	            result = Object(value);

	        while (++index < length) {
	          result[index] = value.charAt(index);
	        }
	        return result;
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to property path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array} Returns the property path array.
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return value;
	      }
	      var result = [];
	      baseToString(value).replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(nativeFloor(size) || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of unique `array` values not included in the other
	     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [4, 2]);
	     * // => [1, 3]
	     */
	    var difference = restParam(function(array, values) {
	      return (isObjectLike(array) && isArrayLike(array))
	        ? baseDifference(array, baseFlatten(values, false, true))
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that match the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active', false), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8], '*', 1, 2);
	     * // => [4, '*', 8]
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(chr) {
	     *   return chr.user == 'barney';
	     * });
	     * // => 0
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findIndex(users, 'active', false);
	     * // => 0
	     *
	     * // using the `_.property` callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    var findIndex = createFindIndex();

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) {
	     *   return chr.user == 'pebbles';
	     * });
	     * // => 2
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastIndex(users, 'active', false);
	     * // => 2
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    var findLastIndex = createFindIndex(true);

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }

	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it's only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, [4]]
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2, 3, [4]]], true);
	     * // => [1, 2, 3, 4]
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }

	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, 4]
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the offset
	     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
	     * performs a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     *
	     * // performing a binary search
	     * _.indexOf([1, 1, 2, 2], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value);
	        if (index < length &&
	            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
	          return index;
	        }
	        return -1;
	      }
	      return baseIndexOf(array, value, fromIndex || 0);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }

	    /**
	     * Creates an array of unique values that are included in all of the provided
	     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     * _.intersection([1, 2], [4, 2], [2, 1]);
	     * // => [2]
	     */
	    var intersection = restParam(function(arrays) {
	      var othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(length),
	          indexOf = getIndexOf(),
	          isCommon = indexOf === baseIndexOf,
	          result = [];

	      while (othIndex--) {
	        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
	        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
	      }
	      var array = arrays[0],
	          index = -1,
	          length = array ? array.length : 0,
	          seen = caches[0];

	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
	          var othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    });

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([1, 1, 2, 2], 2, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        if (value === value ? (value === other) : (other !== other)) {
	          return index;
	        }
	        return -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var args = arguments,
	          array = args[0];

	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = args.length;

	      while (++index < length) {
	        var fromIndex = 0,
	            value = args[index];

	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, 1, 3);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    var pullAt = restParam(function(array, indexes) {
	      indexes = baseFlatten(indexes);

	      var result = baseAt(array, indexes);
	      basePullAt(array, indexes.sort(baseCompareAscending));
	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it's invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    var sortedIndex = createSortedIndex();

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5], 5);
	     * // => 4
	     */
	    var sortedLastIndex = createSortedIndex(true);

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active', false), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all of the provided arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2], [4, 2], [2, 1]);
	     * // => [1, 2, 4]
	     */
	    var union = restParam(function(arrays) {
	      return baseUniq(baseFlatten(arrays, false, true));
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurence of each element
	     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	     * for sorted arrays. If an iteratee function is provided it's invoked for
	     * each element in the array to generate the criterion by which uniqueness
	     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, array).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the `_.property` callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (isSorted != null && typeof isSorted != 'boolean') {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	        isSorted = false;
	      }
	      var callback = getCallback();
	      if (!(iteratee == null && callback === baseCallback)) {
	        iteratee = callback(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() === baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var index = -1,
	          length = 0;

	      array = arrayFilter(array, function(group) {
	        if (isArrayLike(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts an iteratee to specify
	     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee] The function to combine regrouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      iteratee = bindCallback(iteratee, thisArg, 4);
	      return arrayMap(result, function(group) {
	        return arrayReduce(group, iteratee, undefined, true);
	      });
	    }

	    /**
	     * Creates an array excluding all provided values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 3], 1, 2);
	     * // => [3]
	     */
	    var without = restParam(function(array, values) {
	      return isArrayLike(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the provided arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2], [4, 2]);
	     * // => [1, 4]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArrayLike(array)) {
	          var result = result
	            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    var zip = restParam(unzip);

	    /**
	     * The inverse of `_.pairs`; this method returns an object composed from arrays
	     * of property names and values. Provide either a single two dimensional array,
	     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
	     * and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};

	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an iteratee to specify
	     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee] The function to combine grouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
	     * // => [111, 222]
	     */
	    var zipWith = restParam(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 2 ? arrays[length - 2] : undefined,
	          thisArg = length > 1 ? arrays[length - 1] : undefined;

	      if (length > 2 && typeof iteratee == 'function') {
	        length -= 2;
	      } else {
	        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
	        thisArg = undefined;
	      }
	      arrays.length = length;
	      return unzipWith(arrays, iteratee, thisArg);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) {
	     *     return chr.user + ' is ' + chr.age;
	     *   })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Creates a new array joining a wrapped array with any additional arrays
	     * and/or values.
	     *
	     * @name concat
	     * @memberOf _
	     * @category Chain
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var wrapped = _(array).concat(2, [3], [[4]]);
	     *
	     * console.log(wrapped.value());
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    var wrapperConcat = restParam(function(values) {
	      values = baseFlatten(values);
	      return this.thru(function(array) {
	        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
	      });
	    });

	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).map(function(value) {
	     *   return Math.pow(value, 2);
	     * });
	     *
	     * var other = [3, 4];
	     * var otherWrapped = wrapped.plant(other);
	     *
	     * otherWrapped.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;

	      var interceptor = function(value) {
	        return value.reverse();
	      };
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(interceptor);
	    }

	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }

	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c'], [0, 2]);
	     * // => ['a', 'c']
	     *
	     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
	     * // => ['barney', 'pebbles']
	     */
	    var at = restParam(function(collection, props) {
	      if (isArrayLike(collection)) {
	        collection = toIterable(collection);
	      }
	      return baseAt(collection, baseFlatten(props));
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.every(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.filter([4, 5, 6], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 6]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.filter(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) {
	     *   return chr.age < 40;
	     * }), 'user');
	     * // => 'barney'
	     *
	     * // using the `_.matches` callback shorthand
	     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.result(_.find(users, 'active', false), 'user');
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'barney'
	     */
	    var find = createFind(baseEach);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(baseEachRight, true);

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }

	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection). Iteratee functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length" property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEach(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	     *   console.log(n, key);
	     * });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    var forEach = createForEach(arrayEach, baseEach);

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEachRight(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from right to left and returns the array
	     */
	    var forEachRight = createForEach(arrayEachRight, baseEachRight);

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the `_.property` callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });

	    /**
	     * Checks if `target` is in `collection` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the offset
	     * from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex, guard) {
	      var length = collection ? getLength(collection) : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
	        fromIndex = 0;
	      } else {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
	        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return String.fromCharCode(object.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return this.fromCharCode(object.code);
	     * }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function it's
	     * invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invoke = restParam(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	     * `sum`, `uniq`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function timesThree(n) {
	     *   return n * 3;
	     * }
	     *
	     * _.map([1, 2], timesThree);
	     * // => [3, 6]
	     *
	     * _.map({ 'a': 1, 'b': 2 }, timesThree);
	     * // => [3, 6] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) {
	     *   return n % 2;
	     * });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) {
	     *   return this.floor(n) % 2;
	     * }, Math);
	     * // => [[1.2, 3.4], [2.3]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * var mapper = function(array) {
	     *   return _.pluck(array, 'user');
	     * };
	     *
	     * // using the `_.matches` callback shorthand
	     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.map(_.partition(users, 'active', false), mapper);
	     * // => [['barney', 'pebbles'], ['fred']]
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(_.partition(users, 'active'), mapper);
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Gets the property value of `path` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|string} path The path of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, path) {
	      return map(collection, property(path));
	    }

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
	     * and `sortByOrder`
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.reduce([1, 2], function(total, n) {
	     *   return total + n;
	     * });
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
	     */
	    var reduce = createReduce(arrayReduce, baseEach);

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.reject([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.reject(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }

	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var index = -1,
	          result = toArray(collection),
	          length = result.length,
	          lastIndex = length - 1;

	      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
	      while (++index < n) {
	        var rand = baseRandom(index, lastIndex),
	            value = result[rand];

	        result[rand] = result[index];
	        result[index] = value;
	      }
	      result.length = n;
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      return sample(collection, POSITIVE_INFINITY);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? getLength(collection) : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.some(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return Math.sin(n);
	     * });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return this.sin(n);
	     * }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      if (collection == null) {
	        return [];
	      }
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      var index = -1;
	      iteratee = getCallback(iteratee, thisArg, 3);

	      var result = baseMap(collection, function(value, key, collection) {
	        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }

	    /**
	     * This method is like `_.sortBy` except that it can sort by multiple iteratees
	     * or property names.
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
	     *  The iteratees to sort by, specified as individual values or arrays of values.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
	     *
	     * _.map(_.sortByAll(users, 'user', function(chr) {
	     *   return Math.floor(chr.age / 10);
	     * }), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    var sortByAll = restParam(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var guard = iteratees[2];
	      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
	        iteratees.length = 1;
	      }
	      return baseSortByOrder(collection, baseFlatten(iteratees), []);
	    });

	    /**
	     * This method is like `_.sortByAll` except that it allows specifying the
	     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
	     * values are sorted in ascending order. Otherwise, a value is sorted in
	     * ascending order if its corresponding order is "asc", and descending if "desc".
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // sort by `user` in ascending order and by `age` in descending order
	     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    function sortByOrder(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (guard && isIterateeCall(iteratees, orders, guard)) {
	        orders = undefined;
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseSortByOrder(collection, iteratees, orders);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = undefined;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = restParam(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bind.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the "length" property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    var bindAll = restParam(function(object, methodNames) {
	      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

	      var index = -1,
	          length = methodNames.length;

	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = restParam(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bindKey.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    var curry = createCurry(CURRY_FLAG);

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    var curryRight = createCurry(CURRY_RIGHT_FLAG);

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the debounced function return the result of the last
	     * `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it's invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : (+wait || 0);
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = !!options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        lastCalled = 0;
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }

	      function complete(isCalled, id) {
	        if (id) {
	          clearTimeout(id);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (isCalled) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = undefined;
	          }
	        }
	      }

	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          complete(trailingCall, maxTimeoutId);
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }

	      function maxDelayed() {
	        complete(trailing, timeoutId);
	      }

	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = undefined;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    var defer = restParam(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    var delay = restParam(function(func, wait, args) {
	      return baseDelay(func, wait, args);
	    });

	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(_.add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, _.add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }

	    /**
	     * Creates a function that runs each argument through a corresponding
	     * transform function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms] The functions to transform
	     * arguments, specified as individual functions or arrays of functions.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var modded = _.modArgs(function(x, y) {
	     *   return [x, y];
	     * }, square, doubled);
	     *
	     * modded(1, 2);
	     * // => [1, 4]
	     *
	     * modded(5, 10);
	     * // => [25, 20]
	     */
	    var modArgs = restParam(function(func, transforms) {
	      transforms = baseFlatten(transforms);
	      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = transforms.length;
	      return restParam(function(args) {
	        var index = nativeMin(args.length, length);
	        while (index--) {
	          args[index] = transforms[index](args[index]);
	        }
	        return func.apply(this, args);
	      });
	    });

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = createPartial(PARTIAL_FLAG);

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) {
	     *   return n * 3;
	     * }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    var rearg = restParam(function(func, indexes) {
	      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as an array.
	     *
	     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.restParam(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function restParam(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            rest = Array(length);

	        while (++index < length) {
	          rest[index] = args[start + index];
	        }
	        switch (start) {
	          case 0: return func.call(this, rest);
	          case 1: return func.call(this, args[0], rest);
	          case 2: return func.call(this, args[0], args[1], rest);
	        }
	        var otherArgs = Array(start + 1);
	        index = -1;
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = rest;
	        return func.apply(this, otherArgs);
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the created
	     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
	     *
	     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/Web/JavaScript/Reference/Operators/Spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(this, array);
	      };
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed invocations. Provide an options object to indicate
	     * that `func` should be invoked on the leading and/or trailing edge of the
	     * `wait` timeout. Subsequent calls to the throttled function return the
	     * result of the last `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it's
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with up to three argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.clone(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
	        isDeep = false;
	      }
	      else if (typeof isDeep == 'function') {
	        thisArg = customizer;
	        customizer = isDeep;
	        isDeep = false;
	      }
	      return typeof customizer == 'function'
	        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))
	        : baseClone(value, isDeep);
	    }

	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it's invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with up to three argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      return typeof customizer == 'function'
	        ? baseClone(value, true, bindCallback(customizer, thisArg, 3))
	        : baseClone(value, true);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    function gt(value, other) {
	      return value > other;
	    }

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    function gte(value, other) {
	      return value >= other;
	    }

	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return isObjectLike(value) && isArrayLike(value) &&
	        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	    }

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(function() { return arguments; }());
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	    };

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return isObjectLike(value) && objToString.call(value) == dateTag;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is empty. A value is considered empty unless it's an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !value.length;
	      }
	      return !keys(value).length;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it's invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with up to
	     * three arguments: (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @alias eq
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
	     *     return true;
	     *   }
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in older versions of Chrome and Safari which return 'function' for regexes
	      // and Safari 8 which returns 'object' for typed array constructors.
	      return isObject(value) && objToString.call(value) == funcTag;
	    }

	    /**
	     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return !!value && (type == 'object' || type == 'function');
	    }

	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it's invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments: (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      return baseIsMatch(object, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
	     * which returns `true` for `undefined` and other non-numeric values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (isFunction(value)) {
	        return reIsNative.test(fnToString.call(value));
	      }
	      return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      var Ctor;

	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||
	          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      if (lodash.support.ownLast) {
	        baseForIn(value, function(subValue, key, object) {
	          result = hasOwnProperty.call(object, key);
	          return false;
	        });
	        return result !== false;
	      }
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return result === undefined || hasOwnProperty.call(value, result);
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return isObject(value) && objToString.call(value) == regexpTag;
	    }

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    function lt(value, other) {
	      return value < other;
	    }

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    function lte(value, other) {
	      return value <= other;
	    }

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() {
	     *   return _.toArray(arguments).slice(1);
	     * }(1, 2, 3));
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? getLength(value) : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return (lodash.support.unindexedChars && isString(value))
	        ? value.split('')
	        : arrayCopy(value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it's invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments: (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   if (_.isArray(a)) {
	     *     return a.concat(b);
	     *   }
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it's invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments:
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * **Note:** This method mutates `object` and is based on
	     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return _.isUndefined(value) ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(function(object, source, customizer) {
	      return customizer
	        ? assignWith(object, source, customizer)
	        : baseAssign(object, source);
	    });

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = undefined;
	      }
	      return properties ? baseAssign(result, properties) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var defaults = createDefaults(assign, assignDefaults);

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */
	    var defaultsDeep = createDefaults(merge, mergeDefaults);

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    var findKey = createFindKey(baseForOwn);

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    var findLastKey = createFindKey(baseForOwnRight);

	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    var forIn = createForIn(baseFor);

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    var forInRight = createForIn(baseForRight);

	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' and 'b' (iteration order is not guaranteed)
	     */
	    var forOwn = createForOwn(baseForOwn);

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
	     */
	    var forOwnRight = createForOwn(baseForOwnRight);

	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['after', 'ary', 'assign', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the property value at `path` of `object`. If the resolved value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, toPath(path), (path + ''));
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': { 'c': 3 } } };
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b.c');
	     * // => true
	     *
	     * _.has(object, ['a', 'b', 'c']);
	     * // => true
	     */
	    function has(object, path) {
	      if (object == null) {
	        return false;
	      }
	      var result = hasOwnProperty.call(object, path);
	      if (!result && !isKey(path)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        if (object == null) {
	          return false;
	        }
	        path = last(path);
	        result = hasOwnProperty.call(object, path);
	      }
	      return result || (isLength(object.length) && isIndex(path, object.length) &&
	        (isArray(object) || isArguments(object) || isString(object)));
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     *
	     * // with `multiValue`
	     * _.invert(object, true);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = undefined;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      var Ctor = object == null ? undefined : object.constructor;
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	          (typeof object == 'function' ? lodash.support.enumPrototypes : isArrayLike(object))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length,
	          support = lodash.support;

	      length = (length && isLength(length) &&
	        (isArray(object) || isArguments(object) || isString(object)) && length) || 0;

	      var Ctor = object.constructor,
	          index = -1,
	          proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,
	          isProto = proto === object,
	          result = Array(length),
	          skipIndexes = length > 0,
	          skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),
	          skipProto = support.enumPrototypes && isFunction(object);

	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      // lodash skips the `constructor` property when it infers it's iterating
	      // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`
	      // attribute of an existing property and the `constructor` property of a
	      // prototype defaults to non-enumerable.
	      for (var key in object) {
	        if (!(skipProto && key == 'prototype') &&
	            !(skipErrorProps && (key == 'message' || key == 'name')) &&
	            !(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      if (support.nonEnumShadows && object !== objectProto) {
	        var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),
	            nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];

	        if (tag == objectTag) {
	          proto = objectProto;
	        }
	        length = shadowProps.length;
	        while (length--) {
	          key = shadowProps[length];
	          var nonEnum = nonEnums[key];
	          if (!(isProto && nonEnum) &&
	              (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {
	            result.push(key);
	          }
	        }
	      }
	      return result;
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * property of `object` through `iteratee`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    var mapKeys = createObjectMapper(true);

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
	     *   return n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the `_.property` callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    var mapValues = createObjectMapper();

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    var omit = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof props[0] != 'function') {
	        var props = arrayMap(baseFlatten(props), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      var predicate = bindCallback(props[0], props[1], 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    });

	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      object = toObject(object);

	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it's invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    var pick = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      return typeof props[0] == 'function'
	        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
	        : pickByArray(object, baseFlatten(props));
	    });

	    /**
	     * This method is like `_.get` except that if the resolved value is a function
	     * it's invoked with the `this` binding of its parent object and its result
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a.b.c', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a.b.c', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      var result = object == null ? undefined : toObject(object)[path];
	      if (result === undefined) {
	        if (object != null && !isKey(path, object)) {
	          path = toPath(path);
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          result = object == null ? undefined : toObject(object)[last(path)];
	        }
	        result = result === undefined ? defaultValue : result;
	      }
	      return isFunction(result) ? result.call(object) : result;
	    }

	    /**
	     * Sets the property value of `path` on `object`. If a portion of `path`
	     * does not exist it's created.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to augment.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, 'x[0].y.z', 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      if (object == null) {
	        return object;
	      }
	      var pathKey = (path + '');
	      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = path[index];
	        if (isObject(nested)) {
	          if (index == lastIndex) {
	            nested[key] = value;
	          } else if (nested[key] == null) {
	            nested[key] = isIndex(path[index + 1]) ? [] : {};
	          }
	        }
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments: (accumulator, value, key, object). Iteratee functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);

	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Checks if `n` is between `start` and up to but not including, `end`. If
	     * `end` is not specified it's set to `start` with `start` then set to `0`.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} n The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     */
	    function inRange(value, start, end) {
	      start = +start || 0;
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      return value >= nativeMin(start, end) && value < nativeMax(start, end);
	    }

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = undefined;
	      }
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });

	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }

	    /**
	     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : nativeMin(position < 0 ? 0 : (+position || 0), length);

	      position -= target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	     * for more details.
	     *
	     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	     * to reduce XSS vectors.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
	     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, escapeRegExpChar)
	        : (string || '(?:)');
	    }

	    /**
	     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;

	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = nativeFloor(mid),
	          rightLength = nativeCeil(mid);

	      chars = createPadding('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    var padLeft = createPadDir();

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    var padRight = createPadDir(true);

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
	     * of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	      // Chrome fails to trim leading <BOM> whitespace characters.
	      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      string = trim(string);
	      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        string += string;
	      } while (n);

	      return result;
	    }

	    /**
	     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null
	        ? 0
	        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

	      return string.lastIndexOf(target, position) == position;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        options = otherOptions = undefined;
	      }
	      string = baseToString(string);
	      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string));
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1);
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? (+options.length || 0) : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);

	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = undefined;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = restParam(function(func, args) {
	      try {
	        return func.apply(undefined, args);
	      } catch(e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt'
	     *       ? object[match[1]] > match[3]
	     *       : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = undefined;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     *
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Creates a function that compares the property value of `path` on a given
	     * object to `value`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }

	    /**
	     * Creates a function that invokes the method at `path` on a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': _.constant(2) } } },
	     *   { 'a': { 'b': { 'c': _.constant(1) } } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    var method = restParam(function(path, args) {
	      return function(object) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path on `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = restParam(function(object, args) {
	      return function(path) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj ? keys(source) : undefined,
	            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;

	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];

	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__),
	                    actions = result.__actions__ = arrayCopy(this.__actions__);

	                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              return func.apply(object, arrayPush([this.value()], arguments));
	            };
	          }(func));
	        }
	      }
	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      root._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function that returns `undefined` regardless of the
	     * arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that returns the property value at `path` on a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': 2 } } },
	     *   { 'a': { 'b': { 'c': 1 } } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the property value at a given path on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return baseGet(object, toPath(path), (path + ''));
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `end` is not specified it's
	     * set to `start` with `start` then set to `0`. If `end` is less than `start`
	     * a zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = undefined;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);

	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) {
	     *   mage.castSpell(n);
	     * });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
	     *
	     * _.times(3, function(n) {
	     *   this.cast(n);
	     * }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = nativeFloor(n);

	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} augend The first number to add.
	     * @param {number} addend The second number to add.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    function add(augend, addend) {
	      return (+augend || 0) + (+addend || 0);
	    }

	    /**
	     * Calculates `n` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Calculates `n` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it's invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 }
	     */
	    var max = createExtremum(gt, NEGATIVE_INFINITY);

	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it's invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var min = createExtremum(lt, POSITIVE_INFINITY);

	    /**
	     * Calculates `n` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Gets the sum of the values in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 6]);
	     * // => 10
	     *
	     * _.sum({ 'a': 4, 'b': 6 });
	     * // => 10
	     *
	     * var objects = [
	     *   { 'n': 4 },
	     *   { 'n': 6 }
	     * ];
	     *
	     * _.sum(objects, function(object) {
	     *   return object.n;
	     * });
	     * // => 10
	     *
	     * // using the `_.property` callback shorthand
	     * _.sum(objects, 'n');
	     * // => 10
	     */
	    function sum(collection, iteratee, thisArg) {
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return iteratee.length == 1
	        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
	        : baseSum(collection, iteratee);
	    }

	    /*------------------------------------------------------------------------*/

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;

	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;

	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;

	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.modArgs = modArgs;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.restParam = restParam;
	    lodash.set = set;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.sortByOrder = sortByOrder;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;

	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add functions that return unwrapped values when chaining.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.floor = floor;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.sum = sum;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;

	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.eq = isEqual;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);

	    /*------------------------------------------------------------------------*/

	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;

	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(result.__takeCount__, n);
	        } else {
	          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type != LAZY_MAP_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone();
	        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : property;

	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(value));
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.reject = function(predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 1);
	      return this.filter(function(value) {
	        return !predicate(value);
	      });
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
	      return this.reverse().takeWhile(predicate, thisArg).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(POSITIVE_INFINITY);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
	          retUnwrapped = /^(?:first|last)$/.test(methodName),
	          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var args = retUnwrapped ? [1] : arguments,
	            chainAll = this.__chain__,
	            value = this.__wrapped__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var interceptor = function(value) {
	          return (retUnwrapped && chainAll)
	            ? lodashFunc(value, 1)[0]
	            : lodashFunc.apply(undefined, arrayPush([value], args));
	        };

	        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
	            onlyLazy = isLazy && !isHybrid;

	        if (retUnwrapped && !chainAll) {
	          if (onlyLazy) {
	            value = value.clone();
	            value.__actions__.push(action);
	            return func.call(value);
	          }
	          return lodashFunc.call(undefined, this.value())[0];
	        }
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push(action);
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });

	    // Add `Array` and `String` methods to `lodash.prototype`.
	    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
	      var protoFunc = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          fixObjects = !support.spliceObjects && /^(?:pop|shift|splice)$/.test(methodName),
	          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

	      // Avoid array-like object bugs with `Array#shift` and `Array#splice` in
	      // IE < 9, Firefox < 10, and RingoJS.
	      var func = !fixObjects ? protoFunc : function() {
	        var result = protoFunc.apply(this, arguments);
	        if (this.length === 0) {
	          delete this[0];
	        }
	        return result;
	      };

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });

	    // Map minified function names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chaining functions to the `lodash` wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.concat = wrapperConcat;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add function aliases to the `lodash` wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    define(function() {
	      return _;
	    });
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Rhino with CommonJS support.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));

	},{}],15:[function(require,module,exports){
	var process=require("__browserify_process");/**
	 * Wrapper for the elasticsearch.js client, which will register the client constructor
	 * as a factory within angular that can be easily injected with Angular's awesome DI.
	 *
	 * It will also instruct the client to use Angular's $http service for it's ajax requests
	 */
	var AngularConnector = require('./lib/connectors/angular');
	var Client = require('./lib/client');

	process.angular_build = true;

	/* global angular */
	angular.module('elasticsearch', [])
	  .factory('esFactory', ['$injector', '$q', function ($injector, $q) {

	    var factory = function (config) {
	      config = config || {};
	      config.connectionClass = AngularConnector;
	      config.$injector = $injector;
	      config.defer = function () {
	        return $q.defer();
	      };
	      config.serializer = config.serializer || 'angular';
	      return new Client(config);
	    };

	    factory.errors = require('./lib/errors');
	    factory.ConnectionPool = require('./lib/connection_pool');
	    factory.Transport = require('./lib/transport');

	    return factory;
	  }]);

	},{"./lib/client":20,"./lib/connection_pool":23,"./lib/connectors/angular":24,"./lib/errors":26,"./lib/transport":39,"__browserify_process":13}],16:[function(require,module,exports){
	/* jshint maxlen: false */

	var ca = require('../client_action').makeFactoryWithModifier(function (spec) {
	  return require('../utils').merge(spec, {
	    params: {
	      filterPath: {
	        type: 'list',
	        name: 'filter_path'
	      }
	    }
	  });
	});
	var namespace = require('../client_action').namespaceFactory;
	var api = module.exports = {};

	api._namespaces = ['cat', 'cluster', 'indices', 'nodes', 'snapshot'];

	/**
	 * Perform a [bulk](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-bulk.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} [params.replication=sync] - Explicitely set the replication type
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {String} params.type - Default document type for items which don't provide one
	 * @param {String} params.index - Default index for items which don't provide one
	 */
	api.bulk = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    replication: {
	      type: 'enum',
	      'default': 'sync',
	      options: [
	        'sync',
	        'async'
	      ]
	    },
	    routing: {
	      type: 'string'
	    },
	    timeout: {
	      type: 'time'
	    },
	    type: {
	      type: 'string'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_bulk',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_bulk',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_bulk'
	    }
	  ],
	  needBody: true,
	  bulkBody: true,
	  method: 'POST'
	});

	api.cat = namespace();

	/**
	 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to return
	 */
	api.cat.prototype.aliases = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/aliases/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/aliases'
	    }
	  ]
	});

	/**
	 * Perform a [cat.allocation](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-allocation.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
	 */
	api.cat.prototype.allocation = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/allocation/<%=nodeId%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/allocation'
	    }
	  ]
	});

	/**
	 * Perform a [cat.count](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-count.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.count = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/count/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/count'
	    }
	  ]
	});

	/**
	 * Perform a [cat.fielddata](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return the fielddata size
	 */
	api.cat.prototype.fielddata = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    },
	    fields: {
	      type: 'list'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/fielddata/<%=fields%>',
	      req: {
	        fields: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/fielddata'
	    }
	  ]
	});

	/**
	 * Perform a [cat.health](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-health.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.ts=true] - Set to false to disable timestamping
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 */
	api.cat.prototype.health = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    ts: {
	      type: 'boolean',
	      'default': true
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  url: {
	    fmt: '/_cat/health'
	  }
	});

	/**
	 * Perform a [cat.help](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.help - Return help information
	 */
	api.cat.prototype.help = ca({
	  params: {
	    help: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  url: {
	    fmt: '/_cat'
	  }
	});

	/**
	 * Perform a [cat.indices](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-indices.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.pri - Set to true to return stats only for primary shards
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.indices = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    pri: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/indices/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/indices'
	    }
	  ]
	});

	/**
	 * Perform a [cat.master](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-master.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 */
	api.cat.prototype.master = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  url: {
	    fmt: '/_cat/master'
	  }
	});

	/**
	 * Perform a [cat.nodes](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-nodes.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 */
	api.cat.prototype.nodes = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  url: {
	    fmt: '/_cat/nodes'
	  }
	});

	/**
	 * Perform a [cat.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-pending-tasks.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 */
	api.cat.prototype.pendingTasks = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  url: {
	    fmt: '/_cat/pending_tasks'
	  }
	});

	/**
	 * Perform a [cat.plugins](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 */
	api.cat.prototype.plugins = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  url: {
	    fmt: '/_cat/plugins'
	  }
	});

	/**
	 * Perform a [cat.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-recovery.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.recovery = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/recovery/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/recovery'
	    }
	  ]
	});

	/**
	 * Perform a [cat.segments](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.segments = ca({
	  params: {
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/segments/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/segments'
	    }
	  ]
	});

	/**
	 * Perform a [cat.shards](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cat-shards.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.shards = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/shards/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/shards'
	    }
	  ]
	});

	/**
	 * Perform a [cat.threadPool](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.v - Verbose mode. Display column headers
	 * @param {Boolean} params.fullId - Enables displaying the complete node ids
	 */
	api.cat.prototype.threadPool = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': false
	    },
	    fullId: {
	      type: 'boolean',
	      'default': false,
	      name: 'full_id'
	    }
	  },
	  url: {
	    fmt: '/_cat/thread_pool'
	  }
	});

	/**
	 * Perform a [clearScroll](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-request-scroll.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.scrollId - A comma-separated list of scroll IDs to clear
	 */
	api.clearScroll = ca({
	  urls: [
	    {
	      fmt: '/_search/scroll/<%=scrollId%>',
	      req: {
	        scrollId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search/scroll'
	    }
	  ],
	  method: 'DELETE'
	});

	api.cluster = namespace();

	/**
	 * Perform a [cluster.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-update-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 */
	api.cluster.prototype.getSettings = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_cluster/settings'
	  }
	});

	/**
	 * Perform a [cluster.health](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-health.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} [params.level=cluster] - Specify the level of detail for returned information
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Number} params.waitForActiveShards - Wait until the specified number of shards is active
	 * @param {String} params.waitForNodes - Wait until the specified number of nodes is available
	 * @param {Number} params.waitForRelocatingShards - Wait until the specified number of relocating shards is finished
	 * @param {String} params.waitForStatus - Wait until cluster is in a specific state
	 * @param {String} params.index - Limit the information returned to a specific index
	 */
	api.cluster.prototype.health = ca({
	  params: {
	    level: {
	      type: 'enum',
	      'default': 'cluster',
	      options: [
	        'cluster',
	        'indices',
	        'shards'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    },
	    waitForActiveShards: {
	      type: 'number',
	      name: 'wait_for_active_shards'
	    },
	    waitForNodes: {
	      type: 'string',
	      name: 'wait_for_nodes'
	    },
	    waitForRelocatingShards: {
	      type: 'number',
	      name: 'wait_for_relocating_shards'
	    },
	    waitForStatus: {
	      type: 'enum',
	      'default': null,
	      options: [
	        'green',
	        'yellow',
	        'red'
	      ],
	      name: 'wait_for_status'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cluster/health/<%=index%>',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/health'
	    }
	  ]
	});

	/**
	 * Perform a [cluster.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-pending.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 */
	api.cluster.prototype.pendingTasks = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_cluster/pending_tasks'
	  }
	});

	/**
	 * Perform a [cluster.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-update-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 */
	api.cluster.prototype.putSettings = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_cluster/settings'
	  },
	  method: 'PUT'
	});

	/**
	 * Perform a [cluster.reroute](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-reroute.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.dryRun - Simulate the operation only and return the resulting state
	 * @param {Boolean} params.explain - Return an explanation of why the commands can or cannot be executed
	 * @param {String, String[], Boolean} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 */
	api.cluster.prototype.reroute = ca({
	  params: {
	    dryRun: {
	      type: 'boolean',
	      name: 'dry_run'
	    },
	    explain: {
	      type: 'boolean'
	    },
	    metric: {
	      type: 'list',
	      options: [
	        '_all',
	        'blocks',
	        'metadata',
	        'nodes',
	        'routing_table',
	        'master_node',
	        'version'
	      ]
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_cluster/reroute'
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [cluster.state](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-state.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.metric - Limit the information returned to the specified metrics
	 */
	api.cluster.prototype.state = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'blocks',
	            'metadata',
	            'nodes',
	            'routing_table',
	            'routing_nodes',
	            'master_node',
	            'version'
	          ]
	        },
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/state/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'blocks',
	            'metadata',
	            'nodes',
	            'routing_table',
	            'routing_nodes',
	            'master_node',
	            'version'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/state'
	    }
	  ]
	});

	/**
	 * Perform a [cluster.stats](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 */
	api.cluster.prototype.stats = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/stats'
	    }
	  ]
	});

	/**
	 * Perform a [count](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-count.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Number} params.minScore - Include only documents with a specific `_score` value in the result
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to restrict the results
	 * @param {String, String[], Boolean} params.type - A comma-separated list of types to restrict the results
	 */
	api.count = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    minScore: {
	      type: 'number',
	      name: 'min_score'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_count',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_count',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_count'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [countPercolate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-percolate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.percolateIndex - The index to count percolate the document into. Defaults to index.
	 * @param {String} params.percolateType - The type to count percolate document into. Defaults to type.
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.index - The index of the document being count percolated.
	 * @param {String} params.type - The type of the document being count percolated.
	 * @param {String} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
	 */
	api.countPercolate = ca({
	  params: {
	    routing: {
	      type: 'list'
	    },
	    preference: {
	      type: 'string'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    percolateIndex: {
	      type: 'string',
	      name: 'percolate_index'
	    },
	    percolateType: {
	      type: 'string',
	      name: 'percolate_type'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>/_percolate/count',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [delete](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-delete.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Specific write consistency setting for the operation
	 * @param {String} params.parent - ID of parent document
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} [params.replication=sync] - Specific replication type
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api['delete'] = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    parent: {
	      type: 'string'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    replication: {
	      type: 'enum',
	      'default': 'sync',
	      options: [
	        'sync',
	        'async'
	      ]
	    },
	    routing: {
	      type: 'string'
	    },
	    timeout: {
	      type: 'time'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [deleteByQuery](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-delete-by-query.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {String} params.consistency - Specific write consistency setting for the operation
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} [params.replication=sync] - Specific replication type
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to restrict the operation; use `_all` to perform the operation on all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of types to restrict the operation
	 */
	api.deleteByQuery = ca({
	  params: {
	    analyzer: {
	      type: 'string'
	    },
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    replication: {
	      type: 'enum',
	      'default': 'sync',
	      options: [
	        'sync',
	        'async'
	      ]
	    },
	    q: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_query',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_query',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    }
	  ],
	  method: 'DELETE'
	});

	/**
	 * Perform a [deleteScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Script ID
	 * @param {String} params.lang - Script language
	 */
	api.deleteScript = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_scripts/<%=lang%>/<%=id%>',
	    req: {
	      lang: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Template ID
	 */
	api.deleteTemplate = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_search/template/<%=id%>',
	    req: {
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [exists](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
	 */
	api.exists = ca({
	  params: {
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [explain](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-explain.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
	 * @param {String} params.analyzer - The analyzer for the query string query
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The default field for query string query (default: _all)
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.explain = ca({
	  params: {
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    fields: {
	      type: 'list'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    },
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [fieldStats](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
	 * @param {String} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.fieldStats = ca({
	  params: {
	    fields: {
	      type: 'list'
	    },
	    level: {
	      type: 'enum',
	      'default': 'cluster',
	      options: [
	        'indices',
	        'cluster'
	      ]
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_field_stats',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_field_stats'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [get](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
	 */
	api.get = ca({
	  params: {
	    fields: {
	      type: 'list'
	    },
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [getScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Script ID
	 * @param {String} params.lang - Script language
	 */
	api.getScript = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_scripts/<%=lang%>/<%=id%>',
	    req: {
	      lang: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [getSource](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
	 */
	api.getSource = ca({
	  params: {
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Template ID
	 */
	api.getTemplate = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_search/template/<%=id%>',
	    req: {
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [index](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-index_.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {String} params.parent - ID of the parent document
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} [params.replication=sync] - Specific replication type
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.timestamp - Explicit timestamp for the document
	 * @param {Duration} params.ttl - Expiration time for the document
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.index = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    opType: {
	      type: 'enum',
	      'default': 'index',
	      options: [
	        'index',
	        'create'
	      ],
	      name: 'op_type'
	    },
	    parent: {
	      type: 'string'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    replication: {
	      type: 'enum',
	      'default': 'sync',
	      options: [
	        'sync',
	        'async'
	      ]
	    },
	    routing: {
	      type: 'string'
	    },
	    timeout: {
	      type: 'time'
	    },
	    timestamp: {
	      type: 'time'
	    },
	    ttl: {
	      type: 'duration'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  needBody: true,
	  method: 'POST'
	});

	api.indices = namespace();

	/**
	 * Perform a [indices.analyze](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-analyze.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.analyzer - The name of the analyzer to use
	 * @param {String, String[], Boolean} params.charFilters - A comma-separated list of character filters to use for the analysis
	 * @param {String} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
	 * @param {String, String[], Boolean} params.filters - A comma-separated list of filters to use for the analysis
	 * @param {String} params.index - The name of the index to scope the operation
	 * @param {Boolean} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
	 * @param {String} params.text - The text on which the analysis should be performed (when request body is not used)
	 * @param {String} params.tokenizer - The name of the tokenizer to use for the analysis
	 * @param {String} [params.format=detailed] - Format of the output
	 */
	api.indices.prototype.analyze = ca({
	  params: {
	    analyzer: {
	      type: 'string'
	    },
	    charFilters: {
	      type: 'list',
	      name: 'char_filters'
	    },
	    field: {
	      type: 'string'
	    },
	    filters: {
	      type: 'list'
	    },
	    index: {
	      type: 'string'
	    },
	    preferLocal: {
	      type: 'boolean',
	      name: 'prefer_local'
	    },
	    text: {
	      type: 'string'
	    },
	    tokenizer: {
	      type: 'string'
	    },
	    format: {
	      type: 'enum',
	      'default': 'detailed',
	      options: [
	        'detailed',
	        'text'
	      ]
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_analyze',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_analyze'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.clearCache](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-clearcache.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.fieldData - Clear field data
	 * @param {Boolean} params.fielddata - Clear field data
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
	 * @param {Boolean} params.filter - Clear filter caches
	 * @param {Boolean} params.filterCache - Clear filter caches
	 * @param {Boolean} params.filterKeys - A comma-separated list of keys to clear when using the `filter_cache` parameter (default: all)
	 * @param {Boolean} params.id - Clear ID caches for parent/child
	 * @param {Boolean} params.idCache - Clear ID caches for parent/child
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index name to limit the operation
	 * @param {Boolean} params.recycler - Clear the recycler cache
	 * @param {Boolean} params.queryCache - Clear query cache
	 */
	api.indices.prototype.clearCache = ca({
	  params: {
	    fieldData: {
	      type: 'boolean',
	      name: 'field_data'
	    },
	    fielddata: {
	      type: 'boolean'
	    },
	    fields: {
	      type: 'list'
	    },
	    filter: {
	      type: 'boolean'
	    },
	    filterCache: {
	      type: 'boolean',
	      name: 'filter_cache'
	    },
	    filterKeys: {
	      type: 'boolean',
	      name: 'filter_keys'
	    },
	    id: {
	      type: 'boolean'
	    },
	    idCache: {
	      type: 'boolean',
	      name: 'id_cache'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    index: {
	      type: 'list'
	    },
	    recycler: {
	      type: 'boolean'
	    },
	    queryCache: {
	      type: 'boolean',
	      name: 'query_cache'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_cache/clear',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cache/clear'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.close](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-open-close.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The name of the index
	 */
	api.indices.prototype.close = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_close',
	    req: {
	      index: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [indices.create](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-create-index.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String} params.index - The name of the index
	 */
	api.indices.prototype.create = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>',
	    req: {
	      index: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [indices.delete](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-delete-index.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
	 */
	api.indices.prototype['delete'] = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>',
	    req: {
	      index: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.deleteAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit timestamp for the document
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
	 * @param {String, String[], Boolean} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
	 */
	api.indices.prototype.deleteAlias = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_alias/<%=name%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      name: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.deleteMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-delete-mapping.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to delete (supports wildcards); use `_all` to delete all document types in the specified indices.
	 */
	api.indices.prototype.deleteMapping = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/_mapping',
	    req: {
	      index: {
	        type: 'list'
	      },
	      type: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.deleteTemplate = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_template/<%=name%>',
	    req: {
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.deleteWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-warmers.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.name - A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.
	 */
	api.indices.prototype.deleteWarmer = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    name: {
	      type: 'list'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_warmer/<%=name%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      name: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.exists](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-exists.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to check
	 */
	api.indices.prototype.exists = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>',
	    req: {
	      index: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.existsAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to filter aliases
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to return
	 */
	api.indices.prototype.existsAlias = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': [
	        'open',
	        'closed'
	      ],
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_alias/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_alias/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_alias',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    }
	  ],
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.existsTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.existsTemplate = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/_template/<%=name%>',
	    req: {
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.existsType](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-types-exists.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to check
	 */
	api.indices.prototype.existsType = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      type: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.flush](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-flush.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
	 * @param {Boolean} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is false and will cause an exception to be thrown on the shard level if another flush operation is already running.
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
	 */
	api.indices.prototype.flush = ca({
	  params: {
	    force: {
	      type: 'boolean'
	    },
	    waitIfOngoing: {
	      type: 'boolean',
	      name: 'wait_if_ongoing'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_flush',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_flush'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.flushSynced](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 */
	api.indices.prototype.flushSynced = ca({
	  urls: [
	    {
	      fmt: '/<%=index%>/_flush/synced',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_flush/synced'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.get](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-index.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Boolean} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
	 * @param {Boolean} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
	 * @param {String} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names
	 * @param {String, String[], Boolean} params.feature - A comma-separated list of features
	 */
	api.indices.prototype.get = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=feature%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        feature: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    }
	  ]
	});

	/**
	 * Perform a [indices.getAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to filter aliases
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to return
	 */
	api.indices.prototype.getAlias = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_alias/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_alias/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_alias',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_alias'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getAliases](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to filter aliases
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to filter
	 */
	api.indices.prototype.getAliases = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_aliases/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_aliases',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_aliases/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_aliases'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getFieldMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-field-mapping.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.includeDefaults - Whether the default mapping values should be returned as well
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types
	 * @param {String, String[], Boolean} params.field - A comma-separated list of fields
	 */
	api.indices.prototype.getFieldMapping = ca({
	  params: {
	    includeDefaults: {
	      type: 'boolean',
	      name: 'include_defaults'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=field%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        },
	        field: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mapping/field/<%=field%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        field: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/<%=type%>/field/<%=field%>',
	      req: {
	        type: {
	          type: 'list'
	        },
	        field: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/field/<%=field%>',
	      req: {
	        field: {
	          type: 'list'
	        }
	      }
	    }
	  ]
	});

	/**
	 * Perform a [indices.getMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-mapping.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types
	 */
	api.indices.prototype.getMapping = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_mapping/<%=type%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mapping',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/<%=type%>',
	      req: {
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-get-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.name - The name of the settings that should be included
	 */
	api.indices.prototype.getSettings = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': [
	        'open',
	        'closed'
	      ],
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_settings/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_settings',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_settings/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_settings'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.getTemplate = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_template/<%=name%>',
	      req: {
	        name: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_template'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getUpgrade](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.getUpgrade = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_upgrade',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_upgrade'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-warmers.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices
	 * @param {String, String[], Boolean} params.name - The name of the warmer (supports wildcards); leave empty to get all warmers
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
	 */
	api.indices.prototype.getWarmer = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_warmer',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_warmer/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_warmer'
	    }
	  ]
	});

	/**
	 * Perform a [indices.open](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-open-close.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The name of the index
	 */
	api.indices.prototype.open = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'closed',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_open',
	    req: {
	      index: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [indices.optimize](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-optimize.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Number} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
	 * @param {Boolean} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {Boolean} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
	 * @param {Boolean} params.force - Force a merge operation to run, even if there is a single segment in the index (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.optimize = ca({
	  params: {
	    flush: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    maxNumSegments: {
	      type: 'number',
	      name: 'max_num_segments'
	    },
	    onlyExpungeDeletes: {
	      type: 'boolean',
	      name: 'only_expunge_deletes'
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    },
	    waitForMerge: {
	      type: 'boolean',
	      name: 'wait_for_merge'
	    },
	    force: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_optimize',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_optimize'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.putAlias](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit timestamp for the document
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
	 * @param {String} params.name - The name of the alias to be created or updated
	 */
	api.indices.prototype.putAlias = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_alias/<%=name%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putMapping](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-put-mapping.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreConflicts - Specify whether to ignore conflicts while updating the mapping (default: false)
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
	 * @param {String} params.type - The name of the document type
	 */
	api.indices.prototype.putMapping = ca({
	  params: {
	    ignoreConflicts: {
	      type: 'boolean',
	      name: 'ignore_conflicts'
	    },
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_mapping/<%=type%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/<%=type%>',
	      req: {
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-update-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.putSettings = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_settings',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_settings'
	    }
	  ],
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
	 * @param {Boolean} params.create - Whether the index template should only be added if new or can also replace an existing one
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.putTemplate = ca({
	  params: {
	    order: {
	      type: 'number'
	    },
	    create: {
	      type: 'boolean',
	      'default': false
	    },
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    }
	  },
	  url: {
	    fmt: '/_template/<%=name%>',
	    req: {
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-warmers.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices
	 * @param {String} params.name - The name of the warmer
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types
	 */
	api.indices.prototype.putWarmer = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        },
	        name: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_warmer/<%=name%>',
	      req: {
	        name: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.detailed - Whether to display detailed information about shard recovery
	 * @param {Boolean} params.activeOnly - Display only those recoveries that are currently on-going
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.recovery = ca({
	  params: {
	    detailed: {
	      type: 'boolean',
	      'default': false
	    },
	    activeOnly: {
	      type: 'boolean',
	      'default': false,
	      name: 'active_only'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_recovery',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_recovery'
	    }
	  ]
	});

	/**
	 * Perform a [indices.refresh](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-refresh.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.force - Force a refresh even if not required
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.refresh = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    force: {
	      type: 'boolean',
	      'default': false
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_refresh',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_refresh'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.segments](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-segments.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.segments = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_segments',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_segments'
	    }
	  ]
	});

	/**
	 * Perform a [indices.stats](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.groups - A comma-separated list of search groups for `search` index metric
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String} [params.level=indices] - Return stats aggregated at cluster, index or shard level
	 * @param {String, String[], Boolean} params.types - A comma-separated list of document types for the `indexing` index metric
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.metric - Limit the information returned the specific metrics.
	 */
	api.indices.prototype.stats = ca({
	  params: {
	    completionFields: {
	      type: 'list',
	      name: 'completion_fields'
	    },
	    fielddataFields: {
	      type: 'list',
	      name: 'fielddata_fields'
	    },
	    fields: {
	      type: 'list'
	    },
	    groups: {
	      type: 'list'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    },
	    level: {
	      type: 'enum',
	      'default': 'indices',
	      options: [
	        'cluster',
	        'indices',
	        'shards'
	      ]
	    },
	    types: {
	      type: 'list'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_stats/<%=metric%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'filter_cache',
	            'flush',
	            'get',
	            'id_cache',
	            'indexing',
	            'merge',
	            'percolate',
	            'query_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_stats/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'filter_cache',
	            'flush',
	            'get',
	            'id_cache',
	            'indexing',
	            'merge',
	            'percolate',
	            'query_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_stats',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_stats'
	    }
	  ]
	});

	/**
	 * Perform a [indices.status](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-status.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {Boolean} params.recovery - Return information about shard recovery
	 * @param {Boolean} params.snapshot - TODO: ?
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.status = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    },
	    recovery: {
	      type: 'boolean'
	    },
	    snapshot: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_status',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_status'
	    }
	  ]
	});

	/**
	 * Perform a [indices.updateAliases](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Request timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 */
	api.indices.prototype.updateAliases = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_aliases'
	  },
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [indices.upgrade](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: true)
	 * @param {Boolean} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.upgrade = ca({
	  params: {
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    waitForCompletion: {
	      type: 'boolean',
	      name: 'wait_for_completion'
	    },
	    onlyAncientSegments: {
	      type: 'boolean',
	      name: 'only_ancient_segments'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_upgrade',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_upgrade'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.validateQuery](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-validate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.explain - Return detailed information about the error
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {Boolean} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
	 */
	api.indices.prototype.validateQuery = ca({
	  params: {
	    explain: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    },
	    q: {
	      type: 'string'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    },
	    rewrite: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_validate/query',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_validate/query',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_validate/query'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [info](http://www.elastic.co/guide/) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 */
	api.info = ca({
	  url: {
	    fmt: '/'
	  }
	});

	/**
	 * Perform a [mget](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-multi-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.mget = ca({
	  params: {
	    fields: {
	      type: 'list'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_mget',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mget',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mget'
	    }
	  ],
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [mlt](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-more-like-this.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.boostTerms - The boost factor
	 * @param {Number} params.maxDocFreq - The word occurrence frequency as count: words with higher occurrence in the corpus will be ignored
	 * @param {Number} params.maxQueryTerms - The maximum query terms to be included in the generated query
	 * @param {Number} params.maxWordLength - The minimum length of the word: longer words will be ignored
	 * @param {Number} params.minDocFreq - The word occurrence frequency as count: words with lower occurrence in the corpus will be ignored
	 * @param {Number} params.minTermFreq - The term frequency as percent: terms with lower occurence in the source document will be ignored
	 * @param {Number} params.minWordLength - The minimum length of the word: shorter words will be ignored
	 * @param {String, String[], Boolean} params.mltFields - Specific fields to perform the query against
	 * @param {Number} params.percentTermsToMatch - How many terms have to match in order to consider the document a match (default: 0.3)
	 * @param {String} params.routing - Specific routing value
	 * @param {Number} params.searchFrom - The offset from which to return results
	 * @param {String, String[], Boolean} params.searchIndices - A comma-separated list of indices to perform the query against (default: the index containing the document)
	 * @param {String} params.searchScroll - A scroll search request definition
	 * @param {Number} params.searchSize - The number of documents to return (default: 10)
	 * @param {String} params.searchSource - A specific search request definition (instead of using the request body)
	 * @param {String} params.searchType - Specific search type (eg. `dfs_then_fetch`, `count`, etc)
	 * @param {String, String[], Boolean} params.searchTypes - A comma-separated list of types to perform the query against (default: the same type as the document)
	 * @param {String, String[], Boolean} params.stopWords - A list of stop words to be ignored
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
	 */
	api.mlt = ca({
	  params: {
	    boostTerms: {
	      type: 'number',
	      name: 'boost_terms'
	    },
	    maxDocFreq: {
	      type: 'number',
	      name: 'max_doc_freq'
	    },
	    maxQueryTerms: {
	      type: 'number',
	      name: 'max_query_terms'
	    },
	    maxWordLength: {
	      type: 'number',
	      name: 'max_word_length'
	    },
	    minDocFreq: {
	      type: 'number',
	      name: 'min_doc_freq'
	    },
	    minTermFreq: {
	      type: 'number',
	      name: 'min_term_freq'
	    },
	    minWordLength: {
	      type: 'number',
	      name: 'min_word_length'
	    },
	    mltFields: {
	      type: 'list',
	      name: 'mlt_fields'
	    },
	    percentTermsToMatch: {
	      type: 'number',
	      name: 'percent_terms_to_match'
	    },
	    routing: {
	      type: 'string'
	    },
	    searchFrom: {
	      type: 'number',
	      name: 'search_from'
	    },
	    searchIndices: {
	      type: 'list',
	      name: 'search_indices'
	    },
	    searchScroll: {
	      type: 'string',
	      name: 'search_scroll'
	    },
	    searchSize: {
	      type: 'number',
	      name: 'search_size'
	    },
	    searchSource: {
	      type: 'string',
	      name: 'search_source'
	    },
	    searchType: {
	      type: 'string',
	      name: 'search_type'
	    },
	    searchTypes: {
	      type: 'list',
	      name: 'search_types'
	    },
	    stopWords: {
	      type: 'list',
	      name: 'stop_words'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>/_mlt',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [mpercolate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-percolate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The index of the document being count percolated to use as default
	 * @param {String} params.type - The type of the document being percolated to use as default.
	 */
	api.mpercolate = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_mpercolate',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mpercolate',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mpercolate'
	    }
	  ],
	  needBody: true,
	  bulkBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [msearch](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-multi-search.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.searchType - Search operation type
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to use as default
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to use as default
	 */
	api.msearch = ca({
	  params: {
	    searchType: {
	      type: 'enum',
	      options: [
	        'query_then_fetch',
	        'query_and_fetch',
	        'dfs_query_then_fetch',
	        'dfs_query_and_fetch',
	        'count',
	        'scan'
	      ],
	      name: 'search_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_msearch',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_msearch',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_msearch'
	    }
	  ],
	  needBody: true,
	  bulkBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [mtermvectors](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-multi-termvectors.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
	 * @param {Boolean} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
	 * @param {String} params.index - The index in which the document resides.
	 * @param {String} params.type - The type of the document.
	 * @param {String} params.id - The id of the document.
	 */
	api.mtermvectors = ca({
	  params: {
	    ids: {
	      type: 'list',
	      required: false
	    },
	    termStatistics: {
	      type: 'boolean',
	      'default': false,
	      required: false,
	      name: 'term_statistics'
	    },
	    fieldStatistics: {
	      type: 'boolean',
	      'default': true,
	      required: false,
	      name: 'field_statistics'
	    },
	    fields: {
	      type: 'list',
	      required: false
	    },
	    offsets: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    positions: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    payloads: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    preference: {
	      type: 'string',
	      required: false
	    },
	    routing: {
	      type: 'string',
	      required: false
	    },
	    parent: {
	      type: 'string',
	      required: false
	    },
	    realtime: {
	      type: 'boolean',
	      required: false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mtermvectors',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mtermvectors'
	    }
	  ],
	  method: 'POST'
	});

	api.nodes = namespace();

	/**
	 * Perform a [nodes.hotThreads](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-hot-threads.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.interval - The interval for the second sampling of threads
	 * @param {Number} params.snapshots - Number of samples of thread stacktrace (default: 10)
	 * @param {Number} params.threads - Specify the number of threads to provide information for (default: 3)
	 * @param {Boolean} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
	 * @param {String} params.type - The type to sample (default: cpu)
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 */
	api.nodes.prototype.hotThreads = ca({
	  params: {
	    interval: {
	      type: 'time'
	    },
	    snapshots: {
	      type: 'number'
	    },
	    threads: {
	      type: 'number'
	    },
	    ignoreIdleThreads: {
	      type: 'boolean',
	      name: 'ignore_idle_threads'
	    },
	    type: {
	      type: 'enum',
	      options: [
	        'cpu',
	        'wait',
	        'block'
	      ]
	    }
	  },
	  urls: [
	    {
	      fmt: '/_nodes/<%=nodeId%>/hotthreads',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/hotthreads'
	    }
	  ]
	});

	/**
	 * Perform a [nodes.info](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-info.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 * @param {String, String[], Boolean} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
	 */
	api.nodes.prototype.info = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            'settings',
	            'os',
	            'process',
	            'jvm',
	            'thread_pool',
	            'network',
	            'transport',
	            'http',
	            'plugins'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=nodeId%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            'settings',
	            'os',
	            'process',
	            'jvm',
	            'thread_pool',
	            'network',
	            'transport',
	            'http',
	            'plugins'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes'
	    }
	  ]
	});

	/**
	 * Perform a [nodes.shutdown](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-shutdown.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.delay - Set the delay for the operation (default: 1s)
	 * @param {Boolean} params.exit - Exit the JVM as well (default: true)
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to perform the operation on; use `_local` to perform the operation on the node you're connected to, leave empty to perform the operation on all nodes
	 */
	api.nodes.prototype.shutdown = ca({
	  params: {
	    delay: {
	      type: 'time'
	    },
	    exit: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cluster/nodes/<%=nodeId%>/_shutdown',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_shutdown'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [nodes.stats](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/cluster-nodes-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
	 * @param {Boolean} params.groups - A comma-separated list of search groups for `search` index metric
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String} [params.level=node] - Return indices stats aggregated at node, index or shard level
	 * @param {String, String[], Boolean} params.types - A comma-separated list of document types for the `indexing` index metric
	 * @param {String, String[], Boolean} params.metric - Limit the information returned to the specified metrics
	 * @param {String, String[], Boolean} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 */
	api.nodes.prototype.stats = ca({
	  params: {
	    completionFields: {
	      type: 'list',
	      name: 'completion_fields'
	    },
	    fielddataFields: {
	      type: 'list',
	      name: 'fielddata_fields'
	    },
	    fields: {
	      type: 'list'
	    },
	    groups: {
	      type: 'boolean'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    },
	    level: {
	      type: 'enum',
	      'default': 'node',
	      options: [
	        'node',
	        'indices',
	        'shards'
	      ]
	    },
	    types: {
	      type: 'list'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'network',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        },
	        indexMetric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'filter_cache',
	            'flush',
	            'get',
	            'id_cache',
	            'indexing',
	            'merge',
	            'percolate',
	            'query_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'network',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'network',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        },
	        indexMetric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'filter_cache',
	            'flush',
	            'get',
	            'id_cache',
	            'indexing',
	            'merge',
	            'percolate',
	            'query_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=nodeId%>/stats',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/stats/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'network',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/stats'
	    }
	  ]
	});

	/**
	 * Perform a [percolate](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-percolate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.percolateFormat - Return an array of matching query IDs instead of objects
	 * @param {String} params.percolateIndex - The index to percolate the document into. Defaults to index.
	 * @param {String} params.percolateType - The type to percolate document into. Defaults to type.
	 * @param {String} params.percolateRouting - The routing value to use when percolating the existing document.
	 * @param {String} params.percolatePreference - Which shard to prefer when executing the percolate request.
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.index - The index of the document being percolated.
	 * @param {String} params.type - The type of the document being percolated.
	 * @param {String} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
	 */
	api.percolate = ca({
	  params: {
	    routing: {
	      type: 'list'
	    },
	    preference: {
	      type: 'string'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    percolateFormat: {
	      type: 'enum',
	      options: [
	        'ids'
	      ],
	      name: 'percolate_format'
	    },
	    percolateIndex: {
	      type: 'string',
	      name: 'percolate_index'
	    },
	    percolateType: {
	      type: 'string',
	      name: 'percolate_type'
	    },
	    percolateRouting: {
	      type: 'string',
	      name: 'percolate_routing'
	    },
	    percolatePreference: {
	      type: 'string',
	      name: 'percolate_preference'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>/_percolate',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [ping](http://www.elastic.co/guide/) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 */
	api.ping = ca({
	  url: {
	    fmt: '/'
	  },
	  requestTimeout: 3000,
	  method: 'HEAD'
	});

	/**
	 * Perform a [putScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} [params.opType=index] - Explicit operation type
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Script ID
	 * @param {String} params.lang - Script language
	 */
	api.putScript = ca({
	  params: {
	    opType: {
	      type: 'enum',
	      'default': 'index',
	      options: [
	        'index',
	        'create'
	      ],
	      name: 'op_type'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_scripts/<%=lang%>/<%=id%>',
	    req: {
	      lang: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} [params.opType=index] - Explicit operation type
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Template ID
	 */
	api.putTemplate = ca({
	  params: {
	    opType: {
	      type: 'enum',
	      'default': 'index',
	      options: [
	        'index',
	        'create'
	      ],
	      name: 'op_type'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_search/template/<%=id%>',
	    req: {
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [scroll](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-request-scroll.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Duration} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
	 * @param {String} params.scrollId - The scroll ID
	 */
	api.scroll = ca({
	  params: {
	    scroll: {
	      type: 'duration'
	    },
	    scrollId: {
	      type: 'string',
	      name: 'scroll_id'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_search/scroll/<%=scrollId%>',
	      req: {
	        scrollId: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_search/scroll'
	    }
	  ],
	  paramAsBody: 'scrollId',
	  method: 'POST'
	});

	/**
	 * Perform a [search](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-search.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.explain - Specify whether to return detailed information about score computation as part of a hit
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return as part of a hit
	 * @param {String, String[], Boolean} params.fielddataFields - A comma-separated list of fields to return as the field data representation of a field for each hit
	 * @param {Number} params.from - Starting offset (default: 0)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {Duration} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
	 * @param {String} params.searchType - Search operation type
	 * @param {Number} params.size - Number of hits to return (default: 10)
	 * @param {String, String[], Boolean} params.sort - A comma-separated list of <field>:<direction> pairs
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {String, String[], Boolean} params.stats - Specific 'tag' of the request for logging and statistical purposes
	 * @param {String} params.suggestField - Specify which field to use for suggestions
	 * @param {String} [params.suggestMode=missing] - Specify suggest mode
	 * @param {Number} params.suggestSize - How many suggestions to return in response
	 * @param {Text} params.suggestText - The source text for which the suggestions should be returned
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Boolean} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
	 * @param {Boolean} params.version - Specify whether to return document version as part of a hit
	 * @param {Boolean} params.queryCache - Specify if query cache should be used for this request or not, defaults to index level setting
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
	 */
	api.search = ca({
	  params: {
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    explain: {
	      type: 'boolean'
	    },
	    fields: {
	      type: 'list'
	    },
	    fielddataFields: {
	      type: 'list',
	      name: 'fielddata_fields'
	    },
	    from: {
	      type: 'number'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    },
	    preference: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    routing: {
	      type: 'list'
	    },
	    scroll: {
	      type: 'duration'
	    },
	    searchType: {
	      type: 'enum',
	      options: [
	        'query_then_fetch',
	        'query_and_fetch',
	        'dfs_query_then_fetch',
	        'dfs_query_and_fetch',
	        'count',
	        'scan'
	      ],
	      name: 'search_type'
	    },
	    size: {
	      type: 'number'
	    },
	    sort: {
	      type: 'list'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    },
	    stats: {
	      type: 'list'
	    },
	    suggestField: {
	      type: 'string',
	      name: 'suggest_field'
	    },
	    suggestMode: {
	      type: 'enum',
	      'default': 'missing',
	      options: [
	        'missing',
	        'popular',
	        'always'
	      ],
	      name: 'suggest_mode'
	    },
	    suggestSize: {
	      type: 'number',
	      name: 'suggest_size'
	    },
	    suggestText: {
	      type: 'text',
	      name: 'suggest_text'
	    },
	    timeout: {
	      type: 'time'
	    },
	    trackScores: {
	      type: 'boolean',
	      name: 'track_scores'
	    },
	    version: {
	      type: 'boolean'
	    },
	    queryCache: {
	      type: 'boolean',
	      name: 'query_cache'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [searchExists](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-exists.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Number} params.minScore - Include only documents with a specific `_score` value in the result
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to restrict the results
	 * @param {String, String[], Boolean} params.type - A comma-separated list of types to restrict the results
	 */
	api.searchExists = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    minScore: {
	      type: 'number',
	      name: 'min_score'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search/exists',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search/exists',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search/exists'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [searchShards](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.searchShards = ca({
	  params: {
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    local: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search_shards',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search_shards',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_search_shards'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [searchTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {Duration} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
	 * @param {String} params.searchType - Search operation type
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
	 */
	api.searchTemplate = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'list'
	    },
	    scroll: {
	      type: 'duration'
	    },
	    searchType: {
	      type: 'enum',
	      options: [
	        'query_then_fetch',
	        'query_and_fetch',
	        'dfs_query_then_fetch',
	        'dfs_query_and_fetch',
	        'count',
	        'scan'
	      ],
	      name: 'search_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search/template',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search/template',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search/template'
	    }
	  ],
	  method: 'POST'
	});

	api.snapshot = namespace();

	/**
	 * Perform a [snapshot.create](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.waitForCompletion - Should this request wait until the operation has completed before returning
	 * @param {String} params.repository - A repository name
	 * @param {String} params.snapshot - A snapshot name
	 */
	api.snapshot.prototype.create = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    waitForCompletion: {
	      type: 'boolean',
	      'default': false,
	      name: 'wait_for_completion'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [snapshot.createRepository](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Boolean} params.verify - Whether to verify the repository after creation
	 * @param {String} params.repository - A repository name
	 */
	api.snapshot.prototype.createRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    },
	    verify: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>',
	    req: {
	      repository: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [snapshot.delete](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String} params.repository - A repository name
	 * @param {String} params.snapshot - A snapshot name
	 */
	api.snapshot.prototype['delete'] = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [snapshot.deleteRepository](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {String, String[], Boolean} params.repository - A comma-separated list of repository names
	 */
	api.snapshot.prototype.deleteRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>',
	    req: {
	      repository: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [snapshot.get](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String} params.repository - A repository name
	 * @param {String, String[], Boolean} params.snapshot - A comma-separated list of snapshot names
	 */
	api.snapshot.prototype.get = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'list'
	      }
	    }
	  }
	});

	/**
	 * Perform a [snapshot.getRepository](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.repository - A comma-separated list of repository names
	 */
	api.snapshot.prototype.getRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_snapshot/<%=repository%>',
	      req: {
	        repository: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_snapshot'
	    }
	  ]
	});

	/**
	 * Perform a [snapshot.restore](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.waitForCompletion - Should this request wait until the operation has completed before returning
	 * @param {String} params.repository - A repository name
	 * @param {String} params.snapshot - A snapshot name
	 */
	api.snapshot.prototype.restore = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    waitForCompletion: {
	      type: 'boolean',
	      'default': false,
	      name: 'wait_for_completion'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [snapshot.status](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String} params.repository - A repository name
	 * @param {String, String[], Boolean} params.snapshot - A comma-separated list of snapshot names
	 */
	api.snapshot.prototype.status = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
	      req: {
	        repository: {
	          type: 'string'
	        },
	        snapshot: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_snapshot/<%=repository%>/_status',
	      req: {
	        repository: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_snapshot/_status'
	    }
	  ]
	});

	/**
	 * Perform a [snapshot.verifyRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {String} params.repository - A repository name
	 */
	api.snapshot.prototype.verifyRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/_verify',
	    req: {
	      repository: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [suggest](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/search-suggesters.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
	 */
	api.suggest = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_suggest',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_suggest'
	    }
	  ],
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [termvector](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-termvectors.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
	 * @param {Boolean} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return.
	 * @param {Boolean} [params.offsets=true] - Specifies if term offsets should be returned.
	 * @param {Boolean} [params.positions=true] - Specifies if term positions should be returned.
	 * @param {Boolean} [params.payloads=true] - Specifies if term payloads should be returned.
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random).
	 * @param {String} params.routing - Specific routing value.
	 * @param {String} params.parent - Parent id of documents.
	 * @param {Boolean} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
	 * @param {String} params.index - The index in which the document resides.
	 * @param {String} params.type - The type of the document.
	 * @param {String} params.id - The id of the document.
	 */
	api.termvector = ca({
	  params: {
	    termStatistics: {
	      type: 'boolean',
	      'default': false,
	      required: false,
	      name: 'term_statistics'
	    },
	    fieldStatistics: {
	      type: 'boolean',
	      'default': true,
	      required: false,
	      name: 'field_statistics'
	    },
	    fields: {
	      type: 'list',
	      required: false
	    },
	    offsets: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    positions: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    payloads: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    preference: {
	      type: 'string',
	      required: false
	    },
	    routing: {
	      type: 'string',
	      required: false
	    },
	    parent: {
	      type: 'string',
	      required: false
	    },
	    realtime: {
	      type: 'boolean',
	      required: false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvector',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>/_termvector',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [update](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-update.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {String} params.lang - The script language (default: groovy)
	 * @param {String} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} [params.replication=sync] - Specific replication type
	 * @param {Number} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
	 * @param {String} params.routing - Specific routing value
	 * @param {Anything} params.script - The URL-encoded script definition (instead of using request body)
	 * @param {Anything} params.scriptId - The id of a stored script
	 * @param {Boolean} params.scriptedUpsert - True if the script referenced in script or script_id should be called to perform inserts - defaults to false
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.timestamp - Explicit timestamp for the document
	 * @param {Duration} params.ttl - Expiration time for the document
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.update = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    fields: {
	      type: 'list'
	    },
	    lang: {
	      type: 'string'
	    },
	    parent: {
	      type: 'string'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    replication: {
	      type: 'enum',
	      'default': 'sync',
	      options: [
	        'sync',
	        'async'
	      ]
	    },
	    retryOnConflict: {
	      type: 'number',
	      name: 'retry_on_conflict'
	    },
	    routing: {
	      type: 'string'
	    },
	    script: {},
	    scriptId: {
	      name: 'script_id'
	    },
	    scriptedUpsert: {
	      type: 'boolean',
	      name: 'scripted_upsert'
	    },
	    timeout: {
	      type: 'time'
	    },
	    timestamp: {
	      type: 'time'
	    },
	    ttl: {
	      type: 'duration'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [create](http://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-index_.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {String} params.parent - ID of the parent document
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} [params.replication=sync] - Specific replication type
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.timestamp - Explicit timestamp for the document
	 * @param {Duration} params.ttl - Expiration time for the document
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.create = ca.proxy(api.index, {
	  transform: function (params) {
	    params.op_type = 'create';
	  }
	});
	},{"../client_action":21,"../utils":41}],17:[function(require,module,exports){
	module.exports=require(16)
	},{"../client_action":21,"../utils":41}],18:[function(require,module,exports){
	/* jshint maxlen: false */

	var ca = require('../client_action').makeFactoryWithModifier(function (spec) {
	  return require('../utils').merge(spec, {
	    params: {
	      filterPath: {
	        type: 'list',
	        name: 'filter_path'
	      }
	    }
	  });
	});
	var namespace = require('../client_action').namespaceFactory;
	var api = module.exports = {};

	api._namespaces = ['cat', 'cluster', 'indices', 'nodes', 'snapshot'];

	/**
	 * Perform a [bulk](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-bulk.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {String} params.type - Default document type for items which don't provide one
	 * @param {String, String[], Boolean} params.fields - Default comma-separated list of fields to return in the response for updates
	 * @param {String} params.index - Default index for items which don't provide one
	 */
	api.bulk = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    },
	    timeout: {
	      type: 'time'
	    },
	    type: {
	      type: 'string'
	    },
	    fields: {
	      type: 'list'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_bulk',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_bulk',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_bulk'
	    }
	  ],
	  needBody: true,
	  bulkBody: true,
	  method: 'POST'
	});

	api.cat = namespace();

	/**
	 * Perform a [cat.aliases](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/cat.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to return
	 */
	api.cat.prototype.aliases = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/aliases/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/aliases'
	    }
	  ]
	});

	/**
	 * Perform a [cat.allocation](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-allocation.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information
	 */
	api.cat.prototype.allocation = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/allocation/<%=nodeId%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/allocation'
	    }
	  ]
	});

	/**
	 * Perform a [cat.count](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-count.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.count = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/count/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/count'
	    }
	  ]
	});

	/**
	 * Perform a [cat.fielddata](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-fielddata.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return the fielddata size
	 */
	api.cat.prototype.fielddata = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    },
	    fields: {
	      type: 'list'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/fielddata/<%=fields%>',
	      req: {
	        fields: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/fielddata'
	    }
	  ]
	});

	/**
	 * Perform a [cat.health](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-health.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.ts=true] - Set to false to disable timestamping
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 */
	api.cat.prototype.health = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    ts: {
	      type: 'boolean',
	      'default': true
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  url: {
	    fmt: '/_cat/health'
	  }
	});

	/**
	 * Perform a [cat.help](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.help - Return help information
	 */
	api.cat.prototype.help = ca({
	  params: {
	    help: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  url: {
	    fmt: '/_cat'
	  }
	});

	/**
	 * Perform a [cat.indices](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-indices.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} params.pri - Set to true to return stats only for primary shards
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.indices = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    pri: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/indices/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/indices'
	    }
	  ]
	});

	/**
	 * Perform a [cat.master](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-master.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 */
	api.cat.prototype.master = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  url: {
	    fmt: '/_cat/master'
	  }
	});

	/**
	 * Perform a [cat.nodeattrs](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodeattrs.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 */
	api.cat.prototype.nodeattrs = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  url: {
	    fmt: '/_cat/nodeattrs'
	  }
	});

	/**
	 * Perform a [cat.nodes](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-nodes.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 */
	api.cat.prototype.nodes = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  url: {
	    fmt: '/_cat/nodes'
	  }
	});

	/**
	 * Perform a [cat.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-pending-tasks.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 */
	api.cat.prototype.pendingTasks = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  url: {
	    fmt: '/_cat/pending_tasks'
	  }
	});

	/**
	 * Perform a [cat.plugins](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-plugins.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 */
	api.cat.prototype.plugins = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  url: {
	    fmt: '/_cat/plugins'
	  }
	});

	/**
	 * Perform a [cat.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-recovery.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.bytes - The unit in which to display byte values
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.recovery = ca({
	  params: {
	    bytes: {
	      type: 'enum',
	      options: [
	        'b',
	        'k',
	        'm',
	        'g'
	      ]
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/recovery/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/recovery'
	    }
	  ]
	});

	/**
	 * Perform a [cat.segments](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-segments.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.segments = ca({
	  params: {
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/segments/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/segments'
	    }
	  ]
	});

	/**
	 * Perform a [cat.shards](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-shards.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to limit the returned information
	 */
	api.cat.prototype.shards = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cat/shards/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cat/shards'
	    }
	  ]
	});

	/**
	 * Perform a [cat.threadPool](http://www.elastic.co/guide/en/elasticsearch/reference/master/cat-thread-pool.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String, String[], Boolean} params.h - Comma-separated list of column names to display
	 * @param {Boolean} params.help - Return help information
	 * @param {Boolean} [params.v=true] - Verbose mode. Display column headers
	 * @param {Boolean} params.fullId - Enables displaying the complete node ids
	 */
	api.cat.prototype.threadPool = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    h: {
	      type: 'list'
	    },
	    help: {
	      type: 'boolean',
	      'default': false
	    },
	    v: {
	      type: 'boolean',
	      'default': true
	    },
	    fullId: {
	      type: 'boolean',
	      'default': false,
	      name: 'full_id'
	    }
	  },
	  url: {
	    fmt: '/_cat/thread_pool'
	  }
	});

	/**
	 * Perform a [clearScroll](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.scrollId - A comma-separated list of scroll IDs to clear
	 */
	api.clearScroll = ca({
	  urls: [
	    {
	      fmt: '/_search/scroll/<%=scrollId%>',
	      req: {
	        scrollId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search/scroll'
	    }
	  ],
	  method: 'DELETE'
	});

	api.cluster = namespace();

	/**
	 * Perform a [cluster.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 */
	api.cluster.prototype.getSettings = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_cluster/settings'
	  }
	});

	/**
	 * Perform a [cluster.health](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} [params.level=cluster] - Specify the level of detail for returned information
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Number} params.waitForActiveShards - Wait until the specified number of shards is active
	 * @param {String} params.waitForNodes - Wait until the specified number of nodes is available
	 * @param {Number} params.waitForRelocatingShards - Wait until the specified number of relocating shards is finished
	 * @param {String} params.waitForStatus - Wait until cluster is in a specific state
	 * @param {String} params.index - Limit the information returned to a specific index
	 */
	api.cluster.prototype.health = ca({
	  params: {
	    level: {
	      type: 'enum',
	      'default': 'cluster',
	      options: [
	        'cluster',
	        'indices',
	        'shards'
	      ]
	    },
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    },
	    waitForActiveShards: {
	      type: 'number',
	      name: 'wait_for_active_shards'
	    },
	    waitForNodes: {
	      type: 'string',
	      name: 'wait_for_nodes'
	    },
	    waitForRelocatingShards: {
	      type: 'number',
	      name: 'wait_for_relocating_shards'
	    },
	    waitForStatus: {
	      type: 'enum',
	      'default': null,
	      options: [
	        'green',
	        'yellow',
	        'red'
	      ],
	      name: 'wait_for_status'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cluster/health/<%=index%>',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/health'
	    }
	  ]
	});

	/**
	 * Perform a [cluster.pendingTasks](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-pending.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 */
	api.cluster.prototype.pendingTasks = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_cluster/pending_tasks'
	  }
	});

	/**
	 * Perform a [cluster.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-update-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 */
	api.cluster.prototype.putSettings = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_cluster/settings'
	  },
	  method: 'PUT'
	});

	/**
	 * Perform a [cluster.reroute](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-reroute.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.dryRun - Simulate the operation only and return the resulting state
	 * @param {Boolean} params.explain - Return an explanation of why the commands can or cannot be executed
	 * @param {String, String[], Boolean} params.metric - Limit the information returned to the specified metrics. Defaults to all but metadata
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 */
	api.cluster.prototype.reroute = ca({
	  params: {
	    dryRun: {
	      type: 'boolean',
	      name: 'dry_run'
	    },
	    explain: {
	      type: 'boolean'
	    },
	    metric: {
	      type: 'list',
	      options: [
	        '_all',
	        'blocks',
	        'metadata',
	        'nodes',
	        'routing_table',
	        'master_node',
	        'version'
	      ]
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_cluster/reroute'
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [cluster.state](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-state.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.metric - Limit the information returned to the specified metrics
	 */
	api.cluster.prototype.state = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cluster/state/<%=metric%>/<%=index%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'blocks',
	            'metadata',
	            'nodes',
	            'routing_table',
	            'routing_nodes',
	            'master_node',
	            'version'
	          ]
	        },
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/state/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'blocks',
	            'metadata',
	            'nodes',
	            'routing_table',
	            'routing_nodes',
	            'master_node',
	            'version'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/state'
	    }
	  ]
	});

	/**
	 * Perform a [cluster.stats](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 */
	api.cluster.prototype.stats = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_cluster/stats/nodes/<%=nodeId%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cluster/stats'
	    }
	  ]
	});

	/**
	 * Perform a [count](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Number} params.minScore - Include only documents with a specific `_score` value in the result
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to restrict the results
	 * @param {String, String[], Boolean} params.type - A comma-separated list of types to restrict the results
	 */
	api.count = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    minScore: {
	      type: 'number',
	      name: 'min_score'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_count',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_count',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_count'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [countPercolate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.percolateIndex - The index to count percolate the document into. Defaults to index.
	 * @param {String} params.percolateType - The type to count percolate document into. Defaults to type.
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.index - The index of the document being count percolated.
	 * @param {String} params.type - The type of the document being count percolated.
	 * @param {String} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
	 */
	api.countPercolate = ca({
	  params: {
	    routing: {
	      type: 'list'
	    },
	    preference: {
	      type: 'string'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    percolateIndex: {
	      type: 'string',
	      name: 'percolate_index'
	    },
	    percolateType: {
	      type: 'string',
	      name: 'percolate_type'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate/count',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>/_percolate/count',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [delete](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Specific write consistency setting for the operation
	 * @param {String} params.parent - ID of parent document
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api['delete'] = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    parent: {
	      type: 'string'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    },
	    timeout: {
	      type: 'time'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [deleteScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Script ID
	 * @param {String} params.lang - Script language
	 */
	api.deleteScript = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_scripts/<%=lang%>/<%=id%>',
	    req: {
	      lang: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Template ID
	 */
	api.deleteTemplate = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_search/template/<%=id%>',
	    req: {
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [exists](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
	 */
	api.exists = ca({
	  params: {
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [explain](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-explain.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcards and prefix queries in the query string query should be analyzed (default: false)
	 * @param {String} params.analyzer - The analyzer for the query string query
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The default field for query string query (default: _all)
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.explain = ca({
	  params: {
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    fields: {
	      type: 'list'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    },
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>/_explain',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [fieldStats](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields for to get field statistics for (min value, max value, and more)
	 * @param {String} [params.level=cluster] - Defines if field stats should be returned on a per index level or on a cluster wide level
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.fieldStats = ca({
	  params: {
	    fields: {
	      type: 'list'
	    },
	    level: {
	      type: 'enum',
	      'default': 'cluster',
	      options: [
	        'indices',
	        'cluster'
	      ]
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_field_stats',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_field_stats'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [get](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document (use `_all` to fetch the first document matching the ID across all types)
	 */
	api.get = ca({
	  params: {
	    fields: {
	      type: 'list'
	    },
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [getScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Script ID
	 * @param {String} params.lang - Script language
	 */
	api.getScript = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_scripts/<%=lang%>/<%=id%>',
	    req: {
	      lang: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [getSource](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.parent - The ID of the parent document
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - The document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document; use `_all` to fetch the first document matching the ID across all types
	 */
	api.getSource = ca({
	  params: {
	    parent: {
	      type: 'string'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>/_source',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Template ID
	 */
	api.getTemplate = ca({
	  params: {
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_search/template/<%=id%>',
	    req: {
	      id: {
	        type: 'string'
	      }
	    }
	  }
	});

	/**
	 * Perform a [index](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {String} params.parent - ID of the parent document
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.timestamp - Explicit timestamp for the document
	 * @param {Duration} params.ttl - Expiration time for the document
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.index = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    opType: {
	      type: 'enum',
	      'default': 'index',
	      options: [
	        'index',
	        'create'
	      ],
	      name: 'op_type'
	    },
	    parent: {
	      type: 'string'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    routing: {
	      type: 'string'
	    },
	    timeout: {
	      type: 'time'
	    },
	    timestamp: {
	      type: 'time'
	    },
	    ttl: {
	      type: 'duration'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  needBody: true,
	  method: 'POST'
	});

	api.indices = namespace();

	/**
	 * Perform a [indices.analyze](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-analyze.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.analyzer - The name of the analyzer to use
	 * @param {String, String[], Boolean} params.charFilters - A comma-separated list of character filters to use for the analysis
	 * @param {String} params.field - Use the analyzer configured for this field (instead of passing the analyzer name)
	 * @param {String, String[], Boolean} params.filters - A comma-separated list of filters to use for the analysis
	 * @param {String} params.index - The name of the index to scope the operation
	 * @param {Boolean} params.preferLocal - With `true`, specify that a local shard should be used if available, with `false`, use a random shard (default: true)
	 * @param {String, String[], Boolean} params.text - The text on which the analysis should be performed (when request body is not used)
	 * @param {String} params.tokenizer - The name of the tokenizer to use for the analysis
	 * @param {String} [params.format=detailed] - Format of the output
	 */
	api.indices.prototype.analyze = ca({
	  params: {
	    analyzer: {
	      type: 'string'
	    },
	    charFilters: {
	      type: 'list',
	      name: 'char_filters'
	    },
	    field: {
	      type: 'string'
	    },
	    filters: {
	      type: 'list'
	    },
	    index: {
	      type: 'string'
	    },
	    preferLocal: {
	      type: 'boolean',
	      name: 'prefer_local'
	    },
	    text: {
	      type: 'list'
	    },
	    tokenizer: {
	      type: 'string'
	    },
	    format: {
	      type: 'enum',
	      'default': 'detailed',
	      options: [
	        'detailed',
	        'text'
	      ]
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_analyze',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_analyze'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.clearCache](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-clearcache.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.fieldData - Clear field data
	 * @param {Boolean} params.fielddata - Clear field data
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to clear when using the `field_data` parameter (default: all)
	 * @param {Boolean} params.query - Clear query caches
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index name to limit the operation
	 * @param {Boolean} params.recycler - Clear the recycler cache
	 * @param {Boolean} params.request - Clear request cache
	 */
	api.indices.prototype.clearCache = ca({
	  params: {
	    fieldData: {
	      type: 'boolean',
	      name: 'field_data'
	    },
	    fielddata: {
	      type: 'boolean'
	    },
	    fields: {
	      type: 'list'
	    },
	    query: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    index: {
	      type: 'list'
	    },
	    recycler: {
	      type: 'boolean'
	    },
	    request: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_cache/clear',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_cache/clear'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.close](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The name of the index
	 */
	api.indices.prototype.close = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_close',
	    req: {
	      index: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [indices.create](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-create-index.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
	 * @param {String} params.index - The name of the index
	 */
	api.indices.prototype.create = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    updateAllTypes: {
	      type: 'boolean',
	      name: 'update_all_types'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>',
	    req: {
	      index: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [indices.delete](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to delete; use `_all` or `*` string to delete all indices
	 */
	api.indices.prototype['delete'] = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>',
	    req: {
	      index: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.deleteAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit timestamp for the document
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names (supports wildcards); use `_all` for all indices
	 * @param {String, String[], Boolean} params.name - A comma-separated list of aliases to delete (supports wildcards); use `_all` to delete all aliases for the specified indices.
	 */
	api.indices.prototype.deleteAlias = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_alias/<%=name%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      name: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.deleteTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.deleteTemplate = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_template/<%=name%>',
	    req: {
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.deleteWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.name - A comma-separated list of warmer names to delete (supports wildcards); use `_all` to delete all warmers in the specified indices. You must specify a name either in the uri or in the parameters.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to delete warmers from (supports wildcards); use `_all` to perform the operation on all indices.
	 */
	api.indices.prototype.deleteWarmer = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    name: {
	      type: 'list'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_warmer/<%=name%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      name: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [indices.exists](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to check
	 */
	api.indices.prototype.exists = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>',
	    req: {
	      index: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.existsAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to filter aliases
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to return
	 */
	api.indices.prototype.existsAlias = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': [
	        'open',
	        'closed'
	      ],
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_alias/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_alias/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_alias',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    }
	  ],
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.existsTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.existsTemplate = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/_template/<%=name%>',
	    req: {
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.existsType](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-types-exists.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` to check the types across all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to check
	 */
	api.indices.prototype.existsType = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      type: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'HEAD'
	});

	/**
	 * Perform a [indices.flush](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-flush.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.force - Whether a flush should be forced even if it is not necessarily needed ie. if no changes will be committed to the index. This is useful if transaction log IDs should be incremented even if no uncommitted changes are present. (This setting can be considered as internal)
	 * @param {Boolean} params.waitIfOngoing - If set to true the flush operation will block until the flush can be executed if another flush operation is already executing. The default is false and will cause an exception to be thrown on the shard level if another flush operation is already running.
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
	 */
	api.indices.prototype.flush = ca({
	  params: {
	    force: {
	      type: 'boolean'
	    },
	    waitIfOngoing: {
	      type: 'boolean',
	      name: 'wait_if_ongoing'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_flush',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_flush'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.flushSynced](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-synced-flush.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string for all indices
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 */
	api.indices.prototype.flushSynced = ca({
	  urls: [
	    {
	      fmt: '/<%=index%>/_flush/synced',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_flush/synced'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.get](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Boolean} params.ignoreUnavailable - Ignore unavailable indexes (default: false)
	 * @param {Boolean} params.allowNoIndices - Ignore if a wildcard expression resolves to no concrete indices (default: false)
	 * @param {String} [params.expandWildcards=open] - Whether wildcard expressions should get expanded to open or closed indices (default: open)
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.human - Whether to return version and creation date values in human-readable format.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names
	 * @param {String, String[], Boolean} params.feature - A comma-separated list of features
	 */
	api.indices.prototype.get = ca({
	  params: {
	    local: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=feature%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        feature: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    }
	  ]
	});

	/**
	 * Perform a [indices.getAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to filter aliases
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to return
	 */
	api.indices.prototype.getAlias = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_alias/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_alias/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_alias',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_alias'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getAliases](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to filter aliases
	 * @param {String, String[], Boolean} params.name - A comma-separated list of alias names to filter
	 */
	api.indices.prototype.getAliases = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_aliases/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_aliases',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_aliases/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_aliases'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getFieldMapping](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-field-mapping.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.includeDefaults - Whether the default mapping values should be returned as well
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types
	 * @param {String, String[], Boolean} params.field - A comma-separated list of fields
	 */
	api.indices.prototype.getFieldMapping = ca({
	  params: {
	    includeDefaults: {
	      type: 'boolean',
	      name: 'include_defaults'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_mapping/<%=type%>/field/<%=field%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        },
	        field: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mapping/field/<%=field%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        field: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/<%=type%>/field/<%=field%>',
	      req: {
	        type: {
	          type: 'list'
	        },
	        field: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/field/<%=field%>',
	      req: {
	        field: {
	          type: 'list'
	        }
	      }
	    }
	  ]
	});

	/**
	 * Perform a [indices.getMapping](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types
	 */
	api.indices.prototype.getMapping = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_mapping/<%=type%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mapping',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/<%=type%>',
	      req: {
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open,closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Boolean} params.human - Whether to return version and creation date values in human-readable format.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.name - The name of the settings that should be included
	 */
	api.indices.prototype.getSettings = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': [
	        'open',
	        'closed'
	      ],
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    local: {
	      type: 'boolean'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_settings/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_settings',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_settings/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_settings'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.getTemplate = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_template/<%=name%>',
	      req: {
	        name: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_template'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getUpgrade](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.getUpgrade = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_upgrade',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_upgrade'
	    }
	  ]
	});

	/**
	 * Perform a [indices.getWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to restrict the operation; use `_all` to perform the operation on all indices
	 * @param {String, String[], Boolean} params.name - The name of the warmer (supports wildcards); leave empty to get all warmers
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
	 */
	api.indices.prototype.getWarmer = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_warmer',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_warmer/<%=name%>',
	      req: {
	        name: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_warmer'
	    }
	  ]
	});

	/**
	 * Perform a [indices.open](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=closed] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The name of the index
	 */
	api.indices.prototype.open = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'closed',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_open',
	    req: {
	      index: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [indices.optimize](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-optimize.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flush - Specify whether the index should be flushed after performing the operation (default: true)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Number} params.maxNumSegments - The number of segments the index should be merged into (default: dynamic)
	 * @param {Boolean} params.onlyExpungeDeletes - Specify whether the operation should only expunge deleted documents
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {Boolean} params.waitForMerge - Specify whether the request should block until the merge process is finished (default: true)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.optimize = ca({
	  params: {
	    flush: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    maxNumSegments: {
	      type: 'number',
	      name: 'max_num_segments'
	    },
	    onlyExpungeDeletes: {
	      type: 'boolean',
	      name: 'only_expunge_deletes'
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    },
	    waitForMerge: {
	      type: 'boolean',
	      name: 'wait_for_merge'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_optimize',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_optimize'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.putAlias](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit timestamp for the document
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names the alias should point to (supports wildcards); use `_all` to perform the operation on all indices.
	 * @param {String} params.name - The name of the alias to be created or updated
	 */
	api.indices.prototype.putAlias = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/_alias/<%=name%>',
	    req: {
	      index: {
	        type: 'list'
	      },
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putMapping](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.updateAllTypes - Whether to update the mapping for all fields with the same name across all types or not
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.
	 * @param {String} params.type - The name of the document type
	 */
	api.indices.prototype.putMapping = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    updateAllTypes: {
	      type: 'boolean',
	      name: 'update_all_types'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_mapping/<%=type%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mapping/<%=type%>',
	      req: {
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putSettings](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.putSettings = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_settings',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_settings'
	    }
	  ],
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Number} params.order - The order for this template when merging multiple matching ones (higher numbers are merged later, overriding the lower numbers)
	 * @param {Boolean} params.create - Whether the index template should only be added if new or can also replace an existing one
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {String} params.name - The name of the template
	 */
	api.indices.prototype.putTemplate = ca({
	  params: {
	    order: {
	      type: 'number'
	    },
	    create: {
	      type: 'boolean',
	      'default': false
	    },
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    }
	  },
	  url: {
	    fmt: '/_template/<%=name%>',
	    req: {
	      name: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.putWarmer](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-warmers.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed) in the search request to warm
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices in the search request to warm. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both, in the search request to warm.
	 * @param {Boolean} params.requestCache - Specify whether the request to be wamred shoyd use the request cache, defaults to index level setting
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to register the warmer for; use `_all` or omit to perform the operation on all indices
	 * @param {String} params.name - The name of the warmer
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to register the warmer for; leave empty to perform the operation on all types
	 */
	api.indices.prototype.putWarmer = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    requestCache: {
	      type: 'boolean',
	      name: 'request_cache'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        },
	        name: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_warmer/<%=name%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        name: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_warmer/<%=name%>',
	      req: {
	        name: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [indices.recovery](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.detailed - Whether to display detailed information about shard recovery
	 * @param {Boolean} params.activeOnly - Display only those recoveries that are currently on-going
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.recovery = ca({
	  params: {
	    detailed: {
	      type: 'boolean',
	      'default': false
	    },
	    activeOnly: {
	      type: 'boolean',
	      'default': false,
	      name: 'active_only'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_recovery',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_recovery'
	    }
	  ]
	});

	/**
	 * Perform a [indices.refresh](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-refresh.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.force - Force a refresh even if not required
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.refresh = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    force: {
	      type: 'boolean',
	      'default': false
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_refresh',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_refresh'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.segments](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-segments.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.segments = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_segments',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_segments'
	    }
	  ]
	});

	/**
	 * Perform a [indices.shardStores](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-shards-stores.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.status - A comma-separated list of statuses used to filter on shards to get store information for
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.shardStores = ca({
	  params: {
	    status: {
	      type: 'list',
	      options: [
	        'green',
	        'yellow',
	        'red',
	        'all'
	      ]
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_shard_stores',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_shard_stores'
	    }
	  ]
	});

	/**
	 * Perform a [indices.stats](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.groups - A comma-separated list of search groups for `search` index metric
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String} [params.level=indices] - Return stats aggregated at cluster, index or shard level
	 * @param {String, String[], Boolean} params.types - A comma-separated list of document types for the `indexing` index metric
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.metric - Limit the information returned the specific metrics.
	 */
	api.indices.prototype.stats = ca({
	  params: {
	    completionFields: {
	      type: 'list',
	      name: 'completion_fields'
	    },
	    fielddataFields: {
	      type: 'list',
	      name: 'fielddata_fields'
	    },
	    fields: {
	      type: 'list'
	    },
	    groups: {
	      type: 'list'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    },
	    level: {
	      type: 'enum',
	      'default': 'indices',
	      options: [
	        'cluster',
	        'indices',
	        'shards'
	      ]
	    },
	    types: {
	      type: 'list'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_stats/<%=metric%>',
	      req: {
	        index: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'query_cache',
	            'flush',
	            'get',
	            'indexing',
	            'merge',
	            'percolate',
	            'request_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_stats/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'query_cache',
	            'flush',
	            'get',
	            'indexing',
	            'merge',
	            'percolate',
	            'request_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_stats',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_stats'
	    }
	  ]
	});

	/**
	 * Perform a [indices.updateAliases](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.timeout - Request timeout
	 * @param {Date, Number} params.masterTimeout - Specify timeout for connection to master
	 */
	api.indices.prototype.updateAliases = ca({
	  params: {
	    timeout: {
	      type: 'time'
	    },
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_aliases'
	  },
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [indices.upgrade](http://www.elastic.co/guide/en/elasticsearch/reference/master/indices-upgrade.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.waitForCompletion - Specify whether the request should block until the all segments are upgraded (default: false)
	 * @param {Boolean} params.onlyAncientSegments - If true, only ancient (an older Lucene major release) segments will be upgraded
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices
	 */
	api.indices.prototype.upgrade = ca({
	  params: {
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    waitForCompletion: {
	      type: 'boolean',
	      name: 'wait_for_completion'
	    },
	    onlyAncientSegments: {
	      type: 'boolean',
	      name: 'only_ancient_segments'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_upgrade',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_upgrade'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [indices.validateQuery](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.explain - Return detailed information about the error
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Anything} params.operationThreading - TODO: ?
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {Boolean} params.rewrite - Provide a more detailed explanation showing the actual Lucene query that will be executed.
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to restrict the operation; leave empty to perform the operation on all types
	 */
	api.indices.prototype.validateQuery = ca({
	  params: {
	    explain: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    operationThreading: {
	      name: 'operation_threading'
	    },
	    q: {
	      type: 'string'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    },
	    rewrite: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_validate/query',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_validate/query',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_validate/query'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [info](http://www.elastic.co/guide/) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 */
	api.info = ca({
	  url: {
	    fmt: '/'
	  }
	});

	/**
	 * Perform a [mget](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.realtime - Specify whether to perform the operation in realtime or search mode
	 * @param {Boolean} params.refresh - Refresh the shard containing the document before performing the operation
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.mget = ca({
	  params: {
	    fields: {
	      type: 'list'
	    },
	    preference: {
	      type: 'string'
	    },
	    realtime: {
	      type: 'boolean'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_mget',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mget',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mget'
	    }
	  ],
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [mpercolate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The index of the document being count percolated to use as default
	 * @param {String} params.type - The type of the document being percolated to use as default.
	 */
	api.mpercolate = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_mpercolate',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mpercolate',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mpercolate'
	    }
	  ],
	  needBody: true,
	  bulkBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [msearch](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.searchType - Search operation type
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to use as default
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to use as default
	 */
	api.msearch = ca({
	  params: {
	    searchType: {
	      type: 'enum',
	      options: [
	        'query_then_fetch',
	        'query_and_fetch',
	        'dfs_query_then_fetch',
	        'dfs_query_and_fetch',
	        'count',
	        'scan'
	      ],
	      name: 'search_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_msearch',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_msearch',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_msearch'
	    }
	  ],
	  needBody: true,
	  bulkBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [mtermvectors](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.ids - A comma-separated list of documents ids. You must define ids as parameter or set "ids" or "docs" in the request body
	 * @param {Boolean} params.termStatistics - Specifies if total term frequency and document frequency should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.offsets=true] - Specifies if term offsets should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.positions=true] - Specifies if term positions should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} [params.payloads=true] - Specifies if term payloads should be returned. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random) .Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String} params.routing - Specific routing value. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {String} params.parent - Parent id of documents. Applies to all returned documents unless otherwise specified in body "params" or "docs".
	 * @param {Boolean} params.realtime - Specifies if requests are real-time as opposed to near-real-time (default: true).
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.index - The index in which the document resides.
	 * @param {String} params.type - The type of the document.
	 */
	api.mtermvectors = ca({
	  params: {
	    ids: {
	      type: 'list',
	      required: false
	    },
	    termStatistics: {
	      type: 'boolean',
	      'default': false,
	      required: false,
	      name: 'term_statistics'
	    },
	    fieldStatistics: {
	      type: 'boolean',
	      'default': true,
	      required: false,
	      name: 'field_statistics'
	    },
	    fields: {
	      type: 'list',
	      required: false
	    },
	    offsets: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    positions: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    payloads: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    preference: {
	      type: 'string',
	      required: false
	    },
	    routing: {
	      type: 'string',
	      required: false
	    },
	    parent: {
	      type: 'string',
	      required: false
	    },
	    realtime: {
	      type: 'boolean',
	      required: false
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_mtermvectors',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_mtermvectors',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_mtermvectors'
	    }
	  ],
	  method: 'POST'
	});

	api.nodes = namespace();

	/**
	 * Perform a [nodes.hotThreads](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-hot-threads.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.interval - The interval for the second sampling of threads
	 * @param {Number} params.snapshots - Number of samples of thread stacktrace (default: 10)
	 * @param {Number} params.threads - Specify the number of threads to provide information for (default: 3)
	 * @param {Boolean} params.ignoreIdleThreads - Don't show threads that are in known-idle places, such as waiting on a socket select or pulling from an empty task queue (default: true)
	 * @param {String} params.type - The type to sample (default: cpu)
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 */
	api.nodes.prototype.hotThreads = ca({
	  params: {
	    interval: {
	      type: 'time'
	    },
	    snapshots: {
	      type: 'number'
	    },
	    threads: {
	      type: 'number'
	    },
	    ignoreIdleThreads: {
	      type: 'boolean',
	      name: 'ignore_idle_threads'
	    },
	    type: {
	      type: 'enum',
	      options: [
	        'cpu',
	        'wait',
	        'block'
	      ]
	    }
	  },
	  urls: [
	    {
	      fmt: '/_nodes/<%=nodeId%>/hotthreads',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/hotthreads'
	    }
	  ]
	});

	/**
	 * Perform a [nodes.info](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-info.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.flatSettings - Return settings in flat format (default: false)
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 * @param {String, String[], Boolean} params.metric - A comma-separated list of metrics you wish returned. Leave empty to return all.
	 */
	api.nodes.prototype.info = ca({
	  params: {
	    flatSettings: {
	      type: 'boolean',
	      name: 'flat_settings'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    }
	  },
	  urls: [
	    {
	      fmt: '/_nodes/<%=nodeId%>/<%=metric%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            'settings',
	            'os',
	            'process',
	            'jvm',
	            'thread_pool',
	            'transport',
	            'http',
	            'plugins'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=nodeId%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            'settings',
	            'os',
	            'process',
	            'jvm',
	            'thread_pool',
	            'transport',
	            'http',
	            'plugins'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes'
	    }
	  ]
	});

	/**
	 * Perform a [nodes.stats](http://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-nodes-stats.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.completionFields - A comma-separated list of fields for `fielddata` and `suggest` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fielddataFields - A comma-separated list of fields for `fielddata` index metric (supports wildcards)
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields for `fielddata` and `completion` index metric (supports wildcards)
	 * @param {Boolean} params.groups - A comma-separated list of search groups for `search` index metric
	 * @param {Boolean} params.human - Whether to return time and byte values in human-readable format.
	 * @param {String} [params.level=node] - Return indices stats aggregated at node, index or shard level
	 * @param {String, String[], Boolean} params.types - A comma-separated list of document types for the `indexing` index metric
	 * @param {String, String[], Boolean} params.metric - Limit the information returned to the specified metrics
	 * @param {String, String[], Boolean} params.indexMetric - Limit the information returned for `indices` metric to the specific index metrics. Isn't used if `indices` (or `all`) metric isn't specified.
	 * @param {String, String[], Boolean} params.nodeId - A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes
	 */
	api.nodes.prototype.stats = ca({
	  params: {
	    completionFields: {
	      type: 'list',
	      name: 'completion_fields'
	    },
	    fielddataFields: {
	      type: 'list',
	      name: 'fielddata_fields'
	    },
	    fields: {
	      type: 'list'
	    },
	    groups: {
	      type: 'boolean'
	    },
	    human: {
	      type: 'boolean',
	      'default': false
	    },
	    level: {
	      type: 'enum',
	      'default': 'node',
	      options: [
	        'node',
	        'indices',
	        'shards'
	      ]
	    },
	    types: {
	      type: 'list'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>/<%=indexMetric%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        },
	        indexMetric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'query_cache',
	            'flush',
	            'get',
	            'indexing',
	            'merge',
	            'percolate',
	            'request_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=nodeId%>/stats/<%=metric%>',
	      req: {
	        nodeId: {
	          type: 'list'
	        },
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/stats/<%=metric%>/<%=indexMetric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        },
	        indexMetric: {
	          type: 'list',
	          options: [
	            '_all',
	            'completion',
	            'docs',
	            'fielddata',
	            'query_cache',
	            'flush',
	            'get',
	            'indexing',
	            'merge',
	            'percolate',
	            'request_cache',
	            'refresh',
	            'search',
	            'segments',
	            'store',
	            'warmer',
	            'suggest'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/<%=nodeId%>/stats',
	      req: {
	        nodeId: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/stats/<%=metric%>',
	      req: {
	        metric: {
	          type: 'list',
	          options: [
	            '_all',
	            'breaker',
	            'fs',
	            'http',
	            'indices',
	            'jvm',
	            'os',
	            'process',
	            'thread_pool',
	            'transport'
	          ]
	        }
	      }
	    },
	    {
	      fmt: '/_nodes/stats'
	    }
	  ]
	});

	/**
	 * Perform a [percolate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-percolate.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.percolateIndex - The index to percolate the document into. Defaults to index.
	 * @param {String} params.percolateType - The type to percolate document into. Defaults to type.
	 * @param {String} params.percolateRouting - The routing value to use when percolating the existing document.
	 * @param {String} params.percolatePreference - Which shard to prefer when executing the percolate request.
	 * @param {String} params.percolateFormat - Return an array of matching query IDs instead of objects
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.index - The index of the document being percolated.
	 * @param {String} params.type - The type of the document being percolated.
	 * @param {String} params.id - Substitute the document in the request body with a document that is known by the specified id. On top of the id, the index and type parameter will be used to retrieve the document from within the cluster.
	 */
	api.percolate = ca({
	  params: {
	    routing: {
	      type: 'list'
	    },
	    preference: {
	      type: 'string'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    percolateIndex: {
	      type: 'string',
	      name: 'percolate_index'
	    },
	    percolateType: {
	      type: 'string',
	      name: 'percolate_type'
	    },
	    percolateRouting: {
	      type: 'string',
	      name: 'percolate_routing'
	    },
	    percolatePreference: {
	      type: 'string',
	      name: 'percolate_preference'
	    },
	    percolateFormat: {
	      type: 'enum',
	      options: [
	        'ids'
	      ],
	      name: 'percolate_format'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>/_percolate',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>/_percolate',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [ping](http://www.elastic.co/guide/) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 */
	api.ping = ca({
	  url: {
	    fmt: '/'
	  },
	  requestTimeout: 3000,
	  method: 'HEAD'
	});

	/**
	 * Perform a [putScript](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} [params.opType=index] - Explicit operation type
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Script ID
	 * @param {String} params.lang - Script language
	 */
	api.putScript = ca({
	  params: {
	    opType: {
	      type: 'enum',
	      'default': 'index',
	      options: [
	        'index',
	        'create'
	      ],
	      name: 'op_type'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_scripts/<%=lang%>/<%=id%>',
	    req: {
	      lang: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [putTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} [params.opType=index] - Explicit operation type
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Template ID
	 */
	api.putTemplate = ca({
	  params: {
	    opType: {
	      type: 'enum',
	      'default': 'index',
	      options: [
	        'index',
	        'create'
	      ],
	      name: 'op_type'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/_search/template/<%=id%>',
	    req: {
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'PUT'
	});

	/**
	 * Perform a [renderSearchTemplate](http://www.elasticsearch.org/guide/en/elasticsearch/reference/master/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.id - The id of the stored search template
	 */
	api.renderSearchTemplate = ca({
	  urls: [
	    {
	      fmt: '/_render/template/<%=id%>',
	      req: {
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_render/template'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [scroll](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-scroll.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Duration} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
	 * @param {String} params.scrollId - The scroll ID
	 */
	api.scroll = ca({
	  params: {
	    scroll: {
	      type: 'duration'
	    },
	    scrollId: {
	      type: 'string',
	      name: 'scroll_id'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_search/scroll/<%=scrollId%>',
	      req: {
	        scrollId: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_search/scroll'
	    }
	  ],
	  paramAsBody: 'scrollId',
	  method: 'POST'
	});

	/**
	 * Perform a [search](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.explain - Specify whether to return detailed information about score computation as part of a hit
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return as part of a hit
	 * @param {String, String[], Boolean} params.fielddataFields - A comma-separated list of fields to return as the field data representation of a field for each hit
	 * @param {Number} params.from - Starting offset (default: 0)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {Duration} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
	 * @param {String} params.searchType - Search operation type
	 * @param {Number} params.size - Number of hits to return (default: 10)
	 * @param {String, String[], Boolean} params.sort - A comma-separated list of <field>:<direction> pairs
	 * @param {String, String[], Boolean} params._source - True or false to return the _source field or not, or a list of fields to return
	 * @param {String, String[], Boolean} params._sourceExclude - A list of fields to exclude from the returned _source field
	 * @param {String, String[], Boolean} params._sourceInclude - A list of fields to extract and return from the _source field
	 * @param {Number} params.terminateAfter - The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.
	 * @param {String, String[], Boolean} params.stats - Specific 'tag' of the request for logging and statistical purposes
	 * @param {String} params.suggestField - Specify which field to use for suggestions
	 * @param {String} [params.suggestMode=missing] - Specify suggest mode
	 * @param {Number} params.suggestSize - How many suggestions to return in response
	 * @param {Text} params.suggestText - The source text for which the suggestions should be returned
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Boolean} params.trackScores - Whether to calculate and return scores even if they are not used for sorting
	 * @param {Boolean} params.version - Specify whether to return document version as part of a hit
	 * @param {Boolean} params.requestCache - Specify if request cache should be used for this request or not, defaults to index level setting
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
	 */
	api.search = ca({
	  params: {
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    explain: {
	      type: 'boolean'
	    },
	    fields: {
	      type: 'list'
	    },
	    fielddataFields: {
	      type: 'list',
	      name: 'fielddata_fields'
	    },
	    from: {
	      type: 'number'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    },
	    preference: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    routing: {
	      type: 'list'
	    },
	    scroll: {
	      type: 'duration'
	    },
	    searchType: {
	      type: 'enum',
	      options: [
	        'query_then_fetch',
	        'dfs_query_then_fetch',
	        'count',
	        'scan'
	      ],
	      name: 'search_type'
	    },
	    size: {
	      type: 'number'
	    },
	    sort: {
	      type: 'list'
	    },
	    _source: {
	      type: 'list'
	    },
	    _sourceExclude: {
	      type: 'list',
	      name: '_source_exclude'
	    },
	    _sourceInclude: {
	      type: 'list',
	      name: '_source_include'
	    },
	    terminateAfter: {
	      type: 'number',
	      name: 'terminate_after'
	    },
	    stats: {
	      type: 'list'
	    },
	    suggestField: {
	      type: 'string',
	      name: 'suggest_field'
	    },
	    suggestMode: {
	      type: 'enum',
	      'default': 'missing',
	      options: [
	        'missing',
	        'popular',
	        'always'
	      ],
	      name: 'suggest_mode'
	    },
	    suggestSize: {
	      type: 'number',
	      name: 'suggest_size'
	    },
	    suggestText: {
	      type: 'text',
	      name: 'suggest_text'
	    },
	    timeout: {
	      type: 'time'
	    },
	    trackScores: {
	      type: 'boolean',
	      name: 'track_scores'
	    },
	    version: {
	      type: 'boolean'
	    },
	    requestCache: {
	      type: 'boolean',
	      name: 'request_cache'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [searchExists](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-exists.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {Number} params.minScore - Include only documents with a specific `_score` value in the result
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {String} params.q - Query in the Lucene query string syntax
	 * @param {String} params.analyzer - The analyzer to use for the query string
	 * @param {Boolean} params.analyzeWildcard - Specify whether wildcard and prefix queries should be analyzed (default: false)
	 * @param {String} [params.defaultOperator=OR] - The default operator for query string query (AND or OR)
	 * @param {String} params.df - The field to use as default where no field prefix is given in the query string
	 * @param {Boolean} params.lenient - Specify whether format-based query failures (such as providing text to a numeric field) should be ignored
	 * @param {Boolean} params.lowercaseExpandedTerms - Specify whether query terms should be lowercased
	 * @param {String, String[], Boolean} params.index - A comma-separated list of indices to restrict the results
	 * @param {String, String[], Boolean} params.type - A comma-separated list of types to restrict the results
	 */
	api.searchExists = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    minScore: {
	      type: 'number',
	      name: 'min_score'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    q: {
	      type: 'string'
	    },
	    analyzer: {
	      type: 'string'
	    },
	    analyzeWildcard: {
	      type: 'boolean',
	      name: 'analyze_wildcard'
	    },
	    defaultOperator: {
	      type: 'enum',
	      'default': 'OR',
	      options: [
	        'AND',
	        'OR'
	      ],
	      name: 'default_operator'
	    },
	    df: {
	      type: 'string'
	    },
	    lenient: {
	      type: 'boolean'
	    },
	    lowercaseExpandedTerms: {
	      type: 'boolean',
	      name: 'lowercase_expanded_terms'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search/exists',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search/exists',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search/exists'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [searchShards](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-shards.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.searchShards = ca({
	  params: {
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    },
	    local: {
	      type: 'boolean'
	    },
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search_shards',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search_shards',
	      req: {
	        index: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_search_shards'
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [searchTemplate](http://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String, String[], Boolean} params.routing - A comma-separated list of specific routing values
	 * @param {Duration} params.scroll - Specify how long a consistent view of the index should be maintained for scrolled search
	 * @param {String} params.searchType - Search operation type
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices
	 * @param {String, String[], Boolean} params.type - A comma-separated list of document types to search; leave empty to perform the operation on all types
	 */
	api.searchTemplate = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'list'
	    },
	    scroll: {
	      type: 'duration'
	    },
	    searchType: {
	      type: 'enum',
	      options: [
	        'query_then_fetch',
	        'query_and_fetch',
	        'dfs_query_then_fetch',
	        'dfs_query_and_fetch',
	        'count',
	        'scan'
	      ],
	      name: 'search_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/_search/template',
	      req: {
	        index: {
	          type: 'list'
	        },
	        type: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/_search/template',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_search/template'
	    }
	  ],
	  method: 'POST'
	});

	api.snapshot = namespace();

	/**
	 * Perform a [snapshot.create](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.waitForCompletion - Should this request wait until the operation has completed before returning
	 * @param {String} params.repository - A repository name
	 * @param {String} params.snapshot - A snapshot name
	 */
	api.snapshot.prototype.create = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    waitForCompletion: {
	      type: 'boolean',
	      'default': false,
	      name: 'wait_for_completion'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [snapshot.createRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Boolean} params.verify - Whether to verify the repository after creation
	 * @param {String} params.repository - A repository name
	 */
	api.snapshot.prototype.createRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    },
	    verify: {
	      type: 'boolean'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>',
	    req: {
	      repository: {
	        type: 'string'
	      }
	    }
	  },
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [snapshot.delete](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String} params.repository - A repository name
	 * @param {String} params.snapshot - A snapshot name
	 */
	api.snapshot.prototype['delete'] = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [snapshot.deleteRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {String, String[], Boolean} params.repository - A comma-separated list of repository names
	 */
	api.snapshot.prototype.deleteRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>',
	    req: {
	      repository: {
	        type: 'list'
	      }
	    }
	  },
	  method: 'DELETE'
	});

	/**
	 * Perform a [snapshot.get](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String} params.repository - A repository name
	 * @param {String, String[], Boolean} params.snapshot - A comma-separated list of snapshot names
	 */
	api.snapshot.prototype.get = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'list'
	      }
	    }
	  }
	});

	/**
	 * Perform a [snapshot.getRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.local - Return local information, do not retrieve the state from master node (default: false)
	 * @param {String, String[], Boolean} params.repository - A comma-separated list of repository names
	 */
	api.snapshot.prototype.getRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    local: {
	      type: 'boolean'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_snapshot/<%=repository%>',
	      req: {
	        repository: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_snapshot'
	    }
	  ]
	});

	/**
	 * Perform a [snapshot.restore](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Boolean} params.waitForCompletion - Should this request wait until the operation has completed before returning
	 * @param {String} params.repository - A repository name
	 * @param {String} params.snapshot - A snapshot name
	 */
	api.snapshot.prototype.restore = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    waitForCompletion: {
	      type: 'boolean',
	      'default': false,
	      name: 'wait_for_completion'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_restore',
	    req: {
	      repository: {
	        type: 'string'
	      },
	      snapshot: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [snapshot.status](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {String} params.repository - A repository name
	 * @param {String, String[], Boolean} params.snapshot - A comma-separated list of snapshot names
	 */
	api.snapshot.prototype.status = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    }
	  },
	  urls: [
	    {
	      fmt: '/_snapshot/<%=repository%>/<%=snapshot%>/_status',
	      req: {
	        repository: {
	          type: 'string'
	        },
	        snapshot: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_snapshot/<%=repository%>/_status',
	      req: {
	        repository: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/_snapshot/_status'
	    }
	  ]
	});

	/**
	 * Perform a [snapshot.verifyRepository](http://www.elastic.co/guide/en/elasticsearch/reference/master/modules-snapshots.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Date, Number} params.masterTimeout - Explicit operation timeout for connection to master node
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {String} params.repository - A repository name
	 */
	api.snapshot.prototype.verifyRepository = ca({
	  params: {
	    masterTimeout: {
	      type: 'time',
	      name: 'master_timeout'
	    },
	    timeout: {
	      type: 'time'
	    }
	  },
	  url: {
	    fmt: '/_snapshot/<%=repository%>/_verify',
	    req: {
	      repository: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [suggest](http://www.elastic.co/guide/en/elasticsearch/reference/master/search-suggesters.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.ignoreUnavailable - Whether specified concrete indices should be ignored when unavailable (missing or closed)
	 * @param {Boolean} params.allowNoIndices - Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)
	 * @param {String} [params.expandWildcards=open] - Whether to expand wildcard expression to concrete indices that are open, closed or both.
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random)
	 * @param {String} params.routing - Specific routing value
	 * @param {String, String[], Boolean} params.index - A comma-separated list of index names to restrict the operation; use `_all` or empty string to perform the operation on all indices
	 */
	api.suggest = ca({
	  params: {
	    ignoreUnavailable: {
	      type: 'boolean',
	      name: 'ignore_unavailable'
	    },
	    allowNoIndices: {
	      type: 'boolean',
	      name: 'allow_no_indices'
	    },
	    expandWildcards: {
	      type: 'enum',
	      'default': 'open',
	      options: [
	        'open',
	        'closed',
	        'none',
	        'all'
	      ],
	      name: 'expand_wildcards'
	    },
	    preference: {
	      type: 'string'
	    },
	    routing: {
	      type: 'string'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/_suggest',
	      req: {
	        index: {
	          type: 'list'
	        }
	      }
	    },
	    {
	      fmt: '/_suggest'
	    }
	  ],
	  needBody: true,
	  method: 'POST'
	});

	/**
	 * Perform a [termvectors](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {Boolean} params.termStatistics - Specifies if total term frequency and document frequency should be returned.
	 * @param {Boolean} [params.fieldStatistics=true] - Specifies if document count, sum of document frequencies and sum of total term frequencies should be returned.
	 * @param {Boolean} params.dfs - Specifies if distributed frequencies should be returned instead shard frequencies.
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return.
	 * @param {Boolean} [params.offsets=true] - Specifies if term offsets should be returned.
	 * @param {Boolean} [params.positions=true] - Specifies if term positions should be returned.
	 * @param {Boolean} [params.payloads=true] - Specifies if term payloads should be returned.
	 * @param {String} params.preference - Specify the node or shard the operation should be performed on (default: random).
	 * @param {String} params.routing - Specific routing value.
	 * @param {String} params.parent - Parent id of documents.
	 * @param {Boolean} params.realtime - Specifies if request is real-time as opposed to near-real-time (default: true).
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.index - The index in which the document resides.
	 * @param {String} params.type - The type of the document.
	 * @param {String} params.id - The id of the document, when not specified a doc param should be supplied.
	 */
	api.termvectors = ca({
	  params: {
	    termStatistics: {
	      type: 'boolean',
	      'default': false,
	      required: false,
	      name: 'term_statistics'
	    },
	    fieldStatistics: {
	      type: 'boolean',
	      'default': true,
	      required: false,
	      name: 'field_statistics'
	    },
	    dfs: {
	      type: 'boolean',
	      'default': false,
	      required: false
	    },
	    fields: {
	      type: 'list',
	      required: false
	    },
	    offsets: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    positions: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    payloads: {
	      type: 'boolean',
	      'default': true,
	      required: false
	    },
	    preference: {
	      type: 'string',
	      required: false
	    },
	    routing: {
	      type: 'string',
	      required: false
	    },
	    parent: {
	      type: 'string',
	      required: false
	    },
	    realtime: {
	      type: 'boolean',
	      required: false
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'external',
	        'external_gte',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  urls: [
	    {
	      fmt: '/<%=index%>/<%=type%>/<%=id%>/_termvectors',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        },
	        id: {
	          type: 'string'
	        }
	      }
	    },
	    {
	      fmt: '/<%=index%>/<%=type%>/_termvectors',
	      req: {
	        index: {
	          type: 'string'
	        },
	        type: {
	          type: 'string'
	        }
	      }
	    }
	  ],
	  method: 'POST'
	});

	/**
	 * Perform a [update](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {String, String[], Boolean} params.fields - A comma-separated list of fields to return in the response
	 * @param {String} params.lang - The script language (default: groovy)
	 * @param {String} params.parent - ID of the parent document. Is is only used for routing and when for the upsert request
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {Number} params.retryOnConflict - Specify how many times should the operation be retried when a conflict occurs (default: 0)
	 * @param {String} params.routing - Specific routing value
	 * @param {Anything} params.script - The URL-encoded script definition (instead of using request body)
	 * @param {Anything} params.scriptId - The id of a stored script
	 * @param {Boolean} params.scriptedUpsert - True if the script referenced in script or script_id should be called to perform inserts - defaults to false
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.timestamp - Explicit timestamp for the document
	 * @param {Duration} params.ttl - Expiration time for the document
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.update = ca({
	  params: {
	    consistency: {
	      type: 'enum',
	      options: [
	        'one',
	        'quorum',
	        'all'
	      ]
	    },
	    fields: {
	      type: 'list'
	    },
	    lang: {
	      type: 'string'
	    },
	    parent: {
	      type: 'string'
	    },
	    refresh: {
	      type: 'boolean'
	    },
	    retryOnConflict: {
	      type: 'number',
	      name: 'retry_on_conflict'
	    },
	    routing: {
	      type: 'string'
	    },
	    script: {},
	    scriptId: {
	      name: 'script_id'
	    },
	    scriptedUpsert: {
	      type: 'boolean',
	      name: 'scripted_upsert'
	    },
	    timeout: {
	      type: 'time'
	    },
	    timestamp: {
	      type: 'time'
	    },
	    ttl: {
	      type: 'duration'
	    },
	    version: {
	      type: 'number'
	    },
	    versionType: {
	      type: 'enum',
	      options: [
	        'internal',
	        'force'
	      ],
	      name: 'version_type'
	    }
	  },
	  url: {
	    fmt: '/<%=index%>/<%=type%>/<%=id%>/_update',
	    req: {
	      index: {
	        type: 'string'
	      },
	      type: {
	        type: 'string'
	      },
	      id: {
	        type: 'string'
	      }
	    }
	  },
	  method: 'POST'
	});

	/**
	 * Perform a [create](http://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html) request
	 *
	 * @param {Object} params - An object with parameters used to carry out this action
	 * @param {String} params.consistency - Explicit write consistency setting for the operation
	 * @param {String} params.parent - ID of the parent document
	 * @param {Boolean} params.refresh - Refresh the index after performing the operation
	 * @param {String} params.routing - Specific routing value
	 * @param {Date, Number} params.timeout - Explicit operation timeout
	 * @param {Date, Number} params.timestamp - Explicit timestamp for the document
	 * @param {Duration} params.ttl - Expiration time for the document
	 * @param {Number} params.version - Explicit version number for concurrency control
	 * @param {String} params.versionType - Specific version type
	 * @param {String} params.id - Document ID
	 * @param {String} params.index - The name of the index
	 * @param {String} params.type - The type of the document
	 */
	api.create = ca.proxy(api.index, {
	  transform: function (params) {
	    params.op_type = 'create';
	  }
	});
	},{"../client_action":21,"../utils":41}],19:[function(require,module,exports){
	module.exports = {
	  '2.0': require('./2_0'),
	  '1.7': require('./1_7'),
	  '1.6': require('./1_6')
	};

	},{"./1_6":16,"./1_7":17,"./2_0":18}],20:[function(require,module,exports){
	/**
	 * A client that makes requests to Elasticsearch via a {{#crossLink "Transport"}}Transport{{/crossLink}}
	 *
	 * Initializing a client might look something like:
	 *
	 * ```
	 * var client = new es.Client({
	 *   hosts: [
	 *     'es1.net:9200',
	 *     {
	 *       host: 'es2.net',
	 *       port: 9200
	 *     }
	 *   ],
	 *   sniffOnStart: true,
	 *   log: {
	 *     type: 'file',
	 *     level: 'warning'
	 *   }
	 * });
	 * ```
	 *
	 * @class Client
	 * @constructor
	 */

	module.exports = Client;

	var Transport = require('./transport');
	var clientAction = require('./client_action');
	var _ = require('./utils');

	function Client(config) {
	  config = config || {};

	  if (config.__reused) {
	    throw new Error('Do not reuse objects to configure the elasticsearch Client class: ' +
	      'https://github.com/elasticsearch/elasticsearch-js/issues/33');
	  } else {
	    config.__reused = true;
	  }

	  function EsApiClient() {
	    // our client will log minimally by default
	    if (!config.hasOwnProperty('log')) {
	      config.log = 'warning';
	    }

	    if (!config.hosts && !config.host) {
	      config.host = 'http://localhost:9200';
	    }

	    this.close = function () {
	      this.transport.close();
	    };

	    this.transport = new Transport(config);

	    _.each(EsApiClient.prototype, function (Fn, prop) {
	      if (Fn.prototype instanceof clientAction.ApiNamespace) {
	        this[prop] = new Fn(this.transport);
	      }
	    }, this);

	    delete this._namespaces;
	  }


	  EsApiClient.prototype = _.funcEnum(config, 'apiVersion', Client.apis, '1.7');
	  if (!config.sniffEndpoint && EsApiClient.prototype === Client.apis['0.90']) {
	    config.sniffEndpoint = '/_cluster/nodes';
	  }

	  var Constructor = EsApiClient;

	  if (config.plugins) {
	    Constructor.prototype = _.cloneDeep(Constructor.prototype);

	    _.each(config.plugins, function (setup) {
	      Constructor = setup(Constructor, config, {
	        apis: require('./apis'),
	        connectors: require('./connectors'),
	        loggers: require('./loggers'),
	        selectors: require('./selectors'),
	        serializers: require('./serializers'),
	        Client: require('./client'),
	        clientAction: clientAction,
	        Connection: require('./connection'),
	        ConnectionPool: require('./connection_pool'),
	        Errors: require('./errors'),
	        Host: require('./host'),
	        Log: require('./log'),
	        Logger: require('./logger'),
	        NodesToHost: require('./nodes_to_host'),
	        Transport: require('./transport'),
	        utils: require('./utils')
	      }) || Constructor;
	    });
	  }

	  return new Constructor();
	}

	Client.apis = require('./apis');
	},{"./apis":19,"./client":20,"./client_action":21,"./connection":22,"./connection_pool":23,"./connectors":25,"./errors":26,"./host":27,"./log":28,"./logger":29,"./loggers":30,"./nodes_to_host":32,"./selectors":33,"./serializers":37,"./transport":39,"./utils":41}],21:[function(require,module,exports){

	var _ = require('./utils');

	/**
	 * Constructs a client action factory that uses specific defaults
	 * @type {Function}
	 */
	exports.makeFactoryWithModifier = makeFactoryWithModifier;

	/**
	 * Constructs a function that can be called to make a request to ES
	 * @type {Function}
	 */
	exports.factory = makeFactoryWithModifier();

	/**
	 * Constructs a proxy to another api method
	 * @type {Function}
	 */
	exports.proxyFactory = exports.factory.proxy;

	// export so that we can test this
	exports._resolveUrl = resolveUrl;

	exports.ApiNamespace = function() {};
	exports.namespaceFactory = function () {
	  function ClientNamespace(transport) {
	    this.transport = transport;
	  }

	  ClientNamespace.prototype = new exports.ApiNamespace();

	  return ClientNamespace;
	};

	function makeFactoryWithModifier(modifier) {
	  modifier = modifier || _.identity;

	  var factory = function (spec) {
	    spec = modifier(spec);

	    if (!_.isPlainObject(spec.params)) {
	      spec.params = {};
	    }

	    if (!spec.method) {
	      spec.method = 'GET';
	    }

	    function action(params, cb) {
	      if (typeof params === 'function') {
	        cb = params;
	        params = {};
	      } else {
	        params = params || {};
	        cb = typeof cb === 'function' ? cb : null;
	      }

	      try {
	        return exec(this.transport, spec, _.clone(params), cb);
	      } catch (e) {
	        if (typeof cb === 'function') {
	          _.nextTick(cb, e);
	        } else {
	          var def = this.transport.defer();
	          def.reject(e);
	          return def.promise;
	        }
	      }
	    }

	    action.spec = spec;

	    return action;
	  };

	  factory.proxy = function (fn, spec) {
	    return function (params, cb) {
	      if (typeof params === 'function') {
	        cb = params;
	        params = {};
	      } else {
	        params = params || {};
	        cb = typeof cb === 'function' ? cb : null;
	      }

	      if (spec.transform) {
	        spec.transform(params);
	      }

	      return fn.call(this, params, cb);
	    };
	  };

	  return factory;
	}

	var castType = {
	  'enum': function validSelection(param, val, name) {
	    if (_.isString(val) && val.indexOf(',') > -1) {
	      val = commaSepList(val);
	    }

	    if (_.isArray(val)) {
	      return val.map(function (v) {
	        return validSelection(param, v, name);
	      }).join(',');
	    }

	    /* jshint eqeqeq: false */
	    for (var i = 0; i < param.options.length; i++) {
	      if (param.options[i] == val) {
	        return param.options[i];
	      }
	    }
	    throw new TypeError('Invalid ' + name + ': expected ' + (
	      param.options.length > 1
	      ? 'one of ' + param.options.join(',')
	      : param.options[0]
	    ));
	  },
	  duration: function (param, val, name) {
	    if (_.isNumeric(val) || _.isInterval(val)) {
	      return val;
	    } else {
	      throw new TypeError(
	        'Invalid ' + name + ': expected a number or interval ' +
	        '(an integer followed by one of M, w, d, h, m, s, y or ms).'
	      );
	    }
	  },
	  list: function (param, val, name) {
	    switch (typeof val) {
	    case 'number':
	    case 'boolean':
	      return '' + val;
	    case 'string':
	      val = commaSepList(val);
	      /* falls through */
	    case 'object':
	      if (_.isArray(val)) {
	        return val.join(',');
	      }
	      /* falls through */
	    default:
	      throw new TypeError('Invalid ' + name + ': expected be a comma seperated list, array, number or string.');
	    }
	  },
	  'boolean': function (param, val) {
	    val = _.isString(val) ? val.toLowerCase() : val;
	    return (val === 'no' || val === 'off') ? false : !!val;
	  },
	  number: function (param, val, name) {
	    if (_.isNumeric(val)) {
	      return val * 1;
	    } else {
	      throw new TypeError('Invalid ' + name + ': expected a number.');
	    }
	  },
	  string: function (param, val, name) {
	    switch (typeof val) {
	    case 'number':
	    case 'string':
	      return '' + val;
	    default:
	      throw new TypeError('Invalid ' + name + ': expected a string.');
	    }
	  },
	  time: function (param, val, name) {
	    if (typeof val === 'string') {
	      return val;
	    }
	    else if (_.isNumeric(val)) {
	      return '' + val;
	    }
	    else if (val instanceof Date) {
	      return '' + val.getTime();
	    }
	    else {
	      throw new TypeError('Invalid ' + name + ': expected some sort of time.');
	    }
	  }
	};

	function resolveUrl(url, params) {
	  var vars = {}, i, key;

	  if (url.req) {
	    // url has required params
	    if (!url.reqParamKeys) {
	      // create cached key list on demand
	      url.reqParamKeys = _.keys(url.req);
	    }

	    for (i = 0; i < url.reqParamKeys.length; i ++) {
	      key = url.reqParamKeys[i];
	      if (!params.hasOwnProperty(key) || params[key] == null) {
	        // missing a required param
	        return false;
	      } else {
	        // cast of copy required param
	        if (castType[url.req[key].type]) {
	          vars[key] = castType[url.req[key].type](url.req[key], params[key], key);
	        } else {
	          vars[key] = params[key];
	        }
	      }
	    }
	  }

	  if (url.opt) {
	    // url has optional params
	    if (!url.optParamKeys) {
	      url.optParamKeys = _.keys(url.opt);
	    }

	    for (i = 0; i < url.optParamKeys.length; i ++) {
	      key = url.optParamKeys[i];
	      if (params[key]) {
	        if (castType[url.opt[key].type] || params[key] == null) {
	          vars[key] = castType[url.opt[key].type](url.opt[key], params[key], key);
	        } else {
	          vars[key] = params[key];
	        }
	      } else {
	        vars[key] = url.opt[key]['default'];
	      }
	    }
	  }

	  if (!url.template) {
	    // compile the template on demand
	    url.template = _.template(url.fmt);
	  }

	  return url.template(_.transform(vars, function (note, val, name) {
	    // encode each value
	    note[name] = encodeURIComponent(val);
	    // remove it from the params so that it isn't sent to the final request
	    delete params[name];
	  }, {}));
	}


	function exec(transport, spec, params, cb) {
	  var request = {
	    method: spec.method
	  };
	  var query = {};
	  var i;

	  // pass the timeout from the spec
	  if (spec.requestTimeout) {
	    request.requestTimeout = spec.requestTimeout;
	  }

	  if (!params.body && spec.paramAsBody) {
	    params.body = params[spec.paramAsBody];
	    delete params[spec.paramAsBody];
	  }

	  // verify that we have the body if needed
	  if (spec.needsBody && !params.body) {
	    throw new TypeError('A request body is required.');
	  }

	  // control params
	  if (spec.bulkBody) {
	    request.bulkBody = true;
	  }

	  if (spec.method === 'HEAD') {
	    request.castExists = true;
	  }

	  // pick the url
	  if (spec.url) {
	    // only one url option
	    request.path = resolveUrl(spec.url, params);
	  } else {
	    for (i = 0; i < spec.urls.length; i++) {
	      if (request.path = resolveUrl(spec.urls[i], params)) {
	        break;
	      }
	    }
	  }

	  if (!request.path) {
	    // there must have been some mimimun requirements that were not met
	    var minUrl = spec.url || spec.urls[spec.urls.length - 1];
	    throw new TypeError('Unable to build a path with those params. Supply at least ' + _.keys(minUrl.req).join(', '));
	  }

	  // build the query string
	  if (!spec.paramKeys) {
	    // build a key list on demand
	    spec.paramKeys = _.keys(spec.params);
	    spec.requireParamKeys = _.transform(spec.params, function (req, param, key) {
	      if (param.required) {
	        req.push(key);
	      }
	    }, []);
	  }

	  for (var key in params) {
	    if (params.hasOwnProperty(key) && params[key] != null) {
	      switch (key) {
	      case 'body':
	      case 'headers':
	      case 'requestTimeout':
	      case 'maxRetries':
	        request[key] = params[key];
	        break;
	      case 'ignore':
	        request.ignore = _.isArray(params[key]) ? params[key] : [params[key]];
	        break;
	      case 'method':
	        request.method = _.toUpperString(params[key]);
	        break;
	      default:
	        var paramSpec = spec.params[key];
	        if (paramSpec) {
	          // param keys don't always match the param name, in those cases it's stored in the param def as "name"
	          paramSpec.name = paramSpec.name || key;
	          if (params[key] != null) {
	            if (castType[paramSpec.type]) {
	              query[paramSpec.name] = castType[paramSpec.type](paramSpec, params[key], key);
	            } else {
	              query[paramSpec.name] = params[key];
	            }

	            if (paramSpec['default'] && query[paramSpec.name] === paramSpec['default']) {
	              delete query[paramSpec.name];
	            }
	          }
	        } else {
	          query[key] = params[key];
	        }
	      }
	    }
	  }

	  for (i = 0; i < spec.requireParamKeys.length; i ++) {
	    if (!query.hasOwnProperty(spec.requireParamKeys[i])) {
	      throw new TypeError('Missing required parameter ' + spec.requireParamKeys[i]);
	    }
	  }

	  request.query = query;

	  return transport.request(request, cb);
	}

	function commaSepList(str) {
	  return str.split(',').map(function (i) {
	    return i.trim();
	  });
	}
	},{"./utils":41}],22:[function(require,module,exports){
	module.exports = ConnectionAbstract;

	var _ = require('./utils');
	var EventEmitter = require('events').EventEmitter;
	var Log = require('./log');
	var Host = require('./host');
	var errors = require('./errors');

	/**
	 * Abstract class used for Connection classes
	 * @class ConnectionAbstract
	 * @constructor
	 */
	function ConnectionAbstract(host, config) {
	  config = config || {};
	  EventEmitter.call(this);

	  this.log = config.log || new Log();
	  this.pingTimeout = config.pingTimeout || 3000;

	  if (!host) {
	    throw new TypeError('Missing host');
	  } else if (host instanceof Host) {
	    this.host = host;
	  } else {
	    throw new TypeError('Invalid host');
	  }

	  _.makeBoundMethods(this);
	}
	_.inherits(ConnectionAbstract, EventEmitter);

	/**
	 * Make a request using this connection. Must be overridden by Connection classes, which can add whatever keys to
	 * params that they like. These are just the basics.
	 *
	 * @param [params] {Object} - The parameters for the request
	 * @param params.path {String} - The path for which you are requesting
	 * @param params.method {String} - The HTTP method for the request (GET, HEAD, etc.)
	 * @param params.requestTimeout {Integer} - The amount of time in milliseconds that this request should be allowed to run for.
	 * @param cb {Function} - A callback to be called once with `cb(err, responseBody, responseStatus)`
	 */
	ConnectionAbstract.prototype.request = function () {
	  throw new Error('Connection#request must be overwritten by the Connector');
	};

	ConnectionAbstract.prototype.ping = function (params, cb) {
	  if (typeof params === 'function') {
	    cb = params;
	    params = null;
	  } else {
	    cb = typeof cb === 'function' ? cb : null;
	  }

	  var requestTimeout = this.pingTimeout;
	  var requestTimeoutId;
	  var aborted;
	  var abort;

	  if (params && params.hasOwnProperty('requestTimeout')) {
	    requestTimeout = params.requestTimeout;
	  }

	  abort = this.request(_.defaults(params || {}, {
	    path: '/',
	    method: 'HEAD'
	  }), function (err) {
	    if (aborted) {
	      return;
	    }
	    clearTimeout(requestTimeoutId);
	    if (cb) {
	      cb(err);
	    }
	  });

	  if (requestTimeout) {
	    requestTimeoutId = setTimeout(function () {
	      if (abort) {
	        abort();
	      }
	      aborted = true;
	      if (cb) {
	        cb(new errors.RequestTimeout('Ping Timeout after ' + requestTimeout + 'ms'));
	      }
	    }, requestTimeout);
	  }
	};

	ConnectionAbstract.prototype.setStatus = function (status) {
	  var origStatus = this.status;
	  this.status = status;

	  this.emit('status set', status, origStatus, this);

	  if (status === 'closed') {
	    this.removeAllListeners();
	  }
	};
	},{"./errors":26,"./host":27,"./log":28,"./utils":41,"events":4}],23:[function(require,module,exports){
	var process=require("__browserify_process");/**
	 * Manager of connections to a node(s), capable of ensuring that connections are clear and living
	 * before providing them to the application
	 *
	 * @class ConnectionPool
	 * @constructor
	 * @param {Object} config - The config object passed to the transport.
	 */

	module.exports = ConnectionPool;

	var _ = require('./utils');
	var Log = require('./log');

	function ConnectionPool(config) {
	  config = config || {};
	  _.makeBoundMethods(this);

	  if (!config.log) {
	    this.log = new Log();
	    config.log = this.log;
	  } else {
	    this.log = config.log;
	  }

	  // we will need this when we create connections down the road
	  this._config = config;

	  // get the selector config var
	  this.selector = _.funcEnum(config, 'selector', ConnectionPool.selectors, ConnectionPool.defaultSelector);

	  // get the connection class
	  this.Connection = _.funcEnum(config, 'connectionClass', ConnectionPool.connectionClasses,
	    ConnectionPool.defaultConnectionClass);

	  // time that connections will wait before being revived
	  this.deadTimeout = config.hasOwnProperty('deadTimeout') ? config.deadTimeout : 60000;
	  this.maxDeadTimeout = config.hasOwnProperty('maxDeadTimeout') ? config.maxDeadTimeout : 18e5;
	  this.calcDeadTimeout = _.funcEnum(config, 'calcDeadTimeout', ConnectionPool.calcDeadTimeoutOptions, 'exponential');

	  // a map of connections to their "id" property, used when sniffing
	  this.index = {};

	  this._conns = {
	    alive: [],
	    dead: []
	  };

	  // information about timeouts for dead connections
	  this._timeouts = [];
	}

	// selector options
	ConnectionPool.selectors = require('./selectors');
	ConnectionPool.defaultSelector = 'roundRobin';

	// get the connection options
	ConnectionPool.connectionClasses = require('./connectors');
	ConnectionPool.defaultConnectionClass = ConnectionPool.connectionClasses._default;
	delete ConnectionPool.connectionClasses._default;

	// the function that calculates timeouts based on attempts
	ConnectionPool.calcDeadTimeoutOptions = {
	  flat: function (attempt, baseTimeout) {
	    return baseTimeout;
	  },
	  exponential: function (attempt, baseTimeout) {
	    return Math.min(baseTimeout * 2 * Math.pow(2, (attempt * 0.5 - 1)), this.maxDeadTimeout);
	  }
	};

	/**
	 * Selects a connection from the list using the this.selector
	 * Features:
	 *  - detects if the selector is async or not
	 *  - sync selectors should still return asynchronously
	 *  - catches errors in sync selectors
	 *  - automatically selects the first dead connection when there no living connections
	 *
	 * @param  {Function} cb [description]
	 * @return {[type]}      [description]
	 */
	ConnectionPool.prototype.select = function (cb) {
	  if (this._conns.alive.length) {
	    if (this.selector.length > 1) {
	      this.selector(this._conns.alive, cb);
	    } else {
	      try {
	        _.nextTick(cb, void 0, this.selector(this._conns.alive));
	      } catch (e) {
	        cb(e);
	      }
	    }
	  } else if (this._timeouts.length) {
	    this._selectDeadConnection(cb);
	  } else {
	    _.nextTick(cb, void 0);
	  }
	};

	/**
	 * Handler for the "set status" event emitted but the connections. It will move
	 * the connection to it's proper connection list (unless it was closed).
	 *
	 * @param  {String} status - the connection's new status
	 * @param  {String} oldStatus - the connection's old status
	 * @param  {ConnectionAbstract} connection - the connection object itself
	 */
	ConnectionPool.prototype.onStatusSet = _.handler(function (status, oldStatus, connection) {
	  var index;

	  var died = (status === 'dead');
	  var wasAlreadyDead = (died && oldStatus === 'dead');
	  var revived = (!died && oldStatus === 'dead');
	  var noChange = (oldStatus === status);
	  var from = this._conns[oldStatus];
	  var to = this._conns[status];

	  if (noChange && !died) {
	    return true;
	  }

	  if (from !== to) {
	    if (_.isArray(from)) {
	      index = from.indexOf(connection);
	      if (index !== -1) {
	        from.splice(index, 1);
	      }
	    }

	    if (_.isArray(to)) {
	      index = to.indexOf(connection);
	      if (index === -1) {
	        to.push(connection);
	      }
	    }
	  }

	  if (died) {
	    this._onConnectionDied(connection, wasAlreadyDead);
	  }

	  if (revived) {
	    this._onConnectionRevived(connection);
	  }
	});

	/**
	 * Handler used to clear the times created when a connection dies
	 * @param  {ConnectionAbstract} connection
	 */
	ConnectionPool.prototype._onConnectionRevived = function (connection) {
	  var timeout;
	  for (var i = 0; i < this._timeouts.length; i++)  {
	    if (this._timeouts[i].conn === connection) {
	      timeout = this._timeouts[i];
	      if (timeout.id) {
	        clearTimeout(timeout.id);
	      }
	      this._timeouts.splice(i, 1);
	      break;
	    }
	  }
	};

	/**
	 * Handler used to update or create a timeout for the connection which has died
	 * @param  {ConnectionAbstract} connection
	 * @param  {Boolean} alreadyWasDead - If the connection was preivously dead this must be set to true
	 */
	ConnectionPool.prototype._onConnectionDied = function (connection, alreadyWasDead) {
	  var timeout;
	  if (alreadyWasDead) {
	    for (var i = 0; i < this._timeouts.length; i++)  {
	      if (this._timeouts[i].conn === connection) {
	        timeout = this._timeouts[i];
	        break;
	      }
	    }
	  } else {
	    timeout = {
	      conn: connection,
	      attempt: 0,
	      revive: function (cb) {
	        timeout.attempt++;
	        connection.ping(function (err) {
	          connection.setStatus(err ? 'dead' : 'alive');
	          if (cb && typeof cb === 'function') {
	            cb(err);
	          }
	        });
	      }
	    };
	    this._timeouts.push(timeout);
	  }

	  if (timeout.id) {
	    clearTimeout(timeout.id);
	  }

	  var ms = this.calcDeadTimeout(timeout.attempt, this.deadTimeout);
	  timeout.id = setTimeout(timeout.revive, ms);
	  timeout.runAt = _.now() + ms;
	};

	ConnectionPool.prototype._selectDeadConnection = function (cb) {
	  var orderedTimeouts = _.sortBy(this._timeouts, 'runAt');
	  var log = this.log;

	  process.nextTick(function next() {
	    var timeout = orderedTimeouts.shift();
	    if (!timeout) {
	      cb(void 0);
	      return;
	    }

	    if (!timeout.conn) {
	      next();
	      return;
	    }

	    if (timeout.conn.status === 'dead') {
	      timeout.revive(function (err) {
	        if (err) {
	          log.warning('Unable to revive connection: ' + timeout.conn.id);
	          process.nextTick(next);
	        } else {
	          cb(void 0, timeout.conn);
	        }
	      });
	    } else {
	      cb(void 0, timeout.conn);
	    }
	  });
	};

	/**
	 * Returns a random list of nodes from the living connections up to the limit.
	 * If there are no living connections it will fall back to the dead connections.
	 * If there are no dead connections it will return nothing.
	 *
	 * This is used for testing (when we just want the one existing node)
	 * and sniffing, where using the selector to get all of the living connections
	 * is not reasonable.
	 *
	 * @param {string} [status] - optional status of the connection to fetch
	 * @param {Number} [limit] - optional limit on the number of connections to return
	 */
	ConnectionPool.prototype.getConnections = function (status, limit) {
	  var list;
	  if (status) {
	    list = this._conns[status];
	  } else {
	    list = this._conns[this._conns.alive.length ? 'alive' : 'dead'];
	  }

	  if (limit == null) {
	    return list.slice(0);
	  } else {
	    return _.shuffle(list).slice(0, limit);
	  }
	};

	/**
	 * Add a single connection to the pool and change it's status to "alive".
	 * The connection should inherit from ConnectionAbstract
	 *
	 * @param {ConnectionAbstract} connection - The connection to add
	 */
	ConnectionPool.prototype.addConnection = function (connection) {
	  if (!connection.id) {
	    connection.id = connection.host.toString();
	  }

	  if (!this.index[connection.id]) {
	    this.log.info('Adding connection to', connection.id);
	    this.index[connection.id] = connection;
	    connection.on('status set', this.bound.onStatusSet);
	    connection.setStatus('alive');
	  }
	};

	/**
	 * Remove a connection from the pool, and set it's status to "closed".
	 *
	 * @param  {ConnectionAbstract} connection - The connection to remove/close
	 */
	ConnectionPool.prototype.removeConnection = function (connection) {
	  if (!connection.id) {
	    connection.id = connection.host.toString();
	  }

	  if (this.index[connection.id]) {
	    delete this.index[connection.id];
	    connection.setStatus('closed');
	    connection.removeListener('status set', this.bound.onStatusSet);
	  }
	};

	/**
	 * Override the internal node list. All connections that are not in the new host
	 * list are closed and removed. Non-unique hosts are ignored.
	 *
	 * @param {Host[]} hosts - An array of Host instances.
	 */
	ConnectionPool.prototype.setHosts = function (hosts) {
	  var connection;
	  var i;
	  var id;
	  var host;
	  var toRemove = _.clone(this.index);

	  for (i = 0; i < hosts.length; i++) {
	    host = hosts[i];
	    id = host.toString();
	    if (this.index[id]) {
	      delete toRemove[id];
	    } else {
	      connection = new this.Connection(host, this._config);
	      connection.id = id;
	      this.addConnection(connection);
	    }
	  }

	  var removeIds = _.keys(toRemove);
	  for (i = 0; i < removeIds.length; i++) {
	    this.removeConnection(this.index[removeIds[i]]);
	  }
	};

	/**
	 * Close the conncetion pool, as well as all of it's connections
	 */
	ConnectionPool.prototype.close = function () {
	  this.setHosts([]);
	};
	ConnectionPool.prototype.empty = ConnectionPool.prototype.close;
	},{"./connectors":25,"./log":28,"./selectors":33,"./utils":41,"__browserify_process":13}],24:[function(require,module,exports){
	/**
	 * Connection that registers a module with angular, using angular's $http service
	 * to communicate with ES.
	 *
	 * @class connections.Angular
	 */
	module.exports = AngularConnector;

	var _ = require('../utils');
	var ConnectionAbstract = require('../connection');
	var ConnectionFault = require('../errors').ConnectionFault;

	function AngularConnector(host, config) {
	  ConnectionAbstract.call(this, host, config);

	  var self = this;
	  config.$injector.invoke(['$http', '$q', function ($http, $q) {
	    self.$q = $q;
	    self.$http = $http;
	  }]);

	}
	_.inherits(AngularConnector, ConnectionAbstract);

	AngularConnector.prototype.request = function (params, cb) {
	  var abort = this.$q.defer();

	  this.$http({
	    method: params.method,
	    url: this.host.makeUrl(params),
	    data: params.body,
	    cache: false,
	    headers: this.host.getHeaders(params.headers),
	    transformRequest: [],
	    transformResponse: [],
	    // not actually for timing out, that's handled by the transport
	    timeout: abort.promise
	  }).then(function (response) {
	    cb(null, response.data, response.status, response.headers());
	  }, function (err) {
	    if (err.status) {
	      cb(null, err.data, err.status, err.headers());
	    } else {
	      cb(new ConnectionFault(err.message));
	    }
	  });

	  return function () {
	    abort.resolve();
	  };
	};
	},{"../connection":22,"../errors":26,"../utils":41}],25:[function(require,module,exports){
	var opts = {
	  xhr: require('./xhr'),
	  jquery: require('./jquery'),
	  angular: require('./angular')
	};
	var _ = require('../utils');

	// remove modules that have been ignored by browserify
	_.each(opts, function (conn, name) {
	  if (typeof conn !== 'function') {
	    delete opts[name];
	  }
	});

	// custom _default specification
	if (opts.xhr) {
	  opts._default = 'xhr';
	} else if (opts.angular) {
	  opts._default = 'angular';
	} else {
	  opts._default = 'jquery';
	}

	module.exports = opts;

	},{"../utils":41,"./angular":24,"./jquery":1,"./xhr":1}],26:[function(require,module,exports){
	var _ = require('./utils');
	var errors = module.exports;

	var canCapture = (typeof Error.captureStackTrace === 'function');
	var canStack = !!(new Error()).stack;

	function ErrorAbstract(msg, constructor, metadata) {
	  this.message = msg;

	  Error.call(this, this.message);

	  if (canCapture) {
	    Error.captureStackTrace(this, constructor);
	  }
	  else if (canStack) {
	    this.stack = (new Error()).stack;
	  }
	  else {
	    this.stack = '';
	  }

	  if (metadata) {
	    _.assign(this, metadata);

	    this.toString = function () {
	      return msg + ' :: ' + JSON.stringify(metadata);
	    };

	    this.toJSON = function () {
	      return _.assign({
	        msg: msg
	      }, metadata);
	    };
	  }
	}
	errors._Abstract = ErrorAbstract;
	_.inherits(ErrorAbstract, Error);

	/**
	 * Connection Error
	 * @param {String} [msg] - An error message that will probably end up in a log.
	 */
	errors.ConnectionFault = function ConnectionFault(msg) {
	  ErrorAbstract.call(this, msg || 'Connection Failure', errors.ConnectionFault);
	};
	_.inherits(errors.ConnectionFault, ErrorAbstract);

	/**
	 * No Living Connections
	 * @param {String} [msg] - An error message that will probably end up in a log.
	 */
	errors.NoConnections = function NoConnections(msg) {
	  ErrorAbstract.call(this, msg || 'No Living connections', errors.NoConnections);
	};
	_.inherits(errors.NoConnections, ErrorAbstract);

	/**
	 * Generic Error
	 * @param {String} [msg] - An error message that will probably end up in a log.
	 */
	errors.Generic = function Generic(msg, metadata) {
	  ErrorAbstract.call(this, msg || 'Generic Error', errors.Generic, metadata);
	};
	_.inherits(errors.Generic, ErrorAbstract);

	/**
	 * Request Timeout Error
	 * @param {String} [msg] - An error message that will probably end up in a log.
	 */
	errors.RequestTimeout = function RequestTimeout(msg) {
	  ErrorAbstract.call(this, msg || 'Request Timeout', errors.RequestTimeout);
	};
	_.inherits(errors.RequestTimeout, ErrorAbstract);


	/**
	 * Request Body could not be parsed
	 * @param {String} [msg] - An error message that will probably end up in a log.
	 */
	errors.Serialization = function Serialization(msg) {
	  ErrorAbstract.call(this, msg || 'Unable to parse/serialize body', errors.Serialization);
	};
	_.inherits(errors.Serialization, ErrorAbstract);


	/**
	 * Thrown when a browser compatability issue is detected (cough, IE, cough)
	 */
	errors.RequestTypeError = function RequestTypeError(feature) {
	  ErrorAbstract.call(this, 'Cross-domain AJAX requests ' + feature + ' are not supported', errors.RequestTypeError);
	};
	_.inherits(errors.RequestTypeError, ErrorAbstract);

	var statusCodes = {
	  300: 'Multiple Choices',
	  301: 'Moved Permanently',
	  302: 'Found',
	  303: 'See Other',
	  304: 'Not Modified',
	  305: 'Use Proxy',
	  307: 'Temporary Redirect',
	  308: 'Permanent Redirect',
	  400: 'Bad Request',
	  401: 'Authentication Exception',
	  402: 'Payment Required',
	  403: 'Authorization Exception',
	  404: 'Not Found',
	  405: 'Method Not Allowed',
	  406: 'Not Acceptable',
	  407: 'Proxy Authentication Required',
	  408: 'Request Timeout',
	  409: 'Conflict',
	  410: 'Gone',
	  411: 'Length Required',
	  412: 'Precondition Failed',
	  413: 'Request Entity Too Large',
	  414: 'Request URIToo Long',
	  415: 'Unsupported Media Type',
	  416: 'Requested Range Not Satisfiable',
	  417: 'Expectation Failed',
	  418: 'Im ATeapot',
	  421: 'Too Many Connections From This IP',
	  426: 'Upgrade Required',
	  429: 'Too Many Requests',
	  450: 'Blocked By Windows Parental Controls',
	  494: 'Request Header Too Large',
	  497: 'HTTPTo HTTPS',
	  499: 'Client Closed Request',

	  500: 'Internal Server Error',
	  501: 'Not Implemented',
	  502: 'Bad Gateway',
	  503: 'Service Unavailable',
	  504: 'Gateway Timeout',
	  505: 'HTTPVersion Not Supported',
	  506: 'Variant Also Negotiates',
	  510: 'Not Extended'
	};

	_.each(statusCodes, function (name, status) {
	  var className = _.studlyCase(name);

	  function StatusCodeError(msg, metadata) {
	    this.status = status;

	    var esErrObject = null;
	    if (_.isPlainObject(msg)) {
	      esErrObject = msg;
	      msg = null;
	    }

	    if (!esErrObject) {
	      // errors from es now come in two forms, an error string < 2.0 and
	      // an object >= 2.0
	      // TODO: remove after dropping support for < 2.0
	      ErrorAbstract.call(this, msg || name, StatusCodeError);
	      return this;
	    }

	    msg = [].concat(esErrObject.root_cause || []).reduce(function (memo, cause) {
	      if (memo) memo += ' (and) ';

	      memo += '[' + cause.type + '] ' + cause.reason;

	      var extraData = _.omit(cause, ['type', 'reason']);
	      if (_.size(extraData)) {
	        memo += ', with: ' + JSON.stringify(extraData);
	      }

	      return memo;
	    }, '');

	    if (!msg) {
	      if (esErrObject.type) msg += '[' + esErrObject.type + '] ';
	      if (esErrObject.reason) msg += esErrObject.reason;
	    }

	    ErrorAbstract.call(this, msg || name, StatusCodeError, metadata);
	    return this;
	  }

	  _.inherits(StatusCodeError, ErrorAbstract);
	  errors[className] = StatusCodeError;
	  errors[status] = StatusCodeError;
	});
	},{"./utils":41}],27:[function(require,module,exports){
	var Buffer=require("__browserify_Buffer").Buffer;/**
	 * Class to wrap URLS, formatting them and maintaining their separate details
	 * @type {[type]}
	 */
	module.exports = Host;

	var url = require('url');
	var qs = require('querystring');
	var _ = require('./utils');

	var startsWithProtocolRE = /^([a-z]+:)?\/\//;
	var defaultProto = 'http:';
	var btoa;

	/* jshint ignore:start */
	if (typeof window !== 'undefined') {
	  defaultProto = window.location.protocol;
	  btoa = window.btoa;
	}
	/* jshint ignore:end */

	btoa = btoa || function (data) {
	  return (new Buffer(data, 'utf8')).toString('base64');
	};

	var urlParseFields = [
	  'protocol', 'hostname', 'pathname', 'port', 'auth', 'query'
	];

	var simplify = ['host', 'path'];

	var sslDefaults = {
	  pfx: null,
	  key: null,
	  passphrase: null,
	  cert: null,
	  ca: null,
	  ciphers: null,
	  rejectUnauthorized: false,
	  secureProtocol: null
	};

	// simple reference used when formatting as a url
	// and defines when parsing from a string
	Host.defaultPorts = {
	  http: 80,
	  https: 443
	};

	function Host(config, globalConfig) {
	  config = _.clone(config || {});
	  globalConfig = globalConfig || {};

	  // defaults
	  this.protocol = 'http';
	  this.host = 'localhost';
	  this.path = '';
	  this.port = 9200;
	  this.query = null;
	  this.headers = null;
	  this.suggestCompression = !!globalConfig.suggestCompression;

	  this.ssl = _.defaults({}, config.ssl || {}, globalConfig.ssl || {}, sslDefaults);

	  if (typeof config === 'string') {
	    var firstColon = config.indexOf(':');
	    var firstSlash = config.indexOf('/');
	    var noSlash = firstSlash === -1;
	    var portNoPath = firstColon > -1 && noSlash;
	    var portWithPath = !portNoPath && firstColon < firstSlash;
	    if ((noSlash || portNoPath || portWithPath) && !startsWithProtocolRE.test(config)) {
	      config = defaultProto + '//' + config;
	    }
	    config = _.pick(url.parse(config, false, true), urlParseFields);
	    // default logic for the port is to use 9200 for the default. When a string is specified though,
	    // we will use the default from the protocol of the string.
	    if (!config.port) {
	      var proto = config.protocol || 'http';
	      if (proto.charAt(proto.length - 1) === ':') {
	        proto = proto.substring(0, proto.length - 1);
	      }
	      if (Host.defaultPorts[proto]) {
	        config.port = Host.defaultPorts[proto];
	      }
	    }
	  }

	  if (_.isObject(config)) {
	    // move hostname/portname to host/port semi-intelligently.
	    _.each(simplify, function (to) {
	      var from = to + 'name';
	      if (config[from] && config[to]) {
	        if (config[to].indexOf(config[from]) === 0) {
	          config[to] = config[from];
	        }
	      } else if (config[from]) {
	        config[to] = config[from];
	      }
	      delete config[from];
	    });
	  } else {
	    config = {};
	  }

	  if (config.auth) {
	    config.headers = config.headers || {};
	    config.headers.Authorization = 'Basic ' + btoa(config.auth);
	    delete config.auth;
	  }

	  _.forOwn(config, function (val, prop) {
	    if (val != null) this[prop] = _.clone(val);
	  }, this);

	  // make sure the query string is parsed
	  if (this.query === null) {
	    // majority case
	    this.query = {};
	  } else if (!_.isPlainObject(this.query)) {
	    this.query = qs.parse(this.query);
	  }

	  // make sure that the port is a number
	  if (_.isNumeric(this.port)) {
	    this.port = parseInt(this.port, 10);
	  } else {
	    this.port = 9200;
	  }

	  // make sure the path starts with a leading slash
	  if (this.path === '/') {
	    this.path = '';
	  } else if (this.path && this.path.charAt(0) !== '/') {
	    this.path = '/' + (this.path || '');
	  }

	  // strip trailing ':' on the protocol (when config comes from url.parse)
	  if (this.protocol.substr(-1) === ':') {
	    this.protocol = this.protocol.substring(0, this.protocol.length - 1);
	  }
	}

	Host.prototype.makeUrl = function (params) {
	  params = params || {};
	  // build the port
	  var port = '';
	  if (this.port !== Host.defaultPorts[this.protocol]) {
	    // add an actual port
	    port = ':' + this.port;
	  }

	  // build the path
	  var path = '' + (this.path || '') + (params.path || '');

	  // if path doesn't start with '/' add it.
	  if (path.charAt(0) !== '/') {
	    path = '/' + path;
	  }

	  // build the query string
	  var query = qs.stringify(this.getQuery(params.query));

	  if (this.host) {
	    return this.protocol + '://' + this.host + port + path + (query ? '?' + query : '');
	  } else {
	    return path + (query ? '?' + query : '');
	  }
	};

	function objectPropertyGetter(prop, preOverride) {
	  return function (overrides) {
	    if (preOverride) {
	      overrides = preOverride.call(this, overrides);
	    }

	    var obj = this[prop];
	    if (!obj && !overrides) {
	      return null;
	    }

	    if (overrides) {
	      obj = _.assign({}, obj, overrides);
	    }

	    return _.size(obj) ? obj : null;
	  };
	}

	Host.prototype.getHeaders = objectPropertyGetter('headers', function (overrides) {
	  if (!this.suggestCompression) {
	    return overrides;
	  }

	  return _.defaults(overrides || {}, {
	    'Accept-Encoding': 'gzip,deflate'
	  });
	});

	Host.prototype.getQuery = objectPropertyGetter('query', function (query) {
	  return typeof query === 'string' ? qs.parse(query) : query;
	});

	Host.prototype.toString = function () {
	  return this.makeUrl();
	};

	},{"./utils":41,"__browserify_Buffer":12,"querystring":6,"url":7}],28:[function(require,module,exports){
	var process=require("__browserify_process");var _ = require('./utils');
	var url = require('url');
	var EventEmitter = require('events').EventEmitter;

	/**
	 * Log bridge, which is an [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)
	 * that sends events to one or more outputs/loggers. Setup these loggers by
	 * specifying their config as the first argument, or by passing it to addOutput().
	 *
	 * @class Log
	 * @uses Loggers.Stdio
	 * @constructor
	 * @param {string|Object|ArrayOfStrings|ArrayOfObjects} output - Either the level
	 *  to setup a single logger, a full config object for alogger, or an array of
	 *  config objects to use for creating log outputs.
	 * @param {string} output.level - One of the keys in Log.levels (error, warning, etc.)
	 * @param {string} output.type - The name of the logger to use for this output
	 */
	function Log(config) {
	  config = config || {};

	  var i;
	  var outputs;

	  if (config.log) {
	    if (_.isArrayOfStrings(config.log)) {
	      outputs = [{
	        levels: config.log
	      }];
	    } else {
	      outputs = _.createArray(config.log, function (val) {
	        if (_.isPlainObject(val)) {
	          return val;
	        }
	        if (typeof val === 'string') {
	          return {
	            level: val
	          };
	        }
	      });
	    }

	    if (!outputs) {
	      throw new TypeError('Invalid logging output config. Expected either a log level, array of log levels, ' +
	        'a logger config object, or an array of logger config objects.');
	    }

	    for (i = 0; i < outputs.length; i++) {
	      this.addOutput(outputs[i]);
	    }
	  }
	}
	_.inherits(Log, EventEmitter);

	Log.loggers = require('./loggers');

	Log.prototype.close = function () {
	  this.emit('closing');
	  if (this.listenerCount()) {
	    console.error('Something is still listening for log events, but the logger is closing.');
	    this.clearAllListeners();
	  }
	};

	Log.prototype.listenerCount = function (event) {
	  // node >= 3.0 supports EE#listenerCount()
	  if (EventEmitter.prototype.listenerCount) {
	    return EventEmitter.prototype.listenerCount.call(this, event);
	  }

	  // compatability for node < 0.10
	  if (EventEmitter.listenerCount) {
	    return EventEmitter.listenerCount(this, event);
	  }

	  return this.listeners(event).length;
	};

	/**
	 * Levels observed by the loggers, ordered by rank
	 *
	 * @property levels
	 * @type Array
	 * @static
	 */
	Log.levels = [
	  /**
	   * Event fired for error level log entries
	   * @event error
	   * @param {Error} error - The error object to log
	   */
	  'error',
	  /**
	   * Event fired for "warning" level log entries, which usually represent things
	   * like correctly formatted error responses from ES (400, ...) and recoverable
	   * errors (one node unresponsive)
	   *
	   * @event warning
	   * @param {String} message - A message to be logged
	   */
	  'warning',
	  /**
	   * Event fired for "info" level log entries, which usually describe what a
	   * client is doing (sniffing etc)
	   *
	   * @event info
	   * @param {String} message - A message to be logged
	   */
	  'info',
	  /**
	   * Event fired for "debug" level log entries, which will describe requests sent,
	   * including their url (no data, response codes, or exec times)
	   *
	   * @event debug
	   * @param {String} message - A message to be logged
	   */
	  'debug',
	  /**
	   * Event fired for "trace" level log entries, which provide detailed information
	   * about each request made from a client, including reponse codes, execution times,
	   * and a full curl command that can be copied and pasted into a terminal
	   *
	   * @event trace
	   * @param {String} method method, , body, responseStatus, responseBody
	   * @param {String} url - The url the request was made to
	   * @param {String} body - The body of the request
	   * @param {Integer} responseStatus - The status code returned from the response
	   * @param {String} responseBody - The body of the response
	   */
	  'trace'
	];

	/**
	 * Converts a log config value (string or array) to an array of level names which
	 * it represents
	 *
	 * @method parseLevels
	 * @static
	 * @private
	 * @param  {String|ArrayOfStrings} input - Cound be a string to specify the max
	 *   level, or an array of exact levels
	 * @return {Array} -
	 */
	Log.parseLevels = function (input) {
	  switch (typeof input) {
	  case 'string':
	    var i = _.indexOf(Log.levels, input);
	    if (i >= 0) {
	      return Log.levels.slice(0, i + 1);
	    }
	    /* fall through */
	  case 'object':
	    if (_.isArray(input)) {
	      var valid = _.intersection(input, Log.levels);
	      if (valid.length === input.length) {
	        return valid;
	      }
	    }
	    /* fall through */
	  default:
	    throw new TypeError('invalid logging level ' + input + '. Expected zero or more of these options: ' +
	      Log.levels.join(', '));
	  }
	};

	/**
	 * Combine the array-like param into a simple string
	 *
	 * @method join
	 * @static
	 * @private
	 * @param  {*} arrayish - An array like object that can be itterated by _.each
	 * @return {String} - The final string.
	 */
	Log.join = function (arrayish) {
	  return _.map(arrayish, function (item) {
	    if (_.isPlainObject(item)) {
	      return _.inspect(item) + '\n';
	    } else {
	      return item.toString();
	    }
	  }).join(' ');
	};

	/**
	 * Create a new logger, based on the config.
	 *
	 * @method addOutput
	 * @param {object} config - An object with config options for the logger.
	 * @param {String} [config.type=stdio] - The name of an output/logger. Options
	 *   can be found in the `src/loggers` directory.
	 * @param {String|ArrayOfStrings} [config.levels=warning] - The levels to output
	 *   to this logger, when an array is specified no levels other than the ones
	 *   specified will be listened to. When a string is specified, that and all lower
	 *   levels will be logged.
	 * @return {Logger}
	 */
	Log.prototype.addOutput = function (config) {
	  config = config || {};

	  // force "levels" key
	  config.levels = Log.parseLevels(config.levels || config.level || 'warning');
	  delete config.level;

	  var Logger = _.funcEnum(config, 'type', Log.loggers, process.browser ? 'console' : 'stdio');
	  return new Logger(this, config);
	};

	/**
	 * Log an error
	 *
	 * @method error
	 * @param  {Error|String} error  The Error to log
	 * @return {Boolean} - True if any outputs accepted the message
	 */
	Log.prototype.error = function (e) {
	  if (this.listenerCount('error')) {
	    return this.emit('error', e instanceof Error ? e : new Error(e));
	  }
	};


	/**
	 * Log a warning message
	 *
	 * @method warning
	 * @param  {*} msg* - Any amount of messages that will be joined before logged
	 * @return {Boolean} - True if any outputs accepted the message
	 */
	Log.prototype.warning = function (/* ...msg */) {
	  if (this.listenerCount('warning')) {
	    return this.emit('warning', Log.join(arguments));
	  }
	};


	/**
	 * Log useful info about what's going on
	 *
	 * @method info
	 * @param  {*} msg* - Any amount of messages that will be joined before logged
	 * @return {Boolean} - True if any outputs accepted the message
	 */
	Log.prototype.info = function (/* ...msg */) {
	  if (this.listenerCount('info')) {
	    return this.emit('info', Log.join(arguments));
	  }
	};

	/**
	 * Log a debug level message
	 *
	 * @method debug
	 * @param  {*} msg* - Any amount of messages that will be joined before logged
	 * @return {Boolean} - True if any outputs accepted the message
	 */
	Log.prototype.debug = function (/* ...msg */) {
	  if (this.listenerCount('debug')) {
	    return this.emit('debug', Log.join(arguments));
	  }
	};

	/**
	 * Log a trace level message
	 *
	 * @method trace
	 * @param {String} method - HTTP request method
	 * @param {String|Object} requestUrl - URL requested. If the value is an object,
	 *   it is expected to be the return value of Node's url.parse()
	 * @param {String} body - The request's body
	 * @param {String} responseBody - body returned from ES
	 * @param {String} responseStatus - HTTP status code
	 * @return {Boolean} - True if any outputs accepted the message
	 */
	Log.prototype.trace = function (method, requestUrl, body, responseBody, responseStatus) {
	  if (this.listenerCount('trace')) {
	    return this.emit('trace', Log.normalizeTraceArgs(method, requestUrl, body, responseBody, responseStatus));
	  }
	};

	Log.normalizeTraceArgs = function (method, requestUrl, body, responseBody, responseStatus) {
	  if (typeof requestUrl === 'string') {
	    requestUrl = url.parse(requestUrl, true, true);
	  } else {
	    requestUrl = _.clone(requestUrl);
	    if (requestUrl.path) {
	      requestUrl.query = url.parse(requestUrl.path, true, false).query;
	    }
	    if (!requestUrl.pathname && requestUrl.path) {
	      requestUrl.pathname = requestUrl.path.split('?').shift();
	    }
	  }

	  delete requestUrl.auth;

	  return {
	    method: method,
	    url: url.format(requestUrl),
	    body: body,
	    status: responseStatus,
	    response: responseBody
	  };
	};

	module.exports = Log;

	},{"./loggers":30,"./utils":41,"__browserify_process":13,"events":4,"url":7}],29:[function(require,module,exports){
	var _ = require('./utils');

	/**
	 * Abstract class providing common functionality to loggers
	 * @param {[type]} log [description]
	 * @param {[type]} config [description]
	 */
	function LoggerAbstract(log, config) {
	  this.log = log;
	  this.listeningLevels = [];

	  _.makeBoundMethods(this);

	  // when the log closes, remove our event listeners
	  this.log.once('closing', this.bound.cleanUpListeners);

	  this.setupListeners(config.levels);
	}

	function padNumToTen(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}

	/**
	 * Create a timestamp string used in the format function. Defers to Log.timestamp if it is defined,
	 * Also, feel free to override this at the logger level.
	 * @return {String} - Timestamp in ISO 8601 UTC
	 */
	LoggerAbstract.prototype.timestamp = function () {
	  var d = new Date();
	  return d.getUTCFullYear() + '-' +
	    padNumToTen(d.getUTCMonth() + 1) + '-' +
	    padNumToTen(d.getUTCDate()) + 'T' +
	    padNumToTen(d.getUTCHours()) + ':' +
	    padNumToTen(d.getUTCMinutes()) + ':' +
	    padNumToTen(d.getUTCSeconds()) + 'Z';
	};

	function indent(text, spaces) {
	  var space = _.repeat(' ', spaces || 2);
	  return (text || '').split(/\r?\n/).map(function (line) {
	    return space + line;
	  }).join('\n');
	}

	LoggerAbstract.prototype.format = function (label, message) {
	  return label + ': ' + this.timestamp() + '\n' + indent(message) + '\n\n';
	};

	LoggerAbstract.prototype.write = function () {
	  throw new Error('This should be overwritten by the logger');
	};

	/**
	 * Clear the current event listeners and then re-listen for events based on the level specified
	 *
	 * @method setupListeners
	 * @private
	 * @param  {Integer} level - The max log level that this logger should listen to
	 * @return {undefined}
	 */
	LoggerAbstract.prototype.setupListeners = function (levels) {
	  this.cleanUpListeners();

	  this.listeningLevels = [];

	  _.each(levels, function (level) {
	    var fnName = 'on' + _.ucfirst(level);
	    if (this.bound[fnName]) {
	      this.listeningLevels.push(level);
	      this.log.on(level, this.bound[fnName]);
	    } else {
	      throw new Error('Unable to listen for level "' + level + '"');
	    }
	  }, this);
	};

	/**
	 * Clear the current event listeners
	 *
	 * @method cleanUpListeners
	 * @private
	 * @return {undefined}
	 */
	LoggerAbstract.prototype.cleanUpListeners = _.handler(function () {
	  _.each(this.listeningLevels, function (level) {
	    this.log.removeListener(level, this.bound['on' + _.ucfirst(level)]);
	  }, this);
	});

	/**
	 * Handler for the logs "error" event
	 *
	 * @method onError
	 * @private
	 * @param  {Error} e - The Error object to log
	 * @return {undefined}
	 */
	LoggerAbstract.prototype.onError = _.handler(function (e) {
	  this.write((e.name === 'Error' ? 'ERROR' : e.name), e.stack);
	});

	/**
	 * Handler for the logs "warning" event
	 *
	 * @method onWarning
	 * @private
	 * @param  {String} msg - The message to be logged
	 * @return {undefined}
	 */
	LoggerAbstract.prototype.onWarning = _.handler(function (msg) {
	  this.write('WARNING', msg);
	});

	/**
	 * Handler for the logs "info" event
	 *
	 * @method onInfo
	 * @private
	 * @param  {String} msg - The message to be logged
	 * @return {undefined}
	 */
	LoggerAbstract.prototype.onInfo = _.handler(function (msg) {
	  this.write('INFO', msg);
	});

	/**
	 * Handler for the logs "debug" event
	 *
	 * @method onDebug
	 * @private
	 * @param  {String} msg - The message to be logged
	 * @return {undefined}
	 */
	LoggerAbstract.prototype.onDebug = _.handler(function (msg) {
	  this.write('DEBUG', msg);
	});

	/**
	 * Handler for the logs "trace" event
	 *
	 * @method onTrace
	 * @private
	 * @param  {String} msg - The message to be logged
	 * @return {undefined}
	 */
	LoggerAbstract.prototype.onTrace = _.handler(function (requestDetails) {
	  this.write('TRACE', this._formatTraceMessage(requestDetails));
	});

	LoggerAbstract.prototype._formatTraceMessage = function (req) {
	  return '-> ' + req.method + ' ' + req.url + '\n' +
	    this._prettyJson(req.body) + '\n' +
	    '<- ' + req.status + '\n' +
	    this._prettyJson(req.response);
	/*
	-> GET https://sldfkjsdlfksjdf:9200/slsdkfjlxckvxhclks?sdlkj=sdlfkje
	{
	  asdflksjdf
	}

	<- 502
	{
	  sldfksjdlf
	}
	*/
	};

	LoggerAbstract.prototype._prettyJson = function (body) {
	  try {
	    if (typeof body === 'string') {
	      body = JSON.parse(body);
	    }
	    return JSON.stringify(body, null, '  ').replace(/'/g, '\\u0027');
	  } catch (e) {
	    return typeof body === 'string' ? body : '';
	  }
	};

	module.exports = LoggerAbstract;

	},{"./utils":41}],30:[function(require,module,exports){
	module.exports = {
	  console: require('./console')
	};

	},{"./console":31}],31:[function(require,module,exports){
	/**
	 * Special version of the Stream logger, which logs errors and warnings to stderr and all other
	 * levels to stdout.
	 *
	 * @class Loggers.Console
	 * @extends LoggerAbstract
	 * @constructor
	 * @param {Object} config - The configuration for the Logger
	 * @param {string} config.level - The highest log level for this logger to output.
	 * @param {Log} bridge - The object that triggers logging events, which we will record
	 */

	module.exports = Console;

	var LoggerAbstract = require('../logger');
	var _ = require('../utils');

	function Console(log, config) {
	  LoggerAbstract.call(this, log, config);

	  // config/state
	  this.color = _.has(config, 'color') ? !!config.color : true;
	}
	_.inherits(Console, LoggerAbstract);

	/**
	 * Override the LoggerAbstract's setup listeners to do a little extra setup
	 *
	 * @param  {Array} levels - The levels that we should be listeneing for
	 */
	Console.prototype.setupListeners = function (levels) {
	  // call the super method
	  LoggerAbstract.prototype.setupListeners.call(this, levels);
	};

	Console.prototype.write = function (label, message, to) {
	  if (console[to]) {
	    console[to](this.format(label, message));
	  }
	};

	/**
	 * Handler for the bridges "error" event
	 *
	 * @method onError
	 * @private
	 * @param  {Error} e - The Error object to log
	 * @return {undefined}
	 */
	Console.prototype.onError = _.handler(function (e) {
	  var to = console.error ? 'error' : 'log';
	  this.write(e.name === 'Error' ? 'ERROR' : e.name, e.stack || e.message, to);
	});

	/**
	 * Handler for the bridges "warning" event
	 *
	 * @method onWarning
	 * @private
	 * @param  {String} msg - The message to be logged
	 * @return {undefined}
	 */
	Console.prototype.onWarning = _.handler(function (msg) {
	  this.write('WARNING', msg, console.warn ? 'warn' : 'log');
	});

	/**
	 * Handler for the bridges "info" event
	 *
	 * @method onInfo
	 * @private
	 * @param  {String} msg - The message to be logged
	 * @return {undefined}
	 */
	Console.prototype.onInfo = _.handler(function (msg) {
	  this.write('INFO', msg, console.info ? 'info' : 'log');
	});

	/**
	 * Handler for the bridges "debug" event
	 *
	 * @method onDebug
	 * @private
	 * @param  {String} msg - The message to be logged
	 * @return {undefined}
	 */
	Console.prototype.onDebug = _.handler(function (msg) {
	  this.write('DEBUG', msg, console.debug ? 'debug' : 'log');
	});
	/**
	 * Handler for the bridges "trace" event
	 *
	 * @method onTrace
	 * @private
	 * @return {undefined}
	 */
	Console.prototype.onTrace = _.handler(function (msg) {
	  this.write('TRACE', this._formatTraceMessage(msg), 'log');
	});

	},{"../logger":29,"../utils":41}],32:[function(require,module,exports){
	var _ = require('./utils');
	var extractHostPartsRE = /\[\/*([^:]+):(\d+)\]/;

	function makeNodeParser(hostProp) {
	  return function (nodes) {
	    return _.transform(nodes, function (hosts, node, id) {
	      if (!node[hostProp]) {
	        return;
	      }

	      var hostnameMatches = extractHostPartsRE.exec(node[hostProp]);
	      if (!hostnameMatches) {
	        throw new Error('node\'s ' + hostProp + ' property (' + JSON.stringify(node[hostProp]) +
	          ') does not match the expected pattern ' + extractHostPartsRE + '.');
	      }

	      hosts.push({
	        host: hostnameMatches[1],
	        port: parseInt(hostnameMatches[2], 10),
	        _meta: {
	          id: id,
	          name: node.name,
	          hostname: node.hostname,
	          version: node.version
	        }
	      });
	    }, []);
	  };
	}

	module.exports = makeNodeParser('http_address');
	module.exports.thrift = makeNodeParser('transport_address');

	},{"./utils":41}],33:[function(require,module,exports){
	module.exports = {
	  random: require('./random'),
	  roundRobin: require('./round_robin')
	};

	},{"./random":34,"./round_robin":35}],34:[function(require,module,exports){
	/**
	 * Selects a connection randomly
	 *
	 * @module selectors
	 * @type {Function}
	 * @param {Array} connection - The list of connections to choose from
	 * @return {Connection} - The selected connection
	 */
	module.exports = function RandomSelector(connections) {
	  return connections[Math.floor(Math.random() * connections.length)];
	};

	},{}],35:[function(require,module,exports){
	/**
	 * Selects a connection the simplest way possible, Round Robin
	 *
	 * @module selectors
	 * @type {Function}
	 * @param {Array} connections - The list of connections that this selector needs to choose from
	 * @return {Connection} - The selected connection
	 */
	module.exports = function (connections) {
	  var connection = connections[0];
	  connections.push(connections.shift());
	  return connection;
	};

	},{}],36:[function(require,module,exports){
	/* global angular */
	var _ = require('../utils');
	var JsonSerializer = require('../serializers/json');

	function AngularSerializer() {}
	_.inherits(AngularSerializer, JsonSerializer);

	// mimic the JsonSerializer's encode method, but use angular's toJson instead
	AngularSerializer.prototype.encode = function (val) {
	  switch (typeof val) {
	  case 'string':
	    return val;
	  case 'object':
	    if (val) return angular.toJson(val);
	    /* falls through */
	  default:
	    return;
	  }
	};

	module.exports = AngularSerializer;
	},{"../serializers/json":38,"../utils":41}],37:[function(require,module,exports){
	module.exports = {
	  angular: require('./angular'),
	  json: require('./json')
	};

	},{"./angular":36,"./json":38}],38:[function(require,module,exports){
	/**
	 * Simple JSON serializer
	 * @type {[type]}
	 */
	module.exports = Json;

	var _ = require('../utils');

	function Json() {}

	/**
	 * Converts a value into a string, or an error
	 * @param  {*} val - Any value, methods are stripped and
	 * see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify about other params
	 * @return {String|Error} - A string is always returned, unless an error occured. then it will be that error.
	 */
	Json.prototype.serialize = function (val, replacer, spaces) {
	  switch (typeof val) {
	  case 'string':
	    return val;
	  case 'object':
	    if (val) {
	      return JSON.stringify(val, replacer, spaces);
	    }
	    /* falls through */
	  default:
	    return;
	  }
	};

	/**
	 * Parse a JSON string, if it is already parsed it is ignored
	 * @param  {String} str - the string to parse
	 * @return {[type]}
	 */
	Json.prototype.deserialize = function (str) {
	  if (typeof str === 'string') {
	    try {
	      return JSON.parse(str);
	    } catch (e) {}
	  }
	};

	Json.prototype.bulkBody = function (val) {
	  var body = '', i;

	  if (_.isArray(val)) {
	    for (i = 0; i < val.length; i++) {
	      body += this.serialize(val[i]) + '\n';
	    }
	  } else if (typeof val === 'string') {
	    // make sure the string ends in a new line
	    body = val + (val[val.length - 1] === '\n' ? '' : '\n');
	  } else {
	    throw new TypeError('Bulk body should either be an Array of commands/string, or a String');
	  }

	  return body;
	};

	},{"../utils":41}],39:[function(require,module,exports){
	/**
	 * Class that manages making request, called by all of the API methods.
	 * @type {[type]}
	 */
	module.exports = Transport;

	var _ = require('./utils');
	var errors = require('./errors');
	var Host = require('./host');
	var Promise = require('bluebird');
	var patchSniffOnConnectionFault = require('./transport/sniff_on_connection_fault');

	function Transport(config) {
	  var self = this;
	  config = self._config = config || {};

	  var LogClass = (typeof config.log === 'function') ? config.log : require('./log');
	  config.log = self.log = new LogClass(config);

	  // setup the connection pool
	  var ConnectionPool = _.funcEnum(config, 'connectionPool', Transport.connectionPools, 'main');
	  self.connectionPool = new ConnectionPool(config);

	  // setup the serializer
	  var Serializer = _.funcEnum(config, 'serializer', Transport.serializers, 'json');
	  self.serializer = new Serializer(config);

	  // setup the nodesToHostCallback
	  self.nodesToHostCallback = _.funcEnum(config, 'nodesToHostCallback', Transport.nodesToHostCallbacks, 'main');

	  // setup max retries
	  self.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : 3;

	  // setup endpoint to use for sniffing
	  self.sniffEndpoint = config.hasOwnProperty('sniffEndpoint') ? config.sniffEndpoint : '/_nodes/_all/clear';

	  // setup requestTimeout default
	  self.requestTimeout = config.hasOwnProperty('requestTimeout') ? config.requestTimeout : 30000;

	  if (config.hasOwnProperty('defer')) {
	    self.defer = config.defer;
	  }

	  // randomizeHosts option
	  var randomizeHosts = config.hasOwnProperty('randomizeHosts') ? !!config.randomizeHosts : true;

	  if (config.host) {
	    config.hosts = config.host;
	  }

	  if (config.hosts) {
	    var hostsConfig = _.createArray(config.hosts, function (val) {
	      if (_.isPlainObject(val) || _.isString(val) || val instanceof Host) {
	        return val;
	      }
	    });

	    if (!hostsConfig) {
	      throw new TypeError('Invalid hosts config. Expected a URL, an array of urls, a host config object, ' +
	        'or an array of host config objects.');
	    }

	    var hosts = _.map(hostsConfig, function (conf) {
	      return (conf instanceof Host) ? conf : new Host(conf, self._config);
	    });

	    if (randomizeHosts) {
	      hosts = _.shuffle(hosts);
	    }

	    self.connectionPool.setHosts(hosts);
	  }

	  if (config.sniffOnStart) {
	    self.sniff();
	  }

	  if (config.sniffInterval) {
	    self._timeout(function doSniff() {
	      self.sniff();
	      self._timeout(doSniff, config.sniffInterval);
	    }, config.sniffInterval);
	  }

	  if (config.sniffOnConnectionFault) {
	    patchSniffOnConnectionFault(self);
	  }
	}

	Transport.connectionPools = {
	  main: require('./connection_pool')
	};

	Transport.serializers = require('./serializers');

	Transport.nodesToHostCallbacks = {
	  main: require('./nodes_to_host')
	};

	Transport.prototype.defer = function () {
	  return Promise.defer();
	};

	/**
	 * Perform a request with the client's transport
	 *
	 * @method request
	 * @todo async body writing
	 * @todo abort
	 * @todo access to custom headers, modifying of request in general
	 * @param {object} params
	 * @param {Number} params.requestTimeout - timeout for the entire request (inculding all retries)
	 * @param {Number} params.maxRetries - number of times the request will be re-run in
	 *   the original node chosen can not be connected to.
	 * @param {String} params.url - The url for the request
	 * @param {String} params.method - The HTTP method for the request
	 * @param {String} params.body - The body of the HTTP request
	 * @param {Function} cb - A function to call back with (error, responseBody, responseStatus)
	 */
	Transport.prototype.request = function (params, cb) {
	  var self = this;
	  var remainingRetries = this.maxRetries;
	  var requestTimeout = this.requestTimeout;

	  var connection; // set in sendReqWithConnection
	  var aborted = false; // several connector will respond with an error when the request is aborted
	  var requestAborter; // an abort function, returned by connection#request()
	  var requestTimeoutId; // the id of the ^timeout
	  var ret; // the object returned to the user, might be a promise
	  var defer; // the defer object, will be set when we are using promises.

	  self.log.debug('starting request', params);

	  if (params.body && params.method === 'GET') {
	    _.nextTick(respond, new TypeError('Body can not be sent with method "GET"'));
	    return;
	  }

	  // serialize the body
	  if (params.body) {
	    params.body = self.serializer[params.bulkBody ? 'bulkBody' : 'serialize'](params.body);
	  }

	  if (params.hasOwnProperty('maxRetries')) {
	    remainingRetries = params.maxRetries;
	  }

	  if (params.hasOwnProperty('requestTimeout')) {
	    requestTimeout = params.requestTimeout;
	  }

	  params.req = {
	    method: params.method,
	    path: params.path || '/',
	    query: params.query,
	    body: params.body,
	    headers: params.headers
	  };

	  function sendReqWithConnection(err, _connection) {
	    if (aborted) {
	      return;
	    }

	    if (err) {
	      respond(err);
	    } else if (_connection) {
	      connection = _connection;
	      requestAborter = connection.request(params.req, checkRespForFailure);
	    } else {
	      self.log.warning('No living connections');
	      respond(new errors.NoConnections());
	    }
	  }

	  function checkRespForFailure(err, body, status, headers) {
	    if (aborted) {
	      return;
	    }

	    requestAborter = void 0;

	    if (err instanceof errors.RequestTypeError) {
	      self.log.error('Connection refused to execute the request', err);
	      respond(err, body, status, headers);
	      return;
	    }

	    if (err) {
	      connection.setStatus('dead');
	      if (remainingRetries) {
	        remainingRetries--;
	        self.log.error('Request error, retrying' + (err.message ? ' -- ' + err.message : ''));
	        self.connectionPool.select(sendReqWithConnection);
	      } else {
	        self.log.error('Request complete with error' + (err.message ? ' -- ' + err.message : ''));
	        respond(new errors.ConnectionFault(err));
	      }
	    } else {
	      self.log.debug('Request complete');
	      respond(void 0, body, status, headers);
	    }
	  }

	  function respond(err, body, status, headers) {
	    if (aborted) {
	      return;
	    }

	    self._timeout(requestTimeoutId);
	    var parsedBody;
	    var isJson = !headers || (headers['content-type'] && ~headers['content-type'].indexOf('application/json'));

	    if (!err && body) {
	      if (isJson) {
	        parsedBody = self.serializer.deserialize(body);
	        if (parsedBody == null) {
	          err = new errors.Serialization();
	          parsedBody = body;
	        }
	      } else {
	        parsedBody = body;
	      }
	    }

	    // does the response represent an error?
	    if (
	      (!err || err instanceof errors.Serialization)
	      && (status < 200 || status >= 300)
	      && (!params.ignore || !_.contains(params.ignore, status))
	    ) {

	      var errorMetadata = _.pick(params.req, ['path', 'query', 'body']);
	      errorMetadata.statusCode = status;
	      errorMetadata.response = body;

	      if (errors[status]) {
	        err = new errors[status](parsedBody && parsedBody.error, errorMetadata);
	      } else {
	        err = new errors.Generic('unknown error', errorMetadata);
	      }
	    }

	    // can we cast notfound to false?
	    if (params.castExists) {
	      if (err && err instanceof errors.NotFound) {
	        parsedBody = false;
	        err = void 0;
	      } else {
	        parsedBody = !err;
	      }
	    }

	    // how do we send the response?
	    if (typeof cb === 'function') {
	      if (err) {
	        cb(err, parsedBody, status);
	      } else {
	        cb(void 0, parsedBody, status);
	      }
	    } else if (err) {
	      err.body = parsedBody;
	      err.status = status;
	      defer.reject(err);
	    } else {
	      defer.resolve(parsedBody);
	    }
	  }

	  function abortRequest() {
	    if (aborted) {
	      return;
	    }

	    aborted = true;
	    remainingRetries = 0;
	    self._timeout(requestTimeoutId);
	    if (typeof requestAborter === 'function') {
	      requestAborter();
	    }
	  }

	  if (requestTimeout && requestTimeout !== Infinity) {
	    requestTimeoutId = this._timeout(function () {
	      respond(new errors.RequestTimeout('Request Timeout after ' + requestTimeout + 'ms'));
	      abortRequest();
	    }, requestTimeout);
	  }

	  // determine the response based on the presense of a callback
	  if (typeof cb === 'function') {
	    ret = {
	      abort: abortRequest
	    };
	  } else {
	    defer = this.defer();
	    ret = defer.promise;
	    ret.abort = abortRequest;
	  }


	  if (connection) {
	    sendReqWithConnection(void 0, connection);
	  } else {
	    self.connectionPool.select(sendReqWithConnection);
	  }

	  return ret;
	};

	Transport.prototype._timeout = function (cb, delay) {
	  this._timers = this._timers || [];
	  var id;

	  if ('function' !== typeof cb) {
	    id = cb;
	    cb = void 0;
	  }

	  if (cb) {
	    // set the timer
	    id = setTimeout(cb, delay);
	    this._timers.push(id);
	    return id;
	  }

	  if (id) {
	    clearTimeout(id);

	    var i = this._timers.indexOf(id);
	    if (i !== -1) {
	      this._timers.splice(i, 1);
	    }
	  }
	};

	/**
	 * Ask an ES node for a list of all the nodes, add/remove nodes from the connection
	 * pool as appropriate
	 *
	 * @param  {Function} cb - Function to call back once complete
	 */
	Transport.prototype.sniff = function (cb) {
	  var connectionPool = this.connectionPool;
	  var nodesToHostCallback = this.nodesToHostCallback;
	  var log = this.log;
	  var globalConfig = this._config;

	  // make cb a function if it isn't
	  cb = typeof cb === 'function' ? cb : _.noop;

	  this.request({
	    path: this.sniffEndpoint,
	    method: 'GET'
	  }, function (err, resp, status) {
	    if (!err && resp && resp.nodes) {
	      var hostsConfigs;

	      try {
	        hostsConfigs = nodesToHostCallback(resp.nodes);
	      } catch (e) {
	        log.error(new Error('Unable to convert node list from ' + this.sniffEndpoint +
	          ' to hosts durring sniff. Encountered error:\n' + (e.stack || e.message)));
	        return;
	      }

	      connectionPool.setHosts(_.map(hostsConfigs, function (hostConfig) {
	        return new Host(hostConfig, globalConfig);
	      }));
	    }
	    cb(err, resp, status);
	  });
	};

	/**
	 * Close the Transport, which closes the logs and connection pool
	 * @return {[type]} [description]
	 */
	Transport.prototype.close = function () {
	  this.log.close();
	  _.each(this._timers, clearTimeout);
	  this.connectionPool.close();
	};

	},{"./connection_pool":23,"./errors":26,"./host":27,"./log":28,"./nodes_to_host":32,"./serializers":37,"./transport/sniff_on_connection_fault":40,"./utils":41,"bluebird":1}],40:[function(require,module,exports){
	var _ = require('../utils');


	/**
	 * Patch the transport's connection pool to schedule a sniff after a connection fails.
	 * When a connection fails for the first time it will schedule a sniff 1 second in the
	 * future, and increase the timeout based on the deadTimeout algorithm chosen by the
	 * connectionPool, and the number of times the sniff has failed.
	 *
	 * @param  {Transport} transport - the transport that will be using this behavior
	 * @return {undefined}
	 */
	module.exports = function setupSniffOnConnectionFault(transport) {
	  var failures = 0;
	  var pool = transport.connectionPool;
	  var originalOnDied = pool._onConnectionDied;

	  // do the actual sniff, if the sniff is unable to
	  // connect to a node this function will be called again by the connectionPool
	  var work = function () {
	    work.timerId = transport._timeout(work.timerId);
	    transport.sniff();
	  };

	  // create a function that will count down to a
	  // point n milliseconds into the future
	  var countdownTo = function (ms) {
	    var start = _.now();
	    return function () {
	      return start - ms;
	    };
	  };

	  // overwrite the function, but still call it
	  pool._onConnectionDied = function (connection, wasAlreadyDead) {
	    var ret = originalOnDied.call(pool, connection, wasAlreadyDead);

	    // clear the failures if this is the first failure we have seen
	    failures = work.timerId ? failures + 1 : 0;

	    var ms = pool.calcDeadTimeout(failures, 1000);

	    if (work.timerId && ms < work.timerId && work.countdown()) {
	      // clear the timer
	      work.timerId = transport._timeout(work.timerId);
	    }

	    if (!work.timerId) {
	      work.timerId = transport._timeout(work, ms);
	      work.countdown = countdownTo(ms);
	    }

	    return ret;
	  };

	  pool._onConnectionDied.restore = function () {
	    pool._onConnectionDied = originalOnDied;
	  };
	};
	},{"../utils":41}],41:[function(require,module,exports){
	var process=require("__browserify_process"),Buffer=require("__browserify_Buffer").Buffer;var path = require('path');
	var _ = require('lodash');
	var nodeUtils = require('util');

	/**
	 * Custom utils library, basically a modified version of [lodash](http://lodash.com/docs) +
	 * [node.utils](http://nodejs.org/api/util.html#util_util) that doesn't use mixins to prevent
	 * confusion when requiring lodash itself.
	 *
	 * @class utils
	 * @static
	 */
	var utils = _.extend({}, _, nodeUtils);
	_ = utils;

	/**
	 * Link to [path.join](http://nodejs.org/api/path.html#path_path_join_path1_path2)
	 *
	 * @method utils.joinPath
	 * @type {function}
	 */
	utils.joinPath = path.join;

	/**
	 * Recursively merge two objects, walking into each object and concating arrays. If both to and from have a value at a
	 * key, but the values' types don't match to's value is left unmodified. Only Array and Object values are merged - that
	 * it to say values with a typeof "object"
	 *
	 * @param  {Object} to - Object to merge into (no cloning, the original object
	 *   is modified)
	 * @param  {Object} from - Object to pull changed from
	 * @return {Object} - returns the modified to value
	 */
	utils.deepMerge = function (to, from) {
	  _.each(from, function (fromVal, key) {
	    switch (typeof to[key]) {
	    case 'undefined':
	      to[key] = from[key];
	      break;
	    case 'object':
	      if (_.isArray(to[key]) && _.isArray(from[key])) {
	        to[key] = to[key].concat(from[key]);
	      }
	      else if (_.isPlainObject(to[key]) && _.isPlainObject(from[key])) {
	        utils.deepMerge(to[key], from[key]);
	      }
	    }
	  });
	  return to;
	};

	/**
	 * Test if a value is an array and it's contents are of a specific type
	 *
	 * @method isArrayOf<Strings|Object|Array|Finite|Function|RegExp>s
	 * @param  {Array} arr - An array to check
	 * @return {Boolean}
	 */
	_.each([
	  'String',
	  'Object',
	  'PlainObject',
	  'Array',
	  'Finite',
	  'Function',
	  'RegExp'
	], function (type) {
	  var check = _['is' + type];

	  utils['isArrayOf' + type + 's'] = function (arr) {
	    // quick shallow check of arrays
	    return _.isArray(arr) && _.every(arr.slice(0, 10), check);
	  };
	});


	/**
	 * Capitalize the first letter of a word
	 *
	 * @method  ucfirst
	 * @param  {string} word - The word to transform
	 * @return {string}
	 */
	utils.ucfirst = function (word) {
	  return word[0].toUpperCase() + word.substring(1).toLowerCase();
	};

	/**
	 * Base algo for studlyCase and camelCase
	 * @param  {boolean} firstWordCap - Should the first character of the first word be capitalized
	 * @return {Function}
	 */
	function adjustWordCase(firstWordCap, otherWordsCap, sep) {
	  return function (string) {
	    var i = 0;
	    var words = [];
	    var word = '';
	    var code, c, upper, lower;

	    for (; i < string.length; i++) {
	      code = string.charCodeAt(i);
	      c = string.charAt(i);
	      lower = (code >= 97 && code <= 122) || (code >= 48 && code <= 57);
	      upper = code >= 65 && code <= 90;

	      if (upper || !lower) {
	        // new word
	        if (word.length) {
	          words.push(word);
	        }
	        word = '';
	      }

	      if (upper || lower) {
	        if (lower && word.length) {
	          word += c;
	        } else {
	          if ((!words.length && firstWordCap) || (words.length && otherWordsCap)) {
	            word = c.toUpperCase();
	          }
	          else {
	            word = c.toLowerCase();
	          }
	        }
	      }
	    }
	    if (word.length) {
	      words.push(word);
	    }
	    // add the leading underscore back to strings the had it originally
	    if (words.length && string.charAt(0) === '_') {
	      words[0] = '_' + words[0];
	    }
	    return words.join(sep);
	  };
	}

	/**
	 * Transform a string into StudlyCase
	 *
	 * @method studlyCase
	 * @param  {String} string
	 * @return {String}
	 */
	utils.studlyCase = adjustWordCase(true, true, '');

	/**
	 * Transform a string into camelCase
	 *
	 * @method camelCase
	 * @param  {String} string
	 * @return {String}
	 */
	utils.camelCase = adjustWordCase(false, true, '');

	/**
	 * Transform a string into snakeCase
	 *
	 * @method snakeCase
	 * @param  {String} string
	 * @return {String}
	 */
	utils.snakeCase = adjustWordCase(false, false, '_');

	/**
	 * Lower-case a string, and return an empty string if any is not a string
	 *
	 * @param any {*} - Something or nothing
	 * @returns {string}
	 */
	utils.toLowerString = function (any) {
	  if (any) {
	    if (typeof any !== 'string') {
	      any = any.toString();
	    }
	  } else {
	    any = '';
	  }
	  return any.toLowerCase();
	};

	/**
	 * Upper-case the string, return an empty string if any is not a string
	 *
	 * @param any {*} - Something or nothing
	 * @returns {string}
	 */
	utils.toUpperString = function (any) {
	  if (any) {
	    if (typeof any !== 'string') {
	      any = any.toString();
	    }
	  } else {
	    any = '';
	  }
	  return any.toUpperCase();
	};

	/**
	 * Test if a value is "numeric" meaning that it can be transformed into something besides NaN
	 *
	 * @method isNumeric
	 * @param  {*} val
	 * @return {Boolean}
	 */
	utils.isNumeric = function (val) {
	  return typeof val !== 'object' && val - parseFloat(val) >= 0;
	};

	// regexp to test for intervals
	var intervalRE = /^(\d+(?:\.\d+)?)(M|w|d|h|m|s|y|ms)$/;

	/**
	 * Test if a string represents an interval (eg. 1m, 2Y)
	 *
	 * @method isInterval
	 * @param {String} val
	 * @return {Boolean}
	 */
	utils.isInterval = function (val) {
	  return !!(val.match && val.match(intervalRE));
	};

	/**
	 * Repeat a string n times
	 *
	 * @todo TestPerformance
	 * @method repeat
	 * @param {String} what - The string to repeat
	 * @param {Number} times - Times the string should be repeated
	 * @return {String}
	 */
	utils.repeat = function (what, times) {
	  return (new Array(times + 1)).join(what);
	};

	/**
	 * Call a function, applying the arguments object to it in an optimized way, rather than always turning it into an array
	 *
	 * @param func {Function} - The function to execute
	 * @param context {*} - The context the function will be executed with
	 * @param args {Arguments} - The arguments to send to func
	 * @param [sliceIndex=0] {Integer} - The index that args should be sliced at, before feeding args to func
	 * @returns {*} - the return value of func
	 */
	utils.applyArgs = function (func, context, args, sliceIndex) {
	  sliceIndex = sliceIndex || 0;
	  switch (args.length - sliceIndex) {
	  case 0:
	    return func.call(context);
	  case 1:
	    return func.call(context, args[0 + sliceIndex]);
	  case 2:
	    return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex]);
	  case 3:
	    return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex]);
	  case 4:
	    return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex]);
	  case 5:
	    return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex],
	      args[2 + sliceIndex], args[3 + sliceIndex], args[4 + sliceIndex]);
	  default:
	    return func.apply(context, Array.prototype.slice.call(args, sliceIndex));
	  }
	};

	/**
	 * Schedule a function to be called on the next tick, and supply it with these arguments
	 * when it is called.
	 * @return {[type]} [description]
	 */
	_.nextTick = function (cb) {
	  // bind the function and schedule it
	  process.nextTick(_.bindKey(_, 'applyArgs', cb, null, arguments, 1));
	};

	/**
	 * Marks a method as a handler. Currently this just makes a property on the method
	 * flagging it to be bound to the object at object creation when "makeBoundMethods" is called
	 *
	 * ```
	 * ClassName.prototype.methodName = _.handler(function () {
	 *   // this will always be bound when called via classInstance.bound.methodName
	 *   this === classInstance
	 * });
	 * ```
	 *
	 * @alias _.scheduled
	 * @param  {Function} func - The method that is being defined
	 * @return {Function}
	 */
	_.handler = function (func) {
	  func._provideBound = true;
	  return func;
	};
	_.scheduled = _.handler;

	/**
	 * Creates an "bound" property on an object, which all or a subset of methods from
	 * the object which are bound to the original object.
	 *
	 * ```
	 * var obj = {
	 *   onEvent: function () {}
	 * };
	 *
	 * _.makeBoundMethods(obj);
	 *
	 * obj.bound.onEvent() // is bound to obj, and can safely be used as an event handler.
	 * ```
	 *
	 * @param {Object} obj - The object to bind the methods to
	 */
	_.makeBoundMethods = function (obj) {
	  obj.bound = {};
	  for (var prop in obj) {
	    // dearest maintainer, we want to look through the prototype
	    if (typeof obj[prop] === 'function' && obj[prop]._provideBound === true) {
	      obj.bound[prop] = _.bind(obj[prop], obj);
	    }
	  }
	};

	_.noop = function () {};

	/**
	 * Implements the standard "string or constructor" check that I was copy/pasting everywhere
	 * @param  {String|Function} val - the value that the user passed in
	 * @param  {Object} opts - a map of the options
	 * @return {Function|undefined} - If a valid option was specified, then the constructor is returned
	 */
	_.funcEnum = function (config, name, opts, def) {
	  var val = config[name];
	  switch (typeof val) {
	  case 'undefined':
	    return opts[def];
	  case 'function':
	    return val;
	  case 'string':
	    if (opts.hasOwnProperty(val)) {
	      return opts[val];
	    }
	    /* falls through */
	  default:
	    var err = 'Invalid ' + name + ' "' + val + '", expected a function';
	    switch (_.size(opts)) {
	    case 0:
	      break;
	    case 1:
	      err += ' or ' + _.keys(opts)[0];
	      break;
	    default:
	      err += ' or one of ' + _.keys(opts).join(', ');
	      break;
	    }
	    throw new TypeError(err);
	  }
	};

	/**
	 * Accepts any object and attempts to convert it into an array. If the object passed in is not
	 * an array it will be wrapped in one. Then the transform/map function will be called for each element
	 * and create a new array that is returned. If the map function fails to return something, the loop is
	 * halted and false is returned instead of an array.
	 *
	 * @param  {*} input - The value to convert
	 * @param  {Function} transform - A function called for each element of the resulting array
	 * @return {Array|false} - an array on success, or false on failure.
	 */
	_.createArray = function (input, transform) {
	  transform = typeof transform === 'function' ? transform : _.identity;
	  var output = [];
	  var item;
	  var i;

	  if (!_.isArray(input)) {
	    input = [input];
	  }

	  for (i = 0; i < input.length; i++) {
	    item = transform(input[i]);
	    if (item === void 0) {
	      return false;
	    } else {
	      output.push(item);
	    }
	  }
	  return output;
	};

	/**
	 * Takes a WritableStream, and returns the chunks that have not successfully written, returning them as a string.
	 *
	 * ONLY WORKS FOR TEXT STREAMS
	 *
	 * @param  {WritableStream} stream - an instance of stream.Writable
	 * @return {string} - the remaining test to be written to the stream
	 */
	_.getUnwrittenFromStream = function (stream) {
	  var writeBuffer = _.getStreamWriteBuffer(stream);
	  if (!writeBuffer) return;

	  // flush the write buffer
	  var out = '';
	  if (!writeBuffer.length) return out;

	  _.each(writeBuffer, function (writeReq) {
	    if (writeReq.chunk) {
	      // 0.9.12+ uses WriteReq objects with a chunk prop
	      out += '' + writeReq.chunk;
	    } else if (_.isArray(writeReq) && (typeof writeReq[0] === 'string' || Buffer.isBuffer(writeReq[0]))) {
	      // 0.9.4 - 0.9.9 buffers are arrays of arrays like [[chunk, cb], [chunk, undef], ...].
	      out += '' + writeReq[0];
	    } else {
	      return false;
	    }
	  });
	  return out;
	};

	_.getStreamWriteBuffer = function (stream) {
	  if (!stream || !stream._writableState) return;

	  var writeState = stream._writableState;

	  if (writeState.getBuffer) {
	    return writeState.getBuffer();
	  } else if (writeState.buffer) {
	    return writeState.buffer;
	  }
	};

	_.clearWriteStreamBuffer = function (stream) {
	  var buffer = _.getStreamWriteBuffer(stream);
	  return buffer && buffer.splice(0);
	};

	/**
	 * return the current time in milliseconds since epoch
	 */
	_.now = function () {
	  return (typeof Date.now === 'function') ? Date.now() : (new Date()).getTime();
	};

	module.exports = utils;

	},{"__browserify_Buffer":12,"__browserify_process":13,"lodash":14,"path":5,"util":8}]},{},[15])
	;
	}());

/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana')

	  /*
	   * Angular doesn't play well with thread blocking calls such as
	   * window.confirm() unless those calls are specifically handled inside a call
	   * to $timeout(). Rather than litter the code with that implementation
	   * detail, safeConfirm() can be used.
	   *
	   * WARNING: safeConfirm differs from a native call to window.confirm in that
	   * it only blocks the thread beginning on the next tick. For that reason, a
	   * promise is returned so consumers can handle the control flow.
	   *
	   * Usage:
	   *  safeConfirm('This message will be passed to window.confirm()').then(
	   *    function () {
	   *      // user clicked confirm
	   *    },
	   *    function () {
	   *      // user canceled the confirmation
	   *    }
	   *  );
	   */
	  .factory('safeConfirm', function ($window, $timeout, $q) {
	    return function safeConfirm(message) {
	      return $timeout(function () {
	        return $window.confirm(message) || $q.reject(false);
	      });
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(428);
	__webpack_require__(192);
	__webpack_require__(220);
	__webpack_require__(501);
	__webpack_require__(533);
	__webpack_require__(502);
	__webpack_require__(507);
	__webpack_require__(503);
	__webpack_require__(508);
	__webpack_require__(443);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana/index_patterns');
	  __webpack_require__(428);

	  module.service('indexPatterns', function (es, Notifier, Private, Promise, kbnIndex) {
	    var self = this;
	    var _ = __webpack_require__(192);
	    var errors = __webpack_require__(220);

	    var IndexPattern = Private(__webpack_require__(501));
	    var patternCache = Private(__webpack_require__(533));

	    var notify = new Notifier({ location: 'IndexPatterns Service' });

	    self.get = function (id) {
	      if (!id) return self.make();

	      var cache = patternCache.get(id);
	      return cache || patternCache.set(id, self.make(id));
	    };

	    self.make = function (id) {
	      return new IndexPattern(id).init();
	    };

	    self['delete'] = function (pattern) {
	      self.getIds.clearCache();
	      patternCache['delete'](pattern.id);
	      return es['delete']({
	        index: kbnIndex,
	        type: 'index-pattern',
	        id: pattern.id
	      });
	    };

	    self.errors = {
	      MissingIndices: errors.IndexPatternMissingIndices
	    };

	    self.cache = patternCache;
	    self.getIds = Private(__webpack_require__(502));
	    self.intervals = Private(__webpack_require__(507));
	    self.mapper = Private(__webpack_require__(503));
	    self.patternToWildcard = Private(__webpack_require__(508));
	    self.fieldFormats = Private(__webpack_require__(443));
	    self.IndexPattern = IndexPattern;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(220);
	__webpack_require__(209);
	__webpack_require__(443);
	__webpack_require__(502);
	__webpack_require__(503);
	__webpack_require__(507);
	__webpack_require__(510);
	__webpack_require__(511);
	__webpack_require__(530);
	__webpack_require__(434);
	__webpack_require__(531);
	__webpack_require__(532);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function IndexPatternFactory(Private, timefilter, Notifier, config, kbnIndex, Promise, $rootScope) {
	    var _ = __webpack_require__(192);
	    var errors = __webpack_require__(220);
	    var angular = __webpack_require__(209);

	    var fieldformats = Private(__webpack_require__(443));
	    var getIds = Private(__webpack_require__(502));
	    var mapper = Private(__webpack_require__(503));
	    var intervals = Private(__webpack_require__(507));
	    var getComputedFields = __webpack_require__(510);
	    var DocSource = Private(__webpack_require__(511));
	    var mappingSetup = Private(__webpack_require__(530));
	    var FieldList = Private(__webpack_require__(434));

	    var flattenHit = Private(__webpack_require__(531));
	    var formatHit = __webpack_require__(532);

	    var type = 'index-pattern';

	    var notify = new Notifier();

	    var mapping = mappingSetup.expandShorthand({
	      title: 'string',
	      timeFieldName: 'string',
	      intervalName: 'string',
	      fields: 'json',
	      fieldFormatMap: {
	        type: 'string',
	        _serialize: function _serialize(map) {
	          if (map == null) return;

	          var count = 0;
	          var serialized = _.transform(map, function (flat, format, field) {
	            if (!format) return;
	            count++;
	            flat[field] = format;
	          });

	          if (count) return angular.toJson(serialized);
	        },
	        _deserialize: function _deserialize(map) {
	          if (map == null) return {};
	          return _.mapValues(angular.fromJson(map), function (mapping) {
	            var FieldFormat = fieldformats.byId[mapping.id];
	            return FieldFormat && new FieldFormat(mapping.params);
	          });
	        }
	      }
	    });

	    function IndexPattern(id) {
	      var self = this;

	      setId(id);

	      var docSource = new DocSource();

	      self.init = function () {
	        // tell the docSource where to find the doc
	        docSource.index(kbnIndex).type(type).id(self.id);

	        // listen for config changes and update field list
	        $rootScope.$on('change:config', function () {
	          initFields();
	        });

	        return mappingSetup.isDefined(type).then(function (defined) {
	          // create mapping for this type if one does not exist
	          if (defined) return true;
	          return mappingSetup.setup(type, mapping);
	        }).then(function () {
	          // If there is no id, then there is no document to fetch from elasticsearch
	          if (!self.id) return;

	          // fetch the object from ES
	          return docSource.fetch().then(function applyESResp(resp) {
	            if (!resp.found) throw new errors.SavedObjectNotFound(type, self.id);

	            // deserialize any json fields
	            _.forOwn(mapping, function ittr(fieldMapping, name) {
	              if (fieldMapping._deserialize) {
	                resp._source[name] = fieldMapping._deserialize(resp._source[name], resp, name, fieldMapping);
	              }
	            });

	            // Give obj all of the values in _source
	            _.assign(self, resp._source);

	            self._indexFields();

	            // Any time obj is updated, re-call applyESResp
	            docSource.onUpdate().then(applyESResp, notify.fatal);
	          });
	        }).then(function () {
	          // return our obj as the result of init()
	          return self;
	        });
	      };

	      function initFields(fields) {
	        self.fields = new FieldList(self, fields || self.fields || []);
	      }

	      self._indexFields = function () {
	        if (self.id) {
	          if (!self.fields) {
	            return self.refreshFields();
	          } else {
	            initFields();
	          }
	        }
	      };

	      self.addScriptedField = function (name, script, type, lang) {
	        type = type || 'string';

	        var scriptFields = _.pluck(self.getScriptedFields(), 'name');

	        if (_.contains(scriptFields, name)) {
	          throw new errors.DuplicateField(name);
	        }

	        self.fields.push({
	          name: name,
	          script: script,
	          type: type,
	          scripted: true,
	          lang: lang
	        });

	        self.save();
	      };

	      self.removeScriptedField = function (name) {
	        var fieldIndex = _.findIndex(self.fields, {
	          name: name,
	          scripted: true
	        });

	        self.fields.splice(fieldIndex, 1);

	        self.save();
	      };

	      self.popularizeField = function (fieldName, unit) {
	        if (unit == null) unit = 1;

	        var field = _.get(self, ['fields', 'byName', fieldName]);
	        if (!field) return;

	        var count = Math.max((field.count || 0) + unit, 0);
	        if (field.count !== count) {
	          field.count = count;
	          self.save();
	        }
	      };

	      self.getNonScriptedFields = function () {
	        return _.where(self.fields, { scripted: false });
	      };

	      self.getScriptedFields = function () {
	        return _.where(self.fields, { scripted: true });
	      };

	      self.getInterval = function () {
	        return this.intervalName && _.find(intervals, { name: this.intervalName });
	      };

	      self.toIndexList = function (start, stop) {
	        var interval = this.getInterval();
	        if (interval) {
	          return intervals.toIndexList(self.id, interval, start, stop);
	        } else {
	          return self.id;
	        }
	      };

	      self.prepBody = function () {
	        var body = {};

	        // serialize json fields
	        _.forOwn(mapping, function (fieldMapping, fieldName) {
	          if (self[fieldName] != null) {
	            body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(self[fieldName]) : self[fieldName];
	          }
	        });

	        // ensure that the docSource has the current self.id
	        docSource.id(self.id);

	        // clear the indexPattern list cache
	        getIds.clearCache();
	        return body;
	      };

	      function setId(id) {
	        return self.id = id;
	      }

	      self.create = function () {
	        var body = self.prepBody();
	        return docSource.doCreate(body).then(setId)['catch'](function (err) {
	          var confirmMessage = 'Are you sure you want to overwrite this?';
	          if (_.get(err, 'origError.status') === 409 && window.confirm(confirmMessage)) {
	            // eslint-disable-line no-alert
	            return docSource.doIndex(body).then(setId);
	          }
	          return Promise.resolve(false);
	        });
	      };

	      self.save = function () {
	        var body = self.prepBody();
	        return docSource.doIndex(body).then(setId);
	      };

	      self.refreshFields = function () {
	        return mapper.clearCache(self).then(self._fetchFields).then(self.save);
	      };

	      self._fetchFields = function () {
	        return mapper.getFieldsForIndexPattern(self, true).then(function (fields) {
	          // append existing scripted fields
	          fields = fields.concat(self.getScriptedFields());

	          // initialize self.field with this field list
	          initFields(fields);
	        });
	      };

	      self.toJSON = function () {
	        return self.id;
	      };

	      self.toString = function () {
	        return '' + self.toJSON();
	      };

	      self.metaFields = config.get('metaFields');
	      self.getComputedFields = getComputedFields.bind(self);

	      self.flattenHit = flattenHit(self);
	      self.formatHit = formatHit(self, fieldformats.getDefaultInstance('string'));
	      self.formatField = self.formatHit.formatField;
	    }

	    IndexPattern.prototype.routes = {
	      edit: '/settings/indices/{{id}}',
	      addField: '/settings/indices/{{id}}/create-field',
	      indexedFields: '/settings/indices/{{id}}?_a=(tab:indexedFields)',
	      scriptedFields: '/settings/indices/{{id}}?_a=(tab:scriptedFields)'
	    };

	    return IndexPattern;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function GetIndexPatternIdsFn(es, kbnIndex) {
	    var _ = __webpack_require__(192);

	    // many places may require the id list, so we will cache it seperately
	    // didn't incorportate with the indexPattern cache to prevent id collisions.
	    var cachedPromise;

	    var getIds = function getIds() {
	      if (cachedPromise) {
	        // retrun a clone of the cached response
	        return cachedPromise.then(function (cachedResp) {
	          return _.clone(cachedResp);
	        });
	      }

	      cachedPromise = es.search({
	        index: kbnIndex,
	        type: 'index-pattern',
	        fields: [],
	        body: {
	          query: { match_all: {} },
	          size: 2147483647
	        }
	      }).then(function (resp) {
	        return _.pluck(resp.hits.hits, '_id');
	      });

	      // ensure that the response stays pristine by cloning it here too
	      return cachedPromise.then(function (resp) {
	        return _.clone(resp);
	      });
	    };

	    getIds.clearCache = function () {
	      cachedPromise = null;
	    };

	    return getIds;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(220);
	__webpack_require__(504);
	__webpack_require__(507);
	__webpack_require__(508);
	__webpack_require__(509);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function MapperService(Private, Promise, es, config, kbnIndex) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);

	    var IndexPatternMissingIndices = __webpack_require__(220).IndexPatternMissingIndices;
	    var transformMappingIntoFields = Private(__webpack_require__(504));
	    var intervals = Private(__webpack_require__(507));
	    var patternToWildcard = Private(__webpack_require__(508));

	    var LocalCache = Private(__webpack_require__(509));

	    function Mapper() {

	      // Save a reference to mapper
	      var self = this;

	      // proper-ish cache, keeps a clean copy of the object, only returns copies of it's copy
	      var fieldCache = self.cache = new LocalCache();

	      /**
	       * Gets an object containing all fields with their mappings
	       * @param {dataSource} dataSource
	       * @param {boolean} skipIndexPatternCache - should we ping the index-pattern objects
	       * @returns {Promise}
	       * @async
	       */
	      self.getFieldsForIndexPattern = function (indexPattern, skipIndexPatternCache) {
	        var id = indexPattern.id;

	        var cache = fieldCache.get(id);
	        if (cache) return Promise.resolve(cache);

	        if (!skipIndexPatternCache) {
	          return es.get({
	            index: kbnIndex,
	            type: 'index-pattern',
	            id: id,
	            _sourceInclude: ['fields']
	          }).then(function (resp) {
	            if (resp.found && resp._source.fields) {
	              fieldCache.set(id, JSON.parse(resp._source.fields));
	            }
	            return self.getFieldsForIndexPattern(indexPattern, true);
	          });
	        }

	        var promise = Promise.resolve(id);
	        if (indexPattern.intervalName) {
	          promise = self.getIndicesForIndexPattern(indexPattern).then(function (existing) {
	            if (existing.matches.length === 0) throw new IndexPatternMissingIndices();
	            return existing.matches.slice(-config.get('indexPattern:fieldMapping:lookBack')); // Grab the most recent
	          });
	        }

	        return promise.then(function (indexList) {
	          return es.indices.getFieldMapping({
	            index: indexList,
	            field: '*',
	            ignoreUnavailable: _.isArray(indexList),
	            allowNoIndices: false,
	            includeDefaults: true
	          });
	        })['catch'](handleMissingIndexPattern).then(transformMappingIntoFields).then(function (fields) {
	          fieldCache.set(id, fields);
	          return fieldCache.get(id);
	        });
	      };

	      self.getIndicesForIndexPattern = function (indexPattern) {
	        return es.indices.getAliases({
	          index: patternToWildcard(indexPattern.id)
	        }).then(function (resp) {
	          // var all = Object.keys(resp).sort();
	          var all = _(resp).map(function (index, key) {
	            if (index.aliases) {
	              return [_Object$keys(index.aliases), key];
	            } else {
	              return key;
	            }
	          }).flattenDeep().sort().uniq(true).value();

	          var matches = all.filter(function (existingIndex) {
	            var parsed = moment(existingIndex, indexPattern.id);
	            return existingIndex === parsed.format(indexPattern.id);
	          });

	          return {
	            all: all,
	            matches: matches
	          };
	        })['catch'](handleMissingIndexPattern);
	      };

	      /**
	       * Clears mapping caches from elasticsearch and from local object
	       * @param {dataSource} dataSource
	       * @returns {Promise}
	       * @async
	       */
	      self.clearCache = function (indexPattern) {
	        fieldCache.clear(indexPattern);
	        return Promise.resolve();
	      };
	    }

	    function handleMissingIndexPattern(err) {
	      if (err.status >= 400) {
	        // transform specific error type
	        return Promise.reject(new IndexPatternMissingIndices());
	      } else {
	        // rethrow all others
	        throw err;
	      }
	    }

	    return new Mapper();
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);
	__webpack_require__(505);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function transformMappingIntoFields(Private, kbnIndex, config) {
	    var _ = __webpack_require__(192);
	    var mapField = Private(__webpack_require__(505));

	    /**
	     * Convert the ES response into the simple map for fields to
	     * mappings which we will cache
	     *
	     * @param  {object} response - complex, excessively nested
	     *                           object returned from ES
	     * @return {object} - simple object that works for all of kibana
	     *                    use-cases
	     */
	    return function (response) {
	      var fields = {};
	      _.each(response, function (index, indexName) {
	        if (indexName === kbnIndex) return;
	        _.each(index.mappings, function (mappings) {
	          _.each(mappings, function (field, name) {
	            var keys = _Object$keys(field.mapping);
	            if (keys.length === 0 || name[0] === '_' && !_.contains(config.get('metaFields'), name)) return;

	            var mapping = mapField(field, name);

	            if (fields[name]) {
	              if (fields[name].type !== mapping.type) {
	                // conflict fields are not available for much except showing in the discover table
	                mapping.type = 'conflict';
	                mapping.indexed = false;
	              }
	            }
	            fields[name] = _.pick(mapping, 'type', 'indexed', 'analyzed', 'doc_values');
	          });
	        });
	      });

	      config.get('metaFields').forEach(function (meta) {
	        if (fields[meta]) return;

	        var field = { mapping: {} };
	        field.mapping[meta] = {};
	        fields[meta] = mapField(field, meta);
	      });

	      return _.map(fields, function (mapping, name) {
	        mapping.name = name;
	        return mapping;
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);
	__webpack_require__(506);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function MapFieldFn(Private, config) {
	    var _ = __webpack_require__(192);
	    var castMappingType = Private(__webpack_require__(506));

	    /**
	     * Accepts a field object and its name, and tries to give it a mapping
	     * @param  {Object} field - the field mapping returned by elasticsearch
	     * @param  {String} type - name of the field
	     * @return {Object} - the resulting field after overrides and tweaking
	     */
	    return function mapField(field, name) {
	      var keys = _Object$keys(field.mapping);
	      if (keys.length === 0 || name[0] === '_' && !_.contains(config.get('metaFields'), name)) return;

	      var mapping = _.cloneDeep(field.mapping[keys.shift()]);
	      mapping.type = castMappingType(mapping.type);

	      // Override the mapping, even if elasticsearch says otherwise
	      var mappingOverrides = {
	        _source: { type: '_source' },
	        _index: { type: 'string' },
	        _type: { type: 'string' },
	        _id: { type: 'string' },
	        _timestamp: {
	          type: 'date',
	          indexed: true
	        },
	        _score: {
	          type: 'number',
	          indexed: false
	        }
	      };

	      if (!mapping.index || mapping.index === 'no') {
	        // elasticsearch responds with false sometimes and 'no' others
	        mapping.indexed = false;
	      } else {
	        mapping.indexed = true;
	      }

	      mapping.analyzed = mapping.index === 'analyzed' ? true : false;

	      if (mappingOverrides[name]) {
	        _.merge(mapping, mappingOverrides[name]);
	      }

	      return mapping;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(441);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CastMappingTypeFn() {
	    var IndexedArray = __webpack_require__(441);

	    castMappingType.types = new IndexedArray({
	      index: ['name'],
	      group: ['type'],
	      immutable: true,
	      initialSet: [{ name: 'string', type: 'string', group: 'base' }, { name: 'date', type: 'date', group: 'base' }, { name: 'boolean', type: 'boolean', group: 'base' }, { name: 'float', type: 'number', group: 'number' }, { name: 'double', type: 'number', group: 'number' }, { name: 'integer', type: 'number', group: 'number' }, { name: 'long', type: 'number', group: 'number' }, { name: 'short', type: 'number', group: 'number' }, { name: 'byte', type: 'number', group: 'number' }, { name: 'token_count', type: 'number', group: 'number' }, { name: 'geo_point', type: 'geo_point', group: 'geo' }, { name: 'geo_shape', type: 'geo_shape', group: 'geo' }, { name: 'ip', type: 'ip', group: 'other' }, { name: 'attachment', type: 'attachment', group: 'other' }, { name: 'murmur3', type: 'murmur3', group: 'hash' }]
	    });

	    /**
	     * Accepts a mapping type, and converts it into it's js equivilent
	     * @param  {String} type - the type from the mapping's 'type' field
	     * @return {String} - the most specific type that we care for
	     */
	    function castMappingType(name) {
	      if (!name) return 'unknown';

	      var match = castMappingType.types.byName[name];
	      return match ? match.type : 'string';
	    }

	    return castMappingType;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(441);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function IndexNameIntervalsService(timefilter) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);
	    var IndexedArray = __webpack_require__(441);

	    var intervals = new IndexedArray({
	      index: ['name'],
	      initialSet: [{
	        name: 'hours',
	        startOf: 'hour',
	        display: 'Hourly'
	      }, {
	        name: 'days',
	        startOf: 'day',
	        display: 'Daily'
	      }, {
	        name: 'weeks',
	        startOf: 'isoWeek',
	        display: 'Weekly'
	      }, {
	        name: 'months',
	        startOf: 'month',
	        display: 'Monthly'
	      }, {
	        name: 'years',
	        startOf: 'year',
	        display: 'Yearly'
	      }]
	    });

	    intervals.toIndexList = function (format, interval, a, b) {
	      var bounds;

	      // setup the range that the list will span, return two moment objects that
	      // are in proper order. a and b can be numbers to specify to go before or after now (respectively)
	      // a certain number of times, based on the interval
	      var range = [[a, 'min', 'startOf'], [b, 'max', 'startOf']].map(function (v) {
	        var val = v[0];
	        var bound = v[1];
	        var extend = v[2];

	        // grab a bound from the time filter
	        if (val == null) {
	          bounds = bounds || timefilter.getBounds();
	          val = bounds[bound];
	        }

	        if (_.isNumeric(val)) val = moment().add(val, interval.name);else if (!moment.isMoment(val)) val = moment(val);

	        return val.clone().utc()[extend](interval.startOf);
	      }).sort(function (a, b) {
	        return a - b;
	      });

	      if (typeof interval === 'string') {
	        interval = _.find(intervals, { name: interval });
	        if (!interval) throw new Error('Interval must be one of ' + _.pluck(intervals, 'name'));
	      }

	      var indexList = [];
	      var start = range.shift();
	      // turn stop into milliseconds to that it's not constantly converted by the while condition
	      var stop = range.shift().valueOf();

	      while (start <= stop) {
	        indexList.push(start.format(format));
	        start.add(1, interval.name);
	      }
	      return indexList;
	    };

	    return intervals;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PatternToWildcardFn() {
	    return function (format) {
	      var wildcard = '';
	      var inEscape = false;
	      var inPattern = false;

	      for (var i = 0; i < format.length; i++) {
	        var ch = format.charAt(i);
	        switch (ch) {
	          case '[':
	            inPattern = false;
	            if (!inEscape) {
	              inEscape = true;
	            } else {
	              wildcard += ch;
	            }
	            break;
	          case ']':
	            if (inEscape) {
	              inEscape = false;
	            } else if (!inPattern) {
	              wildcard += ch;
	            }
	            break;
	          default:
	            if (inEscape) {
	              wildcard += ch;
	            } else if (!inPattern) {
	              wildcard += '*';
	              inPattern = true;
	            }
	        }
	      }

	      return wildcard;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);

	  return function LocalCacheFactory() {
	    function LocalCache(opts) {
	      opts = opts || {};
	      var _id = opts.id || function (o) {
	        return '' + o;
	      };
	      var _cache = {};

	      this.get = function (obj) {
	        var id = _id(obj);
	        return _cache[id] ? JSON.parse(_cache[id]) : null;
	      };

	      this.set = function (obj, val) {
	        var id = _id(obj);
	        var clean = !_cache.hasOwnProperty(id);
	        _cache[id] = angular.toJson(val);
	        return clean;
	      };

	      this.clear = function (obj) {
	        if (!obj) {
	          _cache = {};
	          return;
	        }

	        var id = _id(obj);
	        delete _cache[id];
	      };
	    }

	    return LocalCache;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
	// returns a flattened version
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function () {
	    var self = this;
	    var scriptFields = {};
	    var fielddataFields = [];

	    fielddataFields = _.pluck(self.fields.byType.date, 'name');

	    _.each(self.getScriptedFields(), function (field) {
	      scriptFields[field.name] = { script: field.script, lang: field.lang };
	    });

	    return {
	      fields: ['*', '_source'],
	      scriptFields: scriptFields,
	      fielddataFields: fielddataFields
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(512);
	__webpack_require__(527);
	__webpack_require__(528);
	__webpack_require__(529);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function DocSourceFactory(Private, Promise, es, sessionStorage) {
	    var sendToEs = Private(__webpack_require__(512));
	    var SourceAbstract = Private(__webpack_require__(527));
	    var DocRequest = Private(__webpack_require__(528));
	    var docStrategy = Private(__webpack_require__(529));

	    _['class'](DocSource).inherits(SourceAbstract);
	    function DocSource(initialState) {
	      DocSource.Super.call(this, initialState, docStrategy);
	    }

	    DocSource.prototype.onUpdate = SourceAbstract.prototype.onResults;
	    DocSource.prototype.onResults = void 0;

	    /*****
	     * PUBLIC API
	     *****/

	    DocSource.prototype._createRequest = function (defer) {
	      return new DocRequest(this, defer);
	    };

	    /**
	     * List of methods that is turned into a chainable API in the constructor
	     * @type {Array}
	     */
	    DocSource.prototype._methods = ['index', 'type', 'id', 'sourceInclude', 'sourceExclude'];

	    /**
	     * Applies a partial update to the document
	     * @param  {object} fields - The fields to change and their new values (es doc field)
	     * @return {undefined}
	     */
	    DocSource.prototype.doUpdate = function (fields) {
	      if (!this._state.id) return this.doIndex(fields);
	      return sendToEs.call(this, 'update', false, { doc: fields });
	    };

	    /**
	     * Update the document stored
	     * @param  {[type]}   body [description]
	     * @return {[type]}        [description]
	     */
	    DocSource.prototype.doIndex = function (body) {
	      return sendToEs.call(this, 'index', false, body);
	    };

	    DocSource.prototype.doCreate = function (body) {
	      return sendToEs.call(this, 'create', false, body, []);
	    };

	    /*****
	     * PRIVATE API
	     *****/

	    /**
	     * Get the type of this SourceAbstract
	     * @return {string} - 'doc'
	     */
	    DocSource.prototype._getType = function () {
	      return 'doc';
	    };

	    /**
	     * Used to merge properties into the state within ._flatten().
	     * The state is passed in and modified by the function
	     *
	     * @param  {object} state - the current merged state
	     * @param  {*} val - the value at `key`
	     * @param  {*} key - The key of `val`
	     * @return {undefined}
	     */
	    DocSource.prototype._mergeProp = function (state, val, key) {
	      key = '_' + key;

	      if (val != null && state[key] == null) {
	        state[key] = val;
	      }
	    };

	    /**
	     * Creates a key based on the doc's index/type/id
	     * @return {string}
	     */
	    DocSource.prototype._versionKey = function () {
	      var state = this._state;

	      if (!state.index || !state.type || !state.id) return;
	      return 'DocVersion:' + [state.index, state.type, state.id].map(encodeURIComponent).join('/');
	    };

	    /**
	     * Get the cached version number, not the version that is
	     * stored/shared with other tabs
	     *
	     * @return {number} - the version number, or undefined
	     */
	    DocSource.prototype._getVersion = function () {
	      if (this._version) return this._version;else return this._getStoredVersion();
	    };

	    /**
	     * Fetches the stored version from storage
	     * @return {[type]} [description]
	     */
	    DocSource.prototype._getStoredVersion = function () {
	      var key = this._versionKey();
	      if (!key) return;

	      var v = sessionStorage.get(key);
	      this._version = v ? _.parseInt(v) : void 0;
	      return this._version;
	    };

	    /**
	     * Stores the version into storage
	     * @param  {number, NaN} version - the current version number, NaN works well forcing a refresh
	     * @return {undefined}
	     */
	    DocSource.prototype._storeVersion = function (version) {
	      if (!version) return this._clearVersion();

	      var key = this._versionKey();
	      if (!key) return;
	      this._version = version;
	      sessionStorage.set(key, version);
	    };

	    /**
	     * Clears the stored version for a DocSource
	     */
	    DocSource.prototype._clearVersion = function () {
	      var key = this._versionKey();
	      if (!key) return;
	      sessionStorage.remove(key);
	    };

	    return DocSource;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(220);
	__webpack_require__(513);
	__webpack_require__(514);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var errors = __webpack_require__(220);

	  return function (Promise, Private, es) {
	    var requestQueue = Private(__webpack_require__(513));
	    var courierFetch = Private(__webpack_require__(514));

	    /**
	     * Backend for doUpdate and doIndex
	     * @param  {String} method - the client method to call
	     * @param  {Boolean} validateVersion - should our knowledge
	     *                                   of the the docs current version be sent to es?
	     * @param  {String} body - HTTP request body
	     */
	    return function (method, validateVersion, body, ignore) {
	      var doc = this;
	      // straight assignment will causes undefined values
	      var params = _.pick(this._state, ['id', 'type', 'index']);
	      params.body = body;
	      params.ignore = ignore || [409];

	      if (validateVersion && params.id) {
	        params.version = doc._getVersion();
	      }

	      return es[method](params).then(function (resp) {
	        if (resp.status === 409) throw new errors.VersionConflict(resp);

	        doc._storeVersion(resp._version);
	        doc.id(resp._id);

	        var docFetchProm;
	        if (method !== 'index') {
	          docFetchProm = doc.fetch();
	        } else {
	          // we already know what the response will be
	          docFetchProm = Promise.resolve({
	            _id: resp._id,
	            _index: params.index,
	            _source: body,
	            _type: params.type,
	            _version: doc._getVersion(),
	            found: true
	          });
	        }

	        // notify pending request for this same document that we have updates
	        docFetchProm.then(function (fetchResp) {
	          // use the key to compair sources
	          var key = doc._versionKey();

	          // clear the queue and filter out the removed items, pushing the
	          // unmatched ones back in.
	          var respondTo = requestQueue.splice(0).filter(function (req) {
	            var isDoc = req.source._getType() === 'doc';
	            var keyMatches = isDoc && req.source._versionKey() === key;

	            // put some request back into the queue
	            if (!keyMatches) {
	              requestQueue.push(req);
	              return false;
	            }

	            return true;
	          });

	          return courierFetch.fakeFetchThese(respondTo, respondTo.map(function () {
	            return _.cloneDeep(fetchResp);
	          }));
	        });

	        return resp._id;
	      })['catch'](function (err) {
	        // cast the error
	        throw new errors.RequestFailure(err);
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PendingRequestList() {
	    var _ = __webpack_require__(192);

	    /**
	     * Queue of pending requests, requests are removed as
	     * they are processed by fetch.[sourceType]().
	     * @type {Array}
	     */
	    var queue = [];

	    queue.getInactive = function () /* strategies */{
	      return queue.get.apply(queue, arguments).filter(function (req) {
	        return !req.started;
	      });
	    };

	    queue.get = function () /* strategies.. */{
	      var strategies = _.toArray(arguments);
	      return queue.filter(function (req) {
	        var strategyMatch = !strategies.length;
	        if (!strategyMatch) {
	          strategyMatch = strategies.some(function (strategy) {
	            return req.strategy === strategy;
	          });
	        }

	        return strategyMatch && req.canStart();
	      });
	    };

	    return queue;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(513);
	__webpack_require__(515);
	__webpack_require__(525);
	__webpack_require__(524);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function fetchService(Private, Promise) {
	    var _ = __webpack_require__(192);

	    var requestQueue = Private(__webpack_require__(513));
	    var fetchThese = Private(__webpack_require__(515));

	    var callResponseHandlers = Private(__webpack_require__(525));
	    var INCOMPLETE = Private(__webpack_require__(524)).INCOMPLETE;

	    function fetchQueued(strategy) {
	      var requests = requestQueue.get(strategy);
	      if (!requests.length) return Promise.resolve();else return fetchThese(requests);
	    }

	    this.fetchQueued = fetchQueued;

	    function fetchASource(source, strategy) {
	      var defer = Promise.defer();

	      fetchThese([source._createRequest(defer.resolve)]);

	      return defer.promise;
	    }

	    /**
	     * Fetch a single doc source
	     * @param {DocSource} source - The DocSource to request
	     * @async
	     */
	    this.doc = fetchASource;

	    /**
	     * Fetch a single search source
	     * @param {SearchSource} source - The SearchSource to request
	     * @async
	     */
	    this.search = fetchASource;

	    /**
	     * Fetch a list of requests
	     * @param {array} reqs - the requests to fetch
	     * @async
	     */
	    this.these = fetchThese;

	    /**
	     * Send responses to a list of requests, used when requests
	     * should be skipped (like when a doc is updated with an index).
	     *
	     * This logic is a simplified version of what fetch_these does, and
	     * could have been added elsewhere, but I would rather the logic be
	     * here than outside the courier/fetch module.
	     *
	     * @param {array[Request]} requests - the list of requests to respond to
	     * @param {array[any]} responses - the list of responses for each request
	     */
	    this.fakeFetchThese = function (requests, responses) {
	      return Promise.map(requests, function (req) {
	        return req.start();
	      }).then(function () {
	        return callResponseHandlers(requests, responses);
	      }).then(function (requestStates) {
	        if (_.contains(requestStates, INCOMPLETE)) {
	          throw new Error('responding to requests did not complete!');
	        }
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(516);
	__webpack_require__(517);
	__webpack_require__(518);
	__webpack_require__(525);
	__webpack_require__(526);
	__webpack_require__(524);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FetchTheseProvider(Private, Promise) {
	    var notify = Private(__webpack_require__(516));
	    var forEachStrategy = Private(__webpack_require__(517));

	    // core tasks
	    var callClient = Private(__webpack_require__(518));
	    var callResponseHandlers = Private(__webpack_require__(525));
	    var continueIncomplete = Private(__webpack_require__(526));

	    var ABORTED = Private(__webpack_require__(524)).ABORTED;
	    var DUPLICATE = Private(__webpack_require__(524)).DUPLICATE;
	    var INCOMPLETE = Private(__webpack_require__(524)).INCOMPLETE;

	    function fetchThese(requests) {
	      return forEachStrategy(requests, function (strategy, reqsForStrategy) {
	        return fetchWithStrategy(strategy, reqsForStrategy.map(function (req) {
	          if (!req.started) return req;
	          return req.retry();
	        }));
	      })['catch'](notify.fatal);
	    }

	    function fetchWithStrategy(strategy, requests) {

	      requests = requests.map(function (req) {
	        if (req.aborted) {
	          return ABORTED;
	        }

	        if (req.started) {
	          req['continue']();
	        } else {
	          req.start();
	        }

	        return req;
	      });

	      return Promise.resolve().then(function () {
	        return callClient(strategy, requests);
	      }).then(function (responses) {
	        return callResponseHandlers(requests, responses);
	      }).then(function (responses) {
	        return continueIncomplete(strategy, requests, responses, fetchWithStrategy);
	      }).then(function (responses) {
	        return responses.map(function (resp) {
	          switch (resp) {
	            case ABORTED:
	              return null;
	            case DUPLICATE:
	            case INCOMPLETE:
	              throw new Error('Failed to clear incomplete or duplicate request from responses.');
	            default:
	              return resp;
	          }
	        });
	      });
	    }

	    return fetchThese;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierFetchNotifier(Notifier) {
	    return new Notifier({
	      location: 'Courier Fetch'
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FetchForEachRequestStrategy(Private, Promise) {
	    var _ = __webpack_require__(192);

	    function forEachStrategy(requests, block) {
	      block = Promise.method(block);
	      var sets = [];

	      requests.forEach(function (req) {
	        var strategy = req.strategy;
	        var set = _.find(sets, { 0: strategy });
	        if (set) set[1].push(req);else sets.push([strategy, [req]]);
	      });

	      return Promise.all(sets.map(function (set) {
	        return block(set[0], set[1]);
	      }));
	    }

	    return forEachStrategy;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(519);
	__webpack_require__(523);
	__webpack_require__(524);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierFetchCallClient(Private, Promise, es, esShardTimeout, sessionId) {
	    var _ = __webpack_require__(192);

	    var isRequest = Private(__webpack_require__(519));
	    var mergeDuplicateRequests = Private(__webpack_require__(523));

	    var ABORTED = Private(__webpack_require__(524)).ABORTED;
	    var DUPLICATE = Private(__webpack_require__(524)).DUPLICATE;

	    function callClient(strategy, requests) {
	      // merging docs can change status to DUPLICATE, capture new statuses
	      var statuses = mergeDuplicateRequests(requests);

	      // get the actual list of requests that we will be fetching
	      var executable = statuses.filter(isRequest);
	      var execCount = executable.length;

	      // resolved by respond()
	      var esPromise;
	      var defer = Promise.defer();

	      // for each respond with either the response or ABORTED
	      var respond = function respond(responses) {
	        responses = responses || [];
	        return Promise.map(requests, function (req, i) {
	          switch (statuses[i]) {
	            case ABORTED:
	              return ABORTED;
	            case DUPLICATE:
	              return req._uniq.resp;
	            default:
	              return responses[_.findIndex(executable, req)];
	          }
	        }).then(defer.resolve, defer.reject);
	      };

	      // handle a request being aborted while being fetched
	      var requestWasAborted = Promise.method(function (req, i) {
	        if (statuses[i] === ABORTED) {
	          defer.reject(new Error('Request was aborted twice?'));
	        }

	        execCount -= 1;
	        if (execCount > 0) {
	          // the multi-request still contains other requests
	          return;
	        }

	        if (esPromise && _.isFunction(esPromise.abort)) {
	          esPromise.abort();
	        }

	        esPromise = ABORTED;

	        return respond();
	      });

	      // attach abort handlers, close over request index
	      statuses.forEach(function (req, i) {
	        if (!isRequest(req)) return;
	        req.whenAborted(function () {
	          requestWasAborted(req, i)['catch'](defer.reject);
	        });
	      });

	      // Now that all of THAT^^^ is out of the way, lets actually
	      // call out to elasticsearch
	      Promise.map(executable, function (req) {
	        return Promise['try'](req.getFetchParams, void 0, req).then(function (fetchParams) {
	          return req.fetchParams = fetchParams;
	        });
	      }).then(function (reqsFetchParams) {
	        return strategy.reqsFetchParamsToBody(reqsFetchParams);
	      }).then(function (body) {
	        // while the strategy was converting, our request was aborted
	        if (esPromise === ABORTED) {
	          throw ABORTED;
	        }

	        return esPromise = es[strategy.clientMethod]({
	          timeout: esShardTimeout,
	          ignore_unavailable: true,
	          preference: sessionId,
	          body: body
	        });
	      }).then(function (clientResp) {
	        return strategy.getResponses(clientResp);
	      }).then(respond)['catch'](function (err) {
	        if (err === ABORTED) respond();else defer.reject(err);
	      });

	      // return our promise, but catch any errors we create and
	      // send them to the requests
	      return defer.promise['catch'](function (err) {
	        requests.forEach(function (req, i) {
	          if (statuses[i] !== ABORTED) {
	            req.handleFailure(err);
	          }
	        });
	      });
	    }

	    return callClient;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(520);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierFetchIsRequestProvider(Private) {
	    var AbstractRequest = Private(__webpack_require__(520));

	    return function isRequest(obj) {
	      return obj instanceof AbstractRequest;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(220);
	__webpack_require__(513);
	__webpack_require__(521);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AbstractReqProvider(Private, Promise) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);
	    var errors = __webpack_require__(220);
	    var requestQueue = Private(__webpack_require__(513));
	    var requestErrorHandler = Private(__webpack_require__(521));

	    function AbstractReq(source, defer) {
	      if (!(this instanceof AbstractReq) || !this.constructor || this.constructor === AbstractReq) {
	        throw new Error('The AbstractReq class should not be called directly');
	      }

	      this.source = source;
	      this.defer = defer || Promise.defer();

	      requestQueue.push(this);
	    }

	    AbstractReq.prototype.canStart = function () {
	      return Boolean(!this.stopped && !this.source._fetchDisabled);
	    };

	    AbstractReq.prototype.start = function () {
	      if (this.started) {
	        throw new TypeError('Unable to start request because it has already started');
	      }

	      this.started = true;
	      this.moment = moment();

	      var source = this.source;
	      if (source.activeFetchCount) {
	        source.activeFetchCount += 1;
	      } else {
	        source.activeFetchCount = 1;
	      }

	      source.history = [this];
	    };

	    AbstractReq.prototype.getFetchParams = function () {
	      return this.source._flatten();
	    };

	    AbstractReq.prototype.transformResponse = function (resp) {
	      return resp;
	    };

	    AbstractReq.prototype.filterError = function (resp) {
	      return false;
	    };

	    AbstractReq.prototype.handleResponse = function (resp) {
	      this.success = true;
	      this.resp = resp;
	    };

	    AbstractReq.prototype.handleFailure = function (error) {
	      this.success = false;
	      this.resp = error && error.resp;
	      this.retry();
	      return requestErrorHandler(this, error);
	    };

	    AbstractReq.prototype.isIncomplete = function () {
	      return false;
	    };

	    AbstractReq.prototype['continue'] = function () {
	      throw new Error('Unable to continue ' + this.type + ' request');
	    };

	    AbstractReq.prototype.retry = function () {
	      var clone = this.clone();
	      this.abort();
	      return clone;
	    };

	    // don't want people overriding this, so it becomes a natural
	    // part of .abort() and .complete()
	    function stop(then) {
	      return function () {
	        if (this.stopped) return;

	        this.stopped = true;
	        this.source.activeFetchCount -= 1;
	        _.pull(requestQueue, this);
	        then.call(this);
	      };
	    }

	    AbstractReq.prototype.abort = stop(function () {
	      this.defer = null;
	      this.aborted = true;
	      if (this._whenAborted) _.callEach(this._whenAborted);
	    });

	    AbstractReq.prototype.whenAborted = function (cb) {
	      this._whenAborted = this._whenAborted || [];
	      this._whenAborted.push(cb);
	    };

	    AbstractReq.prototype.complete = stop(function () {
	      this.ms = this.moment.diff() * -1;
	      this.defer.resolve(this.resp);
	    });

	    AbstractReq.prototype.clone = function () {
	      return new this.constructor(this.source, this.defer);
	    };

	    return AbstractReq;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(522);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function RequestErrorHandlerFactory(Private, Notifier) {
	    var errHandlers = Private(__webpack_require__(522));

	    var notify = new Notifier({
	      location: 'Courier Fetch Error'
	    });

	    function handleError(req, error) {
	      var myHandlers = [];

	      errHandlers.splice(0).forEach(function (handler) {
	        (handler.source === req.source ? myHandlers : errHandlers).push(handler);
	      });

	      if (!myHandlers.length) {
	        notify.fatal(new Error('unhandled error ' + (error.stack || error.message)));
	      } else {
	        myHandlers.forEach(function (handler) {
	          handler.defer.resolve(error);
	        });
	      }
	    }

	    return handleError;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ErrorHandlerList() {
	    /**
	     * Queue of pending error handlers, they are removed as
	     * they are resolved.
	     * @type {Array}
	     */
	    return [];
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(519);
	__webpack_require__(524);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FetchMergeDuplicateRequests(Private) {
	    var isRequest = Private(__webpack_require__(519));
	    var DUPLICATE = Private(__webpack_require__(524)).DUPLICATE;

	    function mergeDuplicateRequests(requests) {
	      // dedupe requests
	      var index = {};
	      return requests.map(function (req) {
	        if (!isRequest(req)) return req;

	        var iid = req.source._instanceid;
	        if (!index[iid]) {
	          // this request is unique so far
	          index[iid] = req;
	          // keep the request
	          return req;
	        }

	        // the source was requested at least twice
	        req._uniq = index[iid];
	        return DUPLICATE;
	      });
	    }

	    return mergeDuplicateRequests;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierFetchRequestStatus() {
	    return {
	      ABORTED: { CourierFetchRequestStatus: 'aborted' },
	      DUPLICATE: { CourierFetchRequestStatus: 'duplicate' },
	      INCOMPLETE: { CourierFetchRequestStatus: 'incomplete' }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(524);
	__webpack_require__(516);
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierFetchCallResponseHandlers(Private, Promise) {
	    var ABORTED = Private(__webpack_require__(524)).ABORTED;
	    var INCOMPLETE = Private(__webpack_require__(524)).INCOMPLETE;
	    var notify = Private(__webpack_require__(516));

	    var SearchTimeout = __webpack_require__(220).SearchTimeout;
	    var RequestFailure = __webpack_require__(220).RequestFailure;
	    var ShardFailure = __webpack_require__(220).ShardFailure;

	    function callResponseHandlers(requests, responses) {
	      return Promise.map(requests, function (req, i) {
	        if (req === ABORTED || req.aborted) {
	          return ABORTED;
	        }

	        var resp = responses[i];

	        if (resp.timed_out) {
	          notify.warning(new SearchTimeout());
	        }

	        if (resp._shards && resp._shards.failed) {
	          notify.warning(new ShardFailure(resp));
	        }

	        function progress() {
	          if (req.isIncomplete()) {
	            return INCOMPLETE;
	          }

	          req.complete();
	          return resp;
	        }

	        if (resp.error) {
	          if (req.filterError(resp)) {
	            return progress();
	          } else {
	            return req.handleFailure(new RequestFailure(null, resp));
	          }
	        }

	        return Promise['try'](function () {
	          return req.transformResponse(resp);
	        }).then(function () {
	          resp = arguments[0];
	          return req.handleResponse(resp);
	        }).then(progress);
	      });
	    }

	    return callResponseHandlers;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(524);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierFetchContinueIncompleteRequests(Private) {
	    var INCOMPLETE = Private(__webpack_require__(524)).INCOMPLETE;

	    function continueIncompleteRequests(strategy, requests, responses, fetchWithStrategy) {
	      var incomplete = [];

	      responses.forEach(function (resp, i) {
	        if (resp === INCOMPLETE) {
	          incomplete.push(requests[i]);
	        }
	      });

	      if (!incomplete.length) return responses;

	      return fetchWithStrategy(strategy, incomplete).then(function (completedResponses) {
	        return responses.map(function (prevResponse) {
	          if (prevResponse !== INCOMPLETE) return prevResponse;
	          return completedResponses.shift();
	        });
	      });
	    }

	    return continueIncompleteRequests;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(513);
	__webpack_require__(522);
	__webpack_require__(514);
	__webpack_require__(493);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);

	  return function SourceAbstractFactory(Private, Promise, PromiseEmitter) {
	    var requestQueue = Private(__webpack_require__(513));
	    var errorHandlers = Private(__webpack_require__(522));
	    var courierFetch = Private(__webpack_require__(514));

	    function SourceAbstract(initialState, strategy) {
	      var self = this;
	      self._instanceid = _.uniqueId('data_source');

	      self._state = (function () {
	        // state can be serialized as JSON, and passed back in to restore
	        if (initialState) {
	          if (typeof initialState === 'string') {
	            return JSON.parse(initialState);
	          } else {
	            return _.cloneDeep(initialState);
	          }
	        } else {
	          return {};
	        }
	      })();

	      // set internal state values
	      self._methods.forEach(function (name) {
	        self[name] = function (val) {
	          if (val == null) {
	            delete self._state[name];
	          } else {
	            self._state[name] = val;
	          }

	          return self;
	        };
	      });

	      self.history = [];
	      self._fetchStrategy = strategy;
	    }

	    /*****
	     * PUBLIC API
	     *****/

	    /**
	     * Get values from the state
	     * @param {string} name - The name of the property desired
	     * @return {any} - the value found
	     */
	    SourceAbstract.prototype.get = function (name) {
	      var self = this;
	      while (self) {
	        if (self._state[name] !== void 0) return self._state[name];
	        self = self.getParent();
	      }
	    };

	    /**
	     * Get the value from our own state, don't traverse up the chain
	     * @param {string} name - The name of the property desired
	     * @return {any} - the value found
	     */
	    SourceAbstract.prototype.getOwn = function (name) {
	      if (this._state[name] !== void 0) return this._state[name];
	    };

	    /**
	     * Change the entire state of a SourceAbstract
	     * @param {object|string} state - The SourceAbstract's new state, or a
	     *   string of the state value to set
	     */
	    SourceAbstract.prototype.set = function (state, val) {
	      var self = this;

	      if (typeof state === 'string') {
	        // the getter and setter methods check for undefined explicitly
	        // to identify getters and null to identify deletion
	        if (val === undefined) {
	          val = null;
	        }
	        self[state](val);
	      } else {
	        self._state = state;
	      }
	      return self;
	    };

	    /**
	     * Create a new dataSource object of the same type
	     * as this, which inherits this dataSource's properties
	     * @return {SourceAbstract}
	     */
	    SourceAbstract.prototype.extend = function () {
	      return new this.Class().inherits(this);
	    };

	    /**
	     * return a simple, encodable object representing the state of the SourceAbstract
	     * @return {[type]} [description]
	     */
	    SourceAbstract.prototype.toJSON = function () {
	      return _.clone(this._state);
	    };

	    /**
	     * Create a string representation of the object
	     * @return {[type]} [description]
	     */
	    SourceAbstract.prototype.toString = function () {
	      return angular.toJson(this.toJSON());
	    };

	    /**
	     * Put a request in to the courier that this Source should
	     * be fetched on the next run of the courier
	     * @return {Promise}
	     */
	    SourceAbstract.prototype.onResults = function (handler) {
	      var self = this;

	      return new PromiseEmitter(function (resolve, reject, defer) {
	        self._createRequest(defer);
	      }, handler);
	    };

	    /**
	     * Noop
	     */
	    SourceAbstract.prototype.getParent = function () {
	      return this._parent;
	    };

	    /**
	     * similar to onResults, but allows a seperate loopy code path
	     * for error handling.
	     *
	     * @return {Promise}
	     */
	    SourceAbstract.prototype.onError = function (handler) {
	      var self = this;

	      return new PromiseEmitter(function (resolve, reject, defer) {
	        errorHandlers.push({
	          source: self,
	          defer: defer
	        });
	      }, handler);
	    };

	    /**
	     * Fetch just this source ASAP
	     *
	     * ONLY USE IF YOU WILL BE USING THE RESULTS
	     * provided by the returned promise, otherwise
	     * call #fetchQueued()
	     *
	     * @async
	     */
	    SourceAbstract.prototype.fetch = function () {
	      var self = this;
	      var req = _.first(self._myQueued());

	      if (!req) {
	        req = self._createRequest();
	      }

	      courierFetch.these([req]);

	      return req.defer.promise;
	    };

	    /**
	     * Fetch all pending requests for this source ASAP
	     * @async
	     */
	    SourceAbstract.prototype.fetchQueued = function () {
	      return courierFetch.these(this._myQueued());
	    };

	    /**
	     * Cancel all pending requests for this dataSource
	     * @return {undefined}
	     */
	    SourceAbstract.prototype.cancelQueued = function () {
	      _.invoke(this._myQueued(), 'abort');
	    };

	    /**
	     * Completely destroy the SearchSource.
	     * @return {undefined}
	     */
	    SourceAbstract.prototype.destroy = function () {
	      this.cancelQueued();
	    };

	    /*****
	     * PRIVATE API
	     *****/

	    SourceAbstract.prototype._myQueued = function () {
	      var reqs = requestQueue.get(this._fetchStrategy);
	      return _.where(reqs, { source: this });
	    };

	    SourceAbstract.prototype._createRequest = function () {
	      throw new Error('_createRequest must be implemented by subclass');
	    };

	    /**
	     * Walk the inheritance chain of a source and return it's
	     * flat representaion (taking into account merging rules)
	     * @returns {Promise}
	     * @resolved {Object|null} - the flat state of the SourceAbstract
	     */
	    SourceAbstract.prototype._flatten = function () {
	      var type = this._getType();

	      // the merged state of this dataSource and it's ancestors
	      var flatState = {};

	      // function used to write each property from each state object in the chain to flat state
	      var root = this;

	      // start the chain at this source
	      var current = this;

	      // call the ittr and return it's promise
	      return (function ittr() {
	        // itterate the _state object (not array) and
	        // pass each key:value pair to source._mergeProp. if _mergeProp
	        // returns a promise, then wait for it to complete and call _mergeProp again
	        return Promise.all(_.map(current._state, function ittr(value, key) {
	          if (Promise.is(value)) {
	            return value.then(function (value) {
	              return ittr(value, key);
	            });
	          }

	          var prom = root._mergeProp(flatState, value, key);
	          return Promise.is(prom) ? prom : null;
	        })).then(function () {
	          // move to this sources parent
	          var parent = current.getParent();
	          // keep calling until we reach the top parent
	          if (parent) {
	            current = parent;
	            return ittr();
	          }
	        });
	      })().then(function () {
	        if (type === 'search') {
	          // This is down here to prevent the circular dependency
	          var decorateQuery = Private(__webpack_require__(493));

	          flatState.body = flatState.body || {};

	          // defaults for the query
	          if (!flatState.body.query) {
	            flatState.body.query = {
	              'match_all': {}
	            };
	          }

	          if (flatState.body.size === 0) {
	            flatState.search_type = 'count';
	          } else {
	            var computedFields = flatState.index.getComputedFields();
	            flatState.body.fields = computedFields.fields;
	            flatState.body.script_fields = flatState.body.script_fields || {};
	            flatState.body.fielddata_fields = flatState.body.fielddata_fields || [];

	            _.extend(flatState.body.script_fields, computedFields.scriptFields);
	            flatState.body.fielddata_fields = _.union(flatState.body.fielddata_fields, computedFields.fielddataFields);
	          }

	          decorateQuery(flatState.body.query);

	          /**
	           * Create a filter that can be reversed for filters with negate set
	           * @param {boolean} reverse This will reverse the filter. If true then
	           *                          anything where negate is set will come
	           *                          through otherwise it will filter out
	           * @returns {function}
	           */
	          var filterNegate = function filterNegate(reverse) {
	            return function (filter) {
	              if (_.isUndefined(filter.meta) || _.isUndefined(filter.meta.negate)) return !reverse;
	              return filter.meta && filter.meta.negate === reverse;
	            };
	          };

	          /**
	           * Clean out any invalid attributes from the filters
	           * @param {object} filter The filter to clean
	           * @returns {object}
	           */
	          var cleanFilter = function cleanFilter(filter) {
	            return _.omit(filter, ['meta']);
	          };

	          // switch to filtered query if there are filters
	          if (flatState.filters) {
	            if (flatState.filters.length) {
	              _.each(flatState.filters, function (filter) {
	                if (filter.query) {
	                  decorateQuery(filter.query);
	                }
	              });

	              flatState.body.query = {
	                filtered: {
	                  query: flatState.body.query,
	                  filter: {
	                    bool: {
	                      must: _(flatState.filters).filter(filterNegate(false)).map(cleanFilter).value(),
	                      must_not: _(flatState.filters).filter(filterNegate(true)).map(cleanFilter).value()
	                    }
	                  }
	                }
	              };
	            }
	            delete flatState.filters;
	          }
	        }

	        return flatState;
	      });
	    };

	    return SourceAbstract;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(529);
	__webpack_require__(520);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DocRequestProvider(Private) {
	    var _ = __webpack_require__(192);

	    var docStrategy = Private(__webpack_require__(529));
	    var AbstractRequest = Private(__webpack_require__(520));

	    _['class'](DocRequest).inherits(AbstractRequest);
	    function DocRequest(source, defer) {
	      DocRequest.Super.call(this, source, defer);

	      this.type = 'doc';
	      this.strategy = docStrategy;
	    }

	    DocRequest.prototype.canStart = function () {
	      var parent = DocRequest.Super.prototype.canStart.call(this);
	      if (!parent) return false;

	      var version = this.source._version;
	      var storedVersion = this.source._getStoredVersion();

	      // conditions that equal "fetch This DOC!"
	      var unknown = !version && !storedVersion;
	      var mismatch = version !== storedVersion;

	      return Boolean(mismatch || unknown && !this.started);
	    };

	    DocRequest.prototype.handleResponse = function (resp) {
	      if (resp.found) {
	        this.source._storeVersion(resp._version);
	      } else {
	        this.source._clearVersion();
	      }

	      return DocRequest.Super.prototype.handleResponse.call(this, resp);
	    };

	    return DocRequest;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FetchStrategyForDoc(Promise) {
	    return {
	      clientMethod: 'mget',

	      /**
	       * Flatten a series of requests into as ES request body
	       * @param  {array} requests - an array of flattened requests
	       * @return {string} - the request body
	       */
	      reqsFetchParamsToBody: function reqsFetchParamsToBody(reqsFetchParams) {
	        return {
	          docs: reqsFetchParams
	        };
	      },

	      /**
	       * Fetch the multiple responses from the ES Response
	       * @param  {object} resp - The response sent from Elasticsearch
	       * @return {array} - the list of responses
	       */
	      getResponses: function getResponses(resp) {
	        return resp.docs;
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(209);
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function MappingSetupService(kbnIndex, es) {
	    var angular = __webpack_require__(209);
	    var _ = __webpack_require__(192);
	    var mappingSetup = this;

	    var json = {
	      _serialize: function _serialize(val) {
	        if (val != null) return angular.toJson(val);
	      },
	      _deserialize: function _deserialize(val) {
	        if (val != null) return JSON.parse(val);
	      }
	    };

	    /**
	     * Use to create the mappings, but that should only happen one at a time
	     */
	    var activeTypeCreations = {};

	    /**
	     * Get the list of type's mapped in elasticsearch
	     * @return {[type]} [description]
	     */
	    var getKnownKibanaTypes = _.once(function () {
	      var indexName = kbnIndex;
	      return es.indices.getFieldMapping({
	        // only concerned with types in this kibana index
	        index: indexName,
	        // check all types
	        type: '*',
	        // limit the response to just the _source field for each index
	        field: '_source'
	      }).then(function (resp) {
	        return _.keys(resp[indexName].mappings);
	      });
	    });

	    mappingSetup.expandShorthand = function (sh) {
	      return _.mapValues(sh || {}, function (val, prop) {
	        // allow shortcuts for the field types, by just setting the value
	        // to the type name
	        if (typeof val === 'string') val = { type: val };

	        if (val.type === 'json') {
	          val.type = 'string';
	          val._serialize = json._serialize;
	          val._deserialize = json._deserialize;
	        }

	        return val;
	      });
	    };

	    mappingSetup.isDefined = function (type) {
	      return getKnownKibanaTypes().then(function (knownTypes) {
	        // if the type is in the knownTypes array already
	        return !! ~knownTypes.indexOf(type);
	      });
	    };

	    mappingSetup.setup = function (type, mapping) {
	      // if there is already a creation running for this index type
	      if (activeTypeCreations[type]) {
	        // return a promise that will reexecute the setup once the
	        // current is complete.
	        return activeTypeCreations[type].then(function () {
	          return mappingSetup.setup(type, mapping);
	        });
	      }

	      var prom = getKnownKibanaTypes().then(function (knownTypes) {
	        // if the type is in the knownTypes array already
	        if (~knownTypes.indexOf(type)) return false;

	        // we need to create the mapping
	        var body = {};
	        body[type] = {
	          properties: mapping
	        };

	        return es.indices.putMapping({
	          index: kbnIndex,
	          type: type,
	          body: body
	        }).then(function (resp) {
	          // add this type to the list of knownTypes
	          knownTypes.push(type);

	          // cast the response to "true", meaning
	          // the mapping exists
	          return true;
	        });
	      })
	      // wether this fails or not, remove it from the activeTypeCreations obj
	      // once complete
	      ['finally'](function () {
	        delete activeTypeCreations[type];
	      });

	      activeTypeCreations[type] = prom;
	      return prom;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
	// returns a flattened version
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FlattenHitProvider(config, $rootScope) {
	    var _ = __webpack_require__(192);

	    var metaFields = config.get('metaFields');
	    $rootScope.$on('change:config.metaFields', function () {
	      metaFields = config.get('metaFields');
	    });

	    function flattenHit(indexPattern, hit) {
	      var flat = {};

	      // recursively merge _source
	      var fields = indexPattern.fields.byName;
	      (function flatten(obj, keyPrefix) {
	        keyPrefix = keyPrefix ? keyPrefix + '.' : '';
	        _.forOwn(obj, function (val, key) {
	          key = keyPrefix + key;

	          if (flat[key] !== void 0) return;

	          var hasValidMapping = fields[key] && fields[key].type !== 'conflict';
	          var isValue = !_.isPlainObject(val);

	          if (hasValidMapping || isValue) {
	            flat[key] = val;
	            return;
	          }

	          flatten(val, key);
	        });
	      })(hit._source);

	      // assign the meta fields
	      _.each(metaFields, function (meta) {
	        if (meta === '_source') return;
	        flat[meta] = hit[meta];
	      });

	      // unwrap computed fields
	      _.forOwn(hit.fields, function (val, key) {
	        if (key[0] === '_' && !_.contains(metaFields, key)) return;
	        flat[key] = _.isArray(val) && val.length === 1 ? val[0] : val;
	      });

	      return flat;
	    }

	    return function (indexPattern) {
	      function cachedFlatten(hit) {
	        return hit.$$_flattened || (hit.$$_flattened = flattenHit(indexPattern, hit));
	      }

	      cachedFlatten.uncached = _.partial(flattenHit, indexPattern);

	      return cachedFlatten;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	// Takes a hit, merges it with any stored/scripted fields, and with the metaFields
	// returns a formated version
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function (indexPattern, defaultFormat) {

	    function convert(hit, val, fieldName) {
	      var field = indexPattern.fields.byName[fieldName];
	      if (!field) return defaultFormat.convert(val, 'html');
	      return field.format.getConverterFor('html')(val, field, hit);
	    }

	    function formatHit(hit) {
	      if (hit.$$_formatted) return hit.$$_formatted;

	      // use and update the partial cache, but don't rewrite it. _source is stored in partials
	      // but not $$_formatted
	      var partials = hit.$$_partialFormatted || (hit.$$_partialFormatted = {});
	      var cache = hit.$$_formatted = {};

	      _.forOwn(indexPattern.flattenHit(hit), function (val, fieldName) {
	        // sync the formatted and partial cache
	        var formatted = partials[fieldName] == null ? convert(hit, val, fieldName) : partials[fieldName];
	        cache[fieldName] = partials[fieldName] = formatted;
	      });

	      return cache;
	    }

	    formatHit.formatField = function (hit, fieldName) {
	      var partials = hit.$$_partialFormatted;
	      if (partials && partials[fieldName] != null) {
	        return partials[fieldName];
	      }

	      if (!partials) {
	        partials = hit.$$_partialFormatted = {};
	      }

	      var val = fieldName === '_source' ? hit._source : indexPattern.flattenHit(hit)[fieldName];
	      return partials[fieldName] = convert(hit, val, fieldName);
	    };

	    return formatHit;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PatternCache() {
	    var _ = __webpack_require__(192);

	    var vals = {};

	    var validId = function validId(id) {
	      return typeof id !== 'object';
	    };

	    this.get = function (id) {
	      if (validId(id)) return vals[id];
	    };

	    this.set = function (id, prom) {
	      if (validId(id)) vals[id] = prom;
	      return prom;
	    };

	    this.clear = this['delete'] = function (id) {
	      if (validId(id)) delete vals[id];
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(527);
	__webpack_require__(535);
	__webpack_require__(537);
	__webpack_require__(536);
	__webpack_require__(539);
	__webpack_require__(540);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function SearchSourceFactory(Promise, Private) {
	    var _ = __webpack_require__(192);
	    var SourceAbstract = Private(__webpack_require__(527));
	    var SearchRequest = Private(__webpack_require__(535));
	    var SegmentedRequest = Private(__webpack_require__(537));
	    var searchStrategy = Private(__webpack_require__(536));
	    var normalizeSortRequest = Private(__webpack_require__(539));
	    var rootSearchSource = __webpack_require__(540);

	    _['class'](SearchSource).inherits(SourceAbstract);
	    function SearchSource(initialState) {
	      SearchSource.Super.call(this, initialState, searchStrategy);
	    }

	    /*****
	     * PUBLIC API
	     *****/

	    /**
	     * List of the editable state properties that turn into a
	     * chainable API
	     *
	     * @type {Array}
	     */
	    SearchSource.prototype._methods = ['type', 'query', 'filter', 'sort', 'highlight', 'aggs', 'from', 'size', 'source'];

	    SearchSource.prototype.index = function (indexPattern) {
	      if (indexPattern === undefined) return this._state.index;
	      if (indexPattern === null) return delete this._state.index;
	      if (!indexPattern || typeof indexPattern.toIndexList !== 'function') {
	        throw new TypeError('expected indexPattern to be an IndexPattern duck.');
	      }

	      this._state.index = indexPattern;
	      return this;
	    };

	    SearchSource.prototype.extend = function () {
	      return new SearchSource().inherits(this);
	    };

	    /**
	     * Set a searchSource that this source should inherit from
	     * @param  {SearchSource} searchSource - the parent searchSource
	     * @return {this} - chainable
	     */
	    SearchSource.prototype.inherits = function (parent) {
	      this._parent = parent;
	      return this;
	    };

	    /**
	     * Get the parent of this SearchSource
	     * @return {undefined|searchSource}
	     */
	    SearchSource.prototype.getParent = function (onlyHardLinked) {
	      var self = this;
	      if (self._parent === false) return;
	      if (self._parent) return self._parent;
	      return onlyHardLinked ? undefined : Private(rootSearchSource).get();
	    };

	    /**
	     * Temporarily prevent this Search from being fetched... not a fan but it's easy
	     */
	    SearchSource.prototype.disable = function () {
	      this._fetchDisabled = true;
	    };

	    /**
	     * Reverse of SourceAbstract#disable(), only need to call this if source was previously disabled
	     */
	    SearchSource.prototype.enable = function () {
	      this._fetchDisabled = false;
	    };

	    SearchSource.prototype.onBeginSegmentedFetch = function (initFunction) {
	      var self = this;
	      return Promise['try'](function addRequest() {
	        var req = new SegmentedRequest(self, Promise.defer(), initFunction);

	        // return promises created by the completion handler so that
	        // errors will bubble properly
	        return req.defer.promise.then(addRequest);
	      });
	    };

	    /******
	     * PRIVATE APIS
	     ******/

	    /**
	     * Gets the type of the DataSource
	     * @return {string}
	     */
	    SearchSource.prototype._getType = function () {
	      return 'search';
	    };

	    /**
	     * Create a common search request object, which should
	     * be put into the pending request queye, for this search
	     * source
	     *
	     * @param {Deferred} defer - the deferred object that should be resolved
	     *                         when the request is complete
	     * @return {SearchRequest}
	     */
	    SearchSource.prototype._createRequest = function (defer) {
	      return new SearchRequest(this, defer);
	    };

	    /**
	     * Used to merge properties into the state within ._flatten().
	     * The state is passed in and modified by the function
	     *
	     * @param  {object} state - the current merged state
	     * @param  {*} val - the value at `key`
	     * @param  {*} key - The key of `val`
	     * @return {undefined}
	     */
	    SearchSource.prototype._mergeProp = function (state, val, key) {
	      if (typeof val === 'function') {
	        var source = this;
	        return Promise.cast(val(this)).then(function (newVal) {
	          return source._mergeProp(state, newVal, key);
	        });
	      }

	      if (val == null || !key || !_.isString(key)) return;

	      switch (key) {
	        case 'filter':
	          // user a shallow flatten to detect if val is an array, and pull the values out if it is
	          state.filters = _([state.filters || [], val]).flatten()
	          // Yo Dawg! I heard you needed to filter out your filters
	          .reject(function (filter) {
	            return !filter || _.get(filter, 'meta.disabled');
	          }).value();
	          return;
	        case 'index':
	        case 'type':
	        case 'id':
	          if (key && state[key] == null) {
	            state[key] = val;
	          }
	          return;
	        case 'source':
	          key = '_source';
	          addToBody();
	          break;
	        case 'sort':
	          val = normalizeSortRequest(val, this.get('index'));
	          addToBody();
	          break;
	        default:
	          addToBody();
	      }

	      /**
	       * Add the key and val to the body of the resuest
	       */
	      function addToBody() {
	        state.body = state.body || {};
	        // ignore if we already have a value
	        if (state.body[key] == null) {
	          if (key === 'query' && _.isString(val)) {
	            val = { query_string: { query: val } };
	          }

	          state.body[key] = val;
	        }
	      }
	    };

	    return SearchSource;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(536);
	__webpack_require__(520);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function SearchReqProvider(Private) {
	    var _ = __webpack_require__(192);

	    var searchStrategy = Private(__webpack_require__(536));
	    var AbstractRequest = Private(__webpack_require__(520));

	    _['class'](SearchReq).inherits(AbstractRequest);
	    var Super = SearchReq.Super;
	    function SearchReq(source, defer) {
	      Super.call(this, source, defer);

	      this.type = 'search';
	      this.strategy = searchStrategy;
	    }

	    return SearchReq;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FetchStrategyForSearch(Private, Promise, timefilter) {
	    var _ = __webpack_require__(192);
	    var angular = __webpack_require__(209);

	    return {
	      clientMethod: 'msearch',

	      /**
	       * Flatten a series of requests into as ES request body
	       *
	       * @param  {array} requests - the requests to serialize
	       * @return {string} - the request body
	       */
	      reqsFetchParamsToBody: function reqsFetchParamsToBody(reqsFetchParams) {
	        return reqsFetchParams.map(function (fetchParams) {
	          var indexList = fetchParams.index;

	          if (_.isFunction(_.get(indexList, 'toIndexList'))) {
	            var timeBounds = timefilter.getBounds();
	            indexList = indexList.toIndexList(timeBounds.min, timeBounds.max);
	          }

	          return angular.toJson({
	            index: indexList,
	            type: fetchParams.type,
	            search_type: fetchParams.search_type,
	            ignore_unavailable: true
	          }) + '\n' + angular.toJson(fetchParams.body || {});
	        }).join('\n') + '\n';
	      },

	      /**
	       * Fetch the multiple responses from the ES Response
	       * @param  {object} resp - The response sent from Elasticsearch
	       * @return {array} - the list of responses
	       */
	      getResponses: function getResponses(resp) {
	        return resp.responses;
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);
	__webpack_require__(535);
	__webpack_require__(513);
	__webpack_require__(538);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierSegmentedReqProvider(es, Private, Promise, Notifier, timefilter, config) {
	    var _ = __webpack_require__(192);
	    var SearchReq = Private(__webpack_require__(535));
	    var requestQueue = Private(__webpack_require__(513));
	    var SegmentedHandle = Private(__webpack_require__(538));

	    var notify = new Notifier({
	      location: 'Segmented Fetch'
	    });

	    _['class'](SegmentedReq).inherits(SearchReq);
	    function SegmentedReq(source, defer, initFn) {
	      SearchReq.call(this, source, defer);

	      this.type = 'segmented';

	      // segmented request specific state
	      this._initFn = initFn;
	      this._desiredSize = false;
	      this._maxSegments = config.get('courier:maxSegmentCount');
	      this._hitsReceived = 0;
	      this._direction = 'desc';
	      this._handle = new SegmentedHandle(this);

	      // prevent the source from changing between requests,
	      // all calls will return the same promise
	      this._getFlattenedSource = _.once(this._getFlattenedSource);
	    }

	    /*********
	     ** SearchReq overrides
	     *********/

	    SegmentedReq.prototype.start = function () {
	      this._complete = [];
	      this._active = null;
	      this._segments = [];

	      this._mergedResp = {
	        took: 0,
	        hits: {
	          hits: [],
	          total: 0,
	          max_score: 0
	        }
	      };

	      // give the request consumer a chance to receive each segment and set
	      // parameters via the handle
	      if (_.isFunction(this._initFn)) this._initFn(this._handle);
	      this._createQueue();
	      this._all = this._queue.slice(0);

	      // Send the initial fetch status
	      this._reportStatus();

	      return SearchReq.prototype.start.call(this);
	    };

	    SegmentedReq.prototype['continue'] = function () {
	      return this._reportStatus();
	    };

	    SegmentedReq.prototype.getFetchParams = function () {
	      var self = this;

	      return self._getFlattenedSource().then(function (flatSource) {
	        var params = _.cloneDeep(flatSource);

	        // calculate the number of indices to fetch in this request in order to prevent
	        // more than self._maxSegments requests. We use Math.max(1, n) to ensure that each request
	        // has at least one index pattern, and Math.floor() to make sure that if the
	        // number of indices does not round out evenly the extra index is tacked onto the last
	        // request, making sure the first request returns faster.
	        var remainingSegments = self._maxSegments - self._segments.length;
	        var indexCount = Math.max(1, Math.floor(self._queue.length / remainingSegments));
	        params.index = self._active = self._queue.splice(0, indexCount);

	        if (self._desiredSize !== false) {
	          params.body.size = Math.max(self._desiredSize - self._hitsReceived, 0);
	        }

	        if (params.body.size === 0) params.search_type = 'count';

	        return params;
	      });
	    };

	    SegmentedReq.prototype.handleResponse = function (resp) {
	      return this._consumeSegment(resp);
	    };

	    SegmentedReq.prototype.filterError = function (resp) {
	      if (/ClusterBlockException.*index\sclosed/.test(resp.error)) {
	        this._consumeSegment(false);
	        return true;
	      }
	    };

	    SegmentedReq.prototype.isIncomplete = function () {
	      return this._queue.length > 0;
	    };

	    SegmentedReq.prototype.clone = function () {
	      return new SegmentedReq(this.source, this.defer, this._initFn);
	    };

	    SegmentedReq.prototype.complete = function () {
	      this._reportStatus();
	      this._handle.emit('complete');
	      return SearchReq.prototype.complete.call(this);
	    };

	    /*********
	     ** SegmentedReq specific methods
	     *********/

	    /**
	     * Set the sort total number of segments to emit
	     *
	     * @param {number}
	     */
	    SegmentedReq.prototype.setMaxSegments = function (maxSegments) {
	      this._maxSegments = Math.max(_.parseInt(maxSegments), 1);
	    };

	    /**
	     * Set the sort direction for the request.
	     *
	     * @param {string} dir - one of 'asc' or 'desc'
	     */
	    SegmentedReq.prototype.setDirection = function (dir) {
	      switch (dir) {
	        case 'asc':
	        case 'desc':
	          return this._direction = dir;
	        default:
	          throw new TypeError('unknown sort direction "' + dir + '"');
	      }
	    };

	    /**
	     * Set the sort total number of documents to
	     * emit
	     *
	     * Setting to false will not limit the documents,
	     * if a number is set the size of the request to es
	     * will be updated on each new request
	     *
	     * @param {number|false}
	     */
	    SegmentedReq.prototype.setSize = function (totalSize) {
	      this._desiredSize = _.parseInt(totalSize) || false;
	    };

	    SegmentedReq.prototype._createQueue = function () {
	      var timeBounds = timefilter.getBounds();
	      var indexPattern = this.source.get('index');
	      var queue = indexPattern.toIndexList(timeBounds.min, timeBounds.max);

	      if (!_.isArray(queue)) queue = [queue];
	      if (this._direction === 'desc') queue = queue.reverse();

	      return this._queue = queue;
	    };

	    SegmentedReq.prototype._reportStatus = function () {
	      return this._handle.emit('status', {
	        total: this._all.length,
	        complete: this._complete.length,
	        remaining: this._queue.length,
	        hitCount: this._mergedResp.hits.hits.length
	      });
	    };

	    SegmentedReq.prototype._getFlattenedSource = function () {
	      return this.source._flatten();
	    };

	    SegmentedReq.prototype._consumeSegment = function (seg) {
	      var index = this._active;
	      this._complete.push(index);
	      if (!seg) return; // segment was ignored/filtered, don't store it

	      var hadHits = _.get(this._mergedResp, 'hits.hits.length') > 0;
	      var gotHits = _.get(seg, 'hits.hits.length') > 0;
	      var firstHits = !hadHits && gotHits;
	      var haveHits = hadHits || gotHits;

	      this._mergeSegment(seg);
	      this.resp = _.omit(this._mergedResp, '_bucketIndex');
	      this._hitsReceived += seg.hits.hits.length;

	      if (firstHits) this._handle.emit('first', seg);
	      if (gotHits) this._handle.emit('segment', seg);
	      if (haveHits) this._handle.emit('mergedSegment', this.resp);
	    };

	    SegmentedReq.prototype._mergeSegment = notify.timed('merge response segment', function (seg) {
	      var merged = this._mergedResp;

	      this._segments.push(seg);

	      merged.took += seg.took;
	      merged.hits.total += seg.hits.total;
	      merged.hits.max_score = Math.max(merged.hits.max_score, seg.hits.max_score);
	      [].push.apply(merged.hits.hits, seg.hits.hits);

	      if (!seg.aggregations) return;

	      _Object$keys(seg.aggregations).forEach(function (aggKey) {

	        if (!merged.aggregations) {
	          // start merging aggregations
	          merged.aggregations = {};
	          merged._bucketIndex = {};
	        }

	        if (!merged.aggregations[aggKey]) {
	          merged.aggregations[aggKey] = {
	            buckets: []
	          };
	        }

	        seg.aggregations[aggKey].buckets.forEach(function (bucket) {
	          var mbucket = merged._bucketIndex[bucket.key];
	          if (mbucket) {
	            mbucket.doc_count += bucket.doc_count;
	            return;
	          }

	          mbucket = merged._bucketIndex[bucket.key] = bucket;
	          merged.aggregations[aggKey].buckets.push(mbucket);
	        });
	      });
	    });

	    return SegmentedReq;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(238);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function CourierSegmentedReqHandle(Private) {
	    var _ = __webpack_require__(192);
	    var Events = Private(__webpack_require__(238));

	    /**
	     * Simple class for creating an object to send to the
	     * requester of a SegmentedRequest. Since the SegmentedRequest
	     * extends AbstractRequest, it wasn't able to be the event
	     * emitter it was born to be. This provides a channel for
	     * setting values on the segmented request, and an event
	     * emitter for the request to speak outwardly
	     *
	     * @param {SegmentedRequest} - req - the requst this handle relates to
	     */
	    _['class'](SegmentedHandle).inherits(Events);
	    function SegmentedHandle(req) {
	      SegmentedHandle.Super.call(this);

	      // export a couple methods from the request
	      this.setDirection = _.bindKey(req, 'setDirection');
	      this.setSize = _.bindKey(req, 'setSize');
	      this.setMaxSegments = _.bindKey(req, 'setMaxSegments');
	    }

	    return SegmentedHandle;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function normalizeSortRequest(config) {
	    var defaultSortOptions = config.get('sort:options');

	    /**
	     * Decorate queries with default parameters
	     * @param {query} query object
	     * @returns {object}
	     */
	    return function (sortObject, indexPattern) {
	      var normalizedSort = [];

	      // [].concat({}) -> [{}], [].concat([{}]) -> [{}]
	      return [].concat(sortObject).map(function (sortable) {
	        return normalize(sortable, indexPattern);
	      });
	    };

	    /*
	      Normalize the sort description to the more verbose format:
	      { someField: "desc" } into { someField: { "order": "desc"}}
	    */
	    function normalize(sortable, indexPattern) {
	      var normalized = {};
	      var sortField = _.keys(sortable)[0];
	      var sortValue = sortable[sortField];
	      var indexField = indexPattern.fields.byName[sortField];

	      if (indexField && indexField.scripted && indexField.sortable) {
	        var direction;
	        if (_.isString(sortValue)) direction = sortValue;
	        if (_.isObject(sortValue) && sortValue.order) direction = sortValue.order;

	        sortField = '_script';
	        sortValue = {
	          script: indexField.script,
	          type: indexField.type,
	          order: direction
	        };
	      } else {
	        if (_.isString(sortValue)) {
	          sortValue = { order: sortValue };
	        }
	        sortValue = _.defaults({}, sortValue, defaultSortOptions);
	      }

	      normalized[sortField] = sortValue;
	      return normalized;
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(534);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function RootSearchSource(Private, $rootScope, timefilter, Notifier) {
	    var SearchSource = Private(__webpack_require__(534));

	    var notify = new Notifier({ location: 'Root Search Source' });

	    var globalSource = new SearchSource();
	    globalSource.inherits(false); // this is the final source, it has no parents
	    globalSource.filter(function (globalSource) {
	      // dynamic time filter will be called in the _flatten phase of things
	      return timefilter.get(globalSource.get('index'));
	    });

	    var appSource; // set in setAppSource()
	    resetAppSource();

	    // when the route changes, clear the appSource
	    $rootScope.$on('$routeChangeStart', resetAppSource);

	    /**
	     * Get the current AppSource
	     * @return {Promise} - resolved with the current AppSource
	     */
	    function getAppSource() {
	      return appSource;
	    }

	    /**
	     * Set the current AppSource
	     * @param {SearchSource} source - The Source that represents the applications "root" search source object
	     */
	    function setAppSource(source) {
	      appSource = source;

	      // walk the parent chain until we get to the global source or nothing
	      // that's where we will attach to the globalSource
	      var literalRoot = source;
	      while (literalRoot._parent && literalRoot._parent !== globalSource) {
	        literalRoot = literalRoot._parent;
	      }

	      literalRoot.inherits(globalSource);
	    }

	    /**
	     * Sets the appSource to be a new, empty, SearchSource
	     * @return {undefined}
	     */
	    function resetAppSource() {
	      setAppSource(new SearchSource());
	    }

	    return {
	      get: getAppSource,
	      set: setAppSource,

	      getGlobalSource: function getGlobalSource() {
	        return globalSource;
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(514);
	__webpack_require__(542);
	__webpack_require__(529);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DocLooperService(Private) {
	    var fetch = Private(__webpack_require__(514));
	    var Looper = Private(__webpack_require__(542));
	    var docStrategy = Private(__webpack_require__(529));

	    /**
	     * The Looper which will manage the doc fetch interval
	     * @type {Looper}
	     */
	    var docLooper = new Looper(1500, function () {
	      fetch.fetchQueued(docStrategy);
	    });

	    return docLooper;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function LooperFactory($timeout, Notifier, Promise) {
	    var _ = __webpack_require__(192);
	    var notify = new Notifier();

	    function Looper(ms, fn) {
	      this._fn = fn;
	      this._ms = ms === void 0 ? 1500 : ms;
	      this._timer = null;
	      this._started = false;

	      this._loopTheLoop = _.bind(this._loopTheLoop, this);
	    }

	    /**
	     * Set the number of milliseconds between
	     * each loop
	     *
	     * @param  {integer} ms
	     * @chainable
	     */
	    Looper.prototype.ms = function (ms) {
	      this._ms = _.parseInt(ms) || 0;

	      if (!this._started) return;

	      if (this._ms) {
	        this.start(false);
	      } else {
	        this._unScheduleLoop();
	      }

	      return this;
	    };

	    /**
	     * Cancels the current looper while keeping internal
	     * state as started
	     *
	     * @chainable
	     */
	    Looper.prototype.pause = function () {
	      this._unScheduleLoop();
	      return this;
	    };

	    /**
	     * Start the looping madness
	     *
	     * @chainable
	     */
	    Looper.prototype.start = function (loopOver) {
	      if (loopOver == null) loopOver = true;

	      if (!this._started) {
	        this._started = true;
	      } else {
	        this._unScheduleLoop();
	      }

	      if (loopOver) {
	        this._loopTheLoop();
	      } else {
	        this._scheduleLoop();
	      }

	      return this;
	    };

	    /**
	     * ...
	     *
	     * @chainable
	     */
	    Looper.prototype.stop = function () {
	      this._unScheduleLoop();
	      this._started = false;
	      return this;
	    };

	    /**
	     * Restart the looper only if it is already started.
	     * Called automatically when ms is changed
	     *
	     * @chainable
	     */
	    Looper.prototype.restart = function () {
	      this.start(false);
	      return this;
	    };

	    /**
	     * Is the looper currently started/running/scheduled/going to execute
	     *
	     * @return {boolean}
	     */
	    Looper.prototype.started = function () {
	      return !!this._started;
	    };

	    /**
	     * Returns the current loop interval
	     *
	     * @return {number}
	     */
	    Looper.prototype.loopInterval = function () {
	      return this._ms;
	    };

	    /**
	     * Called when the loop is executed before the previous
	     * run has completed.
	     *
	     * @override
	     * @return {undefined}
	     */
	    Looper.prototype.onHastyLoop = function () {
	      // override this in subclasses
	    };

	    /**
	     * Wraps this._fn so that this._fn can be changed
	     * without rescheduling and schedules
	     * the next itteration
	     *
	     * @private
	     * @return {undefined}
	     */
	    Looper.prototype._loopTheLoop = function () {
	      var self = this;

	      if (self.active) {
	        self.onHastyLoop();
	        return;
	      }

	      self.active = Promise['try'](this._fn).then(function () {
	        self._scheduleLoop();
	      })['catch'](function (err) {
	        self.stop();
	        notify.fatal(err);
	      })['finally'](function () {
	        self.active = null;
	      });
	    };

	    /**
	     * Schedule the next itteration of the loop
	     *
	     * @private
	     * @return {number} - the timer promise
	     */
	    Looper.prototype._scheduleLoop = function () {
	      this._unScheduleLoop();
	      this._timer = this._ms ? $timeout(this._loopTheLoop, this._ms) : null;
	      return this._timer;
	    };

	    /**
	     * Cancel the next itteration of the loop
	     *
	     * @private
	     * @return {number} - the timer promise
	     */
	    Looper.prototype._unScheduleLoop = function () {
	      if (this._timer) {
	        $timeout.cancel(this._timer);
	        this._timer = null;
	      }
	    };

	    /**
	     * execute the this._fn, and restart the timer
	     */
	    Looper.prototype.run = function () {
	      this.start();
	    };

	    return Looper;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(514);
	__webpack_require__(536);
	__webpack_require__(513);
	__webpack_require__(542);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function SearchLooperService(Private, Promise, Notifier, $rootScope) {
	    var fetch = Private(__webpack_require__(514));
	    var searchStrategy = Private(__webpack_require__(536));
	    var requestQueue = Private(__webpack_require__(513));

	    var Looper = Private(__webpack_require__(542));
	    var notif = new Notifier({ location: 'Search Looper' });

	    /**
	     * The Looper which will manage the doc fetch interval
	     * @type {Looper}
	     */
	    var searchLooper = new Looper(null, function () {
	      $rootScope.$broadcast('courier:searchRefresh');
	      return fetch.these(requestQueue.getInactive(searchStrategy));
	    });

	    searchLooper.onHastyLoop = function () {
	      if (searchLooper.afterHastyQueued) return;

	      searchLooper.afterHastyQueued = Promise.resolve(searchLooper.active).then(function () {
	        return searchLooper._loopTheLoop();
	      })['finally'](function () {
	        searchLooper.afterHastyQueued = null;
	      });
	    };

	    return searchLooper;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(209);
	__webpack_require__(220);
	__webpack_require__(192);
	__webpack_require__(545);
	__webpack_require__(511);
	__webpack_require__(534);
	__webpack_require__(530);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function SavedObjectFactory(es, kbnIndex, Promise, Private, Notifier, safeConfirm, indexPatterns) {
	    var angular = __webpack_require__(209);
	    var errors = __webpack_require__(220);
	    var _ = __webpack_require__(192);
	    var slugifyId = __webpack_require__(545);

	    var DocSource = Private(__webpack_require__(511));
	    var SearchSource = Private(__webpack_require__(534));
	    var mappingSetup = Private(__webpack_require__(530));

	    function SavedObject(config) {
	      if (!_.isObject(config)) config = {};

	      // save an easy reference to this
	      var self = this;

	      /************
	       * Initialize config vars
	       ************/
	      // the doc which is used to store this object
	      var docSource = new DocSource();

	      // type name for this object, used as the ES-type
	      var type = config.type;

	      // Create a notifier for sending alerts
	      var notify = new Notifier({
	        location: 'Saved ' + type
	      });

	      // mapping definition for the fields that this object will expose
	      var mapping = mappingSetup.expandShorthand(config.mapping);

	      // default field values, assigned when the source is loaded
	      var defaults = config.defaults || {};

	      var afterESResp = config.afterESResp || _.noop;
	      var customInit = config.init || _.noop;

	      // optional search source which this object configures
	      self.searchSource = config.searchSource && new SearchSource();

	      // the id of the document
	      self.id = config.id || void 0;
	      self.defaults = config.defaults;

	      /**
	       * Asynchronously initialize this object - will only run
	       * once even if called multiple times.
	       *
	       * @return {Promise}
	       * @resolved {SavedObject}
	       */
	      self.init = _.once(function () {
	        // ensure that the type is defined
	        if (!type) throw new Error('You must define a type name to use SavedObject objects.');

	        // tell the docSource where to find the doc
	        docSource.index(kbnIndex).type(type).id(self.id);

	        // check that the mapping for this type is defined
	        return mappingSetup.isDefined(type).then(function (defined) {
	          // if it is already defined skip this step
	          if (defined) return true;

	          mapping.kibanaSavedObjectMeta = {
	            properties: {
	              // setup the searchSource mapping, even if it is not used but this type yet
	              searchSourceJSON: {
	                type: 'string'
	              }
	            }
	          };

	          // tell mappingSetup to set type
	          return mappingSetup.setup(type, mapping);
	        }).then(function () {
	          // If there is not id, then there is no document to fetch from elasticsearch
	          if (!self.id) {
	            // just assign the defaults and be done
	            _.assign(self, defaults);
	            return hydrateIndexPattern().then(function () {
	              return afterESResp.call(self);
	            });
	          }

	          // fetch the object from ES
	          return docSource.fetch().then(self.applyESResp);
	        }).then(function () {
	          return customInit.call(self);
	        }).then(function () {
	          // return our obj as the result of init()
	          return self;
	        });
	      });

	      self.applyESResp = function (resp) {
	        self._source = _.cloneDeep(resp._source);

	        if (resp.found != null && !resp.found) throw new errors.SavedObjectNotFound(type, self.id);

	        var meta = resp._source.kibanaSavedObjectMeta || {};
	        delete resp._source.kibanaSavedObjectMeta;

	        if (!config.indexPattern && self._source.indexPattern) {
	          config.indexPattern = self._source.indexPattern;
	          delete self._source.indexPattern;
	        }

	        // assign the defaults to the response
	        _.defaults(self._source, defaults);

	        // transform the source using _deserializers
	        _.forOwn(mapping, function ittr(fieldMapping, fieldName) {
	          if (fieldMapping._deserialize) {
	            self._source[fieldName] = fieldMapping._deserialize(self._source[fieldName], resp, fieldName, fieldMapping);
	          }
	        });

	        // Give obj all of the values in _source.fields
	        _.assign(self, self._source);

	        return Promise['try'](function () {
	          parseSearchSource(meta.searchSourceJSON);
	        }).then(hydrateIndexPattern).then(function () {
	          return Promise.cast(afterESResp.call(self, resp));
	        }).then(function () {
	          // Any time obj is updated, re-call applyESResp
	          docSource.onUpdate().then(self.applyESResp, notify.fatal);
	        });
	      };

	      function parseSearchSource(searchSourceJson) {
	        if (!self.searchSource) return;

	        // if we have a searchSource, set its state based on the searchSourceJSON field
	        var state;
	        try {
	          state = JSON.parse(searchSourceJson);
	        } catch (e) {
	          state = {};
	        }

	        var oldState = self.searchSource.toJSON();
	        var fnProps = _.transform(oldState, function (dynamic, val, name) {
	          if (_.isFunction(val)) dynamic[name] = val;
	        }, {});

	        self.searchSource.set(_.defaults(state, fnProps));
	      }

	      /**
	       * After creation or fetching from ES, ensure that the searchSources index indexPattern
	       * is an bonafide IndexPattern object.
	       *
	       * @return {[type]} [description]
	       */
	      function hydrateIndexPattern() {
	        return Promise['try'](function () {
	          if (self.searchSource) {

	            var index = config.indexPattern || self.searchSource.getOwn('index');
	            if (!index) return;
	            if (config.clearSavedIndexPattern) {
	              self.searchSource.set('index', undefined);
	              return;
	            }

	            if (!(index instanceof indexPatterns.IndexPattern)) {
	              index = indexPatterns.get(index);
	            }

	            return Promise.resolve(index).then(function (indexPattern) {
	              self.searchSource.set('index', indexPattern);
	            });
	          }
	        });
	      }

	      /**
	       * Serialize this object
	       *
	       * @return {Object}
	       */
	      self.serialize = function () {
	        var body = {};

	        _.forOwn(mapping, function (fieldMapping, fieldName) {
	          if (self[fieldName] != null) {
	            body[fieldName] = fieldMapping._serialize ? fieldMapping._serialize(self[fieldName]) : self[fieldName];
	          }
	        });

	        if (self.searchSource) {
	          body.kibanaSavedObjectMeta = {
	            searchSourceJSON: angular.toJson(_.omit(self.searchSource.toJSON(), ['sort', 'size']))
	          };
	        }

	        return body;
	      };

	      /**
	       * Save this object
	       *
	       * @return {Promise}
	       * @resolved {String} - The id of the doc
	       */
	      self.save = function () {

	        var body = self.serialize();

	        // Slugify the object id
	        self.id = slugifyId(self.id);

	        // ensure that the docSource has the current self.id
	        docSource.id(self.id);

	        // index the document
	        return self.saveSource(body);
	      };

	      self.saveSource = function (source) {
	        var finish = function finish(id) {
	          self.id = id;
	          return es.indices.refresh({
	            index: kbnIndex
	          }).then(function () {
	            return self.id;
	          });
	        };

	        return docSource.doCreate(source).then(finish)['catch'](function (err) {
	          // record exists, confirm overwriting
	          if (_.get(err, 'origError.status') === 409) {
	            var confirmMessage = 'Are you sure you want to overwrite ' + self.title + '?';

	            return safeConfirm(confirmMessage).then(function () {
	              return docSource.doIndex(source).then(finish);
	            }, _.noop // if the user doesn't overwrite record, just swallow the error
	            );
	          }
	          return Promise.reject(err);
	        });
	      };

	      /**
	       * Destroy this object
	       *
	       * @return {undefined}
	       */
	      self.destroy = function () {
	        docSource.cancelQueued();
	        if (self.searchSource) {
	          self.searchSource.cancelQueued();
	        }
	      };

	      /**
	       * Delete this object from Elasticsearch
	       * @return {promise}
	       */
	      self['delete'] = function () {
	        return es['delete']({
	          index: kbnIndex,
	          type: type,
	          id: this.id
	        }).then(function () {
	          return es.indices.refresh({
	            index: kbnIndex
	          });
	        });
	      };
	    }

	    return SavedObject;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function (id) {
	    if (id == null) return;

	    var trans = {
	      '/': '-slash-',
	      '\\?': '-questionmark-',
	      '\\&': '-ampersand-',
	      '=': '-equal-'
	    };
	    _.each(trans, function (val, key) {
	      var regex = new RegExp(key, 'g');
	      id = id.replace(regex, val);
	    });
	    id = id.replace(/[\s]+/g, '-');
	    id = id.replace(/[\-]+/g, '-');
	    return id;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var errors = __webpack_require__(220);

	  return function RedirectWhenMissingFn($location, kbnUrl, Notifier, Promise) {
	    var SavedObjectNotFound = errors.SavedObjectNotFound;

	    var notify = new Notifier();

	    /**
	     * Creates an error handler that will redirect to a url when a SavedObjectNotFound
	     * error is thrown
	     *
	     * @param  {string|object} mapping - a mapping of url's to redirect to based on the saved object that
	     *                                 couldn't be found, or just a string that will be used for all types
	     * @return {function} - the handler to pass to .catch()
	     */
	    return function (mapping) {
	      if (typeof mapping === 'string') {
	        mapping = { '*': mapping };
	      }

	      return function (err) {
	        // if this error is not "404", rethrow
	        if (!(err instanceof SavedObjectNotFound)) throw err;

	        var url = mapping[err.savedObjectType] || mapping['*'];
	        if (!url) url = '/';

	        url += (url.indexOf('?') >= 0 ? '&' : '?') + ('notFound=' + err.savedObjectType);

	        notify.error(err);
	        kbnUrl.redirect(url);
	        return Promise.halt();
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(254);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var modules = __webpack_require__(214);
	  var urlParam = '_a';

	  function AppStateProvider(Private, $rootScope, getAppState) {
	    var State = Private(__webpack_require__(254));

	    _['class'](AppState).inherits(State);
	    function AppState(defaults) {
	      AppState.Super.call(this, urlParam, defaults);
	      getAppState._set(this);
	    }

	    // if the url param is missing, write it back
	    AppState.prototype._persistAcrossApps = false;

	    AppState.prototype.destroy = function () {
	      AppState.Super.prototype.destroy.call(this);
	      getAppState._set(null);
	    };

	    return AppState;
	  }

	  modules.get('kibana/global_state').factory('AppState', function (Private) {
	    return Private(AppStateProvider);
	  }).service('getAppState', function ($location) {
	    var currentAppState;

	    function get() {
	      return currentAppState;
	    }

	    // Checks to see if the appState might already exist, even if it hasn't been newed up
	    get.previouslyStored = function () {
	      var search = $location.search();
	      return search[urlParam] ? true : false;
	    };

	    get._set = function (current) {
	      currentAppState = current;
	    };

	    return get;
	  });

	  return AppStateProvider;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 548 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"discover\" class=\"app-container\">\n  <navbar>\n    <form role=\"form\" class=\"fill inline-form\" ng-submit=\"fetch()\" name=\"discoverSearch\">\n      <div class=\"typeahead\" kbn-typeahead=\"discover\">\n        <div class=\"input-group\"\n          ng-class=\"discoverSearch.$invalid ? 'has-error' : ''\">\n          <input validate-query=\"searchSource\"\n            input-focus\n            kbn-typeahead-input\n            ng-model=\"state.query\"\n            placeholder=\"Search...\"\n            aria-label=\"Search input\"\n            type=\"text\"\n            class=\"form-control\">\n          <button type=\"submit\"\n            ng-disabled=\"discoverSearch.$invalid\"\n            aria-label=\"Search\">\n            <span aria-hidden=\"true\" class=\"fa fa-search\"></span></button>\n          <!--<button type=\"button\" ng-click=\"resetQuery()\" aria-label=\"Reset query\"><span aria-hidden=\"true\" class=\"fa fa-ban\"></span></button>-->\n        </div>\n        <kbn-typeahead-items></kbn-typeahead-items>\n      </div>\n    </form>\n\n    <div class=\"button-group\" role=\"toolbar\">\n      <kbn-tooltip text=\"New Search\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          ng-click=\"newQuery()\"\n          aria-label=\"New Search\">\n          <i aria-hidden=\"true\" class=\"fa fa-file-new-o\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Save Search\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          ng-click=\"configTemplate.toggle('save');\"\n          ng-class=\"{active: configTemplate.is('save')}\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('save') }}\"\n          aria-label=\"Save Search\">\n          <i aria-hidden=\"true\" class=\"fa fa-save\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Load Saved Search\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('load') }}\"\n          ng-click=\"configTemplate.toggle('load');\"\n          ng-class=\"{active: configTemplate.is('load')}\"\n          aria-label=\"Load Saved Search\">\n          <i aria-hidden=\"true\" class=\"fa fa-folder-open-o\"></i>\n        </button>\n      </kbn-tooltip>\n    </div>\n  </navbar>\n\n  <config config-template=\"configTemplate\" config-object=\"opts\" config-close=\"configClose\"></config>\n\n  <div class=\"container-fluid\" role=\"main\">\n    <div class=\"row\">\n      <filter-bar state=\"state\"></filter-bar>\n    </div>\n    <div class=\"row\">\n      <div class=\"col-md-2 sidebar-container collapsible-sidebar\">\n        <disc-field-chooser\n          columns=\"state.columns\"\n          refresh=\"refreshFieldList\"\n          hits=\"rows\"\n          field-counts=\"fieldCounts\"\n          filter=\"filterQuery\"\n          index-pattern=\"searchSource.get('index')\"\n          index-pattern-list=\"opts.indexPatternList\"\n          state=\"state\">\n        </disc-field-chooser>\n      </div>\n\n      <div class=\"discover-wrapper col-md-10\">\n\n        <div class=\"discover-info\">\n          <span ng-show=\"opts.savedSearch.id\" class=\"discover-info-title\">\n            <span bindonce bo-bind=\"opts.savedSearch.title\"></span>\n            <i aria-label=\"Reload Saved Search\" tooltip=\"Reload Saved Search\" ng-click=\"resetQuery();\" class=\"fa fa-undo small\"></i>\n          </span>\n\n          <strong class=\"discover-info-hits\">{{(hits || 0) | number:0}}</strong>\n          <ng-pluralize count=\"hits\" when=\"{'1':'hit', 'other':'hits'}\"></ng-pluralize>\n        </div>\n\n        <div class=\"discover-content\">\n          <!-- no results -->\n          <div ng-show=\"resultState === 'none'\">\n              <div class=\"col-md-10 col-md-offset-1\">\n\n                <h1>No results found <i aria-hidden=\"true\" class=\"fa fa-meh-o\"></i></h1>\n\n                <p>\n                  Unfortunately I could not find any results matching your search. I tried really hard. I looked all over the place and frankly, I just couldn't find anything good. Help me, help you. Here's some ideas:\n                </p>\n\n                <div class=\"shard-failures\" ng-show=\"failures\">\n                  <h3>Shard Failures</h3>\n                  <p>The following shard failures ocurred:</p>\n                  <ul>\n                    <li ng-repeat=\"failure in failures | limitTo: failuresShown\"><strong>Index:</strong> {{failure.index}} <strong>Shard:</strong> {{failure.shard}} <strong>Reason:</strong> {{failure.reason}} </li>\n                  </ul>\n                  <a ng-click=\"showAllFailures()\" ng-if=\"failures.length > failuresShown\" title=\"Show More\">Show More</a>\n                  <a ng-click=\"showLessFailures()\" ng-if=\"failures.length === failuresShown && failures.length > 5\" title=\"Show Less\">Show Less</a>\n                </div>\n\n                <div ng-show=\"opts.timefield\">\n                  <p>\n                    <h3>Expand your time range</h3>\n                    <p>I see you are looking at an index with a date field. It is possible your query does not match anything in the current time range, or that there is no data at all in the currently selected time range. Click the button below to open the time picker. For future reference you can open the time picker by clicking the <a class=\"btn btn-xs navbtn\" ng-click=\"toggleTimepicker(); toggledTimepicker = !toggledTimepicker\" aria-expanded=\"{{toggledTimepicker}}\" aria-label=\"time picker\">time picker <i aria-hidden=\"true\" class=\"fa fa-clock-o\"></i></a> in the top right corner of your screen.\n                  </p>\n                </div>\n\n                <h3>Refine your query</h3>\n                <p>\n                  The search bar at the top uses Elasticsearch's support for Lucene <a href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax\" target=\"_blank\">Query String syntax</a>. Let's say we're searching web server logs that have been parsed into a few fields.\n                </p>\n\n                <p>\n                  <h4>Examples:</h4>\n                  Find requests that contain the number 200, in any field:\n                  <pre>200</pre>\n\n                  Or we can search in a specific field. Find 200 in the status field:\n                  <pre>status:200</pre>\n\n                  Find all status codes between 400-499:\n                  <pre>status:[400 TO 499]</pre>\n\n                  Find status codes 400-499 with the extension php:\n                  <pre>status:[400 TO 499] AND extension:PHP</pre>\n\n                  Or HTML\n                  <pre>status:[400 TO 499] AND (extension:php OR extension:html)</pre>\n                </p>\n\n              </div>\n          </div>\n\n          <!-- loading -->\n          <div ng-show=\"resultState === 'loading'\">\n            <div class=\"discover-overlay\">\n              <h2>Searching</h2>\n              <div class=\"spinner large\"></div>\n              <div ng-show=\"fetchStatus\">{{fetchStatus.complete}}/{{fetchStatus.total}}</div>\n            </div>\n          </div>\n\n          <!-- result -->\n          <div class=\"results\" ng-show=\"resultState === 'ready'\">\n            <div class=\"discover-timechart\" ng-if=\"opts.timefield\">\n              <header>\n                <center class=\"small\">\n                  <span tooltip=\"To change the time, click the clock icon in the navigation bar\">{{timeRange.from | moment}} - {{timeRange.to | moment}}</span>\n\n                  &mdash;\n\n                  <span class=\"results-interval\" ng-hide=\"showInterval\">\n                    <a\n                      ng-click=\"toggleInterval()\">\n                      {{ intervalName }}\n                    </a>\n                  </span>\n\n                  <span ng-show=\"showInterval\" class=\"results-interval form-inline\">\n                    <select\n                      class=\"form-control\"\n                      ng-model=\"state.interval\"\n                      ng-options=\"interval.val as interval.display for interval in intervalOptions | filter: intervalEnabled\"\n                      >\n                    </select>\n                  </span>\n                </center>\n\n              </header>\n\n              <visualize ng-if=\"vis && rows.length != 0\" vis=\"vis\" es-resp=\"mergedEsResp\" search-source=\"searchSource\"></visualize>\n            </div>\n\n            <div class=\"discover-table\" fixed-scroll>\n              <doc-table\n                hits=\"rows\"\n                index-pattern=\"indexPattern\"\n                sorting=\"state.sort\"\n                columns=\"state.columns\"\n                infinite-scroll=\"true\"\n                filter=\"filterQuery\">\n              </doc-table>\n\n              <div ng-if=\"rows.length == opts.sampleSize\" class=\"discover-table-footer\">\n                <center>\n                  These are the first {{opts.sampleSize}} documents matching\n                  your search, refine your search to see others.\n                  <a ng-click=\"toTop()\" title=\"Back to top\">Back to top.</a>\n                </center>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(550);
	__webpack_require__(479);
	__webpack_require__(648);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function VisFactory(Notifier, Private) {
	    var _ = __webpack_require__(192);
	    var aggTypes = Private(__webpack_require__(550));
	    var visTypes = Private(__webpack_require__(479));
	    var AggConfigs = Private(__webpack_require__(648));

	    var notify = new Notifier({
	      location: 'Vis'
	    });

	    function Vis(indexPattern, state) {
	      state = state || {};

	      if (_.isString(state)) {
	        state = {
	          type: state
	        };
	      }

	      this.indexPattern = indexPattern;

	      // http://aphyr.com/data/posts/317/state.gif
	      this.setState(state);
	    }

	    Vis.convertOldState = function (type, oldState) {
	      if (!type || _.isString(type)) {
	        type = visTypes.byName[type || 'histogram'];
	      }

	      var schemas = type.schemas;

	      var aggs = _.transform(oldState, function (newConfigs, oldConfigs, oldGroupName) {
	        var schema = schemas.all.byName[oldGroupName];

	        if (!schema) {
	          notify.log('unable to match old schema', oldGroupName, 'to a new schema');
	          return;
	        }

	        oldConfigs.forEach(function (oldConfig) {
	          var agg = {
	            schema: schema.name,
	            type: oldConfig.agg
	          };

	          var aggType = aggTypes.byName[agg.type];
	          if (!aggType) {
	            notify.log('unable to find an agg type for old confg', oldConfig);
	            return;
	          }

	          agg.params = _.pick(oldConfig, _.keys(aggType.params.byName));

	          newConfigs.push(agg);
	        });
	      }, []);

	      return {
	        type: type,
	        aggs: aggs
	      };
	    };

	    Vis.prototype.type = 'histogram';

	    Vis.prototype.setState = function (state) {
	      this.type = state.type || this.type;
	      if (_.isString(this.type)) this.type = visTypes.byName[this.type];

	      this.listeners = _.assign({}, state.listeners, this.type.listeners);
	      this.params = _.defaults({}, _.cloneDeep(state.params || {}), _.cloneDeep(this.type.params.defaults || {}));

	      this.aggs = new AggConfigs(this, state.aggs);
	    };

	    Vis.prototype.getState = function () {
	      return {
	        type: this.type.name,
	        params: this.params,
	        aggs: this.aggs.map(function (agg) {
	          return agg.toJSON();
	        }).filter(Boolean),
	        listeners: this.listeners
	      };
	    };

	    Vis.prototype.createEditableVis = function () {
	      return this._editableVis || (this._editableVis = this.clone());
	    };

	    Vis.prototype.getEditableVis = function () {
	      return this._editableVis || undefined;
	    };

	    Vis.prototype.clone = function () {
	      return new Vis(this.indexPattern, this.getState());
	    };

	    Vis.prototype.requesting = function () {
	      _.invoke(this.aggs.getRequestAggs(), 'requesting');
	    };

	    Vis.prototype.isHierarchical = function () {
	      if (_.isFunction(this.type.hierarchicalData)) {
	        return !!this.type.hierarchicalData(this);
	      } else {
	        return !!this.type.hierarchicalData;
	      }
	    };

	    Vis.prototype.hasSchemaAgg = function (schemaName, aggTypeName) {
	      var aggs = this.aggs.bySchemaName[schemaName] || [];
	      return aggs.some(function (agg) {
	        if (!agg.type || !agg.type.name) return false;
	        return agg.type.name === aggTypeName;
	      });
	    };

	    return Vis;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(441);
	__webpack_require__(551);
	__webpack_require__(566);
	__webpack_require__(567);
	__webpack_require__(568);
	__webpack_require__(578);
	__webpack_require__(579);
	__webpack_require__(580);
	__webpack_require__(581);
	__webpack_require__(570);
	__webpack_require__(582);
	__webpack_require__(584);
	__webpack_require__(599);
	__webpack_require__(603);
	__webpack_require__(619);
	__webpack_require__(624);
	__webpack_require__(631);
	__webpack_require__(641);
	__webpack_require__(645);
	__webpack_require__(646);
	__webpack_require__(554);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeService(Private) {
	    var IndexedArray = __webpack_require__(441);

	    var aggs = {
	      metrics: [Private(__webpack_require__(551)), Private(__webpack_require__(566)), Private(__webpack_require__(567)), Private(__webpack_require__(568)), Private(__webpack_require__(578)), Private(__webpack_require__(579)), Private(__webpack_require__(580)), Private(__webpack_require__(581)), Private(__webpack_require__(570)), Private(__webpack_require__(582))],
	      buckets: [Private(__webpack_require__(584)), Private(__webpack_require__(599)), Private(__webpack_require__(603)), Private(__webpack_require__(619)), Private(__webpack_require__(624)), Private(__webpack_require__(631)), Private(__webpack_require__(641)), Private(__webpack_require__(645)), Private(__webpack_require__(646))]
	    };

	    _Object$keys(aggs).forEach(function (type) {
	      aggs[type].forEach(function (agg) {
	        agg.type = type;
	      });
	    });

	    /**
	     * IndexedArray of Aggregation Types.
	     *
	     * These types form two groups, metric and buckets.
	     *
	     * @module agg_types
	     * @type {IndexedArray}
	     */
	    return new IndexedArray({

	      /**
	       * @type {Array}
	       */
	      index: ['name'],

	      /**
	       * [group description]
	       * @type {Array}
	       */
	      group: ['type'],
	      initialSet: aggs.metrics.concat(aggs.buckets)
	    });
	  };

	  // preload
	  __webpack_require__(554);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(552);
	__webpack_require__(443);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricCountProvider(Private) {
	    var MetricAggType = Private(__webpack_require__(552));
	    var fieldFormats = Private(__webpack_require__(443));

	    return new MetricAggType({
	      name: 'count',
	      title: 'Count',
	      hasNoDsl: true,
	      makeLabel: function makeLabel() {
	        return 'Count';
	      },
	      getFormat: function getFormat() {
	        return fieldFormats.getDefaultInstance('number');
	      },
	      getValue: function getValue(agg, bucket) {
	        return bucket.doc_count;
	      }
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(553);
	__webpack_require__(443);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function MetricAggTypeProvider(Private) {
	    var _ = __webpack_require__(192);
	    var AggType = Private(__webpack_require__(553));
	    var fieldFormats = Private(__webpack_require__(443));

	    _['class'](MetricAggType).inherits(AggType);
	    function MetricAggType(config) {
	      MetricAggType.Super.call(this, config);

	      // allow overriding any value on the prototype
	      _.forOwn(config, function (val, key) {
	        if (_.has(MetricAggType.prototype, key)) {
	          this[key] = val;
	        }
	      }, this);
	    }

	    /**
	     * Read the values for this metric from the
	     * @param  {[type]} bucket [description]
	     * @return {[type]}        [description]
	     */
	    MetricAggType.prototype.getValue = function (agg, bucket) {
	      return bucket[agg.id].value;
	    };

	    /**
	     * Pick a format for the values produced by this agg type,
	     * overriden by several metrics that always output a simple
	     * number
	     *
	     * @param  {agg} agg - the agg to pick a format for
	     * @return {FieldFromat}
	     */
	    MetricAggType.prototype.getFormat = function (agg) {
	      var field = agg.field();
	      return field ? field.format : fieldFormats.getDefaultInstance('number');
	    };

	    return MetricAggType;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(554);
	__webpack_require__(443);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeFactory(Private) {
	    var _ = __webpack_require__(192);
	    var AggParams = Private(__webpack_require__(554));
	    var fieldFormats = Private(__webpack_require__(443));

	    /**
	     * Generic AggType Constructor
	     *
	     * Used to create the values exposed by the agg_types module.
	     *
	     * @class AggType
	     * @private
	     * @param {object} config - used to set the properties of the AggType
	     */
	    function AggType(config) {

	      /**
	       * the unique, unchanging, name that we have assigned this aggType
	       *
	       * @property name
	       * @type {string}
	       */
	      this.name = config.name;

	      /**
	       * the name of the elasticsearch aggregation that this aggType represents. Usually just this.name
	       *
	       * @property name
	       * @type {string}
	       */
	      this.dslName = config.dslName || config.name;

	      /**
	       * the user friendly name that will be shown in the ui for this aggType
	       *
	       * @property title
	       * @type {string}
	       */
	      this.title = config.title;

	      /**
	       * a function that will be called when this aggType is assigned to
	       * an aggConfig, and that aggConfig is being rendered (in a form, chart, etc.).
	       *
	       * @method makeLabel
	       * @param {AggConfig} aggConfig - an agg config of this type
	       * @returns {string} - label that can be used in the ui to descripe the aggConfig
	       */
	      this.makeLabel = config.makeLabel || _.constant(this.name);

	      /**
	       * Describes if this aggType creates data that is ordered, and if that ordered data
	       * is some sort of time series.
	       *
	       * If the aggType does not create ordered data, set this to something "falsey".
	       *
	       * If this does create orderedData, then the value should be an object.
	       *
	       * If the orderdata is some sort of time series, `this.ordered` should be an object
	       * with the property `date: true`
	       *
	       * @property ordered
	       * @type {object|undefined}
	       */
	      this.ordered = config.ordered;

	      /**
	       * Flag that prevents this aggregation from being included in the dsl. This is only
	       * used by the count aggregation (currently) since it doesn't really exist and it's output
	       * is available on every bucket.
	       *
	       * @type {Boolean}
	       */
	      this.hasNoDsl = !!config.hasNoDsl;

	      /**
	       * The method to create a filter representation of the bucket
	       * @param {object} aggConfig The instance of the aggConfig
	       * @param {mixed} key The key for the bucket
	       * @returns {object} The filter
	       */
	      this.createFilter = config.createFilter;

	      /**
	       * An instance of {{#crossLink "AggParams"}}{{/crossLink}}.
	       *
	       * @property params
	       * @type {AggParams}
	       */
	      this.params = config.params || [];
	      if (!(this.params instanceof AggParams)) {
	        // always append the raw JSON param
	        this.params.push({
	          name: 'json',
	          type: 'json',
	          advanced: true
	        });

	        this.params = new AggParams(this.params);
	      }

	      /**
	       * Designed for multi-value metric aggs, this method can return a
	       * set of AggConfigs that should replace this aggConfig in result sets
	       * that walk the AggConfig set.
	       *
	       * @method getResponseAggs
	       * @returns {array[AggConfig]|undefined} - an array of aggConfig objects
	       *                                         that should replace this one,
	       *                                         or undefined
	       */
	      this.getResponseAggs = config.getResponseAggs || _.noop;

	      /**
	       * A function that will be called each time an aggConfig of this type
	       * is created, giving the agg type a chance to modify the agg config
	       */
	      this.decorateAggConfig = config.decorateAggConfig || null;

	      if (config.getFormat) {
	        this.getFormat = config.getFormat;
	      }
	    }

	    /**
	     * Pick a format for the values produced by this agg type,
	     * overriden by several metrics that always output a simple
	     * number
	     *
	     * @param  {agg} agg - the agg to pick a format for
	     * @return {FieldFromat}
	     */
	    AggType.prototype.getFormat = function (agg) {
	      var field = agg.field();
	      return field ? field.format : fieldFormats.getDefaultInstance('string');
	    };

	    return AggType;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(555);
	__webpack_require__(192);
	__webpack_require__(441);
	__webpack_require__(556);
	__webpack_require__(559);
	__webpack_require__(560);
	__webpack_require__(562);
	__webpack_require__(564);
	__webpack_require__(558);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggParamsFactory(Private) {
	    __webpack_require__(555);

	    var _ = __webpack_require__(192);
	    var IndexedArray = __webpack_require__(441);

	    var paramTypeMap = {
	      field: Private(__webpack_require__(556)),
	      optioned: Private(__webpack_require__(559)),
	      regex: Private(__webpack_require__(560)),
	      string: Private(__webpack_require__(562)),
	      json: Private(__webpack_require__(564)),
	      _default: Private(__webpack_require__(558))
	    };

	    /**
	     * Wraps a list of {{#crossLink "AggParam"}}{{/crossLink}} objects; owned by an {{#crossLink "AggType"}}{{/crossLink}}
	     *
	     * used to create:
	     *   - `FieldAggParam`  When the config has `name: "field"`
	     *   - `*AggParam`  When the type matches something in the map above
	     *   - `BaseAggParam`  All other params
	     *
	     * @class AggParams
	     * @constructor
	     * @extends IndexedArray
	     * @param {object[]} params - array of params that get new-ed up as AggParam objects as descibed above
	     */
	    _['class'](AggParams).inherits(IndexedArray);
	    function AggParams(params) {
	      AggParams.Super.call(this, {
	        index: ['name'],
	        initialSet: params.map(function (config) {
	          var type = config.name === 'field' ? config.name : config.type;
	          var Class = paramTypeMap[type] || paramTypeMap._default;
	          return new Class(config);
	        })
	      });
	    }

	    /**
	     * Reads an aggConfigs
	     *
	     * @method write
	     * @param  {AggConfig} aggConfig
	     *         the AggConfig object who's type owns these aggParams and contains the param values for our param defs
	     * @param  {object} [locals]
	     *         an array of locals that will be available to the write function (can be used to enhance
	     *         the quality of things like date_histogram's "auto" interval)
	     * @return {object} output
	     *         output of the write calls, reduced into a single object. A `params: {}` property is exposed on the
	     *         output object which is used to create the agg dsl for the search request. All other properties
	     *         are dependent on the AggParam#write methods which should be studied for each AggType.
	     */
	    AggParams.prototype.write = function (aggConfig, locals) {
	      var output = { params: {} };
	      locals = locals || {};

	      this.forEach(function (param) {
	        if (param.write) {
	          param.write(aggConfig, output, locals);
	        } else {
	          output.params[param.name] = aggConfig.params[param.name];
	        }
	      });

	      return output;
	    };

	    return AggParams;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana').filter('label', function () {
	    return function (str) {
	      var words = str.split(' ');
	      return words.map(capFirst).join(' ');
	    };
	  });

	  function capFirst(str) {
	    var i = str[0];
	    var r = new RegExp(i, 'i');
	    return str.replace(r, i.toUpperCase());
	  }
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(557);
	__webpack_require__(558);
	__webpack_require__(220);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FieldAggParamFactory(Private) {
	    var _ = __webpack_require__(192);

	    var editorHtml = __webpack_require__(557);
	    var BaseAggParam = Private(__webpack_require__(558));
	    var SavedObjectNotFound = __webpack_require__(220).SavedObjectNotFound;

	    _['class'](FieldAggParam).inherits(BaseAggParam);
	    function FieldAggParam(config) {
	      FieldAggParam.Super.call(this, config);
	    }

	    FieldAggParam.prototype.editor = editorHtml;
	    FieldAggParam.prototype.scriptable = false;
	    FieldAggParam.prototype.filterFieldTypes = '*';

	    /**
	     * Called to serialize values for saving an aggConfig object
	     *
	     * @param  {field} field - the field that was selected
	     * @return {string}
	     */
	    FieldAggParam.prototype.serialize = function (field) {
	      return field.name;
	    };

	    /**
	     * Called to read values from a database record into the
	     * aggConfig object
	     *
	     * @param  {string} fieldName
	     * @return {field}
	     */
	    FieldAggParam.prototype.deserialize = function (fieldName, aggConfig) {
	      var field = aggConfig.vis.indexPattern.fields.byName[fieldName];

	      if (!field) {
	        throw new SavedObjectNotFound('index-pattern-field', fieldName);
	      }

	      return field;
	    };

	    /**
	     * Write the aggregation parameter.
	     *
	     * @param  {AggConfig} aggConfig - the entire configuration for this agg
	     * @param  {object} output - the result of calling write on all of the aggregations
	     *                         parameters.
	     * @param  {object} output.params - the final object that will be included as the params
	     *                               for the agg
	     * @return {undefined}
	     */
	    FieldAggParam.prototype.write = function (aggConfig, output) {
	      var field = aggConfig.params.field;

	      if (field.scripted) {
	        output.params.script = field.script;
	        output.params.lang = field.lang;
	      } else {
	        output.params.field = field.name;
	      }
	    };

	    return FieldAggParam;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 557 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label for=\"field\">\n    Field\n  </label>\n\n  <span class=\"pull-right text-warning hintbox-label\" ng-show=\"agg.params.field.analyzed\"\n      ng-click=\"showAnalyzedFieldWarning = !showAnalyzedFieldWarning\">\n    <i class=\"fa fa-warning\"></i> Analyzed Field\n  </span>\n  <div class=\"hintbox\" ng-show=\"showAnalyzedFieldWarning && agg.params.field.analyzed\">\n    <p>\n    <strong>Careful!</strong> The field selected contains analyzed strings. Analyzed strings are highly unique and can use a lot of memory to visualize. Values such as <i>foo-bar</i> will be broken into <i>foo</i> and <i>bar</i>. See <a href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-core-types.html\" target=\"_blank\">Mapping Core Types</a> for more information on setting this field as <i>not_analyzed</i>\n    </p>\n\n    <p ng-show=\"indexedFields.byName[agg.params.field.name + '.raw'].analyzed == false\">\n      <strong>Tip:</strong> <i>{{agg.params.field.name + '.raw'}}</i> may be a <i>not_analyzed</i> version of this field.\n    </p>\n  </div>\n\n  <select\n    class=\"form-control\"\n    name=\"field\"\n    required\n    ng-model=\"agg.params.field\"\n    ng-show=\"indexedFields.length\"\n    auto-select-if-only-one=\"indexedFields\"\n    ng-options=\"field as field.displayName group by field.type for field in indexedFields\"\n    ng-change=\"aggParam.onChange(agg)\">\n  </select>\n\n  <div class=\"hintbox\" ng-if=\"!indexedFields.length\">\n    <p>\n      <i class=\"fa fa-danger text-danger\"></i>\n      <strong>No Compatible Fields:</strong> The \"{{ vis.indexPattern.id }}\" index pattern does not contain any of the following field types: {{ agg.type.params.byName.field.filterFieldTypes | commaList:false }}\n    </p>\n  </div>\n\n</div>\n"

/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function BaseAggParamFactory() {
	    var _ = __webpack_require__(192);

	    function BaseAggParam(config) {
	      _.assign(this, config);
	    }

	    return BaseAggParam;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(441);
	__webpack_require__(558);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function OptionedAggParamFactory(Private) {
	    var _ = __webpack_require__(192);

	    var IndexedArray = __webpack_require__(441);
	    var BaseAggParam = Private(__webpack_require__(558));

	    _['class'](OptionedAggParam).inherits(BaseAggParam);
	    function OptionedAggParam(config) {
	      OptionedAggParam.Super.call(this, config);

	      this.options = new IndexedArray({
	        index: ['val'],
	        immutable: true,
	        initialSet: this.options
	      });
	    }

	    /**
	     * Serialize a selection to be stored in the database
	     * @param  {object} selected - the option that was selected
	     * @return {any}
	     */
	    OptionedAggParam.prototype.serialize = function (selected) {
	      return selected.val;
	    };

	    /**
	     * Take a value that was serialized to the database and
	     * return the option that is represents
	     *
	     * @param  {any} val - the value that was saved
	     * @return {object}
	     */
	    OptionedAggParam.prototype.deserialize = function (val) {
	      return this.options.byVal[val];
	    };

	    /**
	     * Write the aggregation parameter.
	     *
	     * @param  {AggConfig} aggConfig - the entire configuration for this agg
	     * @param  {object} output - the result of calling write on all of the aggregations
	     *                         parameters.
	     * @param  {object} output.params - the final object that will be included as the params
	     *                               for the agg
	     * @return {undefined}
	     */
	    OptionedAggParam.prototype.write = function (aggConfig, output) {
	      output.params[this.name] = aggConfig.params[this.name].val;
	    };

	    return OptionedAggParam;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(558);
	__webpack_require__(561);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function RegexAggParamFactory(Private) {
	    var _ = __webpack_require__(192);

	    var BaseAggParam = Private(__webpack_require__(558));
	    var editorHtml = __webpack_require__(561);

	    _['class'](RegexAggParam).inherits(BaseAggParam);
	    function RegexAggParam(config) {
	      // Java RegExp flags
	      var flags = ['CANON_EQ', 'CASE_INSENSITIVE', 'COMMENTS', 'DOTALL', 'LITERAL', 'MULTILINE', 'UNICODE_CASE', 'UNICODE_CHARACTER_CLASS', 'UNIX_LINES'];

	      _.defaults(config, { pattern: '', flags: flags });
	      RegexAggParam.Super.call(this, config);
	    }

	    RegexAggParam.prototype.editor = editorHtml;

	    /**
	     * Disabled state of the agg param
	     *
	     * @return {bool}
	     */
	    RegexAggParam.prototype.disabled = function (aggConfig) {
	      return false;
	    };

	    /**
	     * Write the aggregation parameter.
	     *
	     * @param  {AggConfig} aggConfig - the entire configuration for this agg
	     * @param  {object} output - the result of calling write on all of the aggregations
	     *                         parameters.
	     * @param  {object} output.params - the final object that will be included as the params
	     *                               for the agg
	     * @return {undefined}
	     */
	    RegexAggParam.prototype.write = function (aggConfig, output) {
	      var param = aggConfig.params[this.name];
	      var paramType = aggConfig.type.params.byName[this.name];

	      // clear aggParam if pattern is not set or is disabled
	      if (!param || !param.pattern || !param.pattern.length || paramType.disabled(aggConfig)) {
	        return;
	      }

	      var obj = {
	        pattern: param.pattern
	      };

	      // include any selected flags
	      if (_.isArray(param.flags) && param.flags.length) {
	        obj.flags = param.flags.join('|');
	      }

	      output.params[this.name] = obj;
	    };

	    return RegexAggParam;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 561 */
/***/ function(module, exports) {

	module.exports = "<div ng-if=\"!aggParam.disabled(agg)\">\n  <div class=\"form-group regex\">\n    <label>{{ aggParam.name | label }} Pattern</label>\n    <input\n      type=\"text\"\n      class=\"form-control\"\n      ng-model=\"agg.params[aggParam.name].pattern\"\n    >\n  </div>\n  <div class=\"form-group regex\">\n    <div class=\"flags\">\n      <label>\n        {{ aggParam.name | label }} Pattern Flags\n        <small>(<a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#field_detail\"\n          target=\"_blank\">reference</a>)</small>\n      </label>\n\n      <select\n        multiple=\"multiple\"\n        ng-options=\"label for label in aggParam.flags\"\n        ng-model=\"agg.params[aggParam.name].flags\">\n      </select>\n\n    </div>\n  </div>\n</div>"

/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(563);
	__webpack_require__(558);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FieldAggParamFactory(Private) {
	    var _ = __webpack_require__(192);

	    var editorHtml = __webpack_require__(563);
	    var BaseAggParam = Private(__webpack_require__(558));

	    _['class'](ScriptAggParam).inherits(BaseAggParam);
	    function ScriptAggParam(config) {
	      ScriptAggParam.Super.call(this, config);
	    }

	    ScriptAggParam.prototype.editor = editorHtml;

	    /**
	     * Write the aggregation parameter.
	     *
	     * @param  {AggConfig} aggConfig - the entire configuration for this agg
	     * @param  {object} output - the result of calling write on all of the aggregations
	     *                         parameters.
	     * @param  {object} output.params - the final object that will be included as the params
	     *                               for the agg
	     * @return {undefined}
	     */
	    ScriptAggParam.prototype.write = function (aggConfig, output) {
	      if (aggConfig.params[this.name] && aggConfig.params[this.name].length) {
	        output.params[this.name] = aggConfig.params[this.name];
	      }
	    };

	    return ScriptAggParam;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 563 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>{{ aggParam.name | label }}</label>\n  <div>\n    <input type=\"text\" ng-model=\"agg.params[aggParam.name]\" class=\"form-control\">\n  </div>\n</div>"

/***/ },
/* 564 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(558);
	__webpack_require__(565);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function RawJSONAggParamFactory(Private) {
	    var _ = __webpack_require__(192);

	    var BaseAggParam = Private(__webpack_require__(558));
	    var editorHtml = __webpack_require__(565);

	    _['class'](RawJSONAggParam).inherits(BaseAggParam);
	    function RawJSONAggParam(config) {
	      // force name override
	      config = _.defaults(config, { name: 'json' });
	      RawJSONAggParam.Super.call(this, config);
	    }

	    RawJSONAggParam.prototype.editor = editorHtml;

	    /**
	     * Write the aggregation parameter.
	     *
	     * @param  {AggConfig} aggConfig - the entire configuration for this agg
	     * @param  {object} output - the result of calling write on all of the aggregations
	     *                         parameters.
	     * @param  {object} output.params - the final object that will be included as the params
	     *                               for the agg
	     * @return {undefined}
	     */
	    RawJSONAggParam.prototype.write = function (aggConfig, output) {
	      var paramJSON;
	      var param = aggConfig.params[this.name];

	      if (!param) {
	        return;
	      }

	      // handle invalid JSON input
	      try {
	        paramJSON = JSON.parse(param);
	      } catch (err) {
	        return;
	      }

	      function filteredCombine(srcA, srcB) {
	        function mergeObjs(a, b) {
	          return _(a).keys().union(_.keys(b)).transform(function (dest, key) {
	            var val = compare(a[key], b[key]);
	            if (val !== undefined) dest[key] = val;
	          }, {}).value();
	        }

	        function mergeArrays(a, b) {
	          // attempt to merge each value
	          return _.times(Math.max(a.length, b.length), function (i) {
	            return compare(a[i], b[i]);
	          });
	        }

	        function compare(a, b) {
	          if (_.isPlainObject(a) && _.isPlainObject(b)) return mergeObjs(a, b);
	          if (_.isArray(a) && _.isArray(b)) return mergeArrays(a, b);
	          if (b === null) return undefined;
	          if (b !== undefined) return b;
	          return a;
	        }

	        return compare(srcA, srcB);
	      }

	      output.params = filteredCombine(output.params, paramJSON);
	      return;
	    };

	    return RawJSONAggParam;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 565 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group regex\">\n    <span class=\"hintbox-label\" ng-click=\"showJsonHint = !showJsonHint\">\n      <label>JSON Input</label>\n      <i class=\"fa fa-info-circle\"></i>\n    </span>\n    <div class=\"hintbox\" ng-show=\"showJsonHint\">\n      <p>\n        Any JSON formatted properties you add here will be merged with the elasticsearch aggregation definition for this section. For example <i>shard_size</i> on a <i>terms</i> aggregation\n      </p>\n    </div>\n  <p>\n    <textarea\n      type=\"text\"\n      class=\"form-control\"\n      ng-model=\"agg.params.json\"\n      validate-json\n      ></textarea>\n  </p>\n</div>\n"

/***/ },
/* 566 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(552);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricAvgProvider(Private) {
	    var MetricAggType = Private(__webpack_require__(552));

	    return new MetricAggType({
	      name: 'avg',
	      title: 'Average',
	      makeLabel: function makeLabel(aggConfig) {
	        return 'Average ' + aggConfig.params.field.displayName;
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number'
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 567 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(552);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricSumProvider(Private) {
	    var MetricAggType = Private(__webpack_require__(552));

	    return new MetricAggType({
	      name: 'sum',
	      title: 'Sum',
	      makeLabel: function makeLabel(aggConfig) {
	        return 'Sum of ' + aggConfig.params.field.displayName;
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number'
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 568 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(552);
	__webpack_require__(569);
	__webpack_require__(570);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricMaxProvider(Private) {
	    var _ = __webpack_require__(192);
	    var MetricAggType = Private(__webpack_require__(552));
	    var getResponseAggConfigClass = Private(__webpack_require__(569));
	    var percentiles = Private(__webpack_require__(570));

	    return new MetricAggType({
	      name: 'median',
	      dslName: 'percentiles',
	      title: 'Median',
	      makeLabel: function makeLabel(aggConfig) {
	        return 'Median ' + aggConfig.params.field.displayName;
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number'
	      }, {
	        name: 'percents',
	        'default': [50]
	      }],
	      getResponseAggs: percentiles.getResponseAggs,
	      getValue: percentiles.getValue
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(201);
	__webpack_require__(192);

	'use strict';

	var _Object$create = __webpack_require__(201)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ResponseAggConfigProvider() {
	    var _ = __webpack_require__(192);

	    /**
	     * Get the ResponseAggConfig class for an aggConfig,
	     * which might be cached on the aggConfig or created.
	     *
	     * @param  {AggConfig} agg - the AggConfig the VAC should inherit from
	     * @param  {object} props - properties that the VAC should have
	     * @return {Constructor} - a constructor for VAC objects that will inherit the aggConfig
	     */
	    return function getResponseConfigClass(agg, props) {
	      if (agg.$$_ResponseAggConfigClass) {
	        return agg.$$_ResponseAggConfigClass;
	      } else {
	        return agg.$$_ResponseAggConfigClass = create(agg, props);
	      }
	    };

	    function create(parentAgg, props) {

	      /**
	       * AggConfig "wrapper" for multi-value metric aggs which
	       * need to modify AggConfig behavior for each value produced.
	       *
	       * @param {string|number} key - the key or index that identifies
	       *                            this part of the multi-value
	       */
	      function ResponseAggConfig(key) {
	        this.key = key;
	        this.parentId = this.id;

	        var subId = String(key);
	        if (subId.indexOf('.') > -1) {
	          this.id = this.parentId + '[\'' + subId.replace(/'/g, '\\\'') + '\']';
	        } else {
	          this.id = this.parentId + '.' + subId;
	        }
	      }

	      ResponseAggConfig.prototype = _Object$create(parentAgg, {
	        constructor: ResponseAggConfig
	      });

	      _.assign(ResponseAggConfig.prototype, props);

	      return ResponseAggConfig;
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(552);
	__webpack_require__(569);
	__webpack_require__(571);
	__webpack_require__(443);
	__webpack_require__(572);
	__webpack_require__(573);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricPercentilesProvider(Private) {
	    var _ = __webpack_require__(192);

	    var MetricAggType = Private(__webpack_require__(552));
	    var getResponseAggConfigClass = Private(__webpack_require__(569));
	    var ordinalSuffix = __webpack_require__(571);
	    var fieldFormats = Private(__webpack_require__(443));

	    var percentsEditor = __webpack_require__(572);
	    // required by the percentiles editor
	    __webpack_require__(573);

	    var valueProps = {
	      makeLabel: function makeLabel() {
	        return ordinalSuffix(this.key) + ' percentile of ' + this.fieldDisplayName();
	      }
	    };

	    return new MetricAggType({
	      name: 'percentiles',
	      title: 'Percentiles',
	      makeLabel: function makeLabel(agg) {
	        return 'Percentiles of ' + agg.fieldDisplayName();
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number'
	      }, {
	        name: 'percents',
	        editor: percentsEditor,
	        'default': [1, 5, 25, 50, 75, 95, 99]
	      }],
	      getResponseAggs: function getResponseAggs(agg) {
	        var ValueAggConfig = getResponseAggConfigClass(agg, valueProps);

	        return agg.params.percents.map(function (percent) {
	          return new ValueAggConfig(percent);
	        });
	      },
	      getValue: function getValue(agg, bucket) {
	        // percentiles for 1, 5, and 10 will come back as 1.0, 5.0, and 10.0 so we
	        // parse the keys and respond with the value that matches
	        return _.find(bucket[agg.parentId].values, function (value, key) {
	          return agg.key === parseFloat(key);
	        });
	      }
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // adopted from http://stackoverflow.com/questions/3109978/php-display-number-with-ordinal-suffix
	  var _ = __webpack_require__(192);
	  return function addOrdinalSuffix(num) {
	    return num + '' + suffix(num);
	  };

	  function suffix(num) {
	    var int = Math.floor(parseFloat(num));

	    var hunth = int % 100;
	    if (hunth >= 11 && hunth <= 13) return 'th';

	    var tenth = int % 10;
	    if (tenth === 1) return 'st';
	    if (tenth === 2) return 'nd';
	    if (tenth === 3) return 'rd';
	    return 'th';
	  }
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 572 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Percents</label>\n  <kbn-number-list\n    ng-model=\"agg.params.percents\"\n    unit-name=\"percent\"\n    range=\"[0,100]\"\n    >\n  </kbn-number-list>\n</div>\n"

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(574);
	__webpack_require__(575);
	__webpack_require__(214);
	__webpack_require__(577);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var parseRange = __webpack_require__(574);

	  __webpack_require__(575);
	  __webpack_require__(214).get('kibana').directive('kbnNumberList', function () {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(577),
	      controllerAs: 'numberListCntr',
	      require: 'ngModel',
	      controller: function controller($scope, $attrs, $parse) {
	        var self = this;

	        // Called from the pre-link function once we have the controllers
	        self.init = function (modelCntr) {
	          self.modelCntr = modelCntr;

	          self.getList = function () {
	            return self.modelCntr.$modelValue;
	          };

	          self.getUnitName = _.partial($parse($attrs.unit), $scope);

	          var defaultRange = self.range = parseRange('[0,Infinity)');

	          $scope.$watch(function () {
	            return $attrs.range;
	          }, function (range, prev) {
	            if (!range) {
	              self.range = defaultRange;
	              return;
	            }

	            try {
	              self.range = parseRange(range);
	            } catch (e) {
	              throw new TypeError('Unable to parse range: ' + e.message);
	            }
	          });

	          /**
	           * Remove an item from list by index
	           * @param  {number} index
	           * @return {undefined}
	           */
	          self.remove = function (index) {
	            var list = self.getList();
	            if (!list) return;

	            list.splice(index, 1);
	          };

	          /**
	           * Add an item to the end of the list
	           * @return {undefined}
	           */
	          self.add = function () {
	            var list = self.getList();
	            if (!list) return;

	            list.push(_.last(list) + 1);
	          };

	          /**
	           * Check to see if the list is too short.
	           *
	           * @return {Boolean}
	           */
	          self.tooShort = function () {
	            return _.size(self.getList()) < 1;
	          };

	          /**
	           * Check to see if the list is too short, but simply
	           * because the user hasn't interacted with it yet
	           *
	           * @return {Boolean}
	           */
	          self.undefinedLength = function () {
	            return self.tooShort() && (self.modelCntr.$untouched && self.modelCntr.$pristine);
	          };

	          /**
	           * Check to see if the list is too short
	           *
	           * @return {Boolean}
	           */
	          self.invalidLength = function () {
	            return self.tooShort() && !self.undefinedLength();
	          };

	          $scope.$watchCollection(self.getList, function () {
	            self.modelCntr.$setValidity('numberListLength', !self.tooShort());
	          });
	        };
	      },
	      link: {
	        pre: function pre($scope, $el, attrs, ngModelCntr) {
	          $scope.numberListCntr.init(ngModelCntr);
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  /**
	   * Regexp portion that matches our number
	   *
	   * supports:
	   *   -100
	   *   -100.0
	   *   0
	   *   0.10
	   *   Infinity
	   *   -Infinity
	   *
	   * @type {String}
	   */
	  var _RE_NUMBER = '(\\-?(?:\\d+(?:\\.\\d+)?|Infinity))';

	  /**
	   * Regexp for the interval notation
	   *
	   * supports:
	   *   [num, num]
	   *   ( num , num ]
	   *   [Infinity,num)
	   *
	   * @type {RegExp}
	   */
	  var RANGE_RE = new RegExp('^\\s*([\\[|\\(])\\s*' + _RE_NUMBER + '\\s*,\\s*' + _RE_NUMBER + '\\s*([\\]|\\)])\\s*$');

	  function parse(input) {

	    var match = String(input).match(RANGE_RE);
	    if (!match) {
	      throw new TypeError('expected input to be in interval notation eg. (100, 200]');
	    }

	    return new Range(match[1] === '[', parseFloat(match[2]), parseFloat(match[3]), match[4] === ']');
	  }

	  function Range() /* minIncl, min, max, maxIncl */{
	    var args = _.toArray(arguments);
	    if (args[1] > args[2]) args.reverse();

	    this.minInclusive = args[0];
	    this.min = args[1];
	    this.max = args[2];
	    this.maxInclusive = args[3];
	  }

	  Range.prototype.within = function (n) {
	    if (this.min === n && !this.minInclusive) return false;
	    if (this.min > n) return false;

	    if (this.max === n && !this.maxInclusive) return false;
	    if (this.max < n) return false;

	    return true;
	  };

	  return parse;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(576);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var $ = __webpack_require__(206);
	  var _ = __webpack_require__(192);
	  var keyMap = __webpack_require__(576);

	  var INVALID = {}; // invalid flag
	  var FLOATABLE = /^[\d\.e\-\+]+$/i;

	  var VALIDATION_ERROR = 'numberListRangeAndOrder';
	  var DIRECTIVE_ATTR = 'kbn-number-list-input';

	  __webpack_require__(214).get('kibana').directive('kbnNumberListInput', function ($parse) {
	    return {
	      restrict: 'A',
	      require: ['ngModel', '^kbnNumberList'],
	      link: function link($scope, $el, attrs, controllers) {
	        var ngModelCntr = controllers[0];
	        var numberListCntr = controllers[1];

	        var $setModel = $parse(attrs.ngModel).assign;
	        var $repeater = $el.closest('[ng-repeat]');

	        var handlers = {
	          up: change(add, 1),
	          'shift-up': change(addTenth, 1),

	          down: change(add, -1),
	          'shift-down': change(addTenth, -1),

	          tab: go('next'),
	          'shift-tab': go('prev'),

	          'shift-enter': numberListCntr.add,

	          backspace: removeIfEmpty,
	          'delete': removeIfEmpty
	        };

	        function removeIfEmpty(event) {
	          if (!ngModelCntr.$viewValue) {
	            $get('prev').focus();
	            numberListCntr.remove($scope.$index);
	            event.preventDefault();
	          }

	          return false;
	        }

	        function $get(dir) {
	          return $repeater[dir]().find('[' + DIRECTIVE_ATTR + ']');
	        }

	        function go(dir) {
	          return function () {
	            var $to = $get(dir);
	            if ($to.size()) $to.focus();else return false;
	          };
	        }

	        function idKey(event) {
	          var id = [];
	          if (event.ctrlKey) id.push('ctrl');
	          if (event.shiftKey) id.push('shift');
	          if (event.metaKey) id.push('meta');
	          if (event.altKey) id.push('alt');
	          id.push(keyMap[event.keyCode] || event.keyCode);
	          return id.join('-');
	        }

	        function add(n, val) {
	          return parse(val + n);
	        }

	        function addTenth(n, val, str) {
	          var int = Math.floor(val);
	          var dec = parseInt(str.split('.')[1] || 0, 10);
	          dec = dec + parseInt(n, 10);

	          if (dec < 0 || dec > 9) {
	            int += Math.floor(dec / 10);
	            if (dec < 0) {
	              dec = 10 + dec % 10;
	            } else {
	              dec = dec % 10;
	            }
	          }

	          return parse(int + '.' + dec);
	        }

	        function change(using, mod) {
	          return function () {
	            var str = String(ngModelCntr.$viewValue);
	            var val = parse(str);
	            if (val === INVALID) return;

	            var next = using(mod, val, str);
	            if (next === INVALID) return;

	            $el.val(next);
	            ngModelCntr.$setViewValue(next);
	          };
	        }

	        function onKeydown(event) {
	          var handler = handlers[idKey(event)];
	          if (!handler) return;

	          if (handler(event) !== false) {
	            event.preventDefault();
	          }

	          $scope.$apply();
	        }

	        $el.on('keydown', onKeydown);
	        $scope.$on('$destroy', function () {
	          $el.off('keydown', onKeydown);
	        });

	        function parse(viewValue) {
	          var num = viewValue;

	          if (typeof num !== 'number' || isNaN(num)) {
	            // parse non-numbers
	            num = String(viewValue || 0).trim();
	            if (!FLOATABLE.test(num)) return INVALID;

	            num = parseFloat(num);
	            if (isNaN(num)) return INVALID;
	          }

	          var range = numberListCntr.range;
	          if (!range.within(num)) return INVALID;

	          if ($scope.$index > 0) {
	            var i = $scope.$index - 1;
	            var list = numberListCntr.getList();
	            var prev = list[i];
	            if (num <= prev) return INVALID;
	          }

	          return num;
	        }

	        $scope.$watchMulti(['$index', {
	          fn: $scope.$watchCollection,
	          get: function get() {
	            return numberListCntr.getList();
	          }
	        }], function () {
	          var valid = parse(ngModelCntr.$viewValue) !== INVALID;
	          ngModelCntr.$setValidity(VALIDATION_ERROR, valid);
	        });

	        function validate(then) {
	          return function (input) {
	            var value = parse(input);
	            var valid = value !== INVALID;
	            value = valid ? value : input;
	            ngModelCntr.$setValidity(VALIDATION_ERROR, valid);
	            then && then(input, value);
	            return value;
	          };
	        }

	        ngModelCntr.$parsers.push(validate());
	        ngModelCntr.$formatters.push(validate(function (input, value) {
	          if (input !== value) $setModel($scope, value);
	        }));

	        if (parse(ngModelCntr.$viewValue) === INVALID) {
	          ngModelCntr.$setTouched();
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return {
	    8: 'backspace',
	    9: 'tab',
	    13: 'enter',
	    16: 'shift',
	    17: 'ctrl',
	    18: 'alt',
	    19: 'pause',
	    20: 'capsLock',
	    27: 'escape',
	    32: 'space',
	    33: 'pageUp',
	    34: 'pageDown',
	    35: 'end',
	    36: 'home',
	    37: 'left',
	    38: 'up',
	    39: 'right',
	    40: 'down',
	    45: 'insert',
	    46: 'delete',
	    48: '0',
	    49: '1',
	    50: '2',
	    51: '3',
	    52: '4',
	    53: '5',
	    54: '6',
	    55: '7',
	    56: '8',
	    57: '9',
	    65: 'a',
	    66: 'b',
	    67: 'c',
	    68: 'd',
	    69: 'e',
	    70: 'f',
	    71: 'g',
	    72: 'h',
	    73: 'i',
	    74: 'j',
	    75: 'k',
	    76: 'l',
	    77: 'm',
	    78: 'n',
	    79: 'o',
	    80: 'p',
	    81: 'q',
	    82: 'r',
	    83: 's',
	    84: 't',
	    85: 'u',
	    86: 'v',
	    87: 'w',
	    88: 'x',
	    89: 'y',
	    90: 'z',
	    91: 'leftWindowKey',
	    92: 'rightWindowKey',
	    93: 'selectKey',
	    96: '0',
	    97: '1',
	    98: '2',
	    99: '3',
	    100: '4',
	    101: '5',
	    102: '6',
	    103: '7',
	    104: '8',
	    105: '9',
	    106: 'multiply',
	    107: 'add',
	    109: 'subtract',
	    110: 'period',
	    111: 'divide',
	    112: 'f1',
	    113: 'f2',
	    114: 'f3',
	    115: 'f4',
	    116: 'f5',
	    117: 'f6',
	    118: 'f7',
	    119: 'f8',
	    120: 'f9',
	    121: 'f10',
	    122: 'f11',
	    123: 'f12',
	    144: 'numLock',
	    145: 'scrollLock',
	    186: 'semiColon',
	    187: 'equalSign',
	    188: 'comma',
	    189: 'dash',
	    190: 'period',
	    191: 'forwardSlash',
	    192: 'graveAccent',
	    219: 'openBracket',
	    220: 'backSlash',
	    221: 'closeBraket',
	    222: 'singleQuote',
	    224: 'meta'
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 577 */
/***/ function(module, exports) {

	module.exports = "<div\n  ng-repeat=\"value in numberListCntr.getList() track by $index\"\n  class=\"form-group vis-editor-agg-form-row vis-editor-agg-form-row\">\n\n  <input\n    ng-model=\"numberListCntr.getList()[$index]\"\n    kbn-number-list-input\n    input-focus\n    class=\"form-control\">\n\n  <button\n    ng-click=\"numberListCntr.remove($index, 1)\"\n    class=\"btn btn-danger btn-xs\"\n    type=\"button\">\n    <i class=\"fa fa-times\"></i>\n  </button>\n\n</div>\n\n<p ng-show=\"numberListCntr.invalidLength()\" class=\"text-danger text-center\">\n  You must specify at least one {{numberListCntr.getUnitName()}}\n</p>\n\n<p ng-show=\"numberListCntr.undefinedLength()\" class=\"text-primary text-center\">\n  <!-- be a bit more polite when the form is first init'd -->\n  Please specify at least one {{numberListCntr.getUnitName()}}\n</p>\n\n<button\n  ng-click=\"numberListCntr.add()\"\n  type=\"button\"\n  class=\"sidebar-item-button primary\">\n  <i class=\"fa fa-plus\"></i> Add {{numberListCntr.getUnitName()}}\n</button>\n"

/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(552);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricMinProvider(Private) {
	    var MetricAggType = Private(__webpack_require__(552));

	    return new MetricAggType({
	      name: 'min',
	      title: 'Min',
	      makeLabel: function makeLabel(aggConfig) {
	        return 'Min ' + aggConfig.params.field.displayName;
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number,date'
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(552);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricMaxProvider(Private) {
	    var MetricAggType = Private(__webpack_require__(552));

	    return new MetricAggType({
	      name: 'max',
	      title: 'Max',
	      makeLabel: function makeLabel(aggConfig) {
	        return 'Max ' + aggConfig.params.field.displayName;
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number,date'
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(552);
	__webpack_require__(569);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricStandardDeviationProvider(Private) {
	    var _ = __webpack_require__(192);
	    var MetricAggType = Private(__webpack_require__(552));
	    var getResponseAggConfigClass = Private(__webpack_require__(569));

	    var responseAggConfigProps = {
	      valProp: function valProp() {
	        var details = this.keyedDetails[this.key];
	        return details.valProp;
	      },
	      makeLabel: function makeLabel() {
	        var details = this.keyedDetails[this.key];
	        return details.title + ' of ' + this.fieldDisplayName();
	      },
	      keyedDetails: {
	        std_lower: {
	          valProp: ['std_deviation_bounds', 'lower'],
	          title: 'Lower Standard Deviation'
	        },
	        avg: {
	          valProp: 'avg',
	          title: 'Average'
	        },
	        std_upper: {
	          valProp: ['std_deviation_bounds', 'upper'],
	          title: 'Upper Standard Deviation'
	        }
	      }
	    };

	    return new MetricAggType({
	      name: 'std_dev',
	      dslName: 'extended_stats',
	      title: 'Standard Deviation',
	      makeLabel: function makeLabel(agg) {
	        return 'Standard Deviation of ' + agg.fieldDisplayName();
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number'
	      }],

	      getResponseAggs: function getResponseAggs(agg) {
	        var ValueAggConfig = getResponseAggConfigClass(agg, responseAggConfigProps);

	        return [new ValueAggConfig('std_lower'), new ValueAggConfig('avg'), new ValueAggConfig('std_upper')];
	      },

	      getValue: function getValue(agg, bucket) {
	        return _.get(bucket[agg.parentId], agg.valProp());
	      }
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(552);
	__webpack_require__(443);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricCardinalityProvider(Private) {
	    var MetricAggType = Private(__webpack_require__(552));
	    var fieldFormats = Private(__webpack_require__(443));

	    return new MetricAggType({
	      name: 'cardinality',
	      title: 'Unique Count',
	      makeLabel: function makeLabel(aggConfig) {
	        return 'Unique count of ' + aggConfig.params.field.displayName;
	      },
	      getFormat: function getFormat() {
	        return fieldFormats.getDefaultInstance('number');
	      },
	      params: [{
	        name: 'field'
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 582 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(552);
	__webpack_require__(569);
	__webpack_require__(443);
	__webpack_require__(583);
	__webpack_require__(573);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggTypeMetricPercentileRanksProvider(Private) {
	    var _ = __webpack_require__(192);

	    var MetricAggType = Private(__webpack_require__(552));
	    var getResponseAggConfigClass = Private(__webpack_require__(569));
	    var fieldFormats = Private(__webpack_require__(443));

	    var valuesEditor = __webpack_require__(583);
	    // required by the values editor
	    __webpack_require__(573);

	    var valueProps = {
	      makeLabel: function makeLabel() {
	        var field = this.field();
	        var format = field && field.format || fieldFormats.getDefaultInstance('number');

	        return 'Percentile rank ' + format.convert(this.key, 'text') + ' of "' + this.fieldDisplayName() + '"';
	      }
	    };

	    return new MetricAggType({
	      name: 'percentile_ranks',
	      title: 'Percentile Ranks',
	      makeLabel: function makeLabel(agg) {
	        return 'Percentile ranks of ' + agg.fieldDisplayName();
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number'
	      }, {
	        name: 'values',
	        editor: valuesEditor,
	        'default': []
	      }],
	      getResponseAggs: function getResponseAggs(agg) {
	        var ValueAggConfig = getResponseAggConfigClass(agg, valueProps);

	        return agg.params.values.map(function (value) {
	          return new ValueAggConfig(value);
	        });
	      },
	      getFormat: function getFormat() {
	        return fieldFormats.getInstance('percent') || fieldFormats.getDefaultInstance('number');
	      },
	      getValue: function getValue(agg, bucket) {
	        // values for 1, 5, and 10 will come back as 1.0, 5.0, and 10.0 so we
	        // parse the keys and respond with the value that matches
	        return _.find(bucket[agg.parentId].values, function (value, key) {
	          return agg.key === parseFloat(key);
	        }) / 100;
	      }
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 583 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Values</label>\n  <kbn-number-list\n    ng-model=\"agg.params.values\"\n    unit-name=\"value\"\n    range=\"[-Infinity,Infinity]\"\n    >\n  </kbn-number-list>\n</div>\n"

/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(585);
	__webpack_require__(586);
	__webpack_require__(587);
	__webpack_require__(591);
	__webpack_require__(593);
	__webpack_require__(595);
	__webpack_require__(597);
	__webpack_require__(598);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DateHistogramAggType(timefilter, config, Private) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);
	    var tzDetect = __webpack_require__(585).jstz;
	    var BucketAggType = Private(__webpack_require__(586));
	    var TimeBuckets = Private(__webpack_require__(587));
	    var createFilter = Private(__webpack_require__(591));
	    var intervalOptions = Private(__webpack_require__(593));
	    var timeZone = tzDetect.determine().name();
	    var tzOffset = moment().format('Z');

	    function getInterval(agg) {
	      var interval = _.get(agg, ['params', 'interval']);
	      if (interval && interval.val === 'custom') interval = _.get(agg, ['params', 'customInterval']);
	      return interval;
	    }

	    function setBounds(agg, force) {
	      if (agg.buckets._alreadySet && !force) return;
	      agg.buckets._alreadySet = true;
	      agg.buckets.setBounds(agg.fieldIsTimeField() && timefilter.getActiveBounds());
	    }

	    __webpack_require__(595);
	    __webpack_require__(597);

	    return new BucketAggType({
	      name: 'date_histogram',
	      title: 'Date Histogram',
	      ordered: {
	        date: true
	      },
	      makeLabel: function makeLabel(agg) {
	        var output = this.params.write(agg);
	        var params = output.params;
	        return params.field + ' per ' + (output.metricScaleText || output.bucketInterval.description);
	      },
	      createFilter: createFilter,
	      decorateAggConfig: function decorateAggConfig() {
	        var buckets;
	        return {
	          buckets: {
	            configurable: true,
	            get: function get() {
	              if (buckets) return buckets;

	              buckets = new TimeBuckets();
	              buckets.setInterval(getInterval(this));
	              setBounds(this);

	              return buckets;
	            }
	          }
	        };
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'date',
	        'default': function _default(agg) {
	          return agg.vis.indexPattern.timeFieldName;
	        },
	        onChange: function onChange(agg) {
	          if (_.get(agg, 'params.interval.val') === 'auto' && !agg.fieldIsTimeField()) {
	            delete agg.params.interval;
	          }

	          setBounds(agg, true);
	        }
	      }, {
	        name: 'interval',
	        type: 'optioned',
	        deserialize: function deserialize(state) {
	          var interval = _.find(intervalOptions, { val: state });
	          return interval || _.find(intervalOptions, function (option) {
	            // For upgrading from 4.0.x to 4.1.x - intervals are now stored as 'y' instead of 'year',
	            // but this maps the old values to the new values
	            return Number(moment.duration(1, state)) === Number(moment.duration(1, option.val));
	          });
	        },
	        'default': 'auto',
	        options: intervalOptions,
	        editor: __webpack_require__(598),
	        onRequest: function onRequest(agg) {
	          setBounds(agg, true);
	        },
	        write: function write(agg, output) {
	          setBounds(agg);
	          agg.buckets.setInterval(getInterval(agg));

	          var interval = agg.buckets.getInterval();
	          output.bucketInterval = interval;
	          output.params.interval = interval.expression;
	          output.params.time_zone = timeZone || tzOffset;

	          var scaleMetrics = interval.scaled && interval.scale < 1;
	          if (scaleMetrics) {
	            scaleMetrics = _.every(agg.vis.aggs.bySchemaGroup.metrics, function (agg) {
	              return agg.type && (agg.type.name === 'count' || agg.type.name === 'sum');
	            });
	          }

	          if (scaleMetrics) {
	            output.metricScale = interval.scale;
	            output.metricScaleText = interval.preScaled.description;
	          }
	        }
	      }, {
	        name: 'customInterval',
	        'default': '2h',
	        write: _.noop
	      }, {
	        name: 'format'
	      }, {
	        name: 'min_doc_count',
	        'default': 1
	      }, {
	        name: 'extended_bounds',
	        'default': {},
	        write: function write(agg, output) {
	          var val = agg.params.extended_bounds;

	          if (val.min != null || val.max != null) {
	            output.params.extended_bounds = {
	              min: moment(val.min).valueOf(),
	              max: moment(val.max).valueOf()
	            };

	            return;
	          }

	          var bounds = timefilter.getActiveBounds();
	          if (bounds) {
	            output.params.extended_bounds = {
	              min: moment(bounds.min).valueOf(),
	              max: moment(bounds.max).valueOf()
	            };
	          }
	        }
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This script gives you the zone info key representing your device's time zone setting.
	 *
	 * @name jsTimezoneDetect
	 * @version 1.0.5
	 * @author Jon Nylander
	 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
	 *
	 * For usage and examples, visit:
	 * http://pellepim.bitbucket.org/jstz/
	 *
	 * Copyright (c) Jon Nylander
	 */

	/*jslint undef: true */
	/*global console, exports*/

	(function(root) {
	  /**
	   * Namespace to hold all the code for timezone detection.
	   */
	  var jstz = (function () {
	      'use strict';
	      var HEMISPHERE_SOUTH = 's',
	          
	          /**
	           * Gets the offset in minutes from UTC for a certain date.
	           * @param {Date} date
	           * @returns {Number}
	           */
	          get_date_offset = function (date) {
	              var offset = -date.getTimezoneOffset();
	              return (offset !== null ? offset : 0);
	          },

	          get_date = function (year, month, date) {
	              var d = new Date();
	              if (year !== undefined) {
	                d.setFullYear(year);
	              }
	              d.setMonth(month);
	              d.setDate(date);
	              return d;
	          },

	          get_january_offset = function (year) {
	              return get_date_offset(get_date(year, 0 ,2));
	          },

	          get_june_offset = function (year) {
	              return get_date_offset(get_date(year, 5, 2));
	          },

	          /**
	           * Private method.
	           * Checks whether a given date is in daylight saving time.
	           * If the date supplied is after august, we assume that we're checking
	           * for southern hemisphere DST.
	           * @param {Date} date
	           * @returns {Boolean}
	           */
	          date_is_dst = function (date) {
	              var is_southern = date.getMonth() > 7,
	                  base_offset = is_southern ? get_june_offset(date.getFullYear()) : 
	                                              get_january_offset(date.getFullYear()),
	                  date_offset = get_date_offset(date),
	                  is_west = base_offset < 0,
	                  dst_offset = base_offset - date_offset;
	                  
	              if (!is_west && !is_southern) {
	                  return dst_offset < 0;
	              }

	              return dst_offset !== 0;
	          },

	          /**
	           * This function does some basic calculations to create information about
	           * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
	           * the script has been tested rather than depend on the year set by the
	           * client device.
	           *
	           * Returns a key that can be used to do lookups in jstz.olson.timezones.
	           * eg: "720,1,2". 
	           *
	           * @returns {String}
	           */

	          lookup_key = function () {
	              var january_offset = get_january_offset(),
	                  june_offset = get_june_offset(),
	                  diff = january_offset - june_offset;

	              if (diff < 0) {
	                  return january_offset + ",1";
	              } else if (diff > 0) {
	                  return june_offset + ",1," + HEMISPHERE_SOUTH;
	              }

	              return january_offset + ",0";
	          },

	          /**
	           * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
	           *
	           * Returns a primitive object on the format:
	           * {'timezone': TimeZone, 'key' : 'the key used to find the TimeZone object'}
	           *
	           * @returns Object
	           */
	          determine = function () {
	              var key = lookup_key();
	              return new jstz.TimeZone(jstz.olson.timezones[key]);
	          },

	          /**
	           * This object contains information on when daylight savings starts for
	           * different timezones.
	           *
	           * The list is short for a reason. Often we do not have to be very specific
	           * to single out the correct timezone. But when we do, this list comes in
	           * handy.
	           *
	           * Each value is a date denoting when daylight savings starts for that timezone.
	           */
	          dst_start_for = function (tz_name) {

	            var ru_pre_dst_change = new Date(2010, 6, 15, 1, 0, 0, 0), // In 2010 Russia had DST, this allows us to detect Russia :)
	                dst_starts = {
	                    'America/Denver': new Date(2011, 2, 13, 3, 0, 0, 0),
	                    'America/Mazatlan': new Date(2011, 3, 3, 3, 0, 0, 0),
	                    'America/Chicago': new Date(2011, 2, 13, 3, 0, 0, 0),
	                    'America/Mexico_City': new Date(2011, 3, 3, 3, 0, 0, 0),
	                    'America/Asuncion': new Date(2012, 9, 7, 3, 0, 0, 0),
	                    'America/Santiago': new Date(2012, 9, 3, 3, 0, 0, 0),
	                    'America/Campo_Grande': new Date(2012, 9, 21, 5, 0, 0, 0),
	                    'America/Montevideo': new Date(2011, 9, 2, 3, 0, 0, 0),
	                    'America/Sao_Paulo': new Date(2011, 9, 16, 5, 0, 0, 0),
	                    'America/Los_Angeles': new Date(2011, 2, 13, 8, 0, 0, 0),
	                    'America/Santa_Isabel': new Date(2011, 3, 5, 8, 0, 0, 0),
	                    'America/Havana': new Date(2012, 2, 10, 2, 0, 0, 0),
	                    'America/New_York': new Date(2012, 2, 10, 7, 0, 0, 0),
	                    'Europe/Helsinki': new Date(2013, 2, 31, 5, 0, 0, 0),
	                    'Pacific/Auckland': new Date(2011, 8, 26, 7, 0, 0, 0),
	                    'America/Halifax': new Date(2011, 2, 13, 6, 0, 0, 0),
	                    'America/Goose_Bay': new Date(2011, 2, 13, 2, 1, 0, 0),
	                    'America/Miquelon': new Date(2011, 2, 13, 5, 0, 0, 0),
	                    'America/Godthab': new Date(2011, 2, 27, 1, 0, 0, 0),
	                    'Europe/Moscow': ru_pre_dst_change,
	                    'Asia/Amman': new Date(2013, 2, 29, 1, 0, 0, 0),
	                    'Asia/Beirut': new Date(2013, 2, 31, 2, 0, 0, 0),
	                    'Asia/Damascus': new Date(2013, 3, 6, 2, 0, 0, 0),
	                    'Asia/Jerusalem': new Date(2013, 2, 29, 5, 0, 0, 0),
	                    'Asia/Yekaterinburg': ru_pre_dst_change,
	                    'Asia/Omsk': ru_pre_dst_change,
	                    'Asia/Krasnoyarsk': ru_pre_dst_change,
	                    'Asia/Irkutsk': ru_pre_dst_change,
	                    'Asia/Yakutsk': ru_pre_dst_change,
	                    'Asia/Vladivostok': ru_pre_dst_change,
	                    'Asia/Baku': new Date(2013, 2, 31, 4, 0, 0),
	                    'Asia/Yerevan': new Date(2013, 2, 31, 3, 0, 0),
	                    'Asia/Kamchatka': ru_pre_dst_change,
	                    'Asia/Gaza': new Date(2010, 2, 27, 4, 0, 0),
	                    'Africa/Cairo': new Date(2010, 4, 1, 3, 0, 0),
	                    'Europe/Minsk': ru_pre_dst_change,
	                    'Pacific/Apia': new Date(2010, 10, 1, 1, 0, 0, 0),
	                    'Pacific/Fiji': new Date(2010, 11, 1, 0, 0, 0),
	                    'Australia/Perth': new Date(2008, 10, 1, 1, 0, 0, 0)
	                };

	              return dst_starts[tz_name];
	          };

	      return {
	          determine: determine,
	          date_is_dst: date_is_dst,
	          dst_start_for: dst_start_for 
	      };
	  }());

	  /**
	   * Simple object to perform ambiguity check and to return name of time zone.
	   */
	  jstz.TimeZone = function (tz_name) {
	      'use strict';
	        /**
	         * The keys in this object are timezones that we know may be ambiguous after
	         * a preliminary scan through the olson_tz object.
	         *
	         * The array of timezones to compare must be in the order that daylight savings
	         * starts for the regions.
	         */
	      var AMBIGUITIES = {
	              'America/Denver':       ['America/Denver', 'America/Mazatlan'],
	              'America/Chicago':      ['America/Chicago', 'America/Mexico_City'],
	              'America/Santiago':     ['America/Santiago', 'America/Asuncion', 'America/Campo_Grande'],
	              'America/Montevideo':   ['America/Montevideo', 'America/Sao_Paulo'],
	              'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Asia/Beirut', 'Europe/Helsinki','Asia/Damascus'],
	              'Pacific/Auckland':     ['Pacific/Auckland', 'Pacific/Fiji'],
	              'America/Los_Angeles':  ['America/Los_Angeles', 'America/Santa_Isabel'],
	              'America/New_York':     ['America/Havana', 'America/New_York'],
	              'America/Halifax':      ['America/Goose_Bay', 'America/Halifax'],
	              'America/Godthab':      ['America/Miquelon', 'America/Godthab'],
	              'Asia/Dubai':           ['Europe/Moscow'],
	              'Asia/Dhaka':           ['Asia/Yekaterinburg'],
	              'Asia/Jakarta':         ['Asia/Omsk'],
	              'Asia/Shanghai':        ['Asia/Krasnoyarsk', 'Australia/Perth'],
	              'Asia/Tokyo':           ['Asia/Irkutsk'],
	              'Australia/Brisbane':   ['Asia/Yakutsk'],
	              'Pacific/Noumea':       ['Asia/Vladivostok'],
	              'Pacific/Tarawa':       ['Asia/Kamchatka', 'Pacific/Fiji'],
	              'Pacific/Tongatapu':    ['Pacific/Apia'],
	              'Asia/Baghdad':         ['Europe/Minsk'],
	              'Asia/Baku':            ['Asia/Yerevan','Asia/Baku'],
	              'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
	          },

	          timezone_name = tz_name,
	          
	          /**
	           * Checks if a timezone has possible ambiguities. I.e timezones that are similar.
	           *
	           * For example, if the preliminary scan determines that we're in America/Denver.
	           * We double check here that we're really there and not in America/Mazatlan.
	           *
	           * This is done by checking known dates for when daylight savings start for different
	           * timezones during 2010 and 2011.
	           */
	          ambiguity_check = function () {
	              var ambiguity_list = AMBIGUITIES[timezone_name],
	                  length = ambiguity_list.length,
	                  i = 0,
	                  tz = ambiguity_list[0];

	              for (; i < length; i += 1) {
	                  tz = ambiguity_list[i];

	                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {
	                      timezone_name = tz;
	                      return;
	                  }
	              }
	          },

	          /**
	           * Checks if it is possible that the timezone is ambiguous.
	           */
	          is_ambiguous = function () {
	              return typeof (AMBIGUITIES[timezone_name]) !== 'undefined';
	          };

	      if (is_ambiguous()) {
	          ambiguity_check();
	      }

	      return {
	          name: function () {
	              return timezone_name;
	          }
	      };
	  };

	  jstz.olson = {};

	  /*
	   * The keys in this dictionary are comma separated as such:
	   *
	   * First the offset compared to UTC time in minutes.
	   *
	   * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
	   * does.
	   *
	   * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
	   * only interesting for timezones with DST.
	   *
	   * The mapped arrays is used for constructing the jstz.TimeZone object from within
	   * jstz.determine_timezone();
	   */
	  jstz.olson.timezones = {
	      '-720,0'   : 'Pacific/Majuro',
	      '-660,0'   : 'Pacific/Pago_Pago',
	      '-600,1'   : 'America/Adak',
	      '-600,0'   : 'Pacific/Honolulu',
	      '-570,0'   : 'Pacific/Marquesas',
	      '-540,0'   : 'Pacific/Gambier',
	      '-540,1'   : 'America/Anchorage',
	      '-480,1'   : 'America/Los_Angeles',
	      '-480,0'   : 'Pacific/Pitcairn',
	      '-420,0'   : 'America/Phoenix',
	      '-420,1'   : 'America/Denver',
	      '-360,0'   : 'America/Guatemala',
	      '-360,1'   : 'America/Chicago',
	      '-360,1,s' : 'Pacific/Easter',
	      '-300,0'   : 'America/Bogota',
	      '-300,1'   : 'America/New_York',
	      '-270,0'   : 'America/Caracas',
	      '-240,1'   : 'America/Halifax',
	      '-240,0'   : 'America/Santo_Domingo',
	      '-240,1,s' : 'America/Santiago',
	      '-210,1'   : 'America/St_Johns',
	      '-180,1'   : 'America/Godthab',
	      '-180,0'   : 'America/Argentina/Buenos_Aires',
	      '-180,1,s' : 'America/Montevideo',
	      '-120,0'   : 'America/Noronha',
	      '-120,1'   : 'America/Noronha',
	      '-60,1'    : 'Atlantic/Azores',
	      '-60,0'    : 'Atlantic/Cape_Verde',
	      '0,0'      : 'UTC',
	      '0,1'      : 'Europe/London',
	      '60,1'     : 'Europe/Berlin',
	      '60,0'     : 'Africa/Lagos',
	      '60,1,s'   : 'Africa/Windhoek',
	      '120,1'    : 'Asia/Beirut',
	      '120,0'    : 'Africa/Johannesburg',
	      '180,0'    : 'Asia/Baghdad',
	      '180,1'    : 'Europe/Moscow',
	      '210,1'    : 'Asia/Tehran',
	      '240,0'    : 'Asia/Dubai',
	      '240,1'    : 'Asia/Baku',
	      '270,0'    : 'Asia/Kabul',
	      '300,1'    : 'Asia/Yekaterinburg',
	      '300,0'    : 'Asia/Karachi',
	      '330,0'    : 'Asia/Kolkata',
	      '345,0'    : 'Asia/Kathmandu',
	      '360,0'    : 'Asia/Dhaka',
	      '360,1'    : 'Asia/Omsk',
	      '390,0'    : 'Asia/Rangoon',
	      '420,1'    : 'Asia/Krasnoyarsk',
	      '420,0'    : 'Asia/Jakarta',
	      '480,0'    : 'Asia/Shanghai',
	      '480,1'    : 'Asia/Irkutsk',
	      '525,0'    : 'Australia/Eucla',
	      '525,1,s'  : 'Australia/Eucla',
	      '540,1'    : 'Asia/Yakutsk',
	      '540,0'    : 'Asia/Tokyo',
	      '570,0'    : 'Australia/Darwin',
	      '570,1,s'  : 'Australia/Adelaide',
	      '600,0'    : 'Australia/Brisbane',
	      '600,1'    : 'Asia/Vladivostok',
	      '600,1,s'  : 'Australia/Sydney',
	      '630,1,s'  : 'Australia/Lord_Howe',
	      '660,1'    : 'Asia/Kamchatka',
	      '660,0'    : 'Pacific/Noumea',
	      '690,0'    : 'Pacific/Norfolk',
	      '720,1,s'  : 'Pacific/Auckland',
	      '720,0'    : 'Pacific/Tarawa',
	      '765,1,s'  : 'Pacific/Chatham',
	      '780,0'    : 'Pacific/Tongatapu',
	      '780,1,s'  : 'Pacific/Apia',
	      '840,0'    : 'Pacific/Kiritimati'
	  };

	  if (true) {
	    exports.jstz = jstz;
	  } else {
	    root.jstz = jstz;
	  }
	})(this);



/***/ },
/* 586 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(553);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function BucketAggTypeProvider(Private) {
	    var _ = __webpack_require__(192);
	    var AggType = Private(__webpack_require__(553));

	    _['class'](BucketAggType).inherits(AggType);
	    function BucketAggType(config) {
	      BucketAggType.Super.call(this, config);

	      if (_.isFunction(config.getKey)) {
	        this.getKey = config.getKey;
	      }
	    }

	    BucketAggType.prototype.getKey = function (bucket, key) {
	      return key || bucket.key;
	    };

	    return BucketAggType;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(201);
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(228);
	__webpack_require__(588);
	__webpack_require__(589);
	__webpack_require__(590);

	'use strict';

	var _Object$create = __webpack_require__(201)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function IntervalHelperProvider(Private, timefilter, config) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);

	    var dateMath = __webpack_require__(228);
	    var parseInterval = __webpack_require__(588);
	    var calcAuto = Private(__webpack_require__(589));
	    var calcEsInterval = Private(__webpack_require__(590));
	    var tzOffset = moment().format('Z');

	    function isValidMoment(m) {
	      return m && 'isValid' in m && m.isValid();
	    }

	    /**
	     * Helper class for wrapping the concept of an "Interval",
	     * which describes a timespan that will seperate moments.
	     *
	     * @param {state} object - one of ""
	     * @param {[type]} display [description]
	     */
	    function TimeBuckets() {
	      return TimeBuckets.__cached__(this);
	    }

	    /****
	     *  PUBLIC API
	     ****/

	    /**
	     * Set the bounds that these buckets are expected to cover.
	     * This is required to support interval "auto" as well
	     * as interval scaling.
	     *
	     * @param {object} input - an object with properties min and max,
	     *                       representing the edges for the time span
	     *                       we should cover
	     *
	     * @returns {undefined}
	     */
	    TimeBuckets.prototype.setBounds = function (input) {
	      if (!input) return this.clearBounds();

	      var bounds;
	      if (_.isPlainObject(input)) {
	        // accept the response from timefilter.getActiveBounds()
	        bounds = [input.min, input.max];
	      } else {
	        bounds = _.isArray(input) ? input : [];
	      }

	      var moments = _(bounds).map(_.ary(moment, 1)).sortBy(Number);

	      var valid = moments.size() === 2 && moments.every(isValidMoment);
	      if (!valid) {
	        this.clearBounds();
	        throw new Error('invalid bounds set: ' + input);
	      }

	      this._lb = moments.shift();
	      this._ub = moments.pop();
	      if (this.getDuration().asSeconds() < 0) {
	        throw new TypeError('Intervals must be positive');
	      }
	    };

	    /**
	     * Clear the stored bounds
	     *
	     * @return {undefined}
	     */
	    TimeBuckets.prototype.clearBounds = function () {
	      this._lb = this._ub = null;
	    };

	    /**
	     * Check to see if we have received bounds yet
	     *
	     * @return {Boolean}
	     */
	    TimeBuckets.prototype.hasBounds = function () {
	      return isValidMoment(this._ub) && isValidMoment(this._lb);
	    };

	    /**
	     * Return the current bounds, if we have any.
	     *
	     * THIS DOES NOT CLONE THE BOUNDS, so editting them
	     * may have unexpected side-effects. Always
	     * call bounds.min.clone() before editting
	     *
	     * @return {object|undefined} - If bounds are not defined, this
	     *                      returns undefined, else it returns the bounds
	     *                      for these buckets. This object has two props,
	     *                      min and max. Each property will be a moment()
	     *                      object
	     *
	     */
	    TimeBuckets.prototype.getBounds = function () {
	      if (!this.hasBounds()) return;
	      return {
	        min: this._lb,
	        max: this._ub
	      };
	    };

	    /**
	     * Get a moment duration object representing
	     * the distance between the bounds, if the bounds
	     * are set.
	     *
	     * @return {moment.duration|undefined}
	     */
	    TimeBuckets.prototype.getDuration = function () {
	      if (!this.hasBounds()) return;
	      return moment.duration(this._ub - this._lb, 'ms');
	    };

	    /**
	     * Update the interval at which buckets should be
	     * generated.
	     *
	     * Input can be one of the following:
	     *  - Any object from src/ui/agg_types/buckets/_interval_options.js
	     *  - "auto"
	     *  - Pass a valid moment unit
	     *  - a moment.duration object.
	     *
	     * @param {object|string|moment.duration} input - see desc
	     */
	    TimeBuckets.prototype.setInterval = function (input) {
	      var interval = input;

	      // selection object -> val
	      if (_.isObject(input)) {
	        interval = input.val;
	      }

	      if (!interval || interval === 'auto') {
	        this._i = 'auto';
	        return;
	      }

	      if (_.isString(interval)) {
	        input = interval;
	        interval = parseInterval(interval);
	        if (+interval === 0) {
	          interval = null;
	        }
	      }

	      // if the value wasn't converted to a duration, and isn't
	      // already a duration, we have a problem
	      if (!moment.isDuration(interval)) {
	        throw new TypeError('"' + input + '" is not a valid interval.');
	      }

	      this._i = interval;
	    };

	    /**
	     * Get the interval for the buckets. If the
	     * number of buckets created by the interval set
	     * is larger than config:histogram:maxBars then the
	     * interval will be scaled up. If the number of buckets
	     * created is less than one, the interval is scaled back.
	     *
	     * The interval object returned is a moment.duration
	     * object that has been decorated with the following
	     * properties.
	     *
	     * interval.description: a text description of the interval.
	     *   designed to be used list "field per {{ desc }}".
	     *     - "minute"
	     *     - "10 days"
	     *     - "3 years"
	     *
	     * interval.expr: the elasticsearch expression that creates this
	     *   interval. If the interval does not properly form an elasticsearch
	     *   expression it will be forced into one.
	     *
	     * interval.scaled: the interval was adjusted to
	     *   accomidate the maxBars setting.
	     *
	     * interval.scale: the numer that y-values should be
	     *   multiplied by
	     *
	     * interval.scaleDescription: a description that reflects
	     *   the values which will be produced by using the
	     *   interval.scale.
	     *
	     *
	     * @return {[type]} [description]
	     */
	    TimeBuckets.prototype.getInterval = function () {
	      var self = this;
	      var duration = self.getDuration();
	      return decorateInterval(maybeScaleInterval(readInterval()));

	      // either pull the interval from state or calculate the auto-interval
	      function readInterval() {
	        var interval = self._i;
	        if (moment.isDuration(interval)) return interval;
	        return calcAuto.near(config.get('histogram:barTarget'), duration);
	      }

	      // check to see if the interval should be scaled, and scale it if so
	      function maybeScaleInterval(interval) {
	        if (!self.hasBounds()) return interval;

	        var maxLength = config.get('histogram:maxBars');
	        var approxLen = duration / interval;
	        var scaled;

	        if (approxLen > maxLength) {
	          scaled = calcAuto.lessThan(maxLength, duration);
	        } else {
	          return interval;
	        }

	        if (+scaled === +interval) return interval;

	        decorateInterval(interval);
	        return _.assign(scaled, {
	          preScaled: interval,
	          scale: interval / scaled,
	          scaled: true
	        });
	      }

	      // append some TimeBuckets specific props to the interval
	      function decorateInterval(interval) {
	        var esInterval = calcEsInterval(interval);
	        interval.esValue = esInterval.value;
	        interval.esUnit = esInterval.unit;
	        interval.expression = esInterval.expression;
	        interval.overflow = duration > interval ? moment.duration(interval - duration) : false;

	        var prettyUnits = moment.normalizeUnits(esInterval.unit);
	        if (esInterval.value === 1) {
	          interval.description = prettyUnits;
	        } else {
	          interval.description = esInterval.value + ' ' + prettyUnits + 's';
	        }

	        return interval;
	      }
	    };

	    /**
	     * Get a date format string that will represent dates that
	     * progress at our interval.
	     *
	     * Since our interval can be as small as 1ms, the default
	     * date format is usually way too much. with `dateFormat:scaled`
	     * users can modify how dates are formatted within series
	     * produced by TimeBuckets
	     *
	     * @return {string}
	     */
	    TimeBuckets.prototype.getScaledDateFormat = function () {
	      var interval = this.getInterval();
	      var rules = config.get('dateFormat:scaled');

	      for (var i = rules.length - 1; i >= 0; i--) {
	        var rule = rules[i];
	        if (!rule[0] || interval >= moment.duration(rule[0])) {
	          return rule[1];
	        }
	      }

	      return config.get('dateFormat');
	    };

	    TimeBuckets.__cached__ = function (self) {
	      var cache = {};
	      var sameMoment = same(moment.isMoment);
	      var sameDuration = same(moment.isDuration);

	      var desc = {
	        __cached__: {
	          value: self
	        }
	      };

	      var breakers = {
	        setBounds: 'bounds',
	        clearBounds: 'bounds',
	        setInterval: 'interval'
	      };

	      var resources = {
	        bounds: {
	          setup: function setup() {
	            return [self._lb, self._ub];
	          },
	          changes: function changes(prev) {
	            return !sameMoment(prev[0], self._lb) || !sameMoment(prev[1], self._ub);
	          }
	        },
	        interval: {
	          setup: function setup() {
	            return self._i;
	          },
	          changes: function changes(prev) {
	            return !sameDuration(prev, this._i);
	          }
	        }
	      };

	      function cachedGetter(prop) {
	        return {
	          value: function cachedGetter() {
	            if (cache.hasOwnProperty(prop)) {
	              return cache[prop];
	            }

	            return cache[prop] = self[prop]();
	          }
	        };
	      }

	      function cacheBreaker(prop) {
	        var resource = resources[breakers[prop]];
	        var setup = resource.setup;
	        var changes = resource.changes;
	        var deps = resource.deps;
	        var fn = self[prop];

	        return {
	          value: function cacheBreaker(input) {
	            var prev = setup.call(self);
	            var ret = fn.apply(self, arguments);

	            if (changes.call(self, prev)) {
	              cache = {};
	            }

	            return ret;
	          }
	        };
	      }

	      function same(checkType) {
	        return function (a, b) {
	          if (a === b) return true;
	          if (checkType(a) === checkType(b)) return +a === +b;
	          return false;
	        };
	      }

	      _.forOwn(TimeBuckets.prototype, function (fn, prop) {
	        if (prop[0] === '_') return;

	        if (breakers.hasOwnProperty(prop)) {
	          desc[prop] = cacheBreaker(prop);
	        } else {
	          desc[prop] = cachedGetter(prop);
	        }
	      });

	      return _Object$create(self, desc);
	    };

	    return TimeBuckets;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(228);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var moment = __webpack_require__(226);
	  var dateMath = __webpack_require__(228);

	  // Assume interval is in the form (value)(unit), such as "1h"
	  var INTERVAL_STRING_RE = new RegExp('^([0-9\\.]*)\\s*(' + dateMath.units.join('|') + ')$');

	  return function parseInterval(interval) {
	    var matches = String(interval).trim().match(INTERVAL_STRING_RE);

	    if (!matches) return null;

	    try {
	      var value = parseFloat(matches[1]) || 1;
	      var unit = matches[2];

	      var duration = moment.duration(value, unit);

	      // There is an error with moment, where if you have a fractional interval between 0 and 1, then when you add that
	      // interval to an existing moment object, it will remain unchanged, which causes problems in the ordered_x_keys
	      // code. To counteract this, we find the first unit that doesn't result in a value between 0 and 1.
	      // For example, if you have '0.5d', then when calculating the x-axis series, we take the start date and begin
	      // adding 0.5 days until we hit the end date. However, since there is a bug in moment, when you add 0.5 days to
	      // the start date, you get the same exact date (instead of being ahead by 12 hours). So instead of returning
	      // a duration corresponding to 0.5 hours, we return a duration corresponding to 12 hours.
	      var selectedUnit = _.find(dateMath.units, function (unit) {
	        return Math.abs(duration.as(unit)) >= 1;
	      });

	      return moment.duration(duration.as(selectedUnit), selectedUnit);
	    } catch (e) {
	      return null;
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DateIntervalRoundingRulesProvider() {
	    var moment = __webpack_require__(226);
	    // these are the rounding rules used by roundInterval()
	    var d = __webpack_require__(226).duration;

	    var roundingRules = [[d(500, 'ms'), d(100, 'ms')], [d(5, 'second'), d(1, 'second')], [d(7.5, 'second'), d(5, 'second')], [d(15, 'second'), d(10, 'second')], [d(45, 'second'), d(30, 'second')], [d(3, 'minute'), d(1, 'minute')], [d(9, 'minute'), d(5, 'minute')], [d(20, 'minute'), d(10, 'minute')], [d(45, 'minute'), d(30, 'minute')], [d(2, 'hour'), d(1, 'hour')], [d(6, 'hour'), d(3, 'hour')], [d(24, 'hour'), d(12, 'hour')], [d(1, 'week'), d(1, 'd')], [d(3, 'week'), d(1, 'week')], [d(1, 'year'), d(1, 'month')], [Infinity, d(1, 'year')]];

	    var revRoundingRules = roundingRules.slice(0).reverse();

	    function find(rules, check, last) {
	      function pick(buckets, duration) {
	        var target = duration / buckets;
	        var lastResp;

	        for (var i = 0; i < rules.length; i++) {
	          var rule = rules[i];
	          var resp = check(rule[0], rule[1], target);

	          if (resp == null) {
	            if (!last) continue;
	            if (lastResp) return lastResp;
	            break;
	          }

	          if (!last) return resp;
	          lastResp = resp;
	        }

	        // fallback to just a number of milliseconds, ensure ms is >= 1
	        var ms = Math.max(Math.floor(target), 1);
	        return moment.duration(ms, 'ms');
	      }

	      return function (buckets, duration) {
	        var interval = pick(buckets, duration);
	        if (interval) return moment.duration(interval._data);
	      };
	    }

	    return {
	      near: find(revRoundingRules, function near(bound, interval, target) {
	        if (bound > target) return interval;
	      }, true),

	      lessThan: find(revRoundingRules, function (bound, interval, target) {
	        if (interval < target) return interval;
	      }),

	      atLeast: find(revRoundingRules, function atLeast(bound, interval, target) {
	        if (interval <= target) return interval;
	      })
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 590 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);
	__webpack_require__(228);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function () {
	    var moment = __webpack_require__(226);
	    var dateMath = __webpack_require__(228);

	    var unitsDesc = dateMath.unitsDesc;
	    var largeMax = unitsDesc.indexOf('M');

	    /**
	     * Convert a moment.duration into an es
	     * compatible expression, and provide
	     * associated metadata
	     *
	     * @param  {moment.duration} duration
	     * @return {object}
	     */
	    function esDuration(duration) {
	      for (var i = 0; i < unitsDesc.length; i++) {
	        var unit = unitsDesc[i];
	        var val = duration.as(unit);
	        // find a unit that rounds neatly
	        if (val >= 1 && Math.floor(val) === val) {

	          // if the unit is "large", like years, but
	          // isn't set to 1 ES will puke. So keep going until
	          // we get out of the "large" units
	          if (i <= largeMax && val !== 1) {
	            continue;
	          }

	          return {
	            value: val,
	            unit: unit,
	            expression: val + unit
	          };
	        }
	      }

	      var ms = duration.as('ms');
	      return {
	        value: ms,
	        unit: 'ms',
	        expression: ms + 'ms'
	      };
	    }

	    return esDuration;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);
	__webpack_require__(592);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function createDateHistogramFilterProvider(Private) {
	    var moment = __webpack_require__(226);
	    var buildRangeFilter = __webpack_require__(592);

	    return function (agg, key) {
	      var start = moment(key);
	      var interval = agg.buckets.getInterval();

	      return buildRangeFilter(agg.params.field, {
	        gte: start.valueOf(),
	        lte: start.add(interval).subtract(1, 'ms').valueOf()
	      }, agg.vis.indexPattern);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var OPERANDS_IN_RANGE = 2;

	  return function buildRangeFilter(field, params, indexPattern, formattedValue) {
	    var filter = { meta: { index: indexPattern.id } };
	    if (formattedValue) filter.meta.formattedValue = formattedValue;

	    params = _.clone(params);

	    if ('gte' in params && 'gt' in params) throw new Error('gte and gt are mutually exclusive');
	    if ('lte' in params && 'lt' in params) throw new Error('lte and lt are mutually exclusive');

	    var totalInfinite = ['gt', 'lt'].reduce(function (totalInfinite, op) {
	      var key = op in params ? op : op + 'e';
	      var isInfinite = Math.abs(params[key]) === Infinity;

	      if (isInfinite) {
	        totalInfinite++;
	        delete params[key];
	      }

	      return totalInfinite;
	    }, 0);

	    if (totalInfinite === OPERANDS_IN_RANGE) {
	      filter.match_all = {};
	      filter.meta.field = field.name;
	    } else if (field.scripted) {
	      (function () {
	        var operators = {
	          gt: '>',
	          gte: '>=',
	          lte: '<=',
	          lt: '<'
	        };

	        var script = _.map(params, function (val, key) {
	          return '(' + field.script + ')' + operators[key] + key;
	        }).join(' && ');

	        var value = _.map(params, function (val, key) {
	          return operators[key] + field.format.convert(val);
	        }).join(' ');

	        filter.script = { script: script, params: params, lang: field.lang };
	        filter.script.params.value = value;
	        filter.meta.field = field.name;
	      })();
	    } else {
	      filter.range = {};
	      filter.range[field.name] = params;
	    }

	    return filter;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 593 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);
	__webpack_require__(594);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function IntervalOptionsService(Private) {
	    var moment = __webpack_require__(226);
	    __webpack_require__(594);

	    // shorthand
	    var ms = function ms(type) {
	      return moment.duration(1, type).asMilliseconds();
	    };

	    return [{
	      display: 'Auto',
	      val: 'auto',
	      enabled: function enabled(agg) {
	        // not only do we need a time field, but the selected field needs
	        // to be the time field. (see #3028)
	        return agg.fieldIsTimeField();
	      }
	    }, {
	      display: 'Second',
	      val: 's'
	    }, {
	      display: 'Minute',
	      val: 'm'
	    }, {
	      display: 'Hourly',
	      val: 'h'
	    }, {
	      display: 'Daily',
	      val: 'd'
	    }, {
	      display: 'Weekly',
	      val: 'w'
	    }, {
	      display: 'Monthly',
	      val: 'M'
	    }, {
	      display: 'Yearly',
	      val: 'y'
	    }, {
	      display: 'Custom',
	      val: 'custom'
	    }];
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 594 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');

	  module.directive('inputWholeNumber', function () {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      link: function link($scope, $elem, attrs, ngModel) {
	        ngModel.$parsers.push(checkWholeNumber);
	        ngModel.$formatters.push(checkWholeNumber);

	        function checkWholeNumber(value) {
	          ngModel.$setValidity('whole', value % 1 === 0);
	          return value;
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 595 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(596);
	__webpack_require__(214);

	// Gets all fields of a given type.
	// You may also pass "*" to get all types
	// Or an array of types to get all fields of that type
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var propFilter = __webpack_require__(596);

	  __webpack_require__(214).get('kibana').filter('fieldType', function () {
	    return propFilter('type');
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 596 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  /**
	   * Filters out a list by a given filter. This is currently used to impelment:
	   *   - fieldType filters a list of fields by their type property
	   *   - aggFilter filters a list of aggs by their name property
	   *
	   * @returns {function} - the filter function which can be registered with angular
	   */
	  function propFilter(prop) {
	    /**
	     * List filtering function which accepts an array or list of values that a property
	     * must contain
	     *
	     * @param  {array} list - array of items to filter
	     * @param  {array|string} filters - the values to match against the list. Can be
	     *                                an array, a single value as a string, or a comma
	     *                                -seperated list of items
	     * @return {array} - the filtered list
	     */
	    return function (list, filters) {
	      if (!filters) return filters;
	      if (!_.isArray(filters)) filters = filters.split(',');
	      if (_.contains(filters, '*')) return list;

	      var options = filters.reduce(function (options, filter) {
	        var type = 'include';
	        var value = filter;

	        if (filter.charAt(0) === '!') {
	          type = 'exclude';
	          value = filter.substr(1);
	        }

	        if (!options[type]) options[type] = [];
	        options[type].push(value);
	        return options;
	      }, {});

	      return list.filter(function (item) {
	        var value = item[prop];

	        var excluded = options.exclude && _.contains(options.exclude, value);
	        if (excluded) return false;

	        var included = !options.include || _.contains(options.include, value);
	        if (included) return true;

	        return false;
	      });
	    };
	  }

	  return propFilter;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 597 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(588);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var parseInterval = __webpack_require__(588);

	  __webpack_require__(214).get('kibana').directive('validateDateInterval', function () {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      link: function link($scope, $el, attrs, ngModelCntrl) {

	        ngModelCntrl.$parsers.push(check);
	        ngModelCntrl.$formatters.push(check);

	        function check(value) {
	          ngModelCntrl.$setValidity('dateInterval', parseInterval(value) != null);
	          return value;
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 598 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>\n    Interval\n    <kbn-info\n      ng-show=\"agg.buckets.getInterval().scaled\"\n      placement=\"right\"\n      class=\"text-warning\"\n      info=\"This interval creates {{ agg.buckets.getInterval().scale > 1 ? 'buckets that are too large' : 'too many buckets' }} to show in the selected time range, so it has been scaled to {{ agg.buckets.getInterval().description }}\">\n    </kbn-info>\n  </label>\n  <select\n    ng-if=\"aggParam.options\"\n    ng-model=\"agg.params.interval\"\n    ng-change=\"agg.write()\"\n    required\n    ng-options=\"opt as opt.display for opt in aggParam.options.raw | filter: optionEnabled\"\n    class=\"form-control\"\n    name=\"interval\">\n    <option value=\"\">-- select a valid interval --</option>\n  </select>\n  <input\n    type=\"text\"\n    name=\"customInterval\"\n    ng-model=\"agg.params.customInterval\"\n    validate-date-interval\n    ng-change=\"aggForm.customInterval.$valid && agg.write()\"\n    ng-if=\"agg.params.interval.val == 'custom'\"\n    class=\"form-control\"\n    required />\n  <input\n    ng-if=\"!aggParam.options\"\n    ng-model=\"agg.params.interval\"\n    required\n    type=\"number\"\n    class=\"form-control\"\n    name=\"interval\"\n    min=\"0\"\n    input-whole-number\n    >\n</div>\n"

/***/ },
/* 599 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(586);
	__webpack_require__(600);
	__webpack_require__(597);
	__webpack_require__(598);
	__webpack_require__(601);
	__webpack_require__(602);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HistogramAggDefinition(Private) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);
	    var BucketAggType = Private(__webpack_require__(586));
	    var createFilter = Private(__webpack_require__(600));

	    __webpack_require__(597);

	    return new BucketAggType({
	      name: 'histogram',
	      title: 'Histogram',
	      ordered: {},
	      makeLabel: function makeLabel(aggConfig) {
	        return aggConfig.params.field.displayName;
	      },
	      createFilter: createFilter,
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'number'
	      }, {
	        name: 'interval',
	        editor: __webpack_require__(598),
	        write: function write(aggConfig, output) {
	          output.params.interval = parseInt(aggConfig.params.interval, 10);
	        }
	      }, {
	        name: 'min_doc_count',
	        'default': null,
	        editor: __webpack_require__(601),
	        write: function write(aggConfig, output) {
	          if (aggConfig.params.min_doc_count) {
	            output.params.min_doc_count = 0;
	          }
	        }
	      }, {
	        name: 'extended_bounds',
	        'default': {},
	        editor: __webpack_require__(602),
	        write: function write(aggConfig, output) {
	          var val = aggConfig.params.extended_bounds;

	          if (val.min != null || val.max != null) {
	            output.params.extended_bounds = {
	              min: val.min,
	              max: val.max
	            };
	          }
	        },

	        // called from the editor
	        shouldShow: function shouldShow(aggConfig) {
	          var field = aggConfig.params.field;
	          if (field && (field.type === 'number' || field.type === 'date')) {
	            return aggConfig.params.min_doc_count;
	          }
	        }
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 600 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(592);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var buildRangeFilter = __webpack_require__(592);

	  return function createHistogramFitlerProvider(Private) {
	    return function (aggConfig, key) {
	      var value = parseInt(key, 10);

	      return buildRangeFilter(aggConfig.params.field, { gte: value, lt: value + aggConfig.params.interval }, aggConfig.vis.indexPattern, aggConfig.fieldFormatter()(key));
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 601 */
/***/ function(module, exports) {

	module.exports = "<div class=\"checkbox ng-scope\">\n  <label>\n    <input ng-model=\"agg.params.min_doc_count\" type=\"checkbox\">\n    Show empty buckets&nbsp;\n    <kbn-info\n      info=\"Show all buckets, not only the buckets with results.\"\n      placement=\"right\">\n      </kbn-info>\n  </label>\n</div>"

/***/ },
/* 602 */
/***/ function(module, exports) {

	module.exports = "<div ng-if=\"aggParam.shouldShow(agg)\">\n  <div>\n    <label>Extended Bounds</label>\n    <kbn-info info=\"Min and Max do not filter the results, but rather extend the bounds of the result set.\"></kbn-info>\n  </div>\n  <div class=\"vis-editor-agg-form-row\">\n    <div class=\"form-group\">\n      <div>Min <small>(optional)</small></div>\n      <input\n        ng-model=\"agg.params.extended_bounds.min\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"extended_bounds.min\" />\n    </div>\n    <div class=\"form-group\">\n      <div>Max <small>(optional)</small></div>\n      <input\n        ng-model=\"agg.params.extended_bounds.max\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"extended_bounds.max\" />\n    </div>\n  </div>\n</div>"

/***/ },
/* 603 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(604);
	__webpack_require__(341);
	__webpack_require__(192);
	__webpack_require__(586);
	__webpack_require__(610);
	__webpack_require__(436);
	__webpack_require__(611);
	__webpack_require__(618);

	'use strict';

	var _WeakMap = __webpack_require__(604)['default'];

	var _Map = __webpack_require__(341)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function RangeAggDefinition(Private) {
	    var _ = __webpack_require__(192);
	    var BucketAggType = Private(__webpack_require__(586));
	    var createFilter = Private(__webpack_require__(610));
	    var FieldFormat = Private(__webpack_require__(436));
	    var RangeKey = Private(__webpack_require__(611));

	    var keyCaches = new _WeakMap();
	    var formats = new _WeakMap();

	    return new BucketAggType({
	      name: 'range',
	      title: 'Range',
	      createFilter: createFilter,
	      makeLabel: function makeLabel(aggConfig) {
	        return aggConfig.params.field.displayName + ' ranges';
	      },
	      getKey: function getKey(bucket, key, agg) {
	        var keys = keyCaches.get(agg);

	        if (!keys) {
	          keys = new _Map();
	          keyCaches.set(agg, keys);
	        }

	        var id = RangeKey.idBucket(bucket);

	        var key = keys.get(id);
	        if (!key) {
	          key = new RangeKey(bucket);
	          keys.set(id, key);
	        }

	        return key;
	      },
	      getFormat: function getFormat(agg) {
	        var format = formats.get(agg);
	        if (format) return format;

	        var RangeFormat = FieldFormat.from(function (range) {
	          var format = agg.fieldOwnFormatter();
	          return format(range.gte) + ' to ' + format(range.lt);
	        });

	        format = new RangeFormat();

	        formats.set(agg, format);
	        return format;
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: ['number']
	      }, {
	        name: 'ranges',
	        'default': [{ from: 0, to: 1000 }, { from: 1000, to: 2000 }],
	        editor: __webpack_require__(618),
	        write: function write(aggConfig, output) {
	          output.params.ranges = aggConfig.params.ranges;
	          output.params.keyed = true;
	        }
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 604 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(605), __esModule: true };

/***/ },
/* 605 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(343);
	__webpack_require__(272);
	__webpack_require__(606);
	module.exports = __webpack_require__(236).WeakMap;

/***/ },
/* 606 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $            = __webpack_require__(203)
	  , weak         = __webpack_require__(607)
	  , isObject     = __webpack_require__(232)
	  , has          = __webpack_require__(286)
	  , frozenStore  = weak.frozenStore
	  , WEAK         = weak.WEAK
	  , isExtensible = Object.isExtensible || isObject
	  , tmp          = {};

	// 23.3 WeakMap Objects
	var $WeakMap = __webpack_require__(350)('WeakMap', function(get){
	  return function WeakMap(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      if(!isExtensible(key))return frozenStore(this).get(key);
	      if(has(key, WEAK))return key[WEAK][this._i];
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	}, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  $.each.call(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    __webpack_require__(282)(proto, key, function(a, b){
	      // store frozen objects on leaky map
	      if(isObject(a) && !isExtensible(a)){
	        var result = frozenStore(this)[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 607 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide         = __webpack_require__(283)
	  , anObject     = __webpack_require__(296)
	  , strictNew    = __webpack_require__(347)
	  , forOf        = __webpack_require__(348)
	  , method       = __webpack_require__(608)
	  , WEAK         = __webpack_require__(289)('weak')
	  , isObject     = __webpack_require__(232)
	  , $has         = __webpack_require__(286)
	  , isExtensible = Object.isExtensible || isObject
	  , find         = method(5)
	  , findIndex    = method(6)
	  , id           = 0;

	// fallback for frozen keys
	var frozenStore = function(that){
	  return that._l || (that._l = new FrozenStore);
	};
	var FrozenStore = function(){
	  this.a = [];
	};
	var findFrozen = function(store, key){
	  return find(store.a, function(it){
	    return it[0] === key;
	  });
	};
	FrozenStore.prototype = {
	  get: function(key){
	    var entry = findFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = findIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      strictNew(that, C, NAME);
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    __webpack_require__(349)(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this)['delete'](key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        if(!isExtensible(key))return frozenStore(this).has(key);
	        return $has(key, WEAK) && $has(key[WEAK], this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    if(!isExtensible(anObject(key))){
	      frozenStore(that).set(key, value);
	    } else {
	      $has(key, WEAK) || hide(key, WEAK, {});
	      key[WEAK][that._i] = value;
	    } return that;
	  },
	  frozenStore: frozenStore,
	  WEAK: WEAK
	};

/***/ },
/* 608 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(320)
	  , isObject = __webpack_require__(232)
	  , IObject  = __webpack_require__(278)
	  , toObject = __webpack_require__(244)
	  , toLength = __webpack_require__(324)
	  , isArray  = __webpack_require__(609)
	  , SPECIES  = __webpack_require__(287)('species');
	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var ASC = function(original, length){
	  var C;
	  if(isArray(original) && isObject(C = original.constructor)){
	    C = C[SPECIES];
	    if(C === null)C = undefined;
	  } return new (C === undefined ? Array : C)(length);
	};
	module.exports = function(TYPE){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? ASC($this, length) : IS_FILTER ? ASC($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 609 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(279);
	module.exports = Array.isArray || function(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 610 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(592);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var buildRangeFilter = __webpack_require__(592);
	  return function createRangeFilterProvider(Private) {
	    return function (aggConfig, key) {
	      return buildRangeFilter(aggConfig.params.field, key, aggConfig.vis.indexPattern, aggConfig.fieldFormatter()(key));
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 611 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = __webpack_require__(222)['default'];

	var _classCallCheck = __webpack_require__(225)['default'];

	var _Symbol = __webpack_require__(612)['default'];

	module.exports = function () {

	  var id = _Symbol('id');

	  var RangeKey = (function () {
	    function RangeKey(bucket) {
	      _classCallCheck(this, RangeKey);

	      this.gte = bucket.from == null ? -Infinity : bucket.from;
	      this.lt = bucket.to == null ? +Infinity : bucket.to;

	      this[id] = RangeKey.idBucket(bucket);
	    }

	    _createClass(RangeKey, [{
	      key: 'toString',
	      value: function toString() {
	        return this[id];
	      }
	    }], [{
	      key: 'idBucket',
	      value: function idBucket(bucket) {
	        return 'from:' + bucket.from + ',to:' + bucket.to;
	      }
	    }]);

	    return RangeKey;
	  })();

	  return RangeKey;
	};

/***/ },
/* 612 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(613), __esModule: true };

/***/ },
/* 613 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(614);
	module.exports = __webpack_require__(236).Symbol;

/***/ },
/* 614 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var $              = __webpack_require__(203)
	  , global         = __webpack_require__(235)
	  , has            = __webpack_require__(286)
	  , SUPPORT_DESC   = __webpack_require__(285)
	  , $def           = __webpack_require__(234)
	  , $redef         = __webpack_require__(282)
	  , $fails         = __webpack_require__(237)
	  , shared         = __webpack_require__(288)
	  , setTag         = __webpack_require__(291)
	  , uid            = __webpack_require__(289)
	  , wks            = __webpack_require__(287)
	  , keyOf          = __webpack_require__(615)
	  , $names         = __webpack_require__(616)
	  , enumKeys       = __webpack_require__(617)
	  , isArray        = __webpack_require__(609)
	  , anObject       = __webpack_require__(296)
	  , toIObject      = __webpack_require__(277)
	  , createDesc     = __webpack_require__(284)
	  , getDesc        = $.getDesc
	  , setDesc        = $.setDesc
	  , _create        = $.create
	  , getNames       = $names.get
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , setter         = false
	  , HIDDEN         = wks('_hidden')
	  , isEnum         = $.isEnum
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , useNative      = typeof $Symbol == 'function'
	  , ObjectProto    = Object.prototype;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = SUPPORT_DESC && $fails(function(){
	  return _create(setDesc({}, 'a', {
	    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = getDesc(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  setDesc(it, key, D);
	  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
	} : setDesc;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol.prototype);
	  sym._k = tag;
	  SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
	    configurable: true,
	    set: function(value){
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    }
	  });
	  return sym;
	};

	var isSymbol = function(it){
	  return typeof it == 'symbol';
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(D && has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return setDesc(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key);
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
	    ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = getDesc(it = toIObject(it), key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = getNames(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	var $stringify = function stringify(it){
	  var args = [it]
	    , i    = 1
	    , $$   = arguments
	    , replacer, $replacer;
	  while($$.length > i)args.push($$[i++]);
	  replacer = args[1];
	  if(typeof replacer == 'function')$replacer = replacer;
	  if($replacer || !isArray(replacer))replacer = function(key, value){
	    if($replacer)value = $replacer.call(this, key, value);
	    if(!isSymbol(value))return value;
	  };
	  args[1] = replacer;
	  return _stringify.apply($JSON, args);
	};
	var buggyJSON = $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	});

	// 19.4.1.1 Symbol([description])
	if(!useNative){
	  $Symbol = function Symbol(){
	    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
	    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
	  };
	  $redef($Symbol.prototype, 'toString', function toString(){
	    return this._k;
	  });

	  isSymbol = function(it){
	    return it instanceof $Symbol;
	  };

	  $.create     = $create;
	  $.isEnum     = $propertyIsEnumerable;
	  $.getDesc    = $getOwnPropertyDescriptor;
	  $.setDesc    = $defineProperty;
	  $.setDescs   = $defineProperties;
	  $.getNames   = $names.get = $getOwnPropertyNames;
	  $.getSymbols = $getOwnPropertySymbols;

	  if(SUPPORT_DESC && !__webpack_require__(281)){
	    $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	}

	var symbolStatics = {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    return keyOf(SymbolRegistry, key);
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	};
	// 19.4.2.2 Symbol.hasInstance
	// 19.4.2.3 Symbol.isConcatSpreadable
	// 19.4.2.4 Symbol.iterator
	// 19.4.2.6 Symbol.match
	// 19.4.2.8 Symbol.replace
	// 19.4.2.9 Symbol.search
	// 19.4.2.10 Symbol.species
	// 19.4.2.11 Symbol.split
	// 19.4.2.12 Symbol.toPrimitive
	// 19.4.2.13 Symbol.toStringTag
	// 19.4.2.14 Symbol.unscopables
	$.each.call((
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
	  'species,split,toPrimitive,toStringTag,unscopables'
	).split(','), function(it){
	  var sym = wks(it);
	  symbolStatics[it] = useNative ? sym : wrap(sym);
	});

	setter = true;

	$def($def.G + $def.W, {Symbol: $Symbol});

	$def($def.S, 'Symbol', symbolStatics);

	$def($def.S + $def.F * !useNative, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setTag(global.JSON, 'JSON', true);

/***/ },
/* 615 */
/***/ function(module, exports, __webpack_require__) {

	var $         = __webpack_require__(203)
	  , toIObject = __webpack_require__(277);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = $.getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 616 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toString  = {}.toString
	  , toIObject = __webpack_require__(277)
	  , getNames  = __webpack_require__(203).getNames;

	var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return getNames(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.get = function getOwnPropertyNames(it){
	  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
	  return getNames(toIObject(it));
	};

/***/ },
/* 617 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var $ = __webpack_require__(203);
	module.exports = function(it){
	  var keys       = $.getKeys(it)
	    , getSymbols = $.getSymbols;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = $.isEnum
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
	  }
	  return keys;
	};

/***/ },
/* 618 */
/***/ function(module, exports) {

	module.exports = "<table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.length\">\n  <tr>\n    <th>\n      <label>From</label>\n    </th>\n    <th colspan=\"2\">\n      <label>To</label>\n    </th>\n  </tr>\n\n  <tr\n    ng-repeat=\"range in agg.params.ranges track by $index\">\n    <td>\n      <input\n        ng-model=\"range.from\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"range.from\"\n        step=\"any\" />\n    </td>\n    <td>\n      <input\n        ng-model=\"range.to\"\n        type=\"number\"\n        class=\"form-control\"\n        name=\"range.to\"\n        step=\"any\" />\n    </td>\n    <td>\n      <button\n        type=\"button\"\n        ng-click=\"agg.params.ranges.splice($index, 1)\"\n        class=\"btn btn-danger btn-xs\">\n        <i class=\"fa fa-times\"></i>\n      </button>\n    </td>\n  </tr>\n</table>\n\n<input ng-model=\"agg.params.ranges.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n<div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n  <p>\n    <i class=\"fa fa-danger text-danger\"></i>\n    <strong>Required:</strong> You must specify at least one range.\n  </p>\n</div>\n\n<div\n  ng-click=\"agg.params.ranges.push({})\"\n  class=\"sidebar-item-button primary\">\n  Add Range\n</div>"

/***/ },
/* 619 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);
	__webpack_require__(620);
	__webpack_require__(621);
	__webpack_require__(586);
	__webpack_require__(622);
	__webpack_require__(443);
	__webpack_require__(623);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var moment = __webpack_require__(226);
	  var dateRange = __webpack_require__(620);
	  __webpack_require__(621);

	  return function DateRangeAggDefinition(Private, config) {
	    var BucketAggType = Private(__webpack_require__(586));
	    var createFilter = Private(__webpack_require__(622));
	    var fieldFormats = Private(__webpack_require__(443));

	    return new BucketAggType({
	      name: 'date_range',
	      title: 'Date Range',
	      createFilter: createFilter,
	      getKey: function getKey(bucket, key, agg) {
	        var formatter = agg.fieldOwnFormatter('text', fieldFormats.getDefaultInstance('date'));
	        return dateRange.toString(bucket, formatter);
	      },
	      getFormat: function getFormat() {
	        return fieldFormats.getDefaultInstance('string');
	      },
	      makeLabel: function makeLabel(aggConfig) {
	        return aggConfig.params.field.displayName + ' date ranges';
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'date',
	        'default': function _default(agg) {
	          return agg.vis.indexPattern.timeFieldName;
	        }
	      }, {
	        name: 'ranges',
	        'default': [{
	          from: 'now-1w/w',
	          to: 'now'
	        }],
	        editor: __webpack_require__(623)
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 620 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var moment = __webpack_require__(226);

	  return {
	    toString: function toString(range, format) {
	      if (!range.from) {
	        return 'Before ' + format(range.to);
	      } else if (!range.to) {
	        return 'After ' + format(range.from);
	      } else {
	        return format(range.from) + ' to ' + format(range.to);
	      }
	    },
	    parse: function parse(rangeString, format) {
	      var chunks = rangeString.split(' to ');
	      if (chunks.length === 2) return { from: moment(chunks[0], format), to: moment(chunks[1], format) };

	      chunks = rangeString.split('Before ');
	      if (chunks.length === 2) return { to: moment(chunks[1], format) };

	      chunks = rangeString.split('After ');
	      if (chunks.length === 2) return { from: moment(chunks[1], format) };

	      throw new Error('Error attempting to parse date range: ' + rangeString);
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 621 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(228);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var dateMath = __webpack_require__(228);

	  __webpack_require__(214).get('kibana').directive('validateDateMath', function () {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      scope: {
	        'ngModel': '='
	      },
	      link: function link($scope, elem, attr, ngModel) {
	        ngModel.$parsers.unshift(validateDateMath);
	        ngModel.$formatters.unshift(validateDateMath);

	        function validateDateMath(input) {
	          if (input == null || input === '') {
	            ngModel.$setValidity('validDateMath', true);
	            return null;
	          }

	          var moment = dateMath.parse(input);
	          ngModel.$setValidity('validDateMath', moment != null && moment.isValid());
	          return input;
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 622 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(620);
	__webpack_require__(592);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var dateRange = __webpack_require__(620);

	  return function createDateRangeFilterProvider(config) {
	    var buildRangeFilter = __webpack_require__(592);

	    return function (agg, key) {
	      var range = dateRange.parse(key, config.get('dateFormat'));

	      var filter = {};
	      if (range.from) filter.gte = +range.from;
	      if (range.to) filter.lt = +range.to;
	      if (range.to && range.from) filter.format = 'epoch_millis';

	      return buildRangeFilter(agg.params.field, filter, agg.vis.indexPattern);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 623 */
/***/ function(module, exports) {

	module.exports = "<div>\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.length\">\n      <tr>\n        <th>\n          <label>From</label>\n        </th>\n        <th colspan=\"2\">\n          <label>To</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges track by $index\">\n        <td class=\"kbn-timepicker\">\n          <input\n            ng-model=\"range.from\"\n            validate-date-math\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td class=\"kbn-timepicker\">\n          <input\n            ng-model=\"range.to\"\n            validate-date-math\n            class=\"form-control\"\n            name=\"range.to\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            ng-click=\"agg.params.ranges.splice($index, 1)\"\n            class=\"btn btn-danger btn-xs\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n      <tr>\n        <td colspan=\"3\">\n          <small>\n            <a target=\"_window\" href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#date-math\">Accepted Date Formats <i class=\"fa-link fa\"></i></a>\n          </small>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-model=\"agg.params.ranges.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one date range.\n      </p>\n    </div>\n\n    <div\n      ng-click=\"agg.params.ranges.push({})\"\n      class=\"sidebar-item-button primary\">\n      Add Range\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 624 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(625);
	__webpack_require__(627);
	__webpack_require__(586);
	__webpack_require__(629);
	__webpack_require__(630);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  __webpack_require__(625);
	  __webpack_require__(627);

	  return function RangeAggDefinition(Private) {
	    var BucketAggType = Private(__webpack_require__(586));
	    var createFilter = Private(__webpack_require__(629));

	    return new BucketAggType({
	      name: 'ip_range',
	      title: 'IPv4 Range',
	      createFilter: createFilter,
	      makeLabel: function makeLabel(aggConfig) {
	        return aggConfig.params.field.displayName + ' IP ranges';
	      },
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'ip'
	      }, {
	        name: 'ipRangeType',
	        'default': 'fromTo',
	        write: _.noop
	      }, {
	        name: 'ranges',
	        'default': {
	          fromTo: [{ from: '0.0.0.0', to: '127.255.255.255' }, { from: '128.0.0.0', to: '191.255.255.255' }],
	          mask: [{ mask: '0.0.0.0/1' }, { mask: '128.0.0.0/2' }]
	        },
	        editor: __webpack_require__(630),
	        write: function write(aggConfig, output) {
	          var ipRangeType = aggConfig.params.ipRangeType;
	          output.params.ranges = aggConfig.params.ranges[ipRangeType];
	        }
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 625 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(626);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var Ipv4Address = __webpack_require__(626);

	  __webpack_require__(214).get('kibana').directive('validateIp', function () {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      scope: {
	        'ngModel': '='
	      },
	      link: function link($scope, elem, attr, ngModel) {
	        function validateIp(ipAddress) {
	          if (ipAddress == null || ipAddress === '') {
	            ngModel.$setValidity('ipInput', true);
	            return null;
	          }

	          try {
	            ipAddress = new Ipv4Address(ipAddress);
	            ngModel.$setValidity('ipInput', true);
	            return ipAddress.toString();
	          } catch (e) {
	            ngModel.$setValidity('ipInput', false);
	          }
	        }

	        // From User
	        ngModel.$parsers.unshift(validateIp);

	        // To user
	        ngModel.$formatters.unshift(validateIp);
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 626 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  var NUM_BYTES = 4;
	  var BYTE_SIZE = 256;

	  function throwError(ipAddress) {
	    throw Error('Invalid IPv4 address: ' + ipAddress);
	  }

	  function isIntegerInRange(integer, min, max) {
	    return !isNaN(integer) && integer >= min && integer < max && integer % 1 === 0;
	  }

	  function Ipv4Address(ipAddress) {
	    this.value = ipAddress;

	    if (typeof ipAddress === 'string') {
	      this.value = 0;

	      var bytes = ipAddress.split('.');
	      if (bytes.length !== NUM_BYTES) throwError(ipAddress);

	      for (var i = 0; i < bytes.length; i++) {
	        var byte = Number(bytes[i]);
	        if (!isIntegerInRange(byte, 0, BYTE_SIZE)) throwError(ipAddress);
	        this.value += Math.pow(BYTE_SIZE, NUM_BYTES - 1 - i) * byte;
	      }
	    }

	    if (!isIntegerInRange(this.value, 0, Math.pow(BYTE_SIZE, NUM_BYTES))) throwError(ipAddress);
	  }

	  Ipv4Address.prototype.toString = function () {
	    var value = this.value;
	    var bytes = [];
	    for (var i = 0; i < NUM_BYTES; i++) {
	      bytes.unshift(value % 256);
	      value = Math.floor(value / 256);
	    }
	    return bytes.join('.');
	  };

	  Ipv4Address.prototype.valueOf = function () {
	    return this.value;
	  };

	  return Ipv4Address;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 627 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(628);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var CidrMask = __webpack_require__(628);

	  __webpack_require__(214).get('kibana').directive('validateCidrMask', function () {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      scope: {
	        'ngModel': '='
	      },
	      link: function link($scope, elem, attr, ngModel) {
	        ngModel.$parsers.unshift(validateCidrMask);
	        ngModel.$formatters.unshift(validateCidrMask);

	        function validateCidrMask(mask) {
	          if (mask == null || mask === '') {
	            ngModel.$setValidity('cidrMaskInput', true);
	            return null;
	          }

	          try {
	            mask = new CidrMask(mask);
	            ngModel.$setValidity('cidrMaskInput', true);
	            return mask.toString();
	          } catch (e) {
	            ngModel.$setValidity('cidrMaskInput', false);
	          }
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 628 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(626);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var Ipv4Address = __webpack_require__(626);
	  var NUM_BITS = 32;

	  function throwError(mask) {
	    throw Error('Invalid CIDR mask: ' + mask);
	  }

	  function CidrMask(mask) {
	    var splits = mask.split('\/');
	    if (splits.length !== 2) throwError(mask);
	    this.initialAddress = new Ipv4Address(splits[0]);
	    this.prefixLength = Number(splits[1]);
	    if (this.prefixLength < 1 || this.prefixLength > NUM_BITS) throwError(mask);
	  }

	  CidrMask.prototype.getRange = function () {
	    var variableBits = NUM_BITS - this.prefixLength;
	    var fromAddress = this.initialAddress.valueOf() >> variableBits << variableBits >>> 0; // >>> 0 coerces to unsigned
	    var numAddresses = Math.pow(2, variableBits);
	    return {
	      from: new Ipv4Address(fromAddress).toString(),
	      to: new Ipv4Address(fromAddress + numAddresses - 1).toString()
	    };
	  };

	  CidrMask.prototype.toString = function () {
	    return this.initialAddress.toString() + '/' + this.prefixLength;
	  };

	  return CidrMask;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 629 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(628);
	__webpack_require__(592);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var CidrMask = __webpack_require__(628);
	  var buildRangeFilter = __webpack_require__(592);
	  return function createIpRangeFilterProvider() {
	    return function (aggConfig, key) {
	      var range;
	      if (aggConfig.params.ipRangeType === 'mask') {
	        range = new CidrMask(key).getRange();
	      } else {
	        var addresses = key.split(/\-/);
	        range = {
	          from: addresses[0],
	          to: addresses[1]
	        };
	      }

	      return buildRangeFilter(aggConfig.params.field, { gte: range.from, lte: range.to }, aggConfig.vis.indexPattern);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 630 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <p>\n    <button type=\"button\" class=\"btn btn-default\" ng-show=\"agg.params.ipRangeType == 'mask'\" ng-click=\"agg.params.ipRangeType = 'fromTo'\">Use From/To</button>\n    <button type=\"button\" class=\"btn btn-default\" ng-show=\"agg.params.ipRangeType != 'mask'\" ng-click=\"agg.params.ipRangeType = 'mask'\">Use CIDR Masks</button>\n  </p>\n\n  <div ng-show=\"agg.params.ipRangeType != 'mask'\">\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.fromTo.length\">\n      <tr>\n        <th>\n          <label>From</label>\n        </th>\n        <th colspan=\"2\">\n          <label>To</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges.fromTo track by $index\">\n        <td>\n          <input\n            validate-ip\n            ng-model=\"range.from\"\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td>\n          <input\n            validate-ip\n            ng-model=\"range.to\"\n            class=\"form-control\"\n            name=\"range.to\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            ng-click=\"agg.params.ranges.fromTo.splice($index, 1)\"\n            class=\"btn btn-danger btn-xs\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-if=\"agg.params.ipRangeType != 'mask'\" ng-model=\"agg.params.ranges.fromTo.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one IP range.\n      </p>\n    </div>\n\n    <div\n      ng-click=\"agg.params.ranges.fromTo.push({})\"\n      class=\"sidebar-item-button primary\">\n      Add Range\n    </div>\n  </div>\n\n  <div ng-show=\"agg.params.ipRangeType == 'mask'\">\n    <table class=\"vis-editor-agg-editor-ranges form-group\" ng-show=\"agg.params.ranges.mask.length\">\n      <tr>\n        <th>\n          <label>Mask</label>\n        </th>\n      </tr>\n\n      <tr\n        ng-repeat=\"range in agg.params.ranges.mask track by $index\">\n        <td>\n          <input\n            validate-cidr-mask\n            ng-model=\"range.mask\"\n            type=\"text\"\n            class=\"form-control\"\n            name=\"range.from\" />\n        </td>\n        <td>\n          <button\n            type=\"button\"\n            ng-click=\"agg.params.ranges.mask.splice($index, 1)\"\n            class=\"btn btn-danger btn-xs\">\n            <i class=\"fa fa-times\" ></i>\n          </button>\n        </td>\n      </tr>\n    </table>\n\n    <input ng-if=\"agg.params.ipRangeType == 'mask'\" ng-model=\"agg.params.ranges.mask.length\" name=\"rangeLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n    <div class=\"hintbox\" ng-show=\"aggForm.rangeLength.$invalid\">\n      <p>\n        <i class=\"fa fa-danger text-danger\"></i>\n        <strong>Required:</strong> You must specify at least one IP range.\n      </p>\n    </div>\n\n    <div\n      ng-click=\"agg.params.ranges.mask.push({})\"\n      class=\"sidebar-item-button primary\">\n      Add Range\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 631 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(586);
	__webpack_require__(632);
	__webpack_require__(633);
	__webpack_require__(634);
	__webpack_require__(637);
	__webpack_require__(639);
	__webpack_require__(640);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TermsAggDefinition(Private) {
	    var _ = __webpack_require__(192);
	    var BucketAggType = Private(__webpack_require__(586));
	    var bucketCountBetween = Private(__webpack_require__(632));
	    var AggConfig = Private(__webpack_require__(633));
	    var Schemas = Private(__webpack_require__(634));
	    var createFilter = Private(__webpack_require__(637));

	    var orderAggSchema = new Schemas([{
	      group: 'none',
	      name: 'orderAgg',
	      title: 'Order Agg',
	      aggFilter: ['!percentiles', '!median', '!std_dev']
	    }]).all[0];

	    function isNotType(type) {
	      return function (agg) {
	        var field = agg.params.field;
	        return !field || field.type !== type;
	      };
	    }

	    return new BucketAggType({
	      name: 'terms',
	      title: 'Terms',
	      makeLabel: function makeLabel(agg) {
	        var params = agg.params;
	        return params.field.displayName + ': ' + params.order.display;
	      },
	      createFilter: createFilter,
	      params: [{
	        name: 'field',
	        scriptable: true,
	        filterFieldTypes: ['number', 'boolean', 'date', 'ip', 'string']
	      }, {
	        name: 'exclude',
	        type: 'regex',
	        advanced: true,
	        disabled: isNotType('string')
	      }, {
	        name: 'include',
	        type: 'regex',
	        advanced: true,
	        disabled: isNotType('string')
	      }, {
	        name: 'size',
	        'default': 5
	      }, {
	        name: 'orderAgg',
	        type: AggConfig,
	        'default': null,
	        editor: __webpack_require__(639),
	        serialize: function serialize(orderAgg) {
	          return orderAgg.toJSON();
	        },
	        deserialize: function deserialize(state, agg) {
	          return this.makeOrderAgg(agg, state);
	        },
	        makeOrderAgg: function makeOrderAgg(termsAgg, state) {
	          state = state || {};
	          state.schema = orderAggSchema;
	          var orderAgg = new AggConfig(termsAgg.vis, state);
	          orderAgg.id = termsAgg.id + '-orderAgg';
	          return orderAgg;
	        },
	        controller: function controller($scope) {
	          $scope.safeMakeLabel = function (agg) {
	            try {
	              return agg.makeLabel();
	            } catch (e) {
	              return '- agg not valid -';
	            }
	          };

	          var INIT = {}; // flag to know when prevOrderBy has changed
	          var prevOrderBy = INIT;

	          $scope.$watch('responseValueAggs', updateOrderAgg);
	          $scope.$watch('agg.params.orderBy', updateOrderAgg);

	          function updateOrderAgg() {
	            var agg = $scope.agg;
	            var aggs = agg.vis.aggs;
	            var params = agg.params;
	            var orderBy = params.orderBy;
	            var paramDef = agg.type.params.byName.orderAgg;

	            // setup the initial value of orderBy
	            if (!orderBy && prevOrderBy === INIT) {
	              // abort until we get the responseValueAggs
	              if (!$scope.responseValueAggs) return;
	              params.orderBy = (_.first($scope.responseValueAggs) || { id: 'custom' }).id;
	              return;
	            }

	            // track the previous value
	            prevOrderBy = orderBy;

	            // we aren't creating a custom aggConfig
	            if (!orderBy || orderBy !== 'custom') {
	              params.orderAgg = null;

	              if (orderBy === '_term') {
	                params.orderBy = '_term';
	                return;
	              }

	              // ensure that orderBy is set to a valid agg
	              if (!_.find($scope.responseValueAggs, { id: orderBy })) {
	                params.orderBy = null;
	              }
	              return;
	            }

	            params.orderAgg = params.orderAgg || paramDef.makeOrderAgg(agg);
	          }
	        },
	        write: function write(agg, output) {
	          var vis = agg.vis;
	          var dir = agg.params.order.val;
	          var order = output.params.order = {};

	          var orderAgg = agg.params.orderAgg || vis.aggs.getResponseAggById(agg.params.orderBy);

	          // TODO: This works around an Elasticsearch bug the always casts terms agg scripts to strings
	          // thus causing issues with filtering. This probably causes other issues since float might not
	          // be able to contain the number on the elasticsearch side
	          if (output.params.script) {
	            output.params.valueType = agg.field().type === 'number' ? 'float' : agg.field().type;
	          }

	          if (!orderAgg) {
	            order[agg.params.orderBy || '_count'] = dir;
	            return;
	          }

	          if (orderAgg.type.name === 'count') {
	            order._count = dir;
	            return;
	          }

	          var orderAggId = orderAgg.id;
	          if (orderAgg.parentId) {
	            orderAgg = vis.aggs.byId[orderAgg.parentId];
	          }

	          output.subAggs = (output.subAggs || []).concat(orderAgg);
	          order[orderAggId] = dir;
	        }
	      }, {
	        name: 'order',
	        type: 'optioned',
	        'default': 'desc',
	        editor: __webpack_require__(640),
	        options: [{ display: 'Descending', val: 'desc' }, { display: 'Ascending', val: 'asc' }],
	        write: _.noop // prevent default write, it's handled by orderAgg
	      }, {
	        name: 'orderBy',
	        write: _.noop // prevent default write, it's handled by orderAgg
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 632 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function BucketCountBetweenProvider() {

	    /**
	     * Count the number of bucket aggs between two agg config objects owned
	     * by the same vis.
	     *
	     * If one of the two aggs was not found in the agg list, returns null.
	     * If a was found after b, the count will be negative
	     * If a was found first, the count will be positive.
	     *
	     * @param  {AggConfig} aggConfigA - the aggConfig that is expected first
	     * @param  {AggConfig} aggConfigB - the aggConfig that is expected second
	     * @return {null|number}
	     */
	    function bucketCountBetween(aggConfigA, aggConfigB) {
	      var aggs = aggConfigA.vis.aggs.getRequestAggs();

	      var aIndex = aggs.indexOf(aggConfigA);
	      var bIndex = aggs.indexOf(aggConfigB);

	      if (aIndex === -1 || bIndex === -1) {
	        return null;
	      }

	      // return a negative distance, if b is before a
	      var negative = aIndex > bIndex;

	      var count = aggs.slice(Math.min(aIndex, bIndex), Math.max(aIndex, bIndex)).reduce(function (count, cfg) {
	        if (cfg === aggConfigA || cfg === aggConfigB || cfg.schema.group !== 'buckets') {
	          return count;
	        } else {
	          return count + 1;
	        }
	      }, 0);

	      return (negative ? -1 : 1) * count;
	    }

	    return bucketCountBetween;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 633 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(204);
	__webpack_require__(192);
	__webpack_require__(443);

	'use strict';

	var _Object$defineProperties = __webpack_require__(204)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggConfigFactory(Private, fieldTypeFilter) {
	    var _ = __webpack_require__(192);
	    var fieldFormats = Private(__webpack_require__(443));

	    function AggConfig(vis, opts) {
	      var self = this;

	      self.id = String(opts.id || AggConfig.nextId(vis.aggs));
	      self.vis = vis;
	      self._opts = opts = opts || {};

	      // setters
	      self.type = opts.type;
	      self.schema = opts.schema;

	      // resolve the params
	      self.fillDefaults(opts.params);
	    }

	    /**
	     * Ensure that all of the objects in the list have ids, the objects
	     * and list are modified by reference.
	     *
	     * @param  {array[object]} list - a list of objects, objects can be anything really
	     * @return {array} - the list that was passed in
	     */
	    AggConfig.ensureIds = function (list) {
	      var have = [];
	      var haveNot = [];
	      list.forEach(function (obj) {
	        (obj.id ? have : haveNot).push(obj);
	      });

	      var nextId = AggConfig.nextId(have);
	      haveNot.forEach(function (obj) {
	        obj.id = String(nextId++);
	      });

	      return list;
	    };

	    /**
	     * Calculate the next id based on the ids in this list
	     *
	     * @return {array} list - a list of objects with id properties
	     */
	    AggConfig.nextId = function (list) {
	      return 1 + list.reduce(function (max, obj) {
	        return Math.max(max, +obj.id || 0);
	      }, 0);
	    };

	    _Object$defineProperties(AggConfig.prototype, {
	      type: {
	        get: function get() {
	          return this.__type;
	        },
	        set: function set(type) {
	          if (this.__typeDecorations) {
	            _.forOwn(this.__typeDecorations, function (prop, name) {
	              delete this[name];
	            }, this);
	          }

	          if (_.isString(type)) {
	            type = AggConfig.aggTypes.byName[type];
	          }

	          if (type && _.isFunction(type.decorateAggConfig)) {
	            this.__typeDecorations = type.decorateAggConfig();
	            _Object$defineProperties(this, this.__typeDecorations);
	          }

	          this.__type = type;
	        }
	      },
	      schema: {
	        get: function get() {
	          return this.__schema;
	        },
	        set: function set(schema) {
	          if (_.isString(schema)) {
	            schema = this.vis.type.schemas.all.byName[schema];
	          }

	          this.__schema = schema;
	        }
	      }
	    });

	    /**
	     * Write the current values to this.params, filling in the defaults as we go
	     *
	     * @param  {object} [from] - optional object to read values from,
	     *                         used when initializing
	     * @return {undefined}
	     */
	    AggConfig.prototype.fillDefaults = function (from) {
	      var self = this;
	      from = from || self.params || {};
	      var to = self.params = {};

	      self.getAggParams().forEach(function (aggParam) {
	        var val = from[aggParam.name];

	        if (val == null) {
	          if (aggParam['default'] == null) return;

	          if (!_.isFunction(aggParam['default'])) {
	            val = aggParam['default'];
	          } else {
	            val = aggParam['default'](self);
	            if (val == null) return;
	          }
	        }

	        if (aggParam.deserialize) {
	          var isTyped = _.isFunction(aggParam.type);

	          var isType = isTyped && val instanceof aggParam.type;
	          var isObject = !isTyped && _.isObject(val);
	          var isDeserialized = isType || isObject;

	          if (!isDeserialized) {
	            val = aggParam.deserialize(val, self);
	          }

	          to[aggParam.name] = val;
	          return;
	        }

	        to[aggParam.name] = _.cloneDeep(val);
	      });
	    };

	    /**
	     * Clear the parameters for this aggConfig
	     *
	     * @return {object} the new params object
	     */
	    AggConfig.prototype.resetParams = function () {
	      var fieldParam = this.type && this.type.params.byName.field;
	      var field;

	      if (fieldParam) {
	        var prevField = this.params.field;
	        var fieldOpts = fieldTypeFilter(this.vis.indexPattern.fields, fieldParam.filterFieldTypes);
	        field = _.contains(fieldOpts, prevField) ? prevField : null;
	      }

	      return this.fillDefaults({ row: this.params.row, field: field });
	    };

	    AggConfig.prototype.write = function () {
	      return this.type.params.write(this);
	    };

	    AggConfig.prototype.createFilter = function (key) {
	      if (!_.isFunction(this.type.createFilter)) {
	        throw new TypeError('The "' + this.type.title + '" aggregation does not support filtering.');
	      }

	      var field = this.field();
	      var label = this.fieldDisplayName();
	      if (field && !field.filterable) {
	        var message = 'The "' + label + '" field can not be used for filtering.';
	        if (field.scripted) {
	          message = 'The "' + label + '" field is scripted and can not be used for filtering.';
	        }
	        throw new TypeError(message);
	      }

	      return this.type.createFilter(this, key);
	    };

	    /**
	     * Hook into param onRequest handling, and tell the aggConfig that it
	     * is being sent to elasticsearc.
	     *
	     * @return {[type]} [description]
	     */
	    AggConfig.prototype.requesting = function () {
	      var self = this;
	      self.type && self.type.params.forEach(function (param) {
	        if (param.onRequest) param.onRequest(self);
	      });
	    };

	    /**
	     * Convert this aggConfig to it's dsl syntax.
	     *
	     * Adds params and adhoc subaggs to a pojo, then returns it
	     *
	     * @param  {AggConfig} aggConfig - the config object to convert
	     * @return {void|Object} - if the config has a dsl representation, it is
	     *                         returned, else undefined is returned
	     */
	    AggConfig.prototype.toDsl = function () {
	      if (this.type.hasNoDsl) return;
	      var output = this.write();

	      var configDsl = {};
	      configDsl[this.type.dslName || this.type.name] = output.params;

	      // if the config requires subAggs, write them to the dsl as well
	      if (output.subAggs) {
	        var subDslLvl = configDsl.aggs || (configDsl.aggs = {});
	        output.subAggs.forEach(function nestAdhocSubAggs(subAggConfig) {
	          subDslLvl[subAggConfig.id] = subAggConfig.toDsl();
	        });
	      }

	      return configDsl;
	    };

	    AggConfig.prototype.toJSON = function () {
	      var self = this;
	      var params = self.params;

	      var outParams = _.transform(self.getAggParams(), function (out, aggParam) {
	        var val = params[aggParam.name];

	        // don't serialize undefined/null values
	        if (val == null) return;
	        if (aggParam.serialize) val = aggParam.serialize(val, self);
	        if (val == null) return;

	        // to prevent accidental leaking, we will clone all complex values
	        out[aggParam.name] = _.cloneDeep(val);
	      }, {});

	      return {
	        id: self.id,
	        type: self.type && self.type.name,
	        schema: self.schema && self.schema.name,
	        params: outParams
	      };
	    };

	    AggConfig.prototype.getAggParams = function () {
	      return [].concat(this.type ? this.type.params.raw : [], this.schema ? this.schema.params.raw : []);
	    };

	    AggConfig.prototype.getResponseAggs = function () {
	      if (!this.type) return;
	      return this.type.getResponseAggs(this) || [this];
	    };

	    AggConfig.prototype.getValue = function (bucket) {
	      return this.type.getValue(this, bucket);
	    };

	    AggConfig.prototype.getKey = function (bucket, key) {
	      return this.type.getKey(bucket, key, this);
	    };

	    AggConfig.prototype.makeLabel = function () {
	      if (!this.type) return '';
	      var pre = _.get(this.vis, 'params.mode') === 'percentage' ? 'Percentage of ' : '';
	      return pre += this.type.makeLabel(this);
	    };

	    AggConfig.prototype.field = function () {
	      return this.params.field;
	    };

	    AggConfig.prototype.fieldFormatter = function (contentType, defaultFormat) {
	      var format = this.type && this.type.getFormat(this);
	      if (format) return format.getConverterFor(contentType);
	      return this.fieldOwnFormatter(contentType, defaultFormat);
	    };

	    AggConfig.prototype.fieldOwnFormatter = function (contentType, defaultFormat) {
	      var field = this.field();
	      var format = field && field.format;
	      if (!format) format = defaultFormat;
	      if (!format) format = fieldFormats.getDefaultInstance('string');
	      return format.getConverterFor(contentType);
	    };

	    AggConfig.prototype.fieldName = function () {
	      var field = this.field();
	      return field ? field.name : '';
	    };

	    AggConfig.prototype.fieldDisplayName = function () {
	      var field = this.field();
	      return field ? field.displayName || this.fieldName() : '';
	    };

	    AggConfig.prototype.fieldIsTimeField = function () {
	      var timeFieldName = this.vis.indexPattern.timeFieldName;
	      return timeFieldName && this.fieldName() === timeFieldName;
	    };

	    return AggConfig;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 634 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(441);
	__webpack_require__(554);
	__webpack_require__(635);
	__webpack_require__(636);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function VisTypeSchemasFactory(Private) {
	    var _ = __webpack_require__(192);
	    var IndexedArray = __webpack_require__(441);
	    var AggParams = Private(__webpack_require__(554));

	    function Schemas(schemas) {
	      var self = this;

	      _(schemas || []).map(function (schema) {
	        if (!schema.name) throw new Error('all schema must have a unique name');

	        if (schema.name === 'split') {
	          schema.params = [{
	            name: 'row',
	            'default': true
	          }];
	          schema.editor = __webpack_require__(635);
	        } else if (schema.name === 'radius') {
	          schema.editor = __webpack_require__(636);
	        }

	        _.defaults(schema, {
	          min: 0,
	          max: Infinity,
	          group: 'buckets',
	          title: schema.name,
	          aggFilter: '*',
	          editor: false,
	          params: []
	        });

	        // convert the params into a params registry
	        schema.params = new AggParams(schema.params);

	        return schema;
	      }).tap(function (schemas) {
	        self.all = new IndexedArray({
	          index: ['name'],
	          group: ['group'],
	          immutable: true,
	          initialSet: schemas
	        });
	      }).groupBy('group').forOwn(function (group, groupName) {
	        self[groupName] = new IndexedArray({
	          index: ['name'],
	          immutable: true,
	          initialSet: group
	        });
	      }).commit();
	    }

	    return Schemas;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 635 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <div class=\"btn-group\">\n    <button\n      type=\"button\"\n      class=\"btn btn-xs btn-default\"\n      ng-model=\"agg.params.row\"\n      btn-radio=\"true\">\n      Rows\n    </button>\n    <button\n      type=\"button\"\n      class=\"btn btn-xs btn-default\"\n      ng-model=\"agg.params.row\"\n      btn-radio=\"false\">\n      Columns\n    </button>\n  </div>\n</div>"

/***/ },
/* 636 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <label>\n    Dot Size Ratio:\n    <kbn-info\n      placement=\"right\"\n      info=\"Change the ratio of the radius of the smallest point to the largest point.\">\n    </kbn-info>\n  </label>\n  <input type=\"range\" step=\"2\" min=\"1\" max=\"100\" class=\"form-control\" ng-model=\"vis.params.radiusRatio\" />\n</div>\n"

/***/ },
/* 637 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(638);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var buildPhraseFilter = __webpack_require__(638);
	  return function createTermsFilterProvider(Private) {
	    return function (aggConfig, key) {
	      return buildPhraseFilter(aggConfig.params.field, key, aggConfig.vis.indexPattern);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 638 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function buildPhraseFilter(field, value, indexPattern) {
	    var filter = { meta: { index: indexPattern.id } };

	    if (field.scripted) {
	      filter.script = {
	        script: '(' + field.script + ') == value',
	        lang: field.lang,
	        params: {
	          value: value
	        }
	      };
	      filter.meta.field = field.name;
	    } else {
	      filter.query = { match: {} };
	      filter.query.match[field.name] = {
	        query: value,
	        type: 'phrase'
	      };
	    }
	    return filter;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 639 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"aggParam.controller\">\n  <div class=\"form-group\">\n    <label>Order By</label>\n    <select\n      name=\"orderBy\"\n      ng-model=\"agg.params.orderBy\"\n      required\n      class=\"form-control\">\n      <option\n        ng-repeat=\"respAgg in responseValueAggs track by respAgg.id\"\n        value=\"{{respAgg.id}}\"\n        ng-selected=\"agg.params.orderBy === respAgg.id\">\n        metric: {{safeMakeLabel(respAgg)}}\n      </option>\n      <option value=\"custom\" ng-selected=\"agg.params.orderBy === 'custom'\">\n        Custom Metric\n      </option>\n       <option value=\"_term\" ng-selected=\"agg.params.orderBy === '_term'\">\n        Term\n      </option>\n    </select>\n  </div>\n  <div ng-show=\"agg.params.orderAgg\" class=\"vis-editor-agg-order-agg\">\n    <vis-editor-agg-params\n      agg=\"agg.params.orderAgg\"\n      ng-if=\"agg.params.orderAgg\"\n      group-name=\"'metrics'\">\n    </vis-editor-agg-params>\n  </div>\n</div>"

/***/ },
/* 640 */
/***/ function(module, exports) {

	module.exports = "<div class=\"vis-editor-agg-form-row\">\n  <div ng-if=\"agg.type.params.byName.order\" class=\"form-group\">\n    <label>Order</label>\n    <select\n      name=\"order\"\n      ng-model=\"agg.params.order\"\n      required\n      ng-options=\"opt as opt.display for opt in aggParam.options\"\n      class=\"form-control\">\n    </select>\n  </div>\n  <div class=\"form-group\">\n    <label>Size</label>\n    <input\n      name=\"size\"\n      ng-model=\"agg.params.size\"\n      required\n      class=\"form-control\"\n      type=\"number\"\n      min=\"0\"\n      >\n  </div>\n</div>"

/***/ },
/* 641 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(586);
	__webpack_require__(642);
	__webpack_require__(493);
	__webpack_require__(644);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function FiltersAggDefinition(Private, Notifier) {
	    var _ = __webpack_require__(192);
	    var angular = __webpack_require__(209);
	    var BucketAggType = Private(__webpack_require__(586));
	    var createFilter = Private(__webpack_require__(642));
	    var decorateQuery = Private(__webpack_require__(493));
	    var notif = new Notifier({ location: 'Filters Agg' });

	    return new BucketAggType({
	      name: 'filters',
	      title: 'Filters',
	      createFilter: createFilter,
	      params: [{
	        name: 'filters',
	        editor: __webpack_require__(644),
	        'default': [{ input: {}, label: '' }],
	        write: function write(aggConfig, output) {
	          var inFilters = aggConfig.params.filters;
	          if (!_.size(inFilters)) return;

	          var outFilters = _.transform(inFilters, function (filters, filter) {
	            var input = filter.input;
	            if (!input) return notif.log('malformed filter agg params, missing "input" query');

	            var query = input.query;
	            if (!query) return notif.log('malformed filter agg params, missing "query" on input');

	            decorateQuery(query);

	            var label = filter.label || _.get(query, 'query_string.query') || angular.toJson(query);
	            filters[label] = input;
	          }, {});

	          if (!_.size(outFilters)) return;

	          var params = output.params || (output.params = {});
	          params.filters = outFilters;
	        }
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 642 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(643);
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var buildQueryFilter = __webpack_require__(643);
	  var _ = __webpack_require__(192);
	  return function CreateFilterFiltersProvider(Private) {
	    return function (aggConfig, key) {
	      // have the aggConfig write agg dsl params
	      var dslFilters = _.get(aggConfig.toDsl(), 'filters.filters');
	      var filter = dslFilters[key];

	      if (filter) {
	        return buildQueryFilter(filter.query, aggConfig.vis.indexPattern.id);
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 643 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function buildQueryFilter(query, index) {
	    return {
	      query: query,
	      meta: {
	        index: index
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 644 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <div ng-repeat=\"filter in agg.params.filters\">\n    <div class=\"vis-editor-agg-header\">\n      <label>\n          Filter {{$index + 1}}\n          <span ng-if=\"filter.label\">- {{ filter.label }}</span>\n      </label>\n\n      <div class=\"btn-group\">\n        <button\n          ng-click=\"showConfig = !showConfig\"\n          type=\"button\"\n          class=\"btn btn-default btn-xs\">\n          <i class=\"fa fa-tag\"></i>\n        </button>\n        <button\n          type=\"button\"\n          ng-click=\"agg.params.filters.splice($index, 1)\"\n          class=\"btn btn-danger btn-xs\">\n          <i class=\"fa fa-times\"></i>\n        </button>\n      </div>\n    </div>\n\n    <div class=\"form-group\">\n      <input validate-query\n        ng-model=\"filter.input.query\"\n        type=\"text\"\n        class=\"form-control\"\n        name=\"filter{{$index}}\">\n    </div>\n\n    <div class=\"form-group\" ng-show=\"showConfig\">\n      <label>Filter {{$index + 1}} label</label>\n      <input\n        ng-model=\"filter.label\"\n        placeholder=\"Label\"\n        type=\"text\"\n        class=\"form-control\"\n        name=\"label{{$index}}\">\n    </div>\n  </div>\n</div>\n\n<input ng-model=\"agg.params.filters.length\" name=\"filterLength\" required min=\"1\" type=\"number\" class=\"ng-hide\" />\n<div class=\"hintbox\" ng-show=\"aggForm.filterLength.$invalid\">\n  <p>\n    <i class=\"fa fa-danger text-danger\"></i>\n    <strong>Required:</strong> You must specify at least one filter.\n  </p>\n</div>\n\n<div\n  click-focus=\"'filter'+(agg.params.filters.length-1)\"\n  ng-click=\"agg.params.filters.push({input:{}})\"\n  class=\"sidebar-item-button primary\">\n  Add Filter\n</div>\n"

/***/ },
/* 645 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(586);
	__webpack_require__(637);
	__webpack_require__(640);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function SignificantTermsAggDefinition(Private) {
	    var _ = __webpack_require__(192);
	    var BucketAggType = Private(__webpack_require__(586));
	    var createFilter = Private(__webpack_require__(637));

	    return new BucketAggType({
	      name: 'significant_terms',
	      title: 'Significant Terms',
	      makeLabel: function makeLabel(aggConfig) {
	        return 'Top ' + aggConfig.params.size + ' unusual terms in ' + aggConfig.params.field.displayName;
	      },
	      createFilter: createFilter,
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'string'
	      }, {
	        name: 'size',
	        editor: __webpack_require__(640)
	      }, {
	        name: 'exclude',
	        type: 'regex',
	        advanced: true
	      }, {
	        name: 'include',
	        type: 'regex',
	        advanced: true
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 646 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(586);
	__webpack_require__(647);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function GeoHashAggDefinition(Private, config) {
	    var _ = __webpack_require__(192);
	    var moment = __webpack_require__(226);
	    var BucketAggType = Private(__webpack_require__(586));
	    var defaultPrecision = 2;

	    function getPrecision(precision) {
	      var maxPrecision = _.parseInt(config.get('visualization:tileMap:maxPrecision'));

	      precision = parseInt(precision, 10);

	      if (isNaN(precision)) {
	        precision = defaultPrecision;
	      }

	      if (precision > maxPrecision) {
	        return maxPrecision;
	      }

	      return precision;
	    }

	    return new BucketAggType({
	      name: 'geohash_grid',
	      title: 'Geohash',
	      params: [{
	        name: 'field',
	        filterFieldTypes: 'geo_point'
	      }, {
	        name: 'autoPrecision',
	        'default': true,
	        write: _.noop
	      }, {
	        name: 'mapZoom',
	        write: _.noop
	      }, {
	        name: 'mapCenter',
	        write: _.noop
	      }, {
	        name: 'precision',
	        'default': defaultPrecision,
	        editor: __webpack_require__(647),
	        controller: function controller($scope) {
	          $scope.$watchMulti(['agg.params.autoPrecision', 'outputAgg.params.precision'], function (cur, prev) {
	            if (cur[1]) $scope.agg.params.precision = cur[1];
	          });
	        },
	        deserialize: getPrecision,
	        write: function write(aggConfig, output) {
	          output.params.precision = getPrecision(aggConfig.params.precision);
	        }
	      }]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 647 */
/***/ function(module, exports) {

	module.exports = "<div class=\"vis-editor-agg-form-row\" ng-controller=\"agg.type.params.byName.precision.controller\">\n  <div ng-if=\"!agg.params.autoPrecision\" class=\"form-group\">\n    <label>Precision</label>\n    <div class=\"vis-editor-agg-form-row\">\n      <input\n        name=\"precision\"\n        ng-model=\"agg.params.precision\"\n        required\n        class=\"form-control\"\n        type=\"range\"\n        min=\"1\"\n        max=\"{{config.get('visualization:tileMap:maxPrecision')}}\"\n        >\n      <div class=\"form-group vis-editor-agg-form-value\">\n        {{agg.params.precision}}\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class=\"vis-option-item\">\n  <label>\n    <input type=\"checkbox\"\n    name=\"autoPrecision\"\n    ng-model=\"agg.params.autoPrecision\">\n    Change precision on map zoom\n  </label>\n</div>\n\n"

/***/ },
/* 648 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(633);
	__webpack_require__(441);
	__webpack_require__(550);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggConfigsFactory(Private) {
	    var _ = __webpack_require__(192);
	    var AggConfig = Private(__webpack_require__(633));
	    var IndexedArray = __webpack_require__(441);

	    AggConfig.aggTypes = Private(__webpack_require__(550));

	    _['class'](AggConfigs).inherits(IndexedArray);
	    function AggConfigs(vis, configStates) {
	      var self = this;
	      self.vis = vis;

	      configStates = AggConfig.ensureIds(configStates || []);

	      AggConfigs.Super.call(self, {
	        index: ['id'],
	        group: ['schema.group', 'type.name', 'schema.name'],
	        initialSet: configStates.map(function (aggConfigState) {
	          if (aggConfigState instanceof AggConfig) return aggConfigState;
	          return new AggConfig(vis, aggConfigState);
	        })
	      });

	      // Set the defaults for any schema which has them. If the defaults
	      // for some reason has more then the max only set the max number
	      // of defaults (not sure why a someone define more...
	      // but whatever). Also if a schema.name is already set then don't
	      // set anything.
	      if (vis && vis.type && vis.type.schemas && vis.type.schemas.all) {
	        _(vis.type.schemas.all).filter(function (schema) {
	          return _.isArray(schema.defaults) && schema.defaults.length > 0;
	        }).each(function (schema) {
	          if (!self.bySchemaName[schema.name]) {
	            var defaults = schema.defaults.slice(0, schema.max);
	            _.each(defaults, function (defaultState) {
	              var state = _.defaults({ id: AggConfig.nextId(self) }, defaultState);
	              self.push(new AggConfig(vis, state));
	            });
	          }
	        }).commit();
	      }
	    }

	    AggConfigs.prototype.toDsl = function () {
	      var dslTopLvl = {};
	      var dslLvlCursor;
	      var nestedMetrics;

	      if (this.vis.isHierarchical()) {
	        // collect all metrics, and filter out the ones that we won't be copying
	        nestedMetrics = _(this.vis.aggs.bySchemaGroup.metrics).filter(function (agg) {
	          return agg.type.name !== 'count';
	        }).map(function (agg) {
	          return {
	            config: agg,
	            dsl: agg.toDsl()
	          };
	        }).value();
	      }

	      this.getRequestAggs().filter(function (config) {
	        return !config.type.hasNoDsl;
	      }).forEach(function nestEachConfig(config, i, list) {
	        if (!dslLvlCursor) {
	          // start at the top level
	          dslLvlCursor = dslTopLvl;
	        } else {
	          var prevConfig = list[i - 1];
	          var prevDsl = dslLvlCursor[prevConfig.id];

	          // advance the cursor and nest under the previous agg, or
	          // put it on the same level if the previous agg doesn't accept
	          // sub aggs
	          dslLvlCursor = prevDsl.aggs || dslLvlCursor;
	        }

	        var dsl = dslLvlCursor[config.id] = config.toDsl();
	        var subAggs;

	        if (config.schema.group === 'buckets' && i < list.length - 1) {
	          // buckets that are not the last item in the list accept sub-aggs
	          subAggs = dsl.aggs || (dsl.aggs = {});
	        }

	        if (subAggs && nestedMetrics) {
	          nestedMetrics.forEach(function (agg) {
	            subAggs[agg.config.id] = agg.dsl;
	          });
	        }
	      });

	      return dslTopLvl;
	    };

	    AggConfigs.prototype.getRequestAggs = function () {
	      return _.sortBy(this, function (agg) {
	        return agg.schema.group === 'metrics' ? 1 : 0;
	      });
	    };

	    /**
	     * Gets the AggConfigs (and possibly ResponseAggConfigs) that
	     * represent the values that will be produced when all aggs
	     * are run.
	     *
	     * With multi-value metric aggs it is possible for a single agg
	     * request to result in multiple agg values, which is why the length
	     * of a vis' responseValuesAggs may be different than the vis' aggs
	     *
	     * @return {array[AggConfig]}
	     */
	    AggConfigs.prototype.getResponseAggs = function () {
	      return this.getRequestAggs().reduce(function (responseValuesAggs, agg) {
	        var aggs = agg.getResponseAggs();
	        return aggs ? responseValuesAggs.concat(aggs) : responseValuesAggs;
	      }, []);
	    };

	    /**
	     * Find a response agg by it's id. This may be an agg in the aggConfigs, or one
	     * created specifically for a response value
	     *
	     * @param  {string} id - the id of the agg to find
	     * @return {AggConfig}
	     */
	    AggConfigs.prototype.getResponseAggById = function (id) {
	      id = String(id);
	      var reqAgg = _.find(this.getRequestAggs(), function (agg) {
	        return id.substr(0, String(agg.id).length) === agg.id;
	      });
	      if (!reqAgg) return;
	      return _.find(reqAgg.getResponseAggs(), { id: id });
	    };

	    return AggConfigs;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 649 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(1);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var chrome = __webpack_require__(1);

	  __webpack_require__(214).get('kibana').run(function ($rootScope, docTitle) {
	    // always bind to the route events
	    $rootScope.$on('$routeChangeStart', docTitle.reset);
	    $rootScope.$on('$routeChangeError', docTitle.update);
	    $rootScope.$on('$routeChangeSuccess', docTitle.update);
	    $rootScope.$watch(_.bindKey(chrome, 'getActiveTabTitle'), docTitle.update);
	  }).service('docTitle', function ($rootScope) {
	    var baseTitle = document.title;
	    var self = this;

	    var lastChange;

	    function render() {
	      lastChange = lastChange || [];

	      var parts = [lastChange[0]];
	      var activeTabTitle = chrome.getActiveTabTitle();

	      if (activeTabTitle) parts.push(activeTabTitle);

	      if (!lastChange[1]) parts.push(baseTitle);

	      return _(parts).flattenDeep().compact().join(' - ');
	    }

	    self.change = function (title, complete) {
	      lastChange = [title, complete];
	      self.update();
	    };

	    self.reset = function () {
	      lastChange = null;
	    };

	    self.update = function () {
	      document.title = render();
	    };
	  });

	  // return a "private module" so that it can be used both ways
	  return function DoctitleProvider(docTitle) {
	    return docTitle;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 650 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var moment = __webpack_require__(226);
	  return function brushEventProvider(timefilter) {
	    return function (event) {
	      var from = moment(event.range[0]);
	      var to = moment(event.range[1]);

	      if (to - from === 0) return;

	      timefilter.time.from = from;
	      timefilter.time.to = to;
	      timefilter.time.mode = 'absolute';
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 651 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function HitSortFnFactory() {

	    /**
	     * Creates a sort function that will resort hits based on the value
	     * es used to sort them.
	     *
	     * background:
	     * When a hit is sorted by elasticsearch, es will write the values that it used
	     * to sort them into an array at the top level of the hit like so
	     *
	     * ```
	     * hits: {
	     *   total: x,
	     *   hits: [
	     *     {
	     *       _id: i,
	     *       _source: {},
	     *       sort: [
	     *         // all values used to sort, in the order of precidance
	     *       ]
	     *     }
	     *   ]
	     * };
	     * ```
	     *
	     * @param  {[type]} field     [description]
	     * @param  {[type]} direction [description]
	     * @return {[type]}           [description]
	     */
	    return function createHitSortFn(direction) {
	      var descending = direction === 'desc';

	      return function sortHits(hitA, hitB) {
	        var bBelowa = null;

	        var aSorts = hitA.sort || [];
	        var bSorts = hitB.sort || [];

	        // walk each sort value, and compair until one is different
	        for (var i = 0; i < bSorts.length; i++) {
	          var a = aSorts[i];
	          var b = bSorts[i];

	          if (a == null || b > a) {
	            bBelowa = !descending;
	            break;
	          }

	          if (b < a) {
	            bBelowa = descending;
	            break;
	          }
	        }

	        if (bBelowa !== null) {
	          return bBelowa ? -1 : 1;
	        } else {
	          return 0;
	        }
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 652 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(238);
	__webpack_require__(653);
	__webpack_require__(654);
	__webpack_require__(656);
	__webpack_require__(655);
	__webpack_require__(658);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function (Private, $rootScope, getAppState, globalState) {
	    var EventEmitter = Private(__webpack_require__(238));
	    var onlyDisabled = __webpack_require__(653);
	    var onlyStateChanged = __webpack_require__(654);
	    var uniqFilters = __webpack_require__(656);
	    var compareFilters = __webpack_require__(655);
	    var mapAndFlattenFilters = Private(__webpack_require__(658));

	    var queryFilter = new EventEmitter();

	    queryFilter.getFilters = function () {
	      var compareOptions = { disabled: true, negate: true };
	      var appFilters = queryFilter.getAppFilters();
	      var globalFilters = queryFilter.getGlobalFilters();

	      return uniqFilters(globalFilters.concat(appFilters), compareOptions);
	    };

	    queryFilter.getAppFilters = function () {
	      var appState = getAppState();
	      if (!appState || !appState.filters) return [];
	      return appState.filters ? _.map(appState.filters, appendStoreType('appState')) : [];
	    };

	    queryFilter.getGlobalFilters = function () {
	      if (!globalState.filters) return [];
	      return _.map(globalState.filters, appendStoreType('globalState'));
	    };

	    /**
	     * Adds new filters to the scope and state
	     * @param {object|array} fitlers Filter(s) to add
	     * @param {bool} global Should be added to global state
	     * @retuns {Promise} filter map promise
	     */
	    queryFilter.addFilters = function (filters, global) {
	      var appState = getAppState();
	      var state = global ? globalState : appState;

	      if (!_.isArray(filters)) {
	        filters = [filters];
	      }

	      return mapAndFlattenFilters(filters).then(function (filters) {
	        if (global) {
	          // simply concat global filters, they will be deduped
	          globalState.filters = globalState.filters.concat(filters);
	        } else if (appState) {
	          if (!appState.filters) appState.filters = [];
	          appState.filters = appState.filters.concat(filters);
	        }
	      });
	    };

	    /**
	     * Removes the filter from the proper state
	     * @param {object} matchFilter The filter to remove
	     */
	    queryFilter.removeFilter = function (matchFilter) {
	      var appState = getAppState();
	      var filter = _.omit(matchFilter, ['$$hashKey']);
	      var state;
	      var index;

	      // check for filter in appState
	      if (appState) {
	        index = _.findIndex(appState.filters, filter);
	        if (index !== -1) state = appState;
	      }

	      // if not found, check for filter in globalState
	      if (!state) {
	        index = _.findIndex(globalState.filters, filter);
	        if (index !== -1) state = globalState;else return; // not found in either state, do nothing
	      }

	      state.filters.splice(index, 1);
	    };

	    /**
	     * Removes all filters
	     */
	    queryFilter.removeAll = function () {
	      var appState = getAppState();
	      appState.filters = [];
	      globalState.filters = [];
	    };

	    /**
	     * Toggles the filter between enabled/disabled.
	     * @param {object} filter The filter to toggle
	     & @param {boolean} force Disabled true/false
	     * @returns {object} updated filter
	     */
	    queryFilter.toggleFilter = function (filter, force) {
	      // Toggle the disabled flag
	      var disabled = _.isUndefined(force) ? !filter.meta.disabled : !!force;
	      filter.meta.disabled = disabled;
	      return filter;
	    };

	    /**
	     * Disables all filters
	     * @params {boolean} force Disable/enable all filters
	     */
	    queryFilter.toggleAll = function (force) {
	      function doToggle(filter) {
	        queryFilter.toggleFilter(filter, force);
	      }

	      executeOnFilters(doToggle);
	    };

	    /**
	     * Inverts the nagate value on the filter
	     * @param {object} filter The filter to toggle
	     * @returns {object} updated filter
	     */
	    queryFilter.invertFilter = function (filter) {
	      // Toggle the negate meta state
	      filter.meta.negate = !filter.meta.negate;
	      return filter;
	    };

	    /**
	     * Inverts all filters
	     * @returns {object} Resulting updated filter list
	     */
	    queryFilter.invertAll = function () {
	      executeOnFilters(queryFilter.invertFilter);
	    };

	    /**
	     * Pins the filter to the global state
	     * @param {object} filter The filter to pin
	     * @param {boolean} force pinned state
	     * @returns {object} updated filter
	     */
	    queryFilter.pinFilter = function (filter, force) {
	      var appState = getAppState();
	      if (!appState) return filter;

	      // ensure that both states have a filters property
	      if (!_.isArray(globalState.filters)) globalState.filters = [];
	      if (!_.isArray(appState.filters)) appState.filters = [];

	      var appIndex = _.indexOf(appState.filters, filter);

	      if (appIndex !== -1 && force !== false) {
	        appState.filters.splice(appIndex, 1);
	        globalState.filters.push(filter);
	      } else {
	        var globalIndex = _.indexOf(globalState.filters, filter);

	        if (globalIndex === -1 || force === true) return filter;

	        globalState.filters.splice(globalIndex, 1);
	        appState.filters.push(filter);
	      }

	      return filter;
	    };

	    /**
	     * Pins all filters
	     * @params {boolean} force Pin/Unpin all filters
	     */
	    queryFilter.pinAll = function (force) {
	      function pin(filter) {
	        queryFilter.pinFilter(filter, force);
	      }

	      executeOnFilters(pin);
	    };

	    initWatchers();

	    return queryFilter;

	    /**
	     * Saves both app and global states, ensuring filters are persisted
	     * @returns {object} Resulting filter list, app and global combined
	     */
	    function saveState() {
	      var appState = getAppState();
	      if (appState) appState.save();
	      globalState.save();
	    }

	    function appendStoreType(type) {
	      return function (filter) {
	        filter.$state = {
	          store: type
	        };
	        return filter;
	      };
	    }

	    // helper to run a function on all filters in all states
	    function executeOnFilters(fn) {
	      var appState = getAppState();
	      var globalFilters = [];
	      var appFilters = [];

	      if (globalState.filters) globalFilters = globalState.filters;
	      if (appState && appState.filters) appFilters = appState.filters;

	      globalFilters.concat(appFilters).forEach(fn);
	    }

	    function mergeStateFilters(gFilters, aFilters, compareOptions) {
	      // ensure we don't mutate the filters passed in
	      var globalFilters = gFilters ? _.cloneDeep(gFilters) : [];
	      var appFilters = aFilters ? _.cloneDeep(aFilters) : [];
	      compareOptions = _.defaults(compareOptions || {}, { disabled: true });

	      // existing globalFilters should be mutated by appFilters
	      _.each(appFilters, function (filter, i) {
	        var match = _.find(globalFilters, function (globalFilter) {
	          return compareFilters(globalFilter, filter, compareOptions);
	        });

	        // no match, do nothing
	        if (!match) return;

	        // matching filter in globalState, update global and remove from appState
	        _.assign(match.meta, filter.meta);
	        appFilters.splice(i, 1);
	      });

	      return [uniqFilters(globalFilters, { disabled: true }), uniqFilters(appFilters, { disabled: true })];
	    }

	    /**
	     * Initializes state watchers that use the event emitter
	     * @returns {void}
	     */
	    function initWatchers() {
	      var removeAppStateWatchers;

	      $rootScope.$watch(getAppState, function () {
	        removeAppStateWatchers && removeAppStateWatchers();
	        removeAppStateWatchers = initAppStateWatchers();
	      });

	      function initAppStateWatchers() {
	        // multi watch on the app and global states
	        var stateWatchers = [{
	          fn: $rootScope.$watch,
	          deep: true,
	          get: queryFilter.getGlobalFilters
	        }, {
	          fn: $rootScope.$watch,
	          deep: true,
	          get: queryFilter.getAppFilters
	        }];

	        // when states change, use event emitter to trigger updates and fetches
	        return $rootScope.$watchMulti(stateWatchers, function (next, prev) {
	          // prevent execution on watcher instantiation
	          if (_.isEqual(next, prev)) return;

	          var doUpdate = false;
	          var doFetch = false;

	          // reconcile filter in global and app states
	          var filters = mergeStateFilters(next[0], next[1]);
	          var globalFilters = filters[0];
	          var appFilters = filters[1];
	          var appState = getAppState();

	          // save the state, as it may have updated
	          var globalChanged = !_.isEqual(next[0], globalFilters);
	          var appChanged = !_.isEqual(next[1], appFilters);

	          // the filters were changed, apply to state (re-triggers this watcher)
	          if (globalChanged || appChanged) {
	            globalState.filters = globalFilters;
	            if (appState) appState.filters = appFilters;
	            return;
	          }

	          // check for actions, bail if we're done
	          getActions();
	          if (!doUpdate) return;

	          // save states and emit the required events
	          saveState();
	          queryFilter.emit('update').then(function () {
	            if (!doFetch) return;
	            queryFilter.emit('fetch');
	          });

	          // iterate over each state type, checking for changes
	          function getActions() {
	            var newFilters = [];
	            var oldFilters = [];

	            stateWatchers.forEach(function (watcher, i) {
	              var nextVal = next[i];
	              var prevVal = prev[i];
	              newFilters = newFilters.concat(nextVal);
	              oldFilters = oldFilters.concat(prevVal);

	              // no update or fetch if there was no change
	              if (nextVal === prevVal) return;

	              if (nextVal) doUpdate = true;

	              // don't trigger fetch when only disabled filters
	              if (!onlyDisabled(nextVal, prevVal)) doFetch = true;
	            });

	            // make sure change wasn't only a state move
	            // checking length first is an optimization
	            if (doFetch && newFilters.length === oldFilters.length) {
	              if (onlyStateChanged(newFilters, oldFilters)) doFetch = false;
	            }
	          }
	        });
	      }
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 653 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  var pluckDisabled = function pluckDisabled(filter) {
	    return _.get(filter, 'meta.disabled');
	  };

	  /**
	   * Checks to see if only disabled filters have been changed
	   * @returns {bool} Only disabled filters
	   */
	  return function (newFilters, oldFilters) {
	    return _.every(newFilters.concat(oldFilters), function (newFilter) {
	      return pluckDisabled(newFilter);
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 654 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(655);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var compareFilters = __webpack_require__(655);
	  var compareOptions = { disabled: true, negate: true };

	  /**
	   * Checks to see if only disabled filters have been changed
	   * @returns {bool} Only disabled filters
	   */
	  return function (newFilters, oldFilters) {
	    return _.every(newFilters, function (newFilter, i) {
	      var match = _.find(oldFilters, function (oldFilter) {
	        return compareFilters(newFilter, oldFilter, compareOptions);
	      });
	      return !!match;
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 655 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  var excludedAttributes;
	  var comparators;

	  /**
	   * Compare two filters to see if they match
	   * @param {object} first The first filter to compare
	   * @param {object} second The second filter to compare
	   * @param {object} comparatorOptions Parameters to use for comparison
	   * @returns {bool} Filters are the same
	   */
	  return function (first, second, comparatorOptions) {
	    excludedAttributes = ['$$hashKey', 'meta'];
	    comparators = _.defaults(comparatorOptions || {}, {
	      state: false,
	      negate: false,
	      disabled: false
	    });

	    if (!comparators.state) excludedAttributes.push('$state');

	    return _.isEqual(mapFilter(first), mapFilter(second));
	  };

	  function mapFilter(filter) {
	    var cleaned = _.omit(filter, excludedAttributes);
	    if (comparators.negate) cleaned.negate = filter.meta && !!filter.meta.negate;
	    if (comparators.disabled) cleaned.disabled = filter.meta && !!filter.meta.disabled;
	    return cleaned;
	  }
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 656 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(657);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var dedupFilters = __webpack_require__(657);

	  /**
	   * Remove duplicate filters from an array of filters
	   * @param {array} filters The filters to remove duplicates from
	   * @returns {object} The original filters array with duplicates removed
	   */
	  return function (filters, comparatorOptions) {
	    var results = [];
	    _.each(filters, function (filter) {
	      results = _.union(results, dedupFilters(results, [filter], comparatorOptions));
	    });
	    return results;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 657 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(655);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  var compareFilters = __webpack_require__(655);

	  /**
	   * Combine 2 filter collections, removing duplicates
	   * @param {object} existing The filters to compare to
	   * @param {object} filters The filters being added
	   * @param {object} comparatorOptions Parameters to use for comparison
	   * @returns {object} An array of filters that were not in existing
	   */
	  return function (existingFilters, filters, comparatorOptions) {
	    if (!_.isArray(filters)) filters = [filters];

	    return _.filter(filters, function (filter) {
	      return !_.find(existingFilters, function (existingFilter) {
	        return compareFilters(existingFilter, filter, comparatorOptions);
	      });
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 658 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(659);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function mapAndFlattenFiltersProvider(Private, Promise) {
	    var mapFilter = Private(__webpack_require__(659));
	    return function (filters) {
	      return _(filters).flatten().compact().map(mapFilter).thru(Promise.all).value();
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 659 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(660);
	__webpack_require__(661);
	__webpack_require__(662);
	__webpack_require__(663);
	__webpack_require__(664);
	__webpack_require__(665);
	__webpack_require__(666);
	__webpack_require__(667);
	__webpack_require__(668);
	__webpack_require__(669);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function mapFilterProvider(Promise, Private) {

	    var generateMappingChain = Private(__webpack_require__(660));

	    /** Mappers **/

	    // Each mapper is a simple promise function that test if the mapper can
	    // handle the mapping or not. If it handles it then it will resolve with
	    // and object that has the key and value for the filter. Otherwise it will
	    // reject it with the original filter. We had to go down the promise interface
	    // because mapTerms and mapRange need access to the indexPatterns to format
	    // the values and that's only available through the field formatters.

	    // The mappers to apply. Each mapper will either return
	    // a result object with a key and value attribute or
	    // undefined. If undefined is return then the next
	    // mapper will get the opportunity to map the filter.
	    // To create a new mapper you just need to create a function
	    // that either handles the mapping operation or not
	    // and add it here. ProTip: These are executed in order listed
	    var mappers = [Private(__webpack_require__(661)), Private(__webpack_require__(662)), Private(__webpack_require__(663)), Private(__webpack_require__(664)), Private(__webpack_require__(665)), Private(__webpack_require__(666)), Private(__webpack_require__(667)), Private(__webpack_require__(668)), Private(__webpack_require__(669))];

	    var noop = function noop() {
	      return Promise.reject(new Error('No mappings have been found for filter.'));
	    };

	    // Create a chain of responsibility by reducing all the
	    // mappers down into one function.
	    var mapFn = _.reduceRight(mappers, function (memo, map) {
	      var filterChainFn = generateMappingChain(map);
	      return filterChainFn(memo);
	    }, noop);

	    /**
	     * Map the filter into an object with the key and value exposed so it's
	     * easier to work with in the template
	     * @param {object} fitler The filter the map
	     * @returns {Promise}
	     */
	    return function (filter) {
	      // Apply the mapping function
	      return mapFn(filter).then(function (result) {
	        filter.meta = filter.meta || {};
	        filter.meta.key = result.key;
	        filter.meta.value = result.value;
	        filter.meta.disabled = !!filter.meta.disabled;
	        filter.meta.negate = !!filter.meta.negate;
	        return filter;
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 660 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function generateMappingChainProvider(Promise) {

	    var noop = function noop() {
	      return Promise.reject(new Error('No mappings have been found for filter.'));
	    };

	    return function (fn) {
	      return function (next) {
	        next = next || noop;
	        return function (filter) {
	          return fn(filter)['catch'](function (result) {
	            if (result === filter) {
	              return next(filter);
	            }
	            return Promise.reject(result);
	          });
	        };
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 661 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function mapMatchAllProvider(Promise) {
	    return function (filter) {
	      if (filter.match_all) {
	        var key = filter.meta.field;
	        var value = filter.meta.formattedValue || 'all';
	        return Promise.resolve({ key: key, value: value });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 662 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function mapTermsProvider(Promise, courier) {
	    return function (filter) {
	      var key;
	      var value;
	      var field;
	      if (filter.query && filter.query.match) {
	        return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	          key = _.keys(filter.query.match)[0];
	          field = indexPattern.fields.byName[key];
	          value = filter.query.match[key].query;
	          value = field.format.convert(value);
	          return { key: key, value: value };
	        });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 663 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _require = __webpack_require__(192);

	  var has = _require.has;

	  return function mapRangeProvider(Promise, courier) {
	    return function (filter) {
	      if (!filter.range) return Promise.reject(filter);

	      return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	        var key = _Object$keys(filter.range)[0];
	        var convert = indexPattern.fields.byName[key].format.getConverterFor('text');
	        var range = filter.range[key];

	        var left = has(range, 'gte') ? range.gte : range.gt;
	        if (left == null) left = -Infinity;

	        var right = has(range, 'lte') ? range.lte : range.lt;
	        if (right == null) right = Infinity;

	        return {
	          key: key,
	          value: convert(left) + ' to ' + convert(right)
	        };
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 664 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function mapExistsProvider(Promise) {
	    return function (filter) {
	      var key;
	      var value;
	      if (filter.exists) {
	        key = 'exists';
	        value = filter.exists.field;
	        return Promise.resolve({ key: key, value: value });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 665 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function mapMissingProvider(Promise) {
	    return function (filter) {
	      var key;
	      var value;
	      if (filter.missing) {
	        key = 'missing';
	        value = filter.missing.field;
	        return Promise.resolve({ key: key, value: value });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 666 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function mapQueryStringProvider(Promise) {
	    return function (filter) {
	      var key;
	      var value;
	      if (filter.query && filter.query.query_string) {
	        key = 'query';
	        value = filter.query.query_string.query;
	        return Promise.resolve({ key: key, value: value });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 667 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function mapGeoBoundBoxProvider(Promise, courier) {
	    return function (filter) {
	      var key;
	      var value;
	      var topLeft;
	      var bottomRight;
	      var field;
	      if (filter.geo_bounding_box) {
	        return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	          key = _.keys(filter.geo_bounding_box)[0];
	          field = indexPattern.fields.byName[key];
	          topLeft = field.format.convert(filter.geo_bounding_box[field.name].top_left);
	          bottomRight = field.format.convert(filter.geo_bounding_box[field.name].bottom_right);
	          value = topLeft + ' to ' + bottomRight;
	          return { key: key, value: value };
	        });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 668 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function mapScriptProvider(Promise, courier) {
	    return function (filter) {
	      var key;
	      var value;
	      var field;
	      if (filter.script) {
	        return courier.indexPatterns.get(filter.meta.index).then(function (indexPattern) {
	          key = filter.meta.field;
	          field = indexPattern.fields.byName[key];

	          if (filter.meta.formattedValue) {
	            value = filter.meta.formattedValue;
	          } else {
	            value = filter.script.params.value;
	            value = field.format.convert(value);
	          }

	          return { key: key, value: value };
	        });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 669 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function mapDefaultProvider(Promise) {
	    var angular = __webpack_require__(209);

	    return function (filter) {
	      var key;
	      var value;
	      if (filter.query) {
	        key = 'query';
	        value = angular.toJson(filter.query);
	        return Promise.resolve({ key: key, value: value });
	      }
	      return Promise.reject(filter);
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 670 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(652);

	// Adds a filter to a passed state
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function (Private) {
	    var _ = __webpack_require__(192);
	    var queryFilter = Private(__webpack_require__(652));
	    var filterManager = {};

	    filterManager.add = function (field, values, operation, index) {
	      values = _.isArray(values) ? values : [values];
	      var fieldName = _.isObject(field) ? field.name : field;
	      var filters = _.flatten([queryFilter.getAppFilters()]);
	      var newFilters = [];

	      var negate = operation === '-';

	      // TODO: On array fields, negating does not negate the combination, rather all terms
	      _.each(values, function (value) {
	        var filter;
	        var existing = _.find(filters, function (filter) {
	          if (!filter) return;

	          if (fieldName === '_exists_' && filter.exists) {
	            return filter.exists.field === value;
	          }

	          if (filter.query) {
	            return filter.query.match[fieldName] && filter.query.match[fieldName].query === value;
	          }

	          if (filter.script) {
	            return filter.meta.field === fieldName && filter.script.params.value === value;
	          }
	        });

	        if (existing) {
	          existing.meta.disabled = false;
	          if (existing.meta.negate !== negate) {
	            queryFilter.invertFilter(existing);
	          }
	          return;
	        }

	        switch (fieldName) {
	          case '_exists_':
	            filter = {
	              meta: {
	                negate: negate,
	                index: index
	              },
	              exists: {
	                field: value
	              }
	            };
	            break;
	          default:
	            if (field.scripted) {
	              filter = {
	                meta: { negate: negate, index: index, field: fieldName },
	                script: {
	                  script: '(' + field.script + ') == value',
	                  lang: field.lang,
	                  params: {
	                    value: value
	                  }
	                }
	              };
	            } else {
	              filter = { meta: { negate: negate, index: index }, query: { match: {} } };
	              filter.query.match[fieldName] = { query: value, type: 'phrase' };
	            }

	            break;
	        }

	        newFilters.push(filter);
	      });

	      return queryFilter.addFilters(newFilters);
	    };

	    return filterManager;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 671 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" class=\"container-fluid\" ng-submit=\"fetch()\">\n  <saved-object-finder type=\"searches\"></saved-object-finder>\n</form>\n"

/***/ },
/* 672 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" class=\"container-fluid\" ng-submit=\"opts.saveDataSource()\">\n  <div class=\"container-fluid\">\n    <div class=\"row\">\n      <div class=\"col-md-12\">\n        <div class=\"form-group\">\n          <label for=\"SaveSearch\" class=\"control-label\">Save Search</label>\n          <input id=\"SaveSearch\" ng-model=\"opts.savedSearch.title\" input-focus=\"select\" class=\"form-control\" placeholder=\"Name this search...\">\n        </div>\n        <div class=\"form-group\">\n          <button ng-disabled=\"!opts.savedSearch.title\" type=\"submit\" class=\"btn btn-primary\">\n            Save\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</form>\n"

/***/ },
/* 673 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 674 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(444);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return __webpack_require__(444)({
	    name: 'savedObjects',
	    index: ['loaderProperties.name'],
	    order: ['loaderProperties.name']
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 675 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function savedSearchObjectFn(savedSearches) {
	    return savedSearches;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 676 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(677);
	__webpack_require__(678);
	__webpack_require__(704);
	__webpack_require__(216);
	__webpack_require__(709);
	__webpack_require__(683);
	__webpack_require__(690);
	__webpack_require__(698);
	__webpack_require__(682);
	__webpack_require__(688);
	__webpack_require__(684);
	__webpack_require__(693);
	__webpack_require__(681);
	__webpack_require__(695);
	__webpack_require__(680);
	__webpack_require__(679);
	__webpack_require__(674);
	__webpack_require__(710);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(677);

	  __webpack_require__(678);
	  __webpack_require__(704);

	  __webpack_require__(216).when('/visualize', {
	    redirectTo: '/visualize/step/1'
	  });

	  // preloading
	  __webpack_require__(709);
	  __webpack_require__(683);
	  __webpack_require__(690);
	  __webpack_require__(698);
	  __webpack_require__(682);
	  __webpack_require__(688);
	  __webpack_require__(684);
	  __webpack_require__(678);
	  __webpack_require__(693);
	  __webpack_require__(681);
	  __webpack_require__(695);
	  __webpack_require__(680);
	  __webpack_require__(679);

	  __webpack_require__(674).register(__webpack_require__(710));
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 677 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 678 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(679);
	__webpack_require__(681);
	__webpack_require__(698);
	__webpack_require__(474);
	__webpack_require__(423);
	__webpack_require__(216);
	__webpack_require__(699);
	__webpack_require__(479);
	__webpack_require__(214);
	__webpack_require__(209);
	__webpack_require__(304);
	__webpack_require__(239);
	__webpack_require__(649);
	__webpack_require__(650);
	__webpack_require__(652);
	__webpack_require__(700);
	__webpack_require__(701);
	__webpack_require__(702);
	__webpack_require__(703);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  __webpack_require__(679);
	  __webpack_require__(681);
	  __webpack_require__(698);

	  __webpack_require__(474);
	  __webpack_require__(423);

	  __webpack_require__(216).when('/visualize/create', {
	    template: __webpack_require__(699),
	    resolve: {
	      savedVis: function savedVis(savedVisualizations, courier, $route, Private) {
	        var visTypes = Private(__webpack_require__(479));
	        var visType = _.find(visTypes, { name: $route.current.params.type });
	        if (visType.requiresSearch && !$route.current.params.indexPattern && !$route.current.params.savedSearchId) {
	          throw new Error('You must provide either an indexPattern or a savedSearchId');
	        }

	        return savedVisualizations.get($route.current.params)['catch'](courier.redirectWhenMissing({
	          '*': '/visualize'
	        }));
	      }
	    }
	  }).when('/visualize/edit/:id', {
	    template: __webpack_require__(699),
	    resolve: {
	      savedVis: function savedVis(savedVisualizations, courier, $route) {
	        return savedVisualizations.get($route.current.params.id)['catch'](courier.redirectWhenMissing({
	          'visualization': '/visualize',
	          'search': '/settings/objects/savedVisualizations/' + $route.current.params.id,
	          'index-pattern': '/settings/objects/savedVisualizations/' + $route.current.params.id,
	          'index-pattern-field': '/settings/objects/savedVisualizations/' + $route.current.params.id
	        }));
	      }
	    }
	  });

	  __webpack_require__(214).get('app/visualize', ['kibana/notify', 'kibana/courier']).controller('VisEditor', function ($scope, $route, timefilter, AppState, $location, kbnUrl, $timeout, courier, Private, Promise) {

	    var angular = __webpack_require__(209);
	    var ConfigTemplate = __webpack_require__(304);
	    var Notifier = __webpack_require__(239);
	    var docTitle = Private(__webpack_require__(649));
	    var brushEvent = Private(__webpack_require__(650));
	    var queryFilter = Private(__webpack_require__(652));
	    var filterBarClickHandler = Private(__webpack_require__(700));

	    var notify = new Notifier({
	      location: 'Visualization Editor'
	    });

	    var savedVis = $route.current.locals.savedVis;

	    var vis = savedVis.vis;
	    var editableVis = vis.createEditableVis();
	    vis.requesting = function () {
	      var requesting = editableVis.requesting;
	      requesting.call(vis);
	      requesting.call(editableVis);
	    };

	    var searchSource = savedVis.searchSource;

	    // config panel templates
	    var configTemplate = new ConfigTemplate({
	      save: __webpack_require__(701),
	      load: __webpack_require__(702),
	      share: __webpack_require__(703)
	    });

	    if (savedVis.id) {
	      docTitle.change(savedVis.title);
	    }

	    var $state = $scope.$state = (function initState() {
	      var savedVisState = vis.getState();
	      var stateDefaults = {
	        linked: !!savedVis.savedSearchId,
	        query: searchSource.getOwn('query') || { query_string: { query: '*' } },
	        filters: searchSource.getOwn('filter') || [],
	        vis: savedVisState
	      };

	      $state = new AppState(stateDefaults);

	      if (!angular.equals($state.vis, savedVisState)) {
	        Promise['try'](function () {
	          vis.setState($state.vis);
	          editableVis.setState($state.vis);
	        })['catch'](courier.redirectWhenMissing({
	          'index-pattern-field': '/visualize'
	        }));
	      }

	      return $state;
	    })();

	    function init() {
	      // export some objects
	      $scope.savedVis = savedVis;
	      $scope.searchSource = searchSource;
	      $scope.vis = vis;
	      $scope.indexPattern = vis.indexPattern;
	      $scope.editableVis = editableVis;
	      $scope.state = $state;
	      $scope.conf = _.pick($scope, 'doSave', 'savedVis', 'shareData');
	      $scope.configTemplate = configTemplate;

	      editableVis.listeners.click = vis.listeners.click = filterBarClickHandler($state);
	      editableVis.listeners.brush = vis.listeners.brush = brushEvent;

	      // track state of editable vis vs. "actual" vis
	      $scope.stageEditableVis = transferVisState(editableVis, vis, true);
	      $scope.resetEditableVis = transferVisState(vis, editableVis);
	      $scope.$watch(function () {
	        return editableVis.getState();
	      }, function (newState) {
	        editableVis.dirty = !angular.equals(newState, vis.getState());

	        $scope.responseValueAggs = null;
	        try {
	          $scope.responseValueAggs = editableVis.aggs.getResponseAggs().filter(function (agg) {
	            return _.get(agg, 'schema.group') === 'metrics';
	          });
	        }
	        // this can fail when the agg.type is changed but the
	        // params have not been set yet. watcher will trigger again
	        // when the params update
	        catch (e) {} // eslint-disable-line no-empty
	      }, true);

	      $state.replace();

	      $scope.$watch('searchSource.get("index").timeFieldName', function (timeField) {
	        timefilter.enabled = !!timeField;
	      });

	      // update the searchSource when filters update
	      $scope.$listen(queryFilter, 'update', function () {
	        searchSource.set('filter', queryFilter.getFilters());
	        $state.save();
	      });

	      // fetch data when filters fire fetch event
	      $scope.$listen(queryFilter, 'fetch', $scope.fetch);

	      $scope.$listen($state, 'fetch_with_changes', function (keys) {
	        if (_.contains(keys, 'linked') && $state.linked === true) {
	          // abort and reload route
	          $route.reload();
	          return;
	        }

	        if (_.contains(keys, 'vis')) {
	          $state.vis.listeners = _.defaults($state.vis.listeners || {}, vis.listeners);

	          // only update when we need to, otherwise colors change and we
	          // risk loosing an in-progress result
	          vis.setState($state.vis);
	          editableVis.setState($state.vis);
	        }

	        // we use state to track query, must write before we fetch
	        if ($state.query && !$state.linked) {
	          searchSource.set('query', $state.query);
	        } else {
	          searchSource.set('query', null);
	        }

	        if (_.isEqual(keys, ['filters'])) {
	          // updates will happen in filter watcher if needed
	          return;
	        }

	        $scope.fetch();
	      });

	      // Without this manual emission, we'd miss filters and queries that were on the $state initially
	      $state.emit('fetch_with_changes');

	      $scope.$listen(timefilter, 'fetch', _.bindKey($scope, 'fetch'));

	      $scope.$on('ready:vis', function () {
	        $scope.$emit('application.load');
	      });

	      $scope.$on('$destroy', function () {
	        savedVis.destroy();
	      });
	    }

	    $scope.fetch = function () {
	      $state.save();
	      searchSource.set('filter', queryFilter.getFilters());
	      if (!$state.linked) searchSource.set('query', $state.query);
	      if ($scope.vis.type.requiresSearch) {
	        courier.fetch();
	      }
	    };

	    $scope.startOver = function () {
	      kbnUrl.change('/visualize', {});
	    };

	    $scope.doSave = function () {
	      savedVis.id = savedVis.title;
	      savedVis.visState = $state.vis;

	      savedVis.save().then(function (id) {
	        configTemplate.close('save');

	        if (id) {
	          notify.info('Saved Visualization "' + savedVis.title + '"');
	          if (savedVis.id === $route.current.params.id) return;
	          kbnUrl.change('/visualize/edit/{{id}}', { id: savedVis.id });
	        }
	      }, notify.fatal);
	    };

	    $scope.shareData = function () {
	      return {
	        link: $location.absUrl(),
	        // This sucks, but seems like the cleanest way. Uhg.
	        embed: '<iframe src="' + $location.absUrl().replace('?', '?embed&') + '" height="600" width="800"></iframe>'
	      };
	    };

	    $scope.unlink = function () {
	      if (!$state.linked) return;

	      $state.linked = false;
	      var parent = searchSource.getParent(true);
	      var parentsParent = parent.getParent(true);

	      // display unlinking for 2 seconds, unless it is double clicked
	      $scope.unlinking = $timeout($scope.clearUnlinking, 2000);

	      delete savedVis.savedSearchId;
	      parent.set('filter', _.union(searchSource.getOwn('filter'), parent.getOwn('filter')));

	      // copy over all state except "aggs" and filter, which is already copied
	      _(parent.toJSON()).omit('aggs').forOwn(function (val, key) {
	        searchSource.set(key, val);
	      }).commit();

	      $state.query = searchSource.get('query');
	      $state.filters = searchSource.get('filter');
	      searchSource.inherits(parentsParent);
	    };

	    $scope.clearUnlinking = function () {
	      if ($scope.unlinking) {
	        $timeout.cancel($scope.unlinking);
	        $scope.unlinking = null;
	      }
	    };

	    function transferVisState(fromVis, toVis, fetch) {
	      return function () {
	        toVis.setState(fromVis.getState());
	        editableVis.dirty = false;
	        $state.vis = vis.getState();
	        $state.save();

	        if (fetch) $scope.fetch();
	      };
	    }

	    init();
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 679 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(680);
	__webpack_require__(330);
	__webpack_require__(479);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var app = __webpack_require__(214).get('app/visualize');
	  var _ = __webpack_require__(192);

	  __webpack_require__(680);

	  // Register this service with the saved object registry so it can be
	  // edited by the object editor.
	  __webpack_require__(330).register({
	    service: 'savedVisualizations',
	    title: 'visualizations'
	  });

	  app.service('savedVisualizations', function (Promise, es, kbnIndex, SavedVis, Private, Notifier, kbnUrl) {
	    var visTypes = Private(__webpack_require__(479));
	    var notify = new Notifier({
	      location: 'Saved Visualization Service'
	    });

	    this.type = SavedVis.type;
	    this.Class = SavedVis;

	    this.loaderProperties = {
	      name: 'visualizations',
	      noun: 'Visualization',
	      nouns: 'visualizations'
	    };

	    this.get = function (id) {
	      return new SavedVis(id).init();
	    };

	    this.urlFor = function (id) {
	      return kbnUrl.eval('#/visualize/edit/{{id}}', { id: id });
	    };

	    this['delete'] = function (ids) {
	      ids = !_.isArray(ids) ? [ids] : ids;
	      return Promise.map(ids, function (id) {
	        return new SavedVis(id)['delete']();
	      });
	    };

	    this.find = function (searchString) {
	      var size = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];

	      var self = this;
	      var body;
	      if (searchString) {
	        body = {
	          query: {
	            simple_query_string: {
	              query: searchString + '*',
	              fields: ['title^3', 'description'],
	              default_operator: 'AND'
	            }
	          }
	        };
	      } else {
	        body = { query: { match_all: {} } };
	      }

	      return es.search({
	        index: kbnIndex,
	        type: 'visualization',
	        body: body,
	        size: size
	      }).then(function (resp) {
	        return {
	          total: resp.hits.total,
	          hits: _.transform(resp.hits.hits, function (hits, hit) {
	            var source = hit._source;
	            source.id = hit._id;
	            source.url = self.urlFor(hit._id);

	            var typeName = source.typeName;
	            if (source.visState) {
	              try {
	                typeName = JSON.parse(source.visState).type;
	              } catch (e) {} /* missing typename handled below */ // eslint-disable-line no-empty
	            }

	            if (!typeName || !visTypes.byName[typeName]) {
	              if (!typeName) notify.error('Visualization type is missing. Please add a type to this visualization.', hit);else notify.error('Visualization type of "' + typeName + '" is invalid. Please change to a valid type.', hit);
	              return kbnUrl.redirect('/settings/objects/savedVisualizations/{{id}}', { id: source.id });
	            }

	            source.type = visTypes.byName[typeName];
	            source.icon = source.type.icon;
	            hits.push(source);
	          }, [])
	        };
	      });
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 680 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(549);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('app/visualize').factory('SavedVis', function (config, $injector, courier, Promise, savedSearches, Private, Notifier) {
	    var _ = __webpack_require__(192);
	    var Vis = Private(__webpack_require__(549));

	    var notify = new Notifier({
	      location: 'SavedVis'
	    });

	    _['class'](SavedVis).inherits(courier.SavedObject);
	    function SavedVis(opts) {
	      var self = this;
	      opts = opts || {};
	      if (typeof opts !== 'object') opts = { id: opts };

	      SavedVis.Super.call(self, {
	        type: SavedVis.type,
	        mapping: SavedVis.mapping,
	        searchSource: SavedVis.searchSource,

	        id: opts.id,
	        indexPattern: opts.indexPattern,
	        defaults: {
	          title: 'New Visualization',
	          visState: (function () {
	            if (!opts.type) return null;
	            var def = {};
	            def.type = opts.type;
	            return def;
	          })(),
	          description: '',
	          savedSearchId: opts.savedSearchId,
	          version: 1
	        },

	        afterESResp: this._afterEsResp
	      });
	    }

	    SavedVis.type = 'visualization';

	    SavedVis.mapping = {
	      title: 'string',
	      visState: 'json',
	      description: 'string',
	      savedSearchId: 'string',
	      version: 'integer'
	    };

	    SavedVis.searchSource = true;

	    SavedVis.prototype._afterEsResp = function () {
	      var self = this;

	      return self._getLinkedSavedSearch().then(function () {
	        self.searchSource.size(0);

	        return self.vis ? self._updateVis() : self._createVis();
	      }).then(function (vis) {
	        self.searchSource.aggs(function () {
	          self.vis.requesting();
	          return self.vis.aggs.toDsl();
	        });

	        return self;
	      });
	    };

	    SavedVis.prototype._getLinkedSavedSearch = Promise.method(function () {
	      var self = this;
	      var linkedSearch = !!self.savedSearchId;
	      var current = self.savedSearch;

	      if (linkedSearch && current && current.id === self.savedSearchId) {
	        return;
	      }

	      if (self.savedSearch) {
	        self.searchSource.inherits(self.savedSearch.searchSource.getParent());
	        self.savedSearch.destroy();
	        self.savedSearch = null;
	      }

	      if (linkedSearch) {
	        return savedSearches.get(self.savedSearchId).then(function (savedSearch) {
	          self.savedSearch = savedSearch;
	          self.searchSource.inherits(self.savedSearch.searchSource);
	        });
	      }
	    });

	    SavedVis.prototype._createVis = function () {
	      var self = this;

	      if (self.stateJSON) {
	        self.visState = Vis.convertOldState(self.typeName, JSON.parse(self.stateJSON));
	      }

	      self.vis = new Vis(self.searchSource.get('index'), self.visState);

	      return self.vis;
	    };

	    SavedVis.prototype._updateVis = function () {
	      var self = this;

	      self.vis.indexPattern = self.searchSource.get('index');
	      self.vis.setState(self.visState);
	    };

	    return SavedVis;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 681 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(682);
	__webpack_require__(695);
	__webpack_require__(697);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('app/visualize').directive('visEditorSidebar', function () {
	    var _ = __webpack_require__(192);

	    __webpack_require__(682);
	    __webpack_require__(695);

	    return {
	      restrict: 'E',
	      template: __webpack_require__(697),
	      scope: true,
	      controllerAs: 'sidebar',
	      controller: function controller($scope) {
	        $scope.$bind('vis', 'editableVis');
	        $scope.$bind('outputVis', 'vis');
	        this.section = _.get($scope, 'vis.type.requiresSearch') ? 'data' : 'options';
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 682 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(683);
	__webpack_require__(690);
	__webpack_require__(693);
	__webpack_require__(694);

	'use strict';

	var _ = __webpack_require__(192);

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('app/visualize').directive('visEditorAggGroup', function (Private) {
	    __webpack_require__(683);
	    __webpack_require__(690);
	    __webpack_require__(693);

	    return {
	      restrict: 'E',
	      template: __webpack_require__(694),
	      scope: true,
	      link: function link($scope, $el, attr) {
	        $scope.groupName = attr.groupName;
	        $scope.$bind('group', 'vis.aggs.bySchemaGroup["' + $scope.groupName + '"]');
	        $scope.$bind('schemas', 'vis.type.schemas["' + $scope.groupName + '"]');

	        $scope.$watchMulti(['schemas', '[]group'], function () {
	          var stats = $scope.stats = {
	            min: 0,
	            max: 0,
	            count: $scope.group ? $scope.group.length : 0
	          };

	          if (!$scope.schemas) return;

	          $scope.schemas.forEach(function (schema) {
	            stats.min += schema.min;
	            stats.max += schema.max;
	          });

	          $scope.availableSchema = $scope.schemas.filter(function (schema) {
	            var count = _.where($scope.group, { schema: schema }).length;
	            if (count < schema.max) return true;
	          });
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 683 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(684);
	__webpack_require__(690);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(550);
	__webpack_require__(686);
	__webpack_require__(692);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('app/visualize').directive('visEditorAgg', function ($compile, $parse, $filter, Private, Notifier) {
	    __webpack_require__(684);
	    __webpack_require__(690);

	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var aggTypes = Private(__webpack_require__(550));
	    var advancedToggleHtml = __webpack_require__(686);

	    var notify = new Notifier({
	      location: 'visAggGroup'
	    });

	    return {
	      restrict: 'A',
	      template: __webpack_require__(692),
	      require: 'form',
	      link: function link($scope, $el, attrs, kbnForm) {
	        $scope.$bind('outputAgg', 'outputVis.aggs.byId[agg.id]', $scope);
	        $scope.editorOpen = !!$scope.agg.brandNew;

	        $scope.$watch('editorOpen', function (open) {
	          // make sure that all of the form inputs are "touched"
	          // so that their errors propogate
	          if (!open) kbnForm.$setTouched();
	        });

	        $scope.$watchMulti(['$index', 'group.length'], function () {
	          $scope.aggIsTooLow = calcAggIsTooLow();
	        });

	        /**
	         * Describe the aggregation, for display in the collapsed agg header
	         * @return {[type]} [description]
	         */
	        $scope.describe = function () {
	          if (!$scope.agg.type.makeLabel) return '';
	          var label = $scope.agg.type.makeLabel($scope.agg);
	          return label ? label : '';
	        };

	        function move(below, agg) {
	          _.move($scope.vis.aggs, agg, below, function (otherAgg) {
	            return otherAgg.schema.group === agg.schema.group;
	          });
	        }
	        $scope.moveUp = _.partial(move, false);
	        $scope.moveDown = _.partial(move, true);

	        $scope.remove = function (agg) {
	          var aggs = $scope.vis.aggs;

	          var index = aggs.indexOf(agg);
	          if (index === -1) return notify.log('already removed');

	          aggs.splice(index, 1);
	        };

	        $scope.canRemove = function (aggregation) {
	          var metricCount = _.reduce($scope.group, function (count, agg) {
	            return agg.schema.name === aggregation.schema.name ? ++count : count;
	          }, 0);

	          // make sure the the number of these aggs is above the min
	          return metricCount > aggregation.schema.min;
	        };

	        function calcAggIsTooLow() {
	          if (!$scope.agg.schema.mustBeFirst) {
	            return false;
	          }

	          var firstDifferentSchema = _.findIndex($scope.group, function (agg) {
	            return agg.schema !== $scope.agg.schema;
	          });

	          if (firstDifferentSchema === -1) {
	            return false;
	          }

	          return $scope.$index > firstDifferentSchema;
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 684 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(441);
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(550);
	__webpack_require__(685);
	__webpack_require__(686);
	__webpack_require__(687);
	__webpack_require__(688);
	__webpack_require__(689);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var IndexedArray = __webpack_require__(441);

	  __webpack_require__(214).get('app/visualize').directive('visEditorAggParams', function ($compile, $parse, Private, Notifier, $filter) {
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var aggTypes = Private(__webpack_require__(550));
	    var aggSelectHtml = __webpack_require__(685);
	    var advancedToggleHtml = __webpack_require__(686);
	    __webpack_require__(687);
	    __webpack_require__(688);

	    var notify = new Notifier({
	      location: 'visAggGroup'
	    });

	    return {
	      restrict: 'E',
	      template: __webpack_require__(689),
	      scope: true,
	      link: function link($scope, $el, attr) {
	        $scope.$bind('agg', attr.agg);
	        $scope.$bind('groupName', attr.groupName);

	        $scope.aggTypeOptions = aggTypes.byType[$scope.groupName];
	        $scope.advancedToggled = false;

	        // this will contain the controls for the schema (rows or columns?), which are unrelated to
	        // controls for the agg, which is why they are first
	        var $schemaEditor = $('<div>').addClass('schemaEditors').appendTo($el);

	        if ($scope.agg.schema.editor) {
	          $schemaEditor.append($scope.agg.schema.editor);
	          $compile($schemaEditor)($scope.$new());
	        }

	        // allow selection of an aggregation
	        var $aggSelect = $(aggSelectHtml).appendTo($el);
	        $compile($aggSelect)($scope);

	        // params for the selected agg, these are rebuilt every time the agg in $aggSelect changes
	        var $aggParamEditors; //  container for agg type param editors
	        var $aggParamEditorsScope;
	        $scope.$watch('agg.type', function updateAggParamEditor(newType, oldType) {
	          if ($aggParamEditors) {
	            $aggParamEditors.remove();
	            $aggParamEditors = null;
	          }

	          // if there's an old scope, destroy it
	          if ($aggParamEditorsScope) {
	            $aggParamEditorsScope.$destroy();
	            $aggParamEditorsScope = null;
	          }

	          // create child scope, used in the editors
	          $aggParamEditorsScope = $scope.$new();

	          var agg = $scope.agg;
	          if (!agg) return;

	          var type = $scope.agg.type;

	          if (newType !== oldType) {
	            // don't reset on initial load, the
	            // saved params should persist
	            agg.resetParams();
	          }

	          if (!type) return;

	          var aggParamHTML = {
	            basic: [],
	            advanced: []
	          };

	          // build collection of agg params html
	          type.params.forEach(function (param, i) {
	            var aggParam;
	            // if field param exists, compute allowed fields
	            if (param.name === 'field') {
	              $aggParamEditorsScope.indexedFields = getIndexedFields(param);
	            }

	            if ($aggParamEditorsScope.indexedFields) {
	              var hasIndexedFields = $aggParamEditorsScope.indexedFields.length > 0;
	              var isExtraParam = i > 0;
	              if (!hasIndexedFields && isExtraParam) {
	                // don't draw the rest of the options if their are no indexed fields.
	                return;
	              }
	            }

	            var type = 'basic';
	            if (param.advanced) type = 'advanced';

	            if (aggParam = getAggParamHTML(param, i)) {
	              aggParamHTML[type].push(aggParam);
	            }
	          });

	          // compile the paramEditors html elements
	          var paramEditors = aggParamHTML.basic;

	          if (aggParamHTML.advanced.length) {
	            paramEditors.push($(advancedToggleHtml).get(0));
	            paramEditors = paramEditors.concat(aggParamHTML.advanced);
	          }

	          $aggParamEditors = $(paramEditors).appendTo($el);
	          $compile($aggParamEditors)($aggParamEditorsScope);
	        });

	        // build HTML editor given an aggParam and index
	        function getAggParamHTML(param, idx) {
	          // don't show params without an editor
	          if (!param.editor) {
	            return;
	          }

	          var attrs = {
	            'agg-param': 'agg.type.params[' + idx + ']'
	          };

	          if (param.advanced) {
	            attrs['ng-show'] = 'advancedToggled';
	          }

	          return $('<vis-agg-param-editor>').attr(attrs).append(param.editor).get(0);
	        }

	        function getIndexedFields(param) {
	          var fields = $scope.agg.vis.indexPattern.fields.raw;
	          var fieldTypes = param.filterFieldTypes;

	          if (fieldTypes) {
	            fields = $filter('fieldType')(fields, fieldTypes);
	            fields = $filter('filter')(fields, { bucketable: true });
	            fields = $filter('orderBy')(fields, ['type', 'name']);
	          }

	          return new IndexedArray({

	            /**
	             * @type {Array}
	             */
	            index: ['name'],

	            /**
	             * [group description]
	             * @type {Array}
	             */
	            initialSet: fields
	          });
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 685 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label ng-if=\"$index < 1 || groupName !== 'buckets'\">Aggregation</label>\n  <label ng-if=\"$index >= 1 && groupName === 'buckets'\">Sub Aggregation</label>\n  <select\n    name=\"agg\"\n    class=\"form-control\"\n    ng-model=\"agg.type\"\n    required\n    auto-select-if-only-one=\"aggTypeOptions | aggFilter:agg.schema.aggFilter\"\n    ng-options=\"agg as agg.title for agg in aggTypeOptions | aggFilter:agg.schema.aggFilter\">\n  </select>\n</div>\n"

/***/ },
/* 686 */
/***/ function(module, exports) {

	module.exports = "<div class=\"vis-editor-agg-editor-advanced-toggle\">\n  <a ng-click=\"advancedToggled = !advancedToggled\">\n    <i aria-hidden=\"true\" class=\"fa fa-caret-down\" ng-class=\"{'fa-caret-down': advancedToggled, 'fa-caret-left': !advancedToggled}\"></i>\n    Advanced\n  </a>\n</div>"

/***/ },
/* 687 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	// Gets all fields of a given type.
	// You may also pass "*" to get all types
	// Or an array of types to get all fields of that type
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').filter('matchAny', function () {
	    return function (items, rules) {
	      if (!_.isArray(rules)) {
	        rules = [rules];
	      }

	      return _.filter(items, function (item) {
	        for (var i = 0; i < rules.length; i++) {
	          if (_.some([item], rules[i])) {
	            return true;
	          }
	        }

	        return false;
	      });
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 688 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('app/visualize').directive('visAggParamEditor', function (config, $parse, Private) {
	    return {
	      restrict: 'E',
	      scope: true,
	      template: function template($el) {
	        return $el.html();
	      },
	      link: {
	        pre: function pre($scope, $el, attr) {
	          $scope.$bind('aggParam', attr.aggParam);
	        },
	        post: function post($scope, $el, attr) {
	          $scope.config = config;

	          $scope.optionEnabled = function (option) {
	            if (option && _.isFunction(option.enabled)) {
	              return option.enabled($scope.agg);
	            }

	            return true;
	          };
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 689 */
/***/ function(module, exports) {

	module.exports = "<div ng-if=\"aggIsTooLow\" class=\"form-group\">\n  <p class=\"vis-editor-agg-error\">\n    \"{{ agg.schema.title }}\" aggs must run before all other buckets!\n  </p>\n  <input\n    type=\"number\"\n    name=\"order\"\n    ng-model=\"$index\"\n    max=\"{{aggIsTooLow ? $index - 1 : $index}}\"\n    style=\"display: none;\">\n</div>\n\n<!-- schema editors get added down here: aggSelect.html, agg_types/controls/*.html -->"

/***/ },
/* 690 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(633);
	__webpack_require__(691);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana').directive('visEditorAggAdd', function (Private) {
	    var AggConfig = Private(__webpack_require__(633));

	    return {
	      restrict: 'E',
	      template: __webpack_require__(691),
	      controllerAs: 'add',
	      controller: function controller($scope) {
	        var self = this;

	        self.form = false;
	        self.submit = function (schema) {
	          self.form = false;

	          var aggConfig = new AggConfig($scope.vis, {
	            schema: schema
	          });
	          aggConfig.brandNew = true;

	          $scope.vis.aggs.push(aggConfig);
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 691 */
/***/ function(module, exports) {

	module.exports = "<div ng-show=\"add.form\" class=\"vis-editor-agg-add-schemas\">\n  <label>Select {{ groupName }} type</label>\n  <ul class=\"form-group list-group list-group-menu\">\n    <li\n      ng-repeat=\"schema in availableSchema\"\n      ng-click=\"add.submit(schema)\"\n      class=\"list-group-item list-group-menu-item\">\n      <i ng-show=\"schema.icon\" ng-class=\"schema.icon\"></i>\n      {{schema.title}}\n    </li>\n  </ul>\n</div>\n\n<div\n  ng-if=\"stats.max > stats.count\"\n  ng-init=\"add.form = stats.count < 1 ? !add.form : add.form\"\n  ng-click=\"add.form = !add.form\"\n  class=\"vis-editor-agg-wide-btn\">\n\n  <div ng-if=\"!add.form\">\n    <div class=\"vis-editor-agg-wide-btn-add\" ng-if=\"groupName !== 'buckets' || !stats.count\">\n      <i aria-hidden=\"true\" class=\"fa fa-plus\"></i> Add {{ groupName }}\n    </div>\n    <div class=\"vis-editor-agg-wide-btn-add\" ng-if=\"groupName === 'buckets' && stats.count > 0\">\n      <i aria-hidden=\"true\" class=\"fa fa-code-fork\"></i> Add sub-{{ groupName }}\n    </div>\n  </div>\n  <div class=\"vis-editor-agg-wide-btn-add\" ng-if=\"add.form\">\n    Cancel\n  </div>\n</div>"

/***/ },
/* 692 */
/***/ function(module, exports) {

	module.exports = "<!-- header -->\n<div class=\"vis-editor-agg-header\">\n\n  <!-- open/close editor -->\n  <button\n    aria-label=\"{{ editorOpen ? 'Close Editor' : 'Open Editor' }}\"\n    ng-click=\"editorOpen = !editorOpen\"\n    type=\"button\"\n    class=\"btn btn-default btn-xs vis-editor-agg-header-toggle\">\n    <i aria-hidden=\"true\" ng-class=\"{ 'fa-caret-down': editorOpen, 'fa-caret-right': !editorOpen }\" class=\"fa\"></i>\n  </button>\n\n  <!-- title -->\n  <span class=\"vis-editor-agg-header-title\">\n    {{ agg.schema.title }}\n  </span>\n\n  <!-- description -->\n  <span ng-if=\"!editorOpen && aggForm.$valid\" class=\"vis-editor-agg-header-description\">\n    {{ describe() }}\n  </span>\n\n  <!-- error -->\n  <span ng-if=\"!editorOpen && aggForm.$invalid\" class=\"vis-editor-agg-header-description danger\">\n    {{ aggForm.describeErrors() }}\n  </span>\n\n  <!-- controls !!!actually disabling buttons will break tooltips -->\n  <div class=\"vis-editor-agg-header-controls btn-group\">\n    <!-- up button -->\n    <button\n      aria-label=\"Increase Priority\"\n      ng-if=\"stats.count > 1\"\n      ng-class=\"{ disabled: $first }\"\n      ng-click=\"moveUp(agg)\"\n      tooltip=\"Increase Priority\"\n      tooltip-append-to-body=\"true\"\n      type=\"button\"\n      class=\"btn btn-xs btn-default\">\n      <i aria-hidden=\"true\" class=\"fa fa-caret-up\"></i>\n    </button>\n\n    <!-- down button -->\n    <button\n      aria-lebl=\"Decrease Priority\"\n      ng-if=\"stats.count > 1\"\n      ng-class=\"{ disabled: $last }\"\n      ng-click=\"moveDown(agg)\"\n      tooltip=\"Decrease Priority\"\n      tooltip-append-to-body=\"true\"\n      type=\"button\"\n      class=\"btn btn-xs btn-default\">\n      <i aria-hidden=\"true\" class=\"fa fa-caret-down\"></i>\n    </button>\n\n    <!-- remove button -->\n    <button\n      ng-if=\"canRemove(agg)\"\n      aria-label=\"Remove Dimension\"\n      ng-if=\"stats.count > stats.min\"\n      ng-click=\"remove(agg)\"\n      tooltip=\"Remove Dimension\"\n      tooltip-append-to-body=\"true\"\n      type=\"button\"\n      class=\"btn btn-xs btn-danger\">\n      <i aria-hidden=\"true\" class=\"fa fa-times\"></i>\n    </button>\n  </div>\n</div>\n\n<vis-editor-agg-params\n  agg=\"agg\"\n  group-name=\"groupName\"\n  ng-show=\"editorOpen\"\n  class=\"vis-editor-agg-editor\">\n</vis-editor-agg-params>\n\n<vis-editor-agg-add\n  ng-if=\"$index + 1 === stats.count\"\n  class=\"vis-editor-agg-add vis-editor-agg-add-subagg\">\n</vis-editor-agg-add>\n"

/***/ },
/* 693 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(366);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana').directive('nestingIndicator', function ($rootScope, $parse, Private) {
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var getColors = Private(__webpack_require__(366));

	    return {
	      restrict: 'E',
	      scope: {
	        item: '=',
	        list: '='
	      },
	      link: function link($scope, $el, attr) {
	        $scope.$watchCollection('list', function () {
	          if (!$scope.list || !$scope.item) return;

	          var item = $scope.item;
	          var index = $scope.list.indexOf($scope.item);
	          var bars = $scope.list.slice(0, index + 1);
	          var colors = getColors(bars.length);

	          $el.html(bars.map(function (bar, i) {
	            return $(document.createElement('span')).css('background-color', colors[i]);
	          }));
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 694 */
/***/ function(module, exports) {

	module.exports = "<div class=\"sidebar-item\">\n  <div class=\"sidebar-item-title\">\n    {{ groupName }}\n  </div>\n\n  <div class=\"vis-editor-agg-group\" ng-class=\"groupName\">\n    <!-- wrapper needed for nesting-indicator -->\n    <div ng-repeat=\"agg in group\" class=\"vis-editor-agg-wrapper\">\n      <nesting-indicator\n        ng-if=\"groupName === 'buckets'\"\n        item=\"agg\"\n        index=\"$index\"\n        list=\"group\">\n      </nesting-indicator>\n\n      <!-- agg.html - controls for aggregation -->\n      <ng-form vis-editor-agg name=\"aggForm\" class=\"vis-editor-agg\"></ng-form>\n    </div>\n\n    <vis-editor-agg-add ng-if=\"stats.count === 0\" class=\"vis-editor-agg-add\"></vis-editor-agg-add>\n  </div>\n</div>\n"

/***/ },
/* 695 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(214);
	__webpack_require__(696);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);

	  __webpack_require__(214).get('app/visualize').directive('visEditorVisOptions', function (Private, $timeout, $compile) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(696),
	      scope: {
	        vis: '='
	      },
	      link: function link($scope, $el) {
	        var $optionContainer = $('.visualization-options');
	        var $editor = $compile($scope.vis.type.params.editor)($scope);
	        $optionContainer.append($editor);

	        $scope.$watch('vis.type.schemas.all.length', function (len) {
	          $scope.alwaysShowOptions = len === 0;
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 696 */
/***/ function(module, exports) {

	module.exports = "<div class=\"sidebar-item\" ng-show=\"vis.type.params.editor\">\n  <div class=\"sidebar-item-title\">\n    view options\n  </div>\n  <div class=\"visualization-options\"></div>\n</div>\n"

/***/ },
/* 697 */
/***/ function(module, exports) {

	module.exports = "<div class=\"sidebar-container\">\n  <form class=\"sidebar-list\"\n        ng-submit=\"visualizeEditor.$invalid ? dontApply() : stageEditableVis()\"\n        name=\"visualizeEditor\"\n        novalidate><!-- see http://goo.gl/9kgz5w -->\n\n    <div css-truncate title=\"{{indexPattern.id}}\" ng-if=\"vis.type.requiresSearch\" class=\"index-pattern\">\n      {{ indexPattern.id }}\n    </div>\n\n    <nav class=\"navbar navbar-default subnav\">\n      <div class=\"container-fluid\">\n\n        <!-- tabs -->\n        <ul class=\"nav navbar-nav\">\n          <li ng-class=\"{active: sidebar.section == 'data'}\" ng-show=\"vis.type.schemas.metrics\">\n            <a class=\"navbar-link active\" ng-click=\"sidebar.section='data'\">Data</a>\n          </li>\n          <li ng-class=\"{active: sidebar.section == 'options'}\">\n            <a class=\"navbar-link\" ng-click=\"sidebar.section='options'\">Options</a>\n          </li>\n        </ul>\n\n        <!-- controls -->\n        <ul class=\"nav navbar-nav navbar-right\">\n          <li ng-if=\"visualizeEditor.softErrorCount() > 0\"\n            disabled\n            tooltip=\"{{ visualizeEditor.describeErrors() }}\" tooltip-placement=\"bottom\" tooltip-popup-delay=\"400\" tooltip-append-to-body=\"1\">\n            <a class=\"danger navbar-link\">\n              <i class=\"fa fa-warning\"></i>\n            </a>\n          </li>\n          <li tooltip=\"Apply changes\" tooltip-placement=\"bottom\" tooltip-popup-delay=\"400\" tooltip-append-to-body=\"1\">\n            <button class=\"btn-success navbar-btn-link\"\n              type=\"submit\"\n              ng-disabled=\"!vis.dirty\">\n\n              <i class=\"fa fa-play\"></i>\n            </button>\n          </li>\n          <li tooltip=\"Discard changes\" tooltip-placement=\"bottom\" tooltip-popup-delay=\"400\" tooltip-append-to-body=\"1\">\n            <button class=\"btn-default navbar-btn-link\"\n              ng-disabled=\"!vis.dirty\"\n              ng-click=\"resetEditableVis()\">\n\n              <i class=\"fa fa-close\"></i>\n            </button>\n          </li>\n        </ul>\n      </div>\n    </nav>\n\n    <div class=\"vis-editor-config\" ng-show=\"sidebar.section == 'data'\">\n      <!-- metrics -->\n      <vis-editor-agg-group ng-if=\"vis.type.schemas.metrics\" group-name=\"metrics\"></vis-editor-agg-group>\n\n      <!-- buckets -->\n      <vis-editor-agg-group ng-if=\"vis.type.schemas.buckets\" group-name=\"buckets\"></vis-editor-agg-group>\n    </div>\n\n    <div class=\"vis-editor-config\" ng-show=\"sidebar.section == 'options'\">\n      <!-- vis options -->\n      <vis-editor-vis-options vis=\"vis\"></vis-editor-vis-options>\n    </div>\n\n\n  </form>\n</div>\n\n"

/***/ },
/* 698 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(596);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var propFilter = __webpack_require__(596);

	  __webpack_require__(214).get('kibana').filter('aggFilter', function () {
	    return propFilter('name');
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 699 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"VisEditor\" class=\"vis-editor vis-type-{{ vis.type.name }}\">\n\n  <navbar ng-if=\"chrome.getVisible()\">\n    <div class=\"fill bitty-modal-container\">\n      <div ng-if=\"vis.type.requiresSearch && $state.linked && !unlinking\"\n        ng-dblclick=\"unlink()\"\n        tooltip=\"Double click to unlink this visualization from the saved search\"\n        class=\"bitty-modal visualize-linked\">\n        <i aria-hidden=\"true\" class=\"fa fa-link\"></i>\n        &nbsp;\n        This visualization is linked to a saved search:\n        <b>{{ savedVis.savedSearch.title }}</b>\n      </div>\n\n      <div\n        ng-if=\"vis.type.requiresSearch && unlinking\"\n        ng-click=\"clearUnlinking()\"\n        class=\"bitty-modal\">\n        <i aria-hidden=\"true\" class=\"fa fa-chain-broken\"></i> Unlinked!\n      </div>\n\n      <form ng-if=\"vis.type.requiresSearch && $state.linked\" class=\"inline-form fill\" name=\"queryInput\">\n        <div class=\"typeahead\">\n          <div class=\"input-group\">\n            <input\n              disabled\n              type=\"text\"\n              class=\"form-control\">\n\n            <button\n              class=\"btn btn-default\" type=\"submit\"\n              ng-disabled=\"true\" aria-label=\"Search\">\n              <span aria-hidden=\"true\" class=\"fa fa-search\"></span>\n            </button>\n          </div>\n        </div>\n      </form>\n\n      <form\n        ng-if=\"vis.type.requiresSearch && !$state.linked\"\n        ng-submit=\"fetch()\"\n        class=\"inline-form fill\"\n        name=\"queryInput\">\n        <div class=\"typeahead\" kbn-typeahead=\"visualize\">\n          <div class=\"input-group\"\n            ng-class=\"queryInput.$invalid ? 'has-error' : ''\">\n            <input\n              ng-model=\"state.query\"\n              validate-query\n              input-focus\n              kbn-typeahead-input\n              placeholder=\"Search...\"\n              type=\"text\"\n              class=\"form-control\">\n\n            <button\n              class=\"btn btn-default\" type=\"submit\"\n              ng-disabled=\"queryInput.$invalid\" aria-label=\"Search\">\n              <span aria-hidden=\"true\" class=\"fa fa-search\"></span>\n            </button>\n          </div>\n          <kbn-typeahead-items></kbn-typeahead-items>\n        </div>\n      </form>\n    </div>\n\n    <div class=\"button-group\">\n      <kbn-tooltip text=\"New Visualization\" placement=\"bottom\" append-to-body=\"1\">\n        <button ng-click=\"startOver()\" aria-label=\"New Visualization\"><i aria-hidden=\"true\" class=\"fa fa-file-new-o\"></i></button>\n      </kbn-tooltip>\n\n      <kbn-tooltip text=\"Save Visualization\" placement=\"bottom\" append-to-body=\"1\">\n        <!-- normal save -->\n        <button\n          ng-class=\"{active: configTemplate.is('save')}\"\n          ng-click=\"configTemplate.toggle('save')\"\n          ng-if=\"!editableVis.dirty\"\n          aria-expanded=\"{{ configTemplate.is('save') }}\"\n          aria-label=\"Save Visualization\">\n          <i aria-hidden=\"true\" class=\"fa fa-save\"></i>\n        </button>\n\n        <!-- save stub with tooltip -->\n        <button disabled ng-if=\"editableVis.dirty\" tooltip=\"Apply or Discard your changes before saving\" aria-label=\"Apply or Discard your changes before saving\">\n          <i aria-hidden=\"true\" class=\"fa fa-save\"></i>\n        </button>\n      </kbn-tooltip>\n\n      <kbn-tooltip text=\"Load Saved Visualization\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          ng-class=\"{active: configTemplate.is('load')}\"\n          ng-click=\"configTemplate.toggle('load')\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('load') }}\"\n          aria-label=\"Load Saved Visualization\">\n          <i aria-hidden=\"true\" class=\"fa fa-folder-open-o\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Share Visualization\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          ng-class=\"{active: configTemplate.is('share')}\"\n          ng-click=\"configTemplate.toggle('share')\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('share') }}\"\n          aria-label=\"Share Visualization\">\n          <i aria-hidden=\"true\" class=\"fa fa-external-link\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Refresh\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          ng-click=\"fetch()\"\n          aria-label=\"Refresh\">\n          <i aria-hidden=\"true\" class=\"fa fa-refresh\"></i>\n        </button>\n      </kbn-tooltip>\n    </div>\n  </navbar>\n\n  <config\n    ng-if=\"chrome.getVisible()\"\n    config-template=\"configTemplate\"\n    config-object=\"conf\">\n  </config>\n\n  <filter-bar state=\"state\"></filter-bar>\n\n  <div class=\"vis-editor-content\">\n\n    <div class=\"collapsible-sidebar\">\n        <vis-editor-sidebar class=\"vis-editor-sidebar\" ng-if=\"chrome.getVisible()\"></vis-editor-sidebar>\n    </div>\n\n    <div class=\"vis-editor-canvas\" ng-class=\"{ embedded: !chrome.getVisible() }\">\n      <div class=\"visualize-info\" ng-if=\"savedVis.id\">\n        <div class=\"visualize-info-tab\" title=\"{{savedVis.vis.type.title}}\">\n          <i class=\"fa\" aria-label=\"{{savedVis.vis.type.title}} Icon\" ng-class=\"savedVis.vis.type.icon\"></i>\n          <span bindonce bo-bind=\"savedVis.title\"></span>\n        </div>\n      </div>\n\n      <visualize vis=\"vis\" editable-vis=\"editableVis\"  search-source=\"savedVis.searchSource\"></visualize>\n    </div>\n  </div>\n\n</div>\n"

/***/ },
/* 700 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(657);
	__webpack_require__(656);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var dedupFilters = __webpack_require__(657);
	  var uniqFilters = __webpack_require__(656);

	  // given an object or array of objects, return the value of the passed param
	  // if the param is missing, return undefined
	  function findByParam(values, param) {
	    if (_.isArray(values)) {
	      // point series chart
	      var index = _.findIndex(values, param);
	      if (index === -1) return;
	      return values[index][param];
	    }
	    return values[param]; // pie chart
	  }

	  return function (Notifier) {
	    return function ($state) {
	      return function (event) {
	        var notify = new Notifier({
	          location: 'Filter bar'
	        });
	        var aggConfigResult;

	        // Hierarchical and tabular data set their aggConfigResult parameter
	        // differently because of how the point is rewritten between the two. So
	        // we need to check if the point.orig is set, if not use try the point.aggConfigResult
	        if (event.point.orig) {
	          aggConfigResult = event.point.orig.aggConfigResult;
	        } else if (event.point.values) {
	          aggConfigResult = findByParam(event.point.values, 'aggConfigResult');
	        } else {
	          aggConfigResult = event.point.aggConfigResult;
	        }

	        if (aggConfigResult) {
	          var isLegendLabel = !!event.point.values;
	          var aggBuckets = _.filter(aggConfigResult.getPath(), { type: 'bucket' });

	          // For legend clicks, use the last bucket in the path
	          if (isLegendLabel) {
	            // series data has multiple values, use aggConfig on the first
	            // hierarchical data values is an object with the addConfig
	            var aggConfig = findByParam(event.point.values, 'aggConfig');
	            aggBuckets = aggBuckets.filter(function (result) {
	              return result.aggConfig && result.aggConfig === aggConfig;
	            });
	          }

	          var filters = _(aggBuckets).map(function (result) {
	            try {
	              return result.createFilter();
	            } catch (e) {
	              notify.warning(e.message);
	            }
	          }).filter(Boolean).value();

	          if (!filters.length) return;

	          filters = dedupFilters($state.filters, uniqFilters(filters));
	          // We need to add a bunch of filter deduping here.
	          $state.$newFilters = filters;
	        }
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 701 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" ng-submit=\"conf.doSave()\">\n  <div class=\"form-group\">\n    <label for=\"visTitle\">Title</label>\n    <input class=\"form-control\" input-focus=\"select\" type=\"text\" name=\"visTitle\" ng-model=\"conf.savedVis.title\" required>\n  </div>\n  <button type=\"submit\" class=\"btn btn-primary\">Save</button>\n</form>"

/***/ },
/* 702 */
/***/ function(module, exports) {

	module.exports = "<saved-object-finder type=\"visualizations\"></saved-object-finder>"

/***/ },
/* 703 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" class=\"vis-share\">\n\n  <p>\n    <div class=\"form-group\">\n      <label>\n        Embed this visualization.\n        <small>Add to your html source. Note all clients must still be able to access kibana</small>\n      </label>\n      <div class=\"form-control\" disabled>{{conf.shareData().embed}}</div>\n    </div>\n  </p>\n\n  <p>\n    <div class=\"form-group\">\n      <label>\n        Share a link\n      </label>\n      <div class=\"form-control\" disabled>{{conf.shareData().link}}</div>\n    </div>\n  </p>\n\n</form>"

/***/ },
/* 704 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(679);
	__webpack_require__(705);
	__webpack_require__(328);
	__webpack_require__(214);
	__webpack_require__(216);
	__webpack_require__(707);
	__webpack_require__(479);
	__webpack_require__(708);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(679);
	  __webpack_require__(705);
	  __webpack_require__(328);

	  var templateStep = function templateStep(num, txt) {
	    return '<div ng-controller="VisualizeWizardStep' + num + '" class="container vis-wizard">' + txt + '</div>';
	  };

	  var module = __webpack_require__(214).get('app/visualize', ['kibana/courier']);
	  var routes = __webpack_require__(216);

	  /********
	  /** Wizard Step 1
	  /********/
	  routes.when('/visualize/step/1', {
	    template: templateStep(1, __webpack_require__(707))
	  });

	  module.controller('VisualizeWizardStep1', function ($scope, $route, $location, timefilter, Private) {
	    timefilter.enabled = false;

	    $scope.visTypes = Private(__webpack_require__(479));
	    $scope.visTypeUrl = function (visType) {
	      if (!visType.requiresSearch) return '#/visualize/create?type=' + encodeURIComponent(visType.name);else return '#/visualize/step/2?type=' + encodeURIComponent(visType.name);
	    };
	  });

	  /********
	  /** Wizard Step 2
	  /********/
	  routes.when('/visualize/step/2', {
	    template: templateStep(2, __webpack_require__(708)),
	    resolve: {
	      indexPatternIds: function indexPatternIds(courier) {
	        return courier.indexPatterns.getIds();
	      }
	    }
	  });

	  module.controller('VisualizeWizardStep2', function ($route, $scope, $location, timefilter, kbnUrl) {
	    var type = $route.current.params.type;

	    $scope.step2WithSearchUrl = function (hit) {
	      return kbnUrl.eval('#/visualize/create?&type={{type}}&savedSearchId={{id}}', { type: type, id: hit.id });
	    };

	    timefilter.enabled = false;

	    $scope.indexPattern = {
	      selection: null,
	      list: $route.current.locals.indexPatternIds
	    };

	    $scope.$watch('stepTwoMode', function (mode) {
	      if (mode === 'new') {
	        if ($scope.indexPattern.list && $scope.indexPattern.list.length === 1) {
	          $scope.indexPattern.selection = $scope.indexPattern.list[0];
	        }
	      }
	    });

	    $scope.$watch('indexPattern.selection', function (pattern) {
	      if (!pattern) return;
	      kbnUrl.change('/visualize/create?type={{type}}&indexPattern={{pattern}}', { type: type, pattern: pattern });
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 705 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(250);
	__webpack_require__(576);
	__webpack_require__(674);
	__webpack_require__(706);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var _ = __webpack_require__(192);
	  var rison = __webpack_require__(250);
	  var keymap = __webpack_require__(576);

	  module.directive('savedObjectFinder', function ($location, $injector, kbnUrl, Private) {

	    var services = Private(__webpack_require__(674)).byLoaderPropertiesName;

	    return {
	      restrict: 'E',
	      scope: {
	        type: '@',
	        title: '@?',
	        // optional make-url attr, sets the userMakeUrl in our scope
	        userMakeUrl: '=?makeUrl',
	        // optional on-choose attr, sets the userOnChoose in our scope
	        userOnChoose: '=?onChoose'
	      },
	      template: __webpack_require__(706),
	      controllerAs: 'finder',
	      controller: function controller($scope, $element, $timeout) {
	        var self = this;

	        // the text input element
	        var $input = $element.find('input[ng-model=filter]');

	        // the list that will hold the suggestions
	        var $list = $element.find('ul');

	        // the current filter string, used to check that returned results are still useful
	        var currentFilter = $scope.filter;

	        // the most recently entered search/filter
	        var prevSearch;

	        // the list of hits, used to render display
	        self.hits = [];

	        self.service = services[$scope.type];
	        self.properties = self.service.loaderProperties;

	        filterResults();

	        /**
	         * Passed the hit objects and will determine if the
	         * hit should have a url in the UI, returns it if so
	         * @return {string|null} - the url or nothing
	         */
	        self.makeUrl = function (hit) {
	          if ($scope.userMakeUrl) {
	            return $scope.userMakeUrl(hit);
	          }

	          if (!$scope.userOnChoose) {
	            return hit.url;
	          }

	          return '#';
	        };

	        self.preventClick = function ($event) {
	          $event.preventDefault();
	        };

	        /**
	         * Called when a hit object is clicked, can override the
	         * url behavior if necessary.
	         */
	        self.onChoose = function (hit, $event) {
	          if ($scope.userOnChoose) {
	            $scope.userOnChoose(hit, $event);
	          }

	          var url = self.makeUrl(hit);
	          if (!url || url === '#' || url.charAt(0) !== '#') return;

	          $event.preventDefault();

	          // we want the '/path', not '#/path'
	          kbnUrl.change(url.substr(1));
	        };

	        $scope.$watch('filter', function (newFilter) {
	          // ensure that the currentFilter changes from undefined to ''
	          // which triggers
	          currentFilter = newFilter || '';
	          filterResults();
	        });

	        //manages the state of the keyboard selector
	        self.selector = {
	          enabled: false,
	          index: -1
	        };

	        //key handler for the filter text box
	        self.filterKeyDown = function ($event) {
	          switch (keymap[$event.keyCode]) {
	            case 'tab':
	              if (self.hitCount === 0) return;

	              self.selector.index = 0;
	              self.selector.enabled = true;

	              selectTopHit();

	              $event.preventDefault();
	              break;
	            case 'enter':
	              if (self.hitCount !== 1) return;

	              var hit = self.hits[0];
	              if (!hit) return;

	              self.onChoose(hit, $event);
	              $event.preventDefault();
	              break;
	          }
	        };

	        //key handler for the list items
	        self.hitKeyDown = function ($event, page, paginate) {
	          switch (keymap[$event.keyCode]) {
	            case 'tab':
	              if (!self.selector.enabled) break;

	              self.selector.index = -1;
	              self.selector.enabled = false;

	              //if the user types shift-tab return to the textbox
	              //if the user types tab, set the focus to the currently selected hit.
	              if ($event.shiftKey) {
	                $input.focus();
	              } else {
	                $list.find('li.active a').focus();
	              }

	              $event.preventDefault();
	              break;
	            case 'down':
	              if (!self.selector.enabled) break;

	              if (self.selector.index + 1 < page.length) {
	                self.selector.index += 1;
	              }
	              $event.preventDefault();
	              break;
	            case 'up':
	              if (!self.selector.enabled) break;

	              if (self.selector.index > 0) {
	                self.selector.index -= 1;
	              }
	              $event.preventDefault();
	              break;
	            case 'right':
	              if (!self.selector.enabled) break;

	              if (page.number < page.count) {
	                paginate.goToPage(page.number + 1);
	                self.selector.index = 0;
	                selectTopHit();
	              }
	              $event.preventDefault();
	              break;
	            case 'left':
	              if (!self.selector.enabled) break;

	              if (page.number > 1) {
	                paginate.goToPage(page.number - 1);
	                self.selector.index = 0;
	                selectTopHit();
	              }
	              $event.preventDefault();
	              break;
	            case 'escape':
	              if (!self.selector.enabled) break;

	              $input.focus();
	              $event.preventDefault();
	              break;
	            case 'enter':
	              if (!self.selector.enabled) break;

	              var hitIndex = (page.number - 1) * paginate.perPage + self.selector.index;
	              var hit = self.hits[hitIndex];
	              if (!hit) break;

	              self.onChoose(hit, $event);
	              $event.preventDefault();
	              break;
	            case 'shift':
	              break;
	            default:
	              $input.focus();
	              break;
	          }
	        };

	        self.hitBlur = function ($event) {
	          self.selector.index = -1;
	          self.selector.enabled = false;
	        };

	        self.manageObjects = function (type) {
	          $location.url('/settings/objects?_a=' + rison.encode({ tab: type }));
	        };

	        self.hitCountNoun = function () {
	          return (self.hitCount === 1 ? self.properties.noun : self.properties.nouns).toLowerCase();
	        };

	        function selectTopHit() {
	          setTimeout(function () {
	            //triggering a focus event kicks off a new angular digest cycle.
	            $list.find('a:first').focus();
	          }, 0);
	        }

	        function filterResults() {
	          if (!self.service) return;
	          if (!self.properties) return;

	          // track the filter that we use for this search,
	          // but ensure that we don't search for the same
	          // thing twice. This is called from multiple places
	          // and needs to be smart about when it actually searches
	          var filter = currentFilter;
	          if (prevSearch === filter) return;

	          prevSearch = filter;
	          self.service.find(filter).then(function (hits) {
	            // ensure that we don't display old results
	            // as we can't really cancel requests
	            if (currentFilter === filter) {
	              self.hitCount = hits.total;
	              self.hits = _.sortBy(hits.hits, 'title');
	            }
	          });
	        }

	        function scrollIntoView($element, snapTop) {
	          var el = $element[0];

	          if (!el) return;

	          if ('scrollIntoViewIfNeeded' in el) {
	            el.scrollIntoViewIfNeeded(snapTop);
	          } else if ('scrollIntoView' in el) {
	            el.scrollIntoView(snapTop);
	          }
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 706 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\">\n  <div class=\"form-group finder-form\">\n    <div class=\"finder-form-options\">\n      <a class=\"small\" ng-click=\"finder.manageObjects(finder.properties.name)\">manage {{finder.properties.nouns}}</a>\n    </div>\n    <div class=\"clearfix visible-xs-block\"></div>\n    <input\n      input-focus\n      ng-model=\"filter\"\n      ng-attr-placeholder=\"{{finder.properties.noun}} Filter\"\n      ng-keydown=\"finder.filterKeyDown($event)\"\n      class=\"form-control\"\n      name=\"filter\"\n      type=\"text\" />\n\n    <span class=\"finder-hit-count\"><strong>{{finder.hitCount}}</strong> {{finder.hitCountNoun()}}</span>\n  </div>\n</form>\n<paginate list=\"finder.hits\" per-page=\"5\">\n  <ul\n    class=\"list-group list-group-menu\"\n    ng-class=\"{'select-mode': finder.selector.enabled}\">\n\n    <li\n      class=\"list-group-item list-group-menu-item\"\n      ng-class=\"{'active': finder.selector.index === $index && finder.selector.enabled}\"\n      ng-repeat=\"hit in page\"\n      ng-keydown=\"finder.hitKeyDown($event, page, paginate)\"\n      ng-click=\"finder.onChoose(hit, $event)\">\n\n      <a\n        ng-href=\"{{finder.makeUrl(hit)}}\"\n        ng-blur=\"finder.hitBlur($event)\"\n        ng-click=\"finder.preventClick($event)\">\n\n        <i aria-hidden=\"true\" class=\"fa\" ng-if=\"hit.icon\" ng-class=\"hit.icon\"></i> {{hit.title}}\n        <p ng-if=\"hit.description\" ng-bind=\"hit.description\"></p>\n      </a>\n    </li>\n    <li\n      class=\"list-group-item list-group-no-results\"\n      ng-if=\"finder.hits.length === 0\">\n      <p ng-bind=\"'No matching ' + finder.properties.nouns + ' found.'\"></p>\n    </li>\n  </ul>\n</paginate>"

/***/ },
/* 707 */
/***/ function(module, exports) {

	module.exports = "<h1>\n  Create a new visualization <br class=\"visible-xs\">\n  <span class=\"pull-right label label-default hidden-xs\">Step 1</span>\n  <span class=\"label label-default visible-xs\">Step 1</span>\n</h1>\n\n<div class=\"wizard-vis-types\">\n  <a class=\"wizard-vis-type\"\n     ng-repeat=\"type in visTypes.inTitleOrder\"\n     ng-href=\"{{ visTypeUrl(type) }}\">\n    <div class=\"wizard-vis-type-heading\">\n      <i aria-hidden=\"true\" class=\"fa fa-fw\" ng-class=\"type.icon\"></i>\n      <h4>{{type.title}}</h4>\n    </div>\n    <p class=\"wizard-vis-type-description\">{{type.description}}</p>\n  </a>\n</div>\n\n<h1>Or, open a saved visualization</h1>\n\n<saved-object-finder\n        title=\"Saved Visualizations\"\n        type=\"visualizations\">\n</saved-object-finder>\n"

/***/ },
/* 708 */
/***/ function(module, exports) {

	module.exports = "<h1>\n  Select a search source\n  <span class=\"pull-right label label-default hidden-xs\">Step 2</span>\n  <span class=\"label label-default visible-xs\">Step 2</span>\n</h1>\n<ul class=\"list-group list-group-menu\" ng-switch on=\"stepTwoMode\">\n  <li ng-click=\"stepTwoMode='new'\"\n      ng-class=\"{'active': stepTwoMode=='new'}\"\n      class=\"list-group-item list-group-menu-item\">\n    From a new search\n  </li>\n  <li class=\"list-group-item\" ng-switch-when=\"new\">\n    <!-- Index patterns -->\n    Select an index pattern\n    <div class=\"form-group\">\n      <select\n              class=\"form-control\"\n              ng-model=\"indexPattern.selection\"\n              ng-options=\"pattern as pattern for pattern in indexPattern.list | orderBy:'toString()'\">\n      </select>\n    </div>\n  </li>\n\n  <li ng-click=\"stepTwoMode='saved'\"\n      ng-class=\"{'active': stepTwoMode=='saved'}\"\n      class=\"list-group-item list-group-menu-item\">\n    From a saved search\n  </li>\n  <li class=\"list-group-item\" ng-switch-when=\"saved\">\n    <!-- Saved searches -->\n    <saved-object-finder\n            title=\"Saved Searches\"\n            type=\"searches\"\n            make-url=\"step2WithSearchUrl\">\n    </saved-object-finder>\n  </li>\n</ul>"

/***/ },
/* 709 */
/***/ function(module, exports) {

	"use strict";

/***/ },
/* 710 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function savedVisualizationFn(savedVisualizations) {
	    return savedVisualizations;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 711 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(209);
	__webpack_require__(304);
	__webpack_require__(1);
	__webpack_require__(305);
	__webpack_require__(496);
	__webpack_require__(712);
	__webpack_require__(308);
	__webpack_require__(716);
	__webpack_require__(721);
	__webpack_require__(727);
	__webpack_require__(732);
	__webpack_require__(734);
	__webpack_require__(674);
	__webpack_require__(735);
	__webpack_require__(214);
	__webpack_require__(216);
	__webpack_require__(736);
	__webpack_require__(652);
	__webpack_require__(737);
	__webpack_require__(738);
	__webpack_require__(739);
	__webpack_require__(740);
	__webpack_require__(741);
	__webpack_require__(649);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var angular = __webpack_require__(209);
	  var ConfigTemplate = __webpack_require__(304);
	  var chrome = __webpack_require__(1);

	  __webpack_require__(305);
	  __webpack_require__(496);
	  __webpack_require__(712);
	  __webpack_require__(308);
	  __webpack_require__(716);

	  __webpack_require__(721);
	  __webpack_require__(727);
	  __webpack_require__(732);
	  __webpack_require__(734);

	  __webpack_require__(674).register(__webpack_require__(735));

	  var app = __webpack_require__(214).get('app/dashboard', ['elasticsearch', 'ngRoute', 'kibana/courier', 'kibana/config', 'kibana/notify', 'kibana/typeahead']);

	  __webpack_require__(216).when('/dashboard', {
	    template: __webpack_require__(736),
	    resolve: {
	      dash: function dash(savedDashboards, config) {
	        return savedDashboards.get();
	      }
	    }
	  }).when('/dashboard/:id', {
	    template: __webpack_require__(736),
	    resolve: {
	      dash: function dash(savedDashboards, Notifier, $route, $location, courier) {
	        return savedDashboards.get($route.current.params.id)['catch'](courier.redirectWhenMissing({
	          'dashboard': '/dashboard'
	        }));
	      }
	    }
	  });

	  app.directive('dashboardApp', function (Notifier, courier, AppState, timefilter, kbnUrl) {
	    return {
	      controller: function controller($scope, $rootScope, $route, $routeParams, $location, Private, getAppState) {

	        var queryFilter = Private(__webpack_require__(652));

	        var notify = new Notifier({
	          location: 'Dashboard'
	        });

	        var dash = $scope.dash = $route.current.locals.dash;

	        if (dash.timeRestore && dash.timeTo && dash.timeFrom && !getAppState.previouslyStored()) {
	          timefilter.time.to = dash.timeTo;
	          timefilter.time.from = dash.timeFrom;
	        }

	        $scope.$on('$destroy', dash.destroy);

	        var matchQueryFilter = function matchQueryFilter(filter) {
	          return filter.query && filter.query.query_string && !filter.meta;
	        };

	        var extractQueryFromFilters = function extractQueryFromFilters(filters) {
	          var filter = _.find(filters, matchQueryFilter);
	          if (filter) return filter.query;
	        };

	        var stateDefaults = {
	          title: dash.title,
	          panels: dash.panelsJSON ? JSON.parse(dash.panelsJSON) : [],
	          options: dash.optionsJSON ? JSON.parse(dash.optionsJSON) : {},
	          query: extractQueryFromFilters(dash.searchSource.getOwn('filter')) || { query_string: { query: '*' } },
	          filters: _.reject(dash.searchSource.getOwn('filter'), matchQueryFilter)
	        };

	        var $state = $scope.state = new AppState(stateDefaults);
	        $scope.$watchCollection('state.options', function (newVal, oldVal) {
	          if (!angular.equals(newVal, oldVal)) $state.save();
	        });
	        $scope.$watch('state.options.darkTheme', setDarkTheme);

	        $scope.configTemplate = new ConfigTemplate({
	          save: __webpack_require__(737),
	          load: __webpack_require__(738),
	          share: __webpack_require__(739),
	          pickVis: __webpack_require__(740),
	          options: __webpack_require__(741)
	        });

	        $scope.refresh = _.bindKey(courier, 'fetch');

	        timefilter.enabled = true;
	        $scope.timefilter = timefilter;
	        $scope.$listen(timefilter, 'fetch', $scope.refresh);

	        courier.setRootSearchSource(dash.searchSource);

	        function init() {
	          updateQueryOnRootSource();

	          var docTitle = Private(__webpack_require__(649));
	          if (dash.id) {
	            docTitle.change(dash.title);
	          }

	          $scope.$emit('application.load');
	        }

	        function updateQueryOnRootSource() {
	          var filters = queryFilter.getFilters();
	          if ($state.query) {
	            dash.searchSource.set('filter', _.union(filters, [{
	              query: $state.query
	            }]));
	          } else {
	            dash.searchSource.set('filter', filters);
	          }
	        }

	        function setDarkTheme(enabled) {
	          var theme = Boolean(enabled) ? 'theme-dark' : 'theme-light';
	          chrome.removeApplicationClass(['theme-dark', 'theme-light']);
	          chrome.addApplicationClass(theme);
	        }

	        // update root source when filters update
	        $scope.$listen(queryFilter, 'update', function () {
	          updateQueryOnRootSource();
	          $state.save();
	        });

	        // update data when filters fire fetch event
	        $scope.$listen(queryFilter, 'fetch', $scope.refresh);

	        $scope.newDashboard = function () {
	          kbnUrl.change('/dashboard', {});
	        };

	        $scope.filterResults = function () {
	          updateQueryOnRootSource();
	          $state.save();
	          $scope.refresh();
	        };

	        $scope.save = function () {
	          $state.title = dash.id = dash.title;
	          $state.save();
	          dash.panelsJSON = angular.toJson($state.panels);
	          dash.timeFrom = dash.timeRestore ? timefilter.time.from : undefined;
	          dash.timeTo = dash.timeRestore ? timefilter.time.to : undefined;
	          dash.optionsJSON = angular.toJson($state.options);

	          dash.save().then(function (id) {
	            $scope.configTemplate.close('save');
	            if (id) {
	              notify.info('Saved Dashboard as "' + dash.title + '"');
	              if (dash.id !== $routeParams.id) {
	                kbnUrl.change('/dashboard/{{id}}', { id: dash.id });
	              }
	            }
	          })['catch'](notify.fatal);
	        };

	        var pendingVis = _.size($state.panels);
	        $scope.$on('ready:vis', function () {
	          if (pendingVis) pendingVis--;
	          if (pendingVis === 0) {
	            $state.save();
	            $scope.refresh();
	          }
	        });

	        // listen for notifications from the grid component that changes have
	        // been made, rather than watching the panels deeply
	        $scope.$on('change:vis', function () {
	          $state.save();
	        });

	        // called by the saved-object-finder when a user clicks a vis
	        $scope.addVis = function (hit) {
	          pendingVis++;
	          $state.panels.push({ id: hit.id, type: 'visualization' });
	        };

	        $scope.addSearch = function (hit) {
	          pendingVis++;
	          $state.panels.push({ id: hit.id, type: 'search' });
	        };

	        // Setup configurable values for config directive, after objects are initialized
	        $scope.opts = {
	          dashboard: dash,
	          ui: $state.options,
	          save: $scope.save,
	          addVis: $scope.addVis,
	          addSearch: $scope.addSearch,
	          shareData: function shareData() {
	            return {
	              link: $location.absUrl(),
	              // This sucks, but seems like the cleanest way. Uhg.
	              embed: '<iframe src="' + $location.absUrl().replace('?', '?embed&') + '" height="600" width="800"></iframe>'
	            };
	          }
	        };

	        init();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 712 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(216);
	__webpack_require__(209);
	__webpack_require__(192);
	__webpack_require__(713);
	__webpack_require__(714);
	__webpack_require__(715);
	__webpack_require__(511);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana/config', ['kibana/notify']);

	  __webpack_require__(216).addSetupWork(function (config) {
	    return config.init();
	  });

	  // service for delivering config variables to everywhere else
	  module.service('config', function (Private, Notifier, kbnVersion, kbnIndex, $rootScope, buildNum) {
	    var config = this;

	    var angular = __webpack_require__(209);
	    var _ = __webpack_require__(192);
	    var defaults = Private(__webpack_require__(713));
	    var DelayedUpdater = Private(__webpack_require__(714));
	    var vals = Private(__webpack_require__(715));

	    var notify = new Notifier({
	      location: 'Config'
	    });

	    // active or previous instance of DelayedUpdater. This will log and then process an
	    // update once it is requested by calling #set() or #clear().
	    var updater;

	    var DocSource = Private(__webpack_require__(511));
	    var doc = new DocSource().index(kbnIndex).type('config').id(kbnVersion);

	    /******
	     * PUBLIC API
	     ******/

	    /**
	     * Executes once and returns a promise that is resolved once the
	     * config has loaded for the first time.
	     *
	     * @return {Promise} - Resolved when the config loads initially
	     */
	    config.init = _.once(function () {
	      var complete = notify.lifecycle('config init');

	      return (function getDoc() {

	        // used to apply an entire es response to the vals, silentAndLocal will prevent
	        // event/notifications/writes from occuring.
	        var applyMassUpdate = function applyMassUpdate(resp, silentAndLocal) {
	          _.union(_.keys(resp._source), _.keys(vals)).forEach(function (key) {
	            change(key, resp._source[key], silentAndLocal);
	          });
	        };

	        return doc.fetch().then(function initDoc(resp) {
	          if (!resp.found) {
	            return doc.doIndex({
	              buildNum: buildNum
	            }).then(getDoc);
	          } else {
	            // apply update, and keep it quiet the first time
	            applyMassUpdate(resp, true);

	            // don't keep it quiet other times
	            doc.onUpdate(function (resp) {
	              applyMassUpdate(resp, false);
	            });
	          }
	        });
	      })().then(function () {
	        $rootScope.$broadcast('init:config');
	      }).then(complete, complete.failure);
	    });

	    config.get = function (key, defaultVal) {
	      var keyVal;

	      if (vals[key] == null) {
	        if (defaultVal == null) {
	          keyVal = defaults[key].value;
	        } else {
	          keyVal = _.cloneDeep(defaultVal);
	        }
	      } else {
	        keyVal = vals[key];
	      }

	      if (defaults[key] && defaults[key].type === 'json') {
	        return JSON.parse(keyVal);
	      }
	      return keyVal;
	    };

	    // sets a value in the config
	    config.set = function (key, val) {
	      if (_.isPlainObject(val)) {
	        return change(key, angular.toJson(val));
	      } else {
	        return change(key, val);
	      }
	    };

	    // clears a value from the config
	    config.clear = function (key) {
	      return change(key);
	    };
	    // alias for clear
	    config['delete'] = config.clear;

	    config.close = function () {
	      if (updater) updater.fire();
	    };

	    /**
	     * A little helper for binding config variables to $scopes
	     *
	     * @param  {Scope} $scope - an angular $scope object
	     * @param  {string} key - the config key to bind to
	     * @param  {string} [property] - optional property name where the value should
	     *                             be stored. Defaults to the config key
	     * @return {function} - an unbind function
	     */
	    config.$bind = function ($scope, key, property) {
	      if (!property) property = key;

	      var update = function update() {
	        $scope[property] = config.get(key);
	      };

	      update();
	      return _.partial(_.invoke, [$scope.$on('change:config.' + key, update), $scope.$on('init:config', update)], 'call');
	    };

	    /*****
	     * PRIVATE API
	     *****/
	    function change(key, val, silentAndLocal) {
	      // if the previous updater has already fired, then start over with null
	      if (updater && updater.fired) updater = null;
	      // create a new updater
	      if (!updater) updater = new DelayedUpdater(doc);
	      // return a promise that will be resolved once the action is eventually done
	      return updater.update(key, val, silentAndLocal);
	    }

	    config._vals = function () {
	      return _.cloneDeep(vals);
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 713 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function configDefaultsProvider() {
	    // wraped in provider so that a new instance is given to each app/test

	    return {
	      'buildNum': {
	        readonly: true
	      },
	      'query:queryString:options': {
	        value: '{ "analyze_wildcard": true }',
	        description: 'Options for the lucene query string parser',
	        type: 'json'
	      },
	      'sort:options': {
	        value: '{ "unmapped_type": "boolean" }',
	        description: 'Options the Elasticsearch sort parameter',
	        type: 'json'
	      },
	      'dateFormat': {
	        value: 'MMMM Do YYYY, HH:mm:ss.SSS',
	        description: 'When displaying a pretty formatted date, use this format'
	      },
	      'dateFormat:scaled': {
	        type: 'json',
	        value: '[\n' + '  ["", "hh:mm:ss.SSS"],\n' + '  ["PT1S", "HH:mm:ss"],\n' + '  ["PT1M", "HH:mm"],\n' + '  ["PT1H",\n' + '      "YYYY-MM-DD HH:mm"],\n' + '  ["P1DT", "YYYY-MM-DD"],\n' + '  ["P1YT", "YYYY"]\n' + ']',
	        description: 'Values that define the format used in situations where timebased' + ' data is rendered in order, and formatted timestamps should adapt to the' + ' interval between measurements. Keys are' + ' <a href="http://en.wikipedia.org/wiki/ISO_8601#Time_intervals" target="_blank">' + 'ISO8601 intervals.</a>'
	      },
	      'defaultIndex': {
	        value: null,
	        description: 'The index to access if no index is set'
	      },
	      'metaFields': {
	        value: ['_source', '_id', '_type', '_index', '_score'],
	        description: 'Fields that exist outside of _source to merge into our document when displaying it'
	      },
	      'discover:sampleSize': {
	        value: 500,
	        description: 'The number of rows to show in the table'
	      },
	      'courier:maxSegmentCount': {
	        value: 30,
	        description: 'Requests in discover are split into segments to prevent massive requests from being sent to ' + 'elasticsearch. This setting attempts to prevent the list of segments from getting too long, which might ' + 'cause requests to take much longer to process'
	      },
	      'fields:popularLimit': {
	        value: 10,
	        description: 'The top N most popular fields to show'
	      },
	      'histogram:barTarget': {
	        value: 50,
	        description: 'Attempt to generate around this many bar when using "auto" interval in date histograms'
	      },
	      'histogram:maxBars': {
	        value: 100,
	        description: 'Never show more than this many bar in date histograms, scale values if needed'
	      },
	      'visualization:tileMap:maxPrecision': {
	        value: 7,
	        description: 'The maximum geoHash precision displayed on tile maps: 7 is high, 10 is very high, ' + '12 is the max. ' + '<a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/' + 'search-aggregations-bucket-geohashgrid-aggregation.html#_cell_dimensions_at_the_equator" target="_blank">' + 'Explanation of cell dimensions</a>'
	      },
	      'visualization:tileMap:WMSdefaults': {
	        value: JSON.stringify({
	          enabled: false,
	          url: 'https://basemap.nationalmap.gov/arcgis/services/USGSTopo/MapServer/WMSServer',
	          options: {
	            version: '1.3.0',
	            layers: '0',
	            format: 'image/png',
	            transparent: true,
	            attribution: 'Maps provided by USGS',
	            styles: ''
	          }
	        }, null, '  '),
	        type: 'json',
	        description: 'Default properties for the WMS map server support in the tile map'
	      },
	      'visualization:colorMapping': {
	        type: 'json',
	        value: JSON.stringify({
	          'Count': '#57c17b'
	        }),
	        description: 'Maps values to specified colors within visualizations'
	      },
	      'csv:separator': {
	        value: ',',
	        description: 'Separate exported values with this string'
	      },
	      'csv:quoteValues': {
	        value: true,
	        description: 'Should values be quoted in csv exports?'
	      },
	      'history:limit': {
	        value: 10,
	        description: 'In fields that have history (e.g. query inputs), show this many recent values'
	      },
	      'shortDots:enable': {
	        value: false,
	        description: 'Shorten long fields, for example, instead of foo.bar.baz, show f.b.baz'
	      },
	      'truncate:maxHeight': {
	        value: 115,
	        description: 'The maximum height that a cell in a table should occupy. Set to 0 to disable truncation'
	      },
	      'indexPattern:fieldMapping:lookBack': {
	        value: 5,
	        description: 'For index patterns containing timestamps in their names, look for this many recent matching ' + 'patterns from which to query the field mapping'
	      },
	      'format:defaultTypeMap': {
	        type: 'json',
	        value: ['{', '  "ip": { "id": "ip", "params": {} },', '  "date": { "id": "date", "params": {} },', '  "number": { "id": "number", "params": {} },', '  "_source": { "id": "_source", "params": {} },', '  "_default_": { "id": "string", "params": {} }', '}'].join('\n'),
	        description: 'Map of the format name to use by default for each field type. ' + '"_default_" is used if the field type is not mentioned explicitly'
	      },
	      'format:number:defaultPattern': {
	        type: 'string',
	        value: '0,0.[000]',
	        description: 'Default numeral format for the "number" format'
	      },
	      'format:bytes:defaultPattern': {
	        type: 'string',
	        value: '0,0.[000]b',
	        description: 'Default numeral format for the "bytes" format'
	      },
	      'format:percent:defaultPattern': {
	        type: 'string',
	        value: '0,0.[000]%',
	        description: 'Default numeral format for the "percent" format'
	      },
	      'format:currency:defaultPattern': {
	        type: 'string',
	        value: '($0,0.[00])',
	        description: 'Default numeral format for the "currency" format'
	      },
	      'timepicker:timeDefaults': {
	        type: 'json',
	        value: ['{', '  "from": "now-15m",', '  "to": "now",', '  "mode": "quick"', '}'].join('\n'),
	        description: 'The timefilter selection to use when Kibana is started without one'
	      },
	      'timepicker:refreshIntervalDefaults': {
	        type: 'json',
	        value: ['{', '  "display": "Off",', '  "pause": false,', '  "value": 0', '}'].join('\n'),
	        description: 'The timefilter\'s default refresh interval'
	      },
	      'dashboard:defaultDarkTheme': {
	        value: false,
	        description: 'New dashboards use dark theme by default'
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 714 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(715);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DelayedUpdaterFactory(Private, $rootScope, Promise, Notifier) {
	    var notify = new Notifier();
	    var _ = __webpack_require__(192);
	    var angular = __webpack_require__(209);

	    var vals = Private(__webpack_require__(715));

	    return function DelayedUpdater(doc) {
	      var updater = this;
	      var queue = [];
	      var log = {};
	      var timer;

	      updater.fire = function () {
	        clearTimeout(timer);

	        // only fire once
	        if (updater.fired) return;
	        updater.fired = true;

	        var method;
	        var body;
	        var updated = [];
	        var deleted = [];

	        // seperate the log into lists
	        _Object$keys(log).forEach(function (key) {
	          if (log[key] === 'updated') updated.push(key);else deleted.push(key);
	        });

	        if (deleted.length) {
	          method = 'doIndex';
	          body = _.clone(vals);
	        } else {
	          method = 'doUpdate';
	          body = _.pick(vals, updated);
	        }

	        doc[method](vals).then(function (resp) {
	          queue.forEach(function (q) {
	            q.resolve(resp);
	          });
	        }, function (err) {
	          queue.forEach(function (q) {
	            q.reject(err);
	          });
	        })['finally'](function () {
	          $rootScope.$broadcast('change:config', updated.concat(deleted));
	        });
	      };

	      updater.update = function (key, val, silentAndLocal) {
	        var newVal = val;
	        var oldVal = vals[key];

	        if (angular.equals(newVal, oldVal)) {
	          return Promise.resolve();
	        } else if (newVal == null) {
	          delete vals[key];
	          log[key] = 'deleted';
	        } else {
	          vals[key] = newVal;
	          log[key] = 'updated';
	        }

	        if (silentAndLocal) return Promise.resolve();

	        var defer = Promise.defer();
	        queue.push(defer);
	        notify.log('config change: ' + key + ': ' + oldVal + ' -> ' + newVal);
	        $rootScope.$broadcast('change:config.' + key, newVal, oldVal);

	        // reset the fire timer
	        clearTimeout(timer);
	        timer = setTimeout(updater.fire, 200);
	        return defer.promise;
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 715 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function ConfigValsService() {
	    return {};
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 716 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(717);
	__webpack_require__(718);
	__webpack_require__(719);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var typeahead = __webpack_require__(214).get('kibana/typeahead');

	  __webpack_require__(717);
	  __webpack_require__(718);
	  __webpack_require__(719);

	  typeahead.directive('kbnTypeahead', function () {
	    var keyMap = {
	      ESC: 27,
	      UP: 38,
	      DOWN: 40,
	      TAB: 9,
	      ENTER: 13
	    };

	    return {
	      restrict: 'A',
	      scope: {
	        historyKey: '@kbnTypeahead'
	      },
	      controllerAs: 'typeahead',

	      controller: function controller($scope, $element, $timeout, PersistedLog, config) {
	        var self = this;
	        self.form = $element.closest('form');
	        self.query = '';
	        self.hidden = true;
	        self.focused = false;
	        self.mousedOver = false;

	        // instantiate history and add items to the scope
	        self.history = new PersistedLog('typeahead:' + $scope.historyKey, {
	          maxLength: config.get('history:limit'),
	          filterDuplicates: true
	        });

	        $scope.items = self.history.get();
	        $scope.filteredItems = [];

	        self.setInputModel = function (model) {
	          $scope.inputModel = model;

	          // watch for changes to the query parameter, delegate to typeaheadCtrl
	          $scope.$watch('inputModel.$viewValue', self.filterItemsByQuery);
	        };

	        self.setHidden = function (hidden) {
	          self.hidden = !!hidden;
	        };

	        self.setFocused = function (focused) {
	          self.focused = !!focused;
	        };

	        self.setMouseover = function (mousedOver) {
	          self.mousedOver = !!mousedOver;
	        };

	        // activation methods
	        self.activateItem = function (item) {
	          self.active = item;
	        };

	        self.getActiveIndex = function () {
	          if (!self.active) {
	            return;
	          }

	          return $scope.filteredItems.indexOf(self.active);
	        };

	        self.getItems = function () {
	          return $scope.filteredItems;
	        };

	        self.activateNext = function () {
	          var index = self.getActiveIndex();
	          if (index == null) {
	            index = 0;
	          } else if (index < $scope.filteredItems.length - 1) {
	            ++index;
	          }

	          self.activateItem($scope.filteredItems[index]);
	        };

	        self.activatePrev = function () {
	          var index = self.getActiveIndex();

	          if (index > 0 && index != null) {
	            --index;
	          } else if (index === 0) {
	            self.active = false;
	            return;
	          }

	          self.activateItem($scope.filteredItems[index]);
	        };

	        self.isActive = function (item) {
	          return item === self.active;
	        };

	        // selection methods
	        self.selectItem = function (item, ev) {
	          self.hidden = true;
	          self.active = false;
	          $scope.inputModel.$setViewValue(item);
	          $scope.inputModel.$render();
	          self.persistEntry();

	          if (ev && ev.type === 'click') {
	            $timeout(function () {
	              self.submitForm();
	            });
	          }
	        };

	        self.submitForm = function () {
	          if (self.form.length) {
	            self.form.submit();
	          }
	        };

	        self.persistEntry = function () {
	          if ($scope.inputModel.$viewValue.length) {
	            // push selection into the history
	            $scope.items = self.history.add($scope.inputModel.$viewValue);
	          }
	        };

	        self.selectActive = function () {
	          if (self.active) {
	            self.selectItem(self.active);
	          }
	        };

	        self.keypressHandler = function (ev) {
	          var keyCode = ev.which || ev.keyCode;

	          if (self.focused) {
	            self.hidden = false;
	          }

	          // hide on escape
	          if (_.contains([keyMap.ESC], keyCode)) {
	            self.hidden = true;
	            self.active = false;
	          }

	          // change selection with arrow up/down
	          // on down key, attempt to load all items if none are loaded
	          if (_.contains([keyMap.DOWN], keyCode) && $scope.filteredItems.length === 0) {
	            $scope.filteredItems = $scope.items;
	            $scope.$digest();
	          } else if (_.contains([keyMap.UP, keyMap.DOWN], keyCode)) {
	            if (self.isVisible() && $scope.filteredItems.length) {
	              ev.preventDefault();

	              if (keyCode === keyMap.DOWN) {
	                self.activateNext();
	              } else {
	                self.activatePrev();
	              }
	            }
	          }

	          // persist selection on enter, when not selecting from the list
	          if (_.contains([keyMap.ENTER], keyCode)) {
	            if (!self.active) {
	              self.persistEntry();
	            }
	          }

	          // select on enter or tab
	          if (_.contains([keyMap.ENTER, keyMap.TAB], keyCode)) {
	            self.selectActive();
	            self.hidden = true;
	          }
	        };

	        self.filterItemsByQuery = function (query) {
	          // cache query so we can call it again if needed
	          if (query) {
	            self.query = query;
	          }

	          // if the query is empty, clear the list items
	          if (!self.query.length) {
	            $scope.filteredItems = [];
	            return;
	          }

	          // update the filteredItems using the query
	          var beginningMatches = $scope.items.filter(function (item) {
	            return item.indexOf(query) === 0;
	          });

	          var otherMatches = $scope.items.filter(function (item) {
	            return item.indexOf(query) > 0;
	          });

	          $scope.filteredItems = beginningMatches.concat(otherMatches);
	        };

	        self.isVisible = function () {
	          return !self.hidden && $scope.filteredItems.length > 0 && (self.focused || self.mousedOver);
	        };

	        // handle updates to parent scope history
	        $scope.$watch('items', function (items) {
	          if (self.query) {
	            self.filterItemsByQuery(self.query);
	          }
	        });

	        // watch for changes to the filtered item list
	        $scope.$watch('filteredItems', function (filteredItems) {

	          // if list is empty, or active item is missing, unset active item
	          if (!filteredItems.length || !_.contains(filteredItems, self.active)) {
	            self.active = false;
	          }
	        });
	      },

	      link: function link($scope, $el, attr) {
	        // should be defined via setInput() method
	        if (!$scope.inputModel) {
	          throw new Error('kbn-typeahead-input must be defined');
	        }

	        $scope.$watch('typeahead.isVisible()', function (vis) {
	          $el.toggleClass('visible', vis);
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 717 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 718 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(310);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var typeahead = __webpack_require__(214).get('kibana/typeahead');

	  __webpack_require__(310);

	  typeahead.directive('kbnTypeaheadInput', function ($rootScope) {

	    return {
	      restrict: 'A',
	      require: ['^ngModel', '^kbnTypeahead'],

	      link: function link($scope, $el, $attr, deps) {
	        var model = deps[0];
	        var typeaheadCtrl = deps[1];

	        typeaheadCtrl.setInputModel(model);

	        // disable browser autocomplete
	        $el.attr('autocomplete', 'off');

	        // handle keypresses
	        $el.on('keydown', function (ev) {
	          typeaheadCtrl.keypressHandler(ev);
	          digest();
	        });

	        // update focus state based on the input focus state
	        $el.on('focus', function () {
	          typeaheadCtrl.setFocused(true);
	          digest();
	        });

	        $el.on('blur', function () {
	          typeaheadCtrl.setFocused(false);
	          digest();
	        });

	        // unbind event listeners
	        $scope.$on('$destroy', function () {
	          $el.off();
	        });

	        function digest() {
	          $rootScope.$$phase || $scope.$digest();
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 719 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(720);
	__webpack_require__(310);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var typeahead = __webpack_require__(214).get('kibana/typeahead');
	  var listTemplate = __webpack_require__(720);

	  __webpack_require__(310);

	  typeahead.directive('kbnTypeaheadItems', function () {
	    return {
	      restrict: 'E',
	      require: '^kbnTypeahead',
	      replace: true,
	      template: listTemplate,

	      link: function link($scope, $el, attr, typeaheadCtrl) {
	        $scope.typeahead = typeaheadCtrl;
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 720 */
/***/ function(module, exports) {

	module.exports = "<div\n  ng-show=\"typeahead.isVisible()\"\n  ng-mouseenter=\"typeahead.setMouseover(true);\"\n  ng-mouseleave=\"typeahead.setMouseover(false);\"\n  class=\"typeahead-items\"\n  >\n\n  <div\n    ng-repeat=\"item in typeahead.getItems()\"\n    ng-class=\"{active: item === typeahead.active}\"\n    ng-click=\"typeahead.selectItem(item, $event);\"\n    ng-mouseenter=\"typeahead.activateItem(item);\"\n    class=\"typeahead-item\"\n    >\n    {{item}}\n  </div>\n</div>\n"

/***/ },
/* 721 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(336);
	__webpack_require__(722);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var Binder = __webpack_require__(336);
	  __webpack_require__(722);

	  var app = __webpack_require__(214).get('app/dashboard');

	  app.directive('dashboardGrid', function ($compile, Notifier) {
	    return {
	      restrict: 'E',
	      require: '^dashboardApp', // must inherit from the dashboardApp
	      link: function link($scope, $el) {
	        var notify = new Notifier();
	        var $container = $el;
	        $el = $('<ul>').appendTo($container);

	        var $window = $(window);
	        var $body = $(document.body);
	        var binder = new Binder($scope);

	        // appState from controller
	        var $state = $scope.state;

	        var gridster; // defined in init()

	        // number of columns to render
	        var COLS = 12;
	        // number of pixed between each column/row
	        var SPACER = 10;
	        // pixels used by all of the spacers (gridster puts have a spacer on the ends)
	        var spacerSize = SPACER * COLS;

	        // debounced layout function is safe to call as much as possible
	        var safeLayout = _.debounce(layout, 200);

	        function init() {
	          $el.addClass('gridster');

	          gridster = $el.gridster({
	            max_cols: COLS,
	            min_cols: COLS,
	            autogenerate_stylesheet: false,
	            resize: {
	              enabled: true,
	              stop: readGridsterChangeHandler
	            },
	            draggable: {
	              handle: '.panel-heading, .panel-title',
	              stop: readGridsterChangeHandler
	            }
	          }).data('gridster');

	          // This is necessary to enable text selection within gridster elements
	          // http://stackoverflow.com/questions/21561027/text-not-selectable-from-editable-div-which-is-draggable
	          binder.jqOn($el, 'mousedown', function () {
	            gridster.disable().disable_resize();
	          });
	          binder.jqOn($el, 'mouseup', function enableResize() {
	            gridster.enable().enable_resize();
	          });

	          $scope.$watchCollection('state.panels', function (panels) {
	            var currentPanels = gridster.$widgets.toArray().map(function (el) {
	              return getPanelFor(el);
	            });

	            // panels that are now missing from the panels array
	            var removed = _.difference(currentPanels, panels);

	            // panels that have been added
	            var added = _.difference(panels, currentPanels);

	            if (removed.length) removed.forEach(removePanel);
	            if (added.length) added.forEach(addPanel);

	            // ensure that every panel can be serialized now that we are done
	            $state.panels.forEach(makePanelSerializeable);

	            // alert interested parties that we have finished processing changes to the panels
	            // TODO: change this from event based to calling a method on dashboardApp
	            if (added.length || removed.length) $scope.$root.$broadcast('change:vis');
	          });

	          $scope.$on('$destroy', function () {
	            $window.off('resize', safeLayout);

	            if (!gridster) return;
	            gridster.$widgets.each(function (i, el) {
	              var panel = getPanelFor(el);
	              removePanel(panel);
	              // stop any animations
	              panel.$el.stop();
	              // not that we will, but lets be safe
	              makePanelSerializeable(panel);
	            });
	          });

	          safeLayout();
	          $window.on('resize', safeLayout);
	          $scope.$on('ready:vis', safeLayout);
	        }

	        // return the panel object for an element.
	        //
	        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	        // ALWAYS CALL makePanelSerializeable AFTER YOU ARE DONE WITH IT
	        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	        function getPanelFor(el) {
	          var $panel = el.jquery ? el : $(el);
	          var panel = $panel.data('panel');

	          panel.$el = $panel;
	          panel.$scope = $panel.data('$scope');

	          return panel;
	        }

	        // since the $el and $scope are circular structures, they need to be
	        // removed from panel before it can be serialized (we also wouldn't
	        // want them to show up in the url)
	        function makePanelSerializeable(panel) {
	          delete panel.$el;
	          delete panel.$scope;
	        }

	        // tell gridster to remove the panel, and cleanup our metadata
	        function removePanel(panel) {
	          // remove from grister 'silently' (don't reorganize after)
	          gridster.remove_widget(panel.$el);

	          // destroy the scope
	          panel.$scope.$destroy();

	          panel.$el.removeData('panel');
	          panel.$el.removeData('$scope');
	        }

	        // tell gridster to add the panel, and create additional meatadata like $scope
	        function addPanel(panel) {
	          _.defaults(panel, {
	            size_x: 3,
	            size_y: 2
	          });

	          // ignore panels that don't have vis id's
	          if (!panel.id) {
	            // In the interest of backwards compat
	            if (panel.visId) {
	              panel.id = panel.visId;
	              panel.type = 'visualization';
	              delete panel.visId;
	            } else {
	              throw new Error('missing object id on panel');
	            }
	          }

	          panel.$scope = $scope.$new();
	          panel.$scope.panel = panel;

	          panel.$el = $compile('<li><dashboard-panel></li>')(panel.$scope);

	          // tell gridster to use the widget
	          gridster.add_widget(panel.$el, panel.size_x, panel.size_y, panel.col, panel.row);

	          // update size/col/etc.
	          refreshPanelStats(panel);

	          // stash the panel and it's scope in the element's data
	          panel.$el.data('panel', panel);
	          panel.$el.data('$scope', panel.$scope);
	        }

	        // ensure that the panel object has the latest size/pos info
	        function refreshPanelStats(panel) {
	          var data = panel.$el.coords().grid;
	          panel.size_x = data.size_x;
	          panel.size_y = data.size_y;
	          panel.col = data.col;
	          panel.row = data.row;
	        }

	        // when gridster tell us it made a change, update each of the panel objects
	        function readGridsterChangeHandler(e, ui, $widget) {
	          // ensure that our panel objects keep their size in sync
	          gridster.$widgets.each(function (i, el) {
	            var panel = getPanelFor(el);
	            refreshPanelStats(panel);
	            panel.$scope.$broadcast('resize');
	            makePanelSerializeable(panel);
	            $scope.$root.$broadcast('change:vis');
	          });
	        }

	        // calculate the position and sizing of the gridster el, and the columns within it
	        // then tell gridster to "reflow" -- which is definitely not supported.
	        // we may need to consider using a different library
	        function reflowGridster() {
	          // https://github.com/gcphost/gridster-responsive/blob/97fe43d4b312b409696b1d702e1afb6fbd3bba71/jquery.gridster.js#L1208-L1235
	          var g = gridster;

	          g.options.widget_margins = [SPACER / 2, SPACER / 2];
	          g.options.widget_base_dimensions = [($container.width() - spacerSize) / COLS, 100];
	          g.min_widget_width = g.options.widget_margins[0] * 2 + g.options.widget_base_dimensions[0];
	          g.min_widget_height = g.options.widget_margins[1] * 2 + g.options.widget_base_dimensions[1];

	          // var serializedGrid = g.serialize();
	          g.$widgets.each(function (i, widget) {
	            g.resize_widget($(widget));
	          });

	          g.generate_grid_and_stylesheet();
	          g.generate_stylesheet({ namespace: '.gridster' });

	          g.get_widgets_from_DOM();
	          // We can't call this method if the gridmap is empty. This was found
	          // when the user double clicked the "New Dashboard" icon. See
	          // https://github.com/elastic/kibana4/issues/390
	          if (gridster.gridmap.length > 0) g.set_dom_grid_height();
	          g.drag_api.set_limits(COLS * g.min_widget_width);
	        }

	        function layout() {
	          var complete = notify.event('reflow dashboard');
	          reflowGridster();
	          readGridsterChangeHandler();
	          complete();
	        }

	        init();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 722 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(206);
	__webpack_require__(723);
	__webpack_require__(724);


/***/ },
/* 723 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 724 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(725)(__webpack_require__(726))

/***/ },
/* 725 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 726 */
/***/ function(module, exports) {

	module.exports = "/*! gridster.js - v0.5.6 - 2014-09-25\n* http://gridster.net/\n* Copyright (c) 2014 ducksboard; Licensed MIT */\n\n;(function(root, factory) {\n\n    if (typeof define === 'function' && define.amd) {\n        define('gridster-coords', ['jquery'], factory);\n    } else {\n       root.GridsterCoords = factory(root.$ || root.jQuery);\n    }\n\n}(this, function($) {\n    /**\n    * Creates objects with coordinates (x1, y1, x2, y2, cx, cy, width, height)\n    * to simulate DOM elements on the screen.\n    * Coords is used by Gridster to create a faux grid with any DOM element can\n    * collide.\n    *\n    * @class Coords\n    * @param {HTMLElement|Object} obj The jQuery HTMLElement or a object with: left,\n    * top, width and height properties.\n    * @return {Object} Coords instance.\n    * @constructor\n    */\n    function Coords(obj) {\n        if (obj[0] && $.isPlainObject(obj[0])) {\n            this.data = obj[0];\n        }else {\n            this.el = obj;\n        }\n\n        this.isCoords = true;\n        this.coords = {};\n        this.init();\n        return this;\n    }\n\n\n    var fn = Coords.prototype;\n\n\n    fn.init = function(){\n        this.set();\n        this.original_coords = this.get();\n    };\n\n\n    fn.set = function(update, not_update_offsets) {\n        var el = this.el;\n\n        if (el && !update) {\n            this.data = el.offset();\n            this.data.width = el.width();\n            this.data.height = el.height();\n        }\n\n        if (el && update && !not_update_offsets) {\n            var offset = el.offset();\n            this.data.top = offset.top;\n            this.data.left = offset.left;\n        }\n\n        var d = this.data;\n\n        typeof d.left === 'undefined' && (d.left = d.x1);\n        typeof d.top === 'undefined' && (d.top = d.y1);\n\n        this.coords.x1 = d.left;\n        this.coords.y1 = d.top;\n        this.coords.x2 = d.left + d.width;\n        this.coords.y2 = d.top + d.height;\n        this.coords.cx = d.left + (d.width / 2);\n        this.coords.cy = d.top + (d.height / 2);\n        this.coords.width  = d.width;\n        this.coords.height = d.height;\n        this.coords.el  = el || false ;\n\n        return this;\n    };\n\n\n    fn.update = function(data){\n        if (!data && !this.el) {\n            return this;\n        }\n\n        if (data) {\n            var new_data = $.extend({}, this.data, data);\n            this.data = new_data;\n            return this.set(true, true);\n        }\n\n        this.set(true);\n        return this;\n    };\n\n\n    fn.get = function(){\n        return this.coords;\n    };\n\n    fn.destroy = function() {\n        this.el.removeData('coords');\n        delete this.el;\n    };\n\n    //jQuery adapter\n    $.fn.coords = function() {\n        if (this.data('coords') ) {\n            return this.data('coords');\n        }\n\n        var ins = new Coords(this, arguments[0]);\n        this.data('coords', ins);\n        return ins;\n    };\n\n    return Coords;\n\n}));\n\n;(function(root, factory) {\n\n    if (typeof define === 'function' && define.amd) {\n        define('gridster-collision', ['jquery', 'gridster-coords'], factory);\n    } else {\n        root.GridsterCollision = factory(root.$ || root.jQuery,\n            root.GridsterCoords);\n    }\n\n}(this, function($, Coords) {\n\n    var defaults = {\n        colliders_context: document.body,\n        overlapping_region: 'C'\n        // ,on_overlap: function(collider_data){},\n        // on_overlap_start : function(collider_data){},\n        // on_overlap_stop : function(collider_data){}\n    };\n\n\n    /**\n    * Detects collisions between a DOM element against other DOM elements or\n    * Coords objects.\n    *\n    * @class Collision\n    * @uses Coords\n    * @param {HTMLElement} el The jQuery wrapped HTMLElement.\n    * @param {HTMLElement|Array} colliders Can be a jQuery collection\n    *  of HTMLElements or an Array of Coords instances.\n    * @param {Object} [options] An Object with all options you want to\n    *        overwrite:\n    *   @param {String} [options.overlapping_region] Determines when collision\n    *    is valid, depending on the overlapped area. Values can be: 'N', 'S',\n    *    'W', 'E', 'C' or 'all'. Default is 'C'.\n    *   @param {Function} [options.on_overlap_start] Executes a function the first\n    *    time each `collider ` is overlapped.\n    *   @param {Function} [options.on_overlap_stop] Executes a function when a\n    *    `collider` is no longer collided.\n    *   @param {Function} [options.on_overlap] Executes a function when the\n    * mouse is moved during the collision.\n    * @return {Object} Collision instance.\n    * @constructor\n    */\n    function Collision(el, colliders, options) {\n        this.options = $.extend(defaults, options);\n        this.$element = el;\n        this.last_colliders = [];\n        this.last_colliders_coords = [];\n        this.set_colliders(colliders);\n\n        this.init();\n    }\n\n    Collision.defaults = defaults;\n\n    var fn = Collision.prototype;\n\n\n    fn.init = function() {\n        this.find_collisions();\n    };\n\n\n    fn.overlaps = function(a, b) {\n        var x = false;\n        var y = false;\n\n        if ((b.x1 >= a.x1 && b.x1 <= a.x2) ||\n            (b.x2 >= a.x1 && b.x2 <= a.x2) ||\n            (a.x1 >= b.x1 && a.x2 <= b.x2)\n        ) { x = true; }\n\n        if ((b.y1 >= a.y1 && b.y1 <= a.y2) ||\n            (b.y2 >= a.y1 && b.y2 <= a.y2) ||\n            (a.y1 >= b.y1 && a.y2 <= b.y2)\n        ) { y = true; }\n\n        return (x && y);\n    };\n\n\n    fn.detect_overlapping_region = function(a, b){\n        var regionX = '';\n        var regionY = '';\n\n        if (a.y1 > b.cy && a.y1 < b.y2) { regionX = 'N'; }\n        if (a.y2 > b.y1 && a.y2 < b.cy) { regionX = 'S'; }\n        if (a.x1 > b.cx && a.x1 < b.x2) { regionY = 'W'; }\n        if (a.x2 > b.x1 && a.x2 < b.cx) { regionY = 'E'; }\n\n        return (regionX + regionY) || 'C';\n    };\n\n\n    fn.calculate_overlapped_area_coords = function(a, b){\n        var x1 = Math.max(a.x1, b.x1);\n        var y1 = Math.max(a.y1, b.y1);\n        var x2 = Math.min(a.x2, b.x2);\n        var y2 = Math.min(a.y2, b.y2);\n\n        return $({\n            left: x1,\n            top: y1,\n             width : (x2 - x1),\n            height: (y2 - y1)\n          }).coords().get();\n    };\n\n\n    fn.calculate_overlapped_area = function(coords){\n        return (coords.width * coords.height);\n    };\n\n\n    fn.manage_colliders_start_stop = function(new_colliders_coords, start_callback, stop_callback){\n        var last = this.last_colliders_coords;\n\n        for (var i = 0, il = last.length; i < il; i++) {\n            if ($.inArray(last[i], new_colliders_coords) === -1) {\n                start_callback.call(this, last[i]);\n            }\n        }\n\n        for (var j = 0, jl = new_colliders_coords.length; j < jl; j++) {\n            if ($.inArray(new_colliders_coords[j], last) === -1) {\n                stop_callback.call(this, new_colliders_coords[j]);\n            }\n\n        }\n    };\n\n\n    fn.find_collisions = function(player_data_coords){\n        var self = this;\n        var overlapping_region = this.options.overlapping_region;\n        var colliders_coords = [];\n        var colliders_data = [];\n        var $colliders = (this.colliders || this.$colliders);\n        var count = $colliders.length;\n        var player_coords = self.$element.coords()\n                             .update(player_data_coords || false).get();\n\n        while(count--){\n          var $collider = self.$colliders ?\n                           $($colliders[count]) : $colliders[count];\n          var $collider_coords_ins = ($collider.isCoords) ?\n                  $collider : $collider.coords();\n          var collider_coords = $collider_coords_ins.get();\n          var overlaps = self.overlaps(player_coords, collider_coords);\n\n          if (!overlaps) {\n            continue;\n          }\n\n          var region = self.detect_overlapping_region(\n              player_coords, collider_coords);\n\n            //todo: make this an option\n            if (region === overlapping_region || overlapping_region === 'all') {\n\n                var area_coords = self.calculate_overlapped_area_coords(\n                    player_coords, collider_coords);\n                var area = self.calculate_overlapped_area(area_coords);\n                var collider_data = {\n                    area: area,\n                    area_coords : area_coords,\n                    region: region,\n                    coords: collider_coords,\n                    player_coords: player_coords,\n                    el: $collider\n                };\n\n                if (self.options.on_overlap) {\n                    self.options.on_overlap.call(this, collider_data);\n                }\n                colliders_coords.push($collider_coords_ins);\n                colliders_data.push(collider_data);\n            }\n        }\n\n        if (self.options.on_overlap_stop || self.options.on_overlap_start) {\n            this.manage_colliders_start_stop(colliders_coords,\n                self.options.on_overlap_start, self.options.on_overlap_stop);\n        }\n\n        this.last_colliders_coords = colliders_coords;\n\n        return colliders_data;\n    };\n\n\n    fn.get_closest_colliders = function(player_data_coords){\n        var colliders = this.find_collisions(player_data_coords);\n\n        colliders.sort(function(a, b) {\n            /* if colliders are being overlapped by the \"C\" (center) region,\n             * we have to set a lower index in the array to which they are placed\n             * above in the grid. */\n            if (a.region === 'C' && b.region === 'C') {\n                if (a.coords.y1 < b.coords.y1 || a.coords.x1 < b.coords.x1) {\n                    return - 1;\n                }else{\n                    return 1;\n                }\n            }\n\n            if (a.area < b.area) {\n                return 1;\n            }\n\n            return 1;\n        });\n        return colliders;\n    };\n\n\n    fn.set_colliders = function(colliders) {\n        if (typeof colliders === 'string' || colliders instanceof $) {\n            this.$colliders = $(colliders,\n                 this.options.colliders_context).not(this.$element);\n        }else{\n            this.colliders = $(colliders);\n        }\n    };\n\n\n    //jQuery adapter\n    $.fn.collision = function(collider, options) {\n          return new Collision( this, collider, options );\n    };\n\n    return Collision;\n\n}));\n\n;(function(window, undefined) {\n\n    /* Delay, debounce and throttle functions taken from underscore.js\n     *\n     * Copyright (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and\n     * Investigative Reporters & Editors\n     *\n     * Permission is hereby granted, free of charge, to any person\n     * obtaining a copy of this software and associated documentation\n     * files (the \"Software\"), to deal in the Software without\n     * restriction, including without limitation the rights to use,\n     * copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the\n     * Software is furnished to do so, subject to the following\n     * conditions:\n     *\n     * The above copyright notice and this permission notice shall be\n     * included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n     * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n     * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n     * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n     * OTHER DEALINGS IN THE SOFTWARE.\n     */\n\n    window.delay = function(func, wait) {\n        var args = Array.prototype.slice.call(arguments, 2);\n        return setTimeout(function(){ return func.apply(null, args); }, wait);\n    };\n\n    window.debounce = function(func, wait, immediate) {\n        var timeout;\n        return function() {\n          var context = this, args = arguments;\n          var later = function() {\n            timeout = null;\n            if (!immediate) func.apply(context, args);\n          };\n          if (immediate && !timeout) func.apply(context, args);\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n        };\n    };\n\n    window.throttle = function(func, wait) {\n        var context, args, timeout, throttling, more, result;\n        var whenDone = debounce(\n            function(){ more = throttling = false; }, wait);\n        return function() {\n          context = this; args = arguments;\n          var later = function() {\n            timeout = null;\n            if (more) func.apply(context, args);\n            whenDone();\n          };\n          if (!timeout) timeout = setTimeout(later, wait);\n          if (throttling) {\n            more = true;\n          } else {\n            result = func.apply(context, args);\n          }\n          whenDone();\n          throttling = true;\n          return result;\n        };\n    };\n\n})(window);\n\n;(function(root, factory) {\n\n    if (typeof define === 'function' && define.amd) {\n        define('gridster-draggable', ['jquery'], factory);\n    } else {\n        root.GridsterDraggable = factory(root.$ || root.jQuery);\n    }\n\n}(this, function($) {\n\n    var defaults = {\n        items: 'li',\n        distance: 1,\n        limit: true,\n        offset_left: 0,\n        autoscroll: true,\n        ignore_dragging: ['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON'], // or function\n        handle: null,\n        container_width: 0,  // 0 == auto\n        move_element: true,\n        helper: false,  // or 'clone'\n        remove_helper: true\n        // drag: function(e) {},\n        // start : function(e, ui) {},\n        // stop : function(e) {}\n    };\n\n    var $window = $(window);\n    var dir_map = { x : 'left', y : 'top' };\n    var isTouch = !!('ontouchstart' in window);\n\n    var capitalize = function(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    };\n\n    var idCounter = 0;\n    var uniqId = function() {\n        return ++idCounter + '';\n    }\n\n    /**\n    * Basic drag implementation for DOM elements inside a container.\n    * Provide start/stop/drag callbacks.\n    *\n    * @class Draggable\n    * @param {HTMLElement} el The HTMLelement that contains all the widgets\n    *  to be dragged.\n    * @param {Object} [options] An Object with all options you want to\n    *        overwrite:\n    *    @param {HTMLElement|String} [options.items] Define who will\n    *     be the draggable items. Can be a CSS Selector String or a\n    *     collection of HTMLElements.\n    *    @param {Number} [options.distance] Distance in pixels after mousedown\n    *     the mouse must move before dragging should start.\n    *    @param {Boolean} [options.limit] Constrains dragging to the width of\n    *     the container\n    *    @param {Object|Function} [options.ignore_dragging] Array of node names\n    *      that sould not trigger dragging, by default is `['INPUT', 'TEXTAREA',\n    *      'SELECT', 'BUTTON']`. If a function is used return true to ignore dragging.\n    *    @param {offset_left} [options.offset_left] Offset added to the item\n    *     that is being dragged.\n    *    @param {Number} [options.drag] Executes a callback when the mouse is\n    *     moved during the dragging.\n    *    @param {Number} [options.start] Executes a callback when the drag\n    *     starts.\n    *    @param {Number} [options.stop] Executes a callback when the drag stops.\n    * @return {Object} Returns `el`.\n    * @constructor\n    */\n    function Draggable(el, options) {\n      this.options = $.extend({}, defaults, options);\n      this.$document = $(document);\n      this.$container = $(el);\n      this.$dragitems = $(this.options.items, this.$container);\n      this.is_dragging = false;\n      this.player_min_left = 0 + this.options.offset_left;\n      this.id = uniqId();\n      this.ns = '.gridster-draggable-' + this.id;\n      this.init();\n    }\n\n    Draggable.defaults = defaults;\n\n    var fn = Draggable.prototype;\n\n    fn.init = function() {\n        var pos = this.$container.css('position');\n        this.calculate_dimensions();\n        this.$container.css('position', pos === 'static' ? 'relative' : pos);\n        this.disabled = false;\n        this.events();\n\n        $(window).bind(this.nsEvent('resize'),\n            throttle($.proxy(this.calculate_dimensions, this), 200));\n    };\n\n    fn.nsEvent = function(ev) {\n        return (ev || '') + this.ns;\n    };\n\n    fn.events = function() {\n        this.pointer_events = {\n            start: this.nsEvent('touchstart') + ' ' + this.nsEvent('mousedown'),\n            move: this.nsEvent('touchmove') + ' ' + this.nsEvent('mousemove'),\n            end: this.nsEvent('touchend') + ' ' + this.nsEvent('mouseup'),\n        };\n\n        this.$container.on(this.nsEvent('selectstart'),\n            $.proxy(this.on_select_start, this));\n\n        this.$container.on(this.pointer_events.start, this.options.items,\n            $.proxy(this.drag_handler, this));\n\n        this.$document.on(this.pointer_events.end, $.proxy(function(e) {\n            this.is_dragging = false;\n            if (this.disabled) { return; }\n            this.$document.off(this.pointer_events.move);\n            if (this.drag_start) {\n                this.on_dragstop(e);\n            }\n        }, this));\n    };\n\n    fn.get_actual_pos = function($el) {\n        var pos = $el.position();\n        return pos;\n    };\n\n\n    fn.get_mouse_pos = function(e) {\n        if (e.originalEvent && e.originalEvent.touches) {\n            var oe = e.originalEvent;\n            e = oe.touches.length ? oe.touches[0] : oe.changedTouches[0];\n        }\n\n        return {\n            left: e.clientX,\n            top: e.clientY\n        };\n    };\n\n\n    fn.get_offset = function(e) {\n        e.preventDefault();\n        var mouse_actual_pos = this.get_mouse_pos(e);\n        var diff_x = Math.round(\n            mouse_actual_pos.left - this.mouse_init_pos.left);\n        var diff_y = Math.round(mouse_actual_pos.top - this.mouse_init_pos.top);\n\n        var left = Math.round(this.el_init_offset.left +\n            diff_x - this.baseX + $(window).scrollLeft() - this.win_offset_x);\n        var top = Math.round(this.el_init_offset.top +\n            diff_y - this.baseY + $(window).scrollTop() - this.win_offset_y);\n\n        if (this.options.limit) {\n            if (left > this.player_max_left) {\n                left = this.player_max_left;\n            } else if(left < this.player_min_left) {\n                left = this.player_min_left;\n            }\n        }\n\n        return {\n            position: {\n                left: left,\n                top: top\n            },\n            pointer: {\n                left: mouse_actual_pos.left,\n                top: mouse_actual_pos.top,\n                diff_left: diff_x + ($(window).scrollLeft() - this.win_offset_x),\n                diff_top: diff_y + ($(window).scrollTop() - this.win_offset_y)\n            }\n        };\n    };\n\n\n    fn.get_drag_data = function(e) {\n        var offset = this.get_offset(e);\n        offset.$player = this.$player;\n        offset.$helper = this.helper ? this.$helper : this.$player;\n\n        return offset;\n    };\n\n\n    fn.set_limits = function(container_width) {\n        container_width || (container_width = this.$container.width());\n        this.player_max_left = (container_width - this.player_width +\n            - this.options.offset_left);\n\n        this.options.container_width = container_width;\n\n        return this;\n    };\n\n\n    fn.scroll_in = function(axis, data) {\n        var dir_prop = dir_map[axis];\n\n        var area_size = 50;\n        var scroll_inc = 30;\n\n        var is_x = axis === 'x';\n        var window_size = is_x ? this.window_width : this.window_height;\n        var doc_size = is_x ? $(document).width() : $(document).height();\n        var player_size = is_x ? this.$player.width() : this.$player.height();\n\n        var next_scroll;\n        var scroll_offset = $window['scroll' + capitalize(dir_prop)]();\n        var min_window_pos = scroll_offset;\n        var max_window_pos = min_window_pos + window_size;\n\n        var mouse_next_zone = max_window_pos - area_size;  // down/right\n        var mouse_prev_zone = min_window_pos + area_size;  // up/left\n\n        var abs_mouse_pos = min_window_pos + data.pointer[dir_prop];\n\n        var max_player_pos = (doc_size - window_size + player_size);\n\n        if (abs_mouse_pos >= mouse_next_zone) {\n            next_scroll = scroll_offset + scroll_inc;\n            if (next_scroll < max_player_pos) {\n                $window['scroll' + capitalize(dir_prop)](next_scroll);\n                this['scroll_offset_' + axis] += scroll_inc;\n            }\n        }\n\n        if (abs_mouse_pos <= mouse_prev_zone) {\n            next_scroll = scroll_offset - scroll_inc;\n            if (next_scroll > 0) {\n                $window['scroll' + capitalize(dir_prop)](next_scroll);\n                this['scroll_offset_' + axis] -= scroll_inc;\n            }\n        }\n\n        return this;\n    };\n\n\n    fn.manage_scroll = function(data) {\n        this.scroll_in('x', data);\n        this.scroll_in('y', data);\n    };\n\n\n    fn.calculate_dimensions = function(e) {\n        this.window_height = $window.height();\n        this.window_width = $window.width();\n    };\n\n\n    fn.drag_handler = function(e) {\n        var node = e.target.nodeName;\n        // skip if drag is disabled, or click was not done with the mouse primary button\n        if (this.disabled || e.which !== 1 && !isTouch) {\n            return;\n        }\n\n        if (this.ignore_drag(e)) {\n            return;\n        }\n\n        var self = this;\n        var first = true;\n        this.$player = $(e.currentTarget);\n\n        this.el_init_pos = this.get_actual_pos(this.$player);\n        this.mouse_init_pos = this.get_mouse_pos(e);\n        this.offsetY = this.mouse_init_pos.top - this.el_init_pos.top;\n\n        this.$document.on(this.pointer_events.move, function(mme) {\n            var mouse_actual_pos = self.get_mouse_pos(mme);\n            var diff_x = Math.abs(\n                mouse_actual_pos.left - self.mouse_init_pos.left);\n            var diff_y = Math.abs(\n                mouse_actual_pos.top - self.mouse_init_pos.top);\n            if (!(diff_x > self.options.distance ||\n                diff_y > self.options.distance)\n                ) {\n                return false;\n            }\n\n            if (first) {\n                first = false;\n                self.on_dragstart.call(self, mme);\n                return false;\n            }\n\n            if (self.is_dragging === true) {\n                self.on_dragmove.call(self, mme);\n            }\n\n            return false;\n        });\n\n        if (!isTouch) { return false; }\n    };\n\n\n    fn.on_dragstart = function(e) {\n        e.preventDefault();\n\n        if (this.is_dragging) { return this; }\n\n        this.drag_start = this.is_dragging = true;\n        var offset = this.$container.offset();\n        this.baseX = Math.round(offset.left);\n        this.baseY = Math.round(offset.top);\n        this.initial_container_width = this.options.container_width || this.$container.width();\n\n        if (this.options.helper === 'clone') {\n            this.$helper = this.$player.clone()\n                .appendTo(this.$container).addClass('helper');\n            this.helper = true;\n        } else {\n            this.helper = false;\n        }\n\n        this.win_offset_y = $(window).scrollTop();\n        this.win_offset_x = $(window).scrollLeft();\n        this.scroll_offset_y = 0;\n        this.scroll_offset_x = 0;\n        this.el_init_offset = this.$player.offset();\n        this.player_width = this.$player.width();\n        this.player_height = this.$player.height();\n\n        this.set_limits(this.options.container_width);\n\n        if (this.options.start) {\n            this.options.start.call(this.$player, e, this.get_drag_data(e));\n        }\n        return false;\n    };\n\n\n    fn.on_dragmove = function(e) {\n        var data = this.get_drag_data(e);\n\n        this.options.autoscroll && this.manage_scroll(data);\n\n        if (this.options.move_element) {\n            (this.helper ? this.$helper : this.$player).css({\n                'position': 'absolute',\n                'left' : data.position.left,\n                'top' : data.position.top\n            });\n        }\n\n        var last_position = this.last_position || data.position;\n        data.prev_position = last_position;\n\n        if (this.options.drag) {\n            this.options.drag.call(this.$player, e, data);\n        }\n\n        this.last_position = data.position;\n        return false;\n    };\n\n\n    fn.on_dragstop = function(e) {\n        var data = this.get_drag_data(e);\n        this.drag_start = false;\n\n        if (this.options.stop) {\n            this.options.stop.call(this.$player, e, data);\n        }\n\n        if (this.helper && this.options.remove_helper) {\n            this.$helper.remove();\n        }\n\n        return false;\n    };\n\n    fn.on_select_start = function(e) {\n        if (this.disabled) { return; }\n\n        if (this.ignore_drag(e)) {\n            return;\n        }\n\n        return false;\n    };\n\n    fn.enable = function() {\n        this.disabled = false;\n    };\n\n    fn.disable = function() {\n        this.disabled = true;\n    };\n\n    fn.destroy = function() {\n        this.disable();\n\n        this.$container.off(this.ns);\n        this.$document.off(this.ns);\n        $(window).off(this.ns);\n\n        $.removeData(this.$container, 'drag');\n    };\n\n    fn.ignore_drag = function(event) {\n        if (this.options.handle) {\n            return !$(event.target).is(this.options.handle);\n        }\n\n        if ($.isFunction(this.options.ignore_dragging)) {\n            return this.options.ignore_dragging(event);\n        }\n\n        return $(event.target).is(this.options.ignore_dragging.join(', '));\n    };\n\n    //jQuery adapter\n    $.fn.drag = function ( options ) {\n        return new Draggable(this, options);\n    };\n\n    return Draggable;\n\n}));\n\n;(function(root, factory) {\n\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery', 'gridster-draggable', 'gridster-collision'], factory);\n    } else {\n        root.Gridster = factory(root.$ || root.jQuery, root.GridsterDraggable,\n            root.GridsterCollision);\n    }\n\n }(this, function($, Draggable, Collision) {\n\n    var defaults = {\n        namespace: '',\n        widget_selector: 'li',\n        widget_margins: [10, 10],\n        widget_base_dimensions: [400, 225],\n        extra_rows: 0,\n        extra_cols: 0,\n        min_cols: 1,\n        max_cols: Infinity,\n        min_rows: 15,\n        max_size_x: false,\n        autogrow_cols: false,\n        autogenerate_stylesheet: true,\n        avoid_overlapped_widgets: true,\n        auto_init: true,\n        serialize_params: function($w, wgd) {\n            return {\n                col: wgd.col,\n                row: wgd.row,\n                size_x: wgd.size_x,\n                size_y: wgd.size_y\n            };\n        },\n        collision: {},\n        draggable: {\n            items: '.gs-w',\n            distance: 4,\n            ignore_dragging: Draggable.defaults.ignore_dragging.slice(0)\n        },\n        resize: {\n            enabled: false,\n            axes: ['both'],\n            handle_append_to: '',\n            handle_class: 'gs-resize-handle',\n            max_size: [Infinity, Infinity],\n            min_size: [1, 1]\n        }\n    };\n\n    /**\n    * @class Gridster\n    * @uses Draggable\n    * @uses Collision\n    * @param {HTMLElement} el The HTMLelement that contains all the widgets.\n    * @param {Object} [options] An Object with all options you want to\n    *        overwrite:\n    *    @param {HTMLElement|String} [options.widget_selector] Define who will\n    *     be the draggable widgets. Can be a CSS Selector String or a\n    *     collection of HTMLElements\n    *    @param {Array} [options.widget_margins] Margin between widgets.\n    *     The first index for the horizontal margin (left, right) and\n    *     the second for the vertical margin (top, bottom).\n    *    @param {Array} [options.widget_base_dimensions] Base widget dimensions\n    *     in pixels. The first index for the width and the second for the\n    *     height.\n    *    @param {Number} [options.extra_cols] Add more columns in addition to\n    *     those that have been calculated.\n    *    @param {Number} [options.extra_rows] Add more rows in addition to\n    *     those that have been calculated.\n    *    @param {Number} [options.min_cols] The minimum required columns.\n    *    @param {Number} [options.max_cols] The maximum columns possible (set to null\n    *     for no maximum).\n    *    @param {Number} [options.min_rows] The minimum required rows.\n    *    @param {Number} [options.max_size_x] The maximum number of columns\n    *     that a widget can span.\n    *    @param {Boolean} [options.autogenerate_stylesheet] If true, all the\n    *     CSS required to position all widgets in their respective columns\n    *     and rows will be generated automatically and injected to the\n    *     `<head>` of the document. You can set this to false, and write\n    *     your own CSS targeting rows and cols via data-attributes like so:\n    *     `[data-col=\"1\"] { left: 10px; }`\n    *    @param {Boolean} [options.avoid_overlapped_widgets] Avoid that widgets loaded\n    *     from the DOM can be overlapped. It is helpful if the positions were\n    *     bad stored in the database or if there was any conflict.\n    *    @param {Boolean} [options.auto_init] Automatically call gridster init\n    *     method or not when the plugin is instantiated.\n    *    @param {Function} [options.serialize_params] Return the data you want\n    *     for each widget in the serialization. Two arguments are passed:\n    *     `$w`: the jQuery wrapped HTMLElement, and `wgd`: the grid\n    *     coords object (`col`, `row`, `size_x`, `size_y`).\n    *    @param {Object} [options.collision] An Object with all options for\n    *     Collision class you want to overwrite. See Collision docs for\n    *     more info.\n    *    @param {Object} [options.draggable] An Object with all options for\n    *     Draggable class you want to overwrite. See Draggable docs for more\n    *     info.\n    *       @param {Object|Function} [options.draggable.ignore_dragging] Note that\n    *        if you use a Function, and resize is enabled, you should ignore the\n    *        resize handlers manually (options.resize.handle_class).\n    *    @param {Object} [options.resize] An Object with resize config options.\n    *       @param {Boolean} [options.resize.enabled] Set to true to enable\n    *        resizing.\n    *       @param {Array} [options.resize.axes] Axes in which widgets can be\n    *        resized. Possible values: ['x', 'y', 'both'].\n    *       @param {String} [options.resize.handle_append_to] Set a valid CSS\n    *        selector to append resize handles to.\n    *       @param {String} [options.resize.handle_class] CSS class name used\n    *        by resize handles.\n    *       @param {Array} [options.resize.max_size] Limit widget dimensions\n    *        when resizing. Array values should be integers:\n    *        `[max_cols_occupied, max_rows_occupied]`\n    *       @param {Array} [options.resize.min_size] Limit widget dimensions\n    *        when resizing. Array values should be integers:\n    *        `[min_cols_occupied, min_rows_occupied]`\n    *       @param {Function} [options.resize.start] Function executed\n    *        when resizing starts.\n    *       @param {Function} [otions.resize.resize] Function executed\n    *        during the resizing.\n    *       @param {Function} [options.resize.stop] Function executed\n    *        when resizing stops.\n    *\n    * @constructor\n    */\n    function Gridster(el, options) {\n        this.options = $.extend(true, {}, defaults, options);\n        this.$el = $(el);\n        this.$wrapper = this.$el.parent();\n        this.$widgets = this.$el.children(\n            this.options.widget_selector).addClass('gs-w');\n        this.widgets = [];\n        this.$changed = $([]);\n        this.wrapper_width = this.$wrapper.width();\n        this.min_widget_width = (this.options.widget_margins[0] * 2) +\n          this.options.widget_base_dimensions[0];\n        this.min_widget_height = (this.options.widget_margins[1] * 2) +\n          this.options.widget_base_dimensions[1];\n\n        this.generated_stylesheets = [];\n        this.$style_tags = $([]);\n\n        this.options.auto_init && this.init();\n    }\n\n    Gridster.defaults = defaults;\n    Gridster.generated_stylesheets = [];\n\n\n    /**\n    * Sorts an Array of grid coords objects (representing the grid coords of\n    * each widget) in ascending way.\n    *\n    * @method sort_by_row_asc\n    * @param {Array} widgets Array of grid coords objects\n    * @return {Array} Returns the array sorted.\n    */\n    Gridster.sort_by_row_asc = function(widgets) {\n        widgets = widgets.sort(function(a, b) {\n            if (!a.row) {\n                a = $(a).coords().grid;\n                b = $(b).coords().grid;\n            }\n\n           if (a.row > b.row) {\n               return 1;\n           }\n           return -1;\n        });\n\n        return widgets;\n    };\n\n\n    /**\n    * Sorts an Array of grid coords objects (representing the grid coords of\n    * each widget) placing first the empty cells upper left.\n    *\n    * @method sort_by_row_and_col_asc\n    * @param {Array} widgets Array of grid coords objects\n    * @return {Array} Returns the array sorted.\n    */\n    Gridster.sort_by_row_and_col_asc = function(widgets) {\n        widgets = widgets.sort(function(a, b) {\n           if (a.row > b.row || a.row === b.row && a.col > b.col) {\n               return 1;\n           }\n           return -1;\n        });\n\n        return widgets;\n    };\n\n\n    /**\n    * Sorts an Array of grid coords objects by column (representing the grid\n    * coords of each widget) in ascending way.\n    *\n    * @method sort_by_col_asc\n    * @param {Array} widgets Array of grid coords objects\n    * @return {Array} Returns the array sorted.\n    */\n    Gridster.sort_by_col_asc = function(widgets) {\n        widgets = widgets.sort(function(a, b) {\n           if (a.col > b.col) {\n               return 1;\n           }\n           return -1;\n        });\n\n        return widgets;\n    };\n\n\n    /**\n    * Sorts an Array of grid coords objects (representing the grid coords of\n    * each widget) in descending way.\n    *\n    * @method sort_by_row_desc\n    * @param {Array} widgets Array of grid coords objects\n    * @return {Array} Returns the array sorted.\n    */\n    Gridster.sort_by_row_desc = function(widgets) {\n        widgets = widgets.sort(function(a, b) {\n            if (a.row + a.size_y < b.row + b.size_y) {\n                return 1;\n            }\n           return -1;\n        });\n        return widgets;\n    };\n\n\n\n    /** Instance Methods **/\n\n    var fn = Gridster.prototype;\n\n    fn.init = function() {\n        this.options.resize.enabled && this.setup_resize();\n        this.generate_grid_and_stylesheet();\n        this.get_widgets_from_DOM();\n        this.set_dom_grid_height();\n        this.set_dom_grid_width();\n        this.$wrapper.addClass('ready');\n        this.draggable();\n        this.options.resize.enabled && this.resizable();\n\n        $(window).bind('resize.gridster', throttle(\n            $.proxy(this.recalculate_faux_grid, this), 200));\n    };\n\n\n    /**\n    * Disables dragging.\n    *\n    * @method disable\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.disable = function() {\n        this.$wrapper.find('.player-revert').removeClass('player-revert');\n        this.drag_api.disable();\n        return this;\n    };\n\n\n    /**\n    * Enables dragging.\n    *\n    * @method enable\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.enable = function() {\n        this.drag_api.enable();\n        return this;\n    };\n\n\n\n    /**\n    * Disables drag-and-drop widget resizing.\n    *\n    * @method disable\n    * @return {Class} Returns instance of gridster Class.\n    */\n    fn.disable_resize = function() {\n        this.$el.addClass('gs-resize-disabled');\n        this.resize_api.disable();\n        return this;\n    };\n\n\n    /**\n    * Enables drag-and-drop widget resizing.\n    *\n    * @method enable\n    * @return {Class} Returns instance of gridster Class.\n    */\n    fn.enable_resize = function() {\n        this.$el.removeClass('gs-resize-disabled');\n        this.resize_api.enable();\n        return this;\n    };\n\n\n    /**\n    * Add a new widget to the grid.\n    *\n    * @method add_widget\n    * @param {String|HTMLElement} html The string representing the HTML of the widget\n    *  or the HTMLElement.\n    * @param {Number} [size_x] The n of rows the widget occupies horizontally.\n    * @param {Number} [size_y] The n of columns the widget occupies vertically.\n    * @param {Number} [col] The column the widget should start in.\n    * @param {Number} [row] The row the widget should start in.\n    * @param {Array} [max_size] max_size Maximun size (in units) for width and height.\n    * @param {Array} [min_size] min_size Minimum size (in units) for width and height.\n    * @return {HTMLElement} Returns the jQuery wrapped HTMLElement representing.\n    *  the widget that was just created.\n    */\n    fn.add_widget = function(html, size_x, size_y, col, row, max_size, min_size) {\n        var pos;\n        size_x || (size_x = 1);\n        size_y || (size_y = 1);\n\n        if (!col & !row) {\n            pos = this.next_position(size_x, size_y);\n        } else {\n            pos = {\n                col: col,\n                row: row,\n                size_x: size_x,\n                size_y: size_y\n            };\n\n            this.empty_cells(col, row, size_x, size_y);\n        }\n\n        var $w = $(html).attr({\n                'data-col': pos.col,\n                'data-row': pos.row,\n                'data-sizex' : size_x,\n                'data-sizey' : size_y\n            }).addClass('gs-w').appendTo(this.$el).hide();\n\n        this.$widgets = this.$widgets.add($w);\n\n        this.register_widget($w);\n\n        this.add_faux_rows(pos.size_y);\n        //this.add_faux_cols(pos.size_x);\n\n        if (max_size) {\n            this.set_widget_max_size($w, max_size);\n        }\n\n        if (min_size) {\n            this.set_widget_min_size($w, min_size);\n        }\n\n        this.set_dom_grid_width();\n        this.set_dom_grid_height();\n\n        this.drag_api.set_limits(this.cols * this.min_widget_width);\n\n        return $w.fadeIn();\n    };\n\n\n    /**\n    * Change widget size limits.\n    *\n    * @method set_widget_min_size\n    * @param {HTMLElement|Number} $widget The jQuery wrapped HTMLElement\n    *  representing the widget or an index representing the desired widget.\n    * @param {Array} min_size Minimum size (in units) for width and height.\n    * @return {HTMLElement} Returns instance of gridster Class.\n    */\n    fn.set_widget_min_size = function($widget, min_size) {\n        $widget = typeof $widget === 'number' ?\n            this.$widgets.eq($widget) : $widget;\n\n        if (!$widget.length) { return this; }\n\n        var wgd = $widget.data('coords').grid;\n        wgd.min_size_x = min_size[0];\n        wgd.min_size_y = min_size[1];\n\n        return this;\n    };\n\n\n    /**\n    * Change widget size limits.\n    *\n    * @method set_widget_max_size\n    * @param {HTMLElement|Number} $widget The jQuery wrapped HTMLElement\n    *  representing the widget or an index representing the desired widget.\n    * @param {Array} max_size Maximun size (in units) for width and height.\n    * @return {HTMLElement} Returns instance of gridster Class.\n    */\n    fn.set_widget_max_size = function($widget, max_size) {\n        $widget = typeof $widget === 'number' ?\n            this.$widgets.eq($widget) : $widget;\n\n        if (!$widget.length) { return this; }\n\n        var wgd = $widget.data('coords').grid;\n        wgd.max_size_x = max_size[0];\n        wgd.max_size_y = max_size[1];\n\n        return this;\n    };\n\n\n    /**\n    * Append the resize handle into a widget.\n    *\n    * @method add_resize_handle\n    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement\n    *  representing the widget.\n    * @return {HTMLElement} Returns instance of gridster Class.\n    */\n    fn.add_resize_handle = function($w) {\n        var append_to = this.options.resize.handle_append_to;\n        $(this.resize_handle_tpl).appendTo( append_to ? $(append_to, $w) : $w);\n\n        return this;\n    };\n\n\n    /**\n    * Change the size of a widget. Width is limited to the current grid width.\n    *\n    * @method resize_widget\n    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement\n    *  representing the widget.\n    * @param {Number} size_x The number of columns that will occupy the widget.\n    *  By default <code>size_x</code> is limited to the space available from\n    *  the column where the widget begins, until the last column to the right.\n    * @param {Number} size_y The number of rows that will occupy the widget.\n    * @param {Function} [callback] Function executed when the widget is removed.\n    * @return {HTMLElement} Returns $widget.\n    */\n    fn.resize_widget = function($widget, size_x, size_y, callback) {\n        var wgd = $widget.coords().grid;\n        var col = wgd.col;\n        var max_cols = this.options.max_cols;\n        var old_size_y = wgd.size_y;\n        var old_col = wgd.col;\n        var new_col = old_col;\n\n        size_x || (size_x = wgd.size_x);\n        size_y || (size_y = wgd.size_y);\n\n        if (max_cols !== Infinity) {\n            size_x = Math.min(size_x, max_cols - col + 1);\n        }\n\n        if (size_y > old_size_y) {\n            this.add_faux_rows(Math.max(size_y - old_size_y, 0));\n        }\n\n        var player_rcol = (col + size_x - 1);\n        if (player_rcol > this.cols) {\n            this.add_faux_cols(player_rcol - this.cols);\n        }\n\n        var new_grid_data = {\n            col: new_col,\n            row: wgd.row,\n            size_x: size_x,\n            size_y: size_y\n        };\n\n        this.mutate_widget_in_gridmap($widget, wgd, new_grid_data);\n\n        this.set_dom_grid_height();\n        this.set_dom_grid_width();\n\n        if (callback) {\n            callback.call(this, new_grid_data.size_x, new_grid_data.size_y);\n        }\n\n        return $widget;\n    };\n\n\n    /**\n    * Mutate widget dimensions and position in the grid map.\n    *\n    * @method mutate_widget_in_gridmap\n    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement\n    *  representing the widget to mutate.\n    * @param {Object} wgd Current widget grid data (col, row, size_x, size_y).\n    * @param {Object} new_wgd New widget grid data.\n    * @return {HTMLElement} Returns instance of gridster Class.\n    */\n    fn.mutate_widget_in_gridmap = function($widget, wgd, new_wgd) {\n        var old_size_x = wgd.size_x;\n        var old_size_y = wgd.size_y;\n\n        var old_cells_occupied = this.get_cells_occupied(wgd);\n        var new_cells_occupied = this.get_cells_occupied(new_wgd);\n\n        var empty_cols = [];\n        $.each(old_cells_occupied.cols, function(i, col) {\n            if ($.inArray(col, new_cells_occupied.cols) === -1) {\n                empty_cols.push(col);\n            }\n        });\n\n        var occupied_cols = [];\n        $.each(new_cells_occupied.cols, function(i, col) {\n            if ($.inArray(col, old_cells_occupied.cols) === -1) {\n                occupied_cols.push(col);\n            }\n        });\n\n        var empty_rows = [];\n        $.each(old_cells_occupied.rows, function(i, row) {\n            if ($.inArray(row, new_cells_occupied.rows) === -1) {\n                empty_rows.push(row);\n            }\n        });\n\n        var occupied_rows = [];\n        $.each(new_cells_occupied.rows, function(i, row) {\n            if ($.inArray(row, old_cells_occupied.rows) === -1) {\n                occupied_rows.push(row);\n            }\n        });\n\n        this.remove_from_gridmap(wgd);\n\n        if (occupied_cols.length) {\n            var cols_to_empty = [\n                new_wgd.col, new_wgd.row, new_wgd.size_x, Math.min(old_size_y, new_wgd.size_y), $widget\n            ];\n            this.empty_cells.apply(this, cols_to_empty);\n        }\n\n        if (occupied_rows.length) {\n            var rows_to_empty = [new_wgd.col, new_wgd.row, new_wgd.size_x, new_wgd.size_y, $widget];\n            this.empty_cells.apply(this, rows_to_empty);\n        }\n\n        // not the same that wgd = new_wgd;\n        wgd.col = new_wgd.col;\n        wgd.row = new_wgd.row;\n        wgd.size_x = new_wgd.size_x;\n        wgd.size_y = new_wgd.size_y;\n\n        this.add_to_gridmap(new_wgd, $widget);\n\n        $widget.removeClass('player-revert');\n\n        //update coords instance attributes\n        $widget.data('coords').update({\n            width: (new_wgd.size_x * this.options.widget_base_dimensions[0] +\n                ((new_wgd.size_x - 1) * this.options.widget_margins[0]) * 2),\n            height: (new_wgd.size_y * this.options.widget_base_dimensions[1] +\n                ((new_wgd.size_y - 1) * this.options.widget_margins[1]) * 2)\n        });\n\n        $widget.attr({\n            'data-col': new_wgd.col,\n            'data-row': new_wgd.row,\n            'data-sizex': new_wgd.size_x,\n            'data-sizey': new_wgd.size_y\n        });\n\n        if (empty_cols.length) {\n            var cols_to_remove_holes = [\n                empty_cols[0], new_wgd.row,\n                empty_cols.length,\n                Math.min(old_size_y, new_wgd.size_y),\n                $widget\n            ];\n\n            this.remove_empty_cells.apply(this, cols_to_remove_holes);\n        }\n\n        if (empty_rows.length) {\n            var rows_to_remove_holes = [\n                new_wgd.col, new_wgd.row, new_wgd.size_x, new_wgd.size_y, $widget\n            ];\n            this.remove_empty_cells.apply(this, rows_to_remove_holes);\n        }\n\n        this.move_widget_up($widget);\n\n        return this;\n    };\n\n\n    /**\n    * Move down widgets in cells represented by the arguments col, row, size_x,\n    * size_y\n    *\n    * @method empty_cells\n    * @param {Number} col The column where the group of cells begin.\n    * @param {Number} row The row where the group of cells begin.\n    * @param {Number} size_x The number of columns that the group of cells\n    * occupy.\n    * @param {Number} size_y The number of rows that the group of cells\n    * occupy.\n    * @param {HTMLElement} $exclude Exclude widgets from being moved.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.empty_cells = function(col, row, size_x, size_y, $exclude) {\n        var $nexts = this.widgets_below({\n                col: col,\n                row: row - size_y,\n                size_x: size_x,\n                size_y: size_y\n            });\n\n        $nexts.not($exclude).each($.proxy(function(i, w) {\n            var wgd = $(w).coords().grid;\n            if ( !(wgd.row <= (row + size_y - 1))) { return; }\n            var diff =  (row + size_y) - wgd.row;\n            this.move_widget_down($(w), diff);\n        }, this));\n\n        this.set_dom_grid_height();\n\n        return this;\n    };\n\n\n    /**\n    * Move up widgets below cells represented by the arguments col, row, size_x,\n    * size_y.\n    *\n    * @method remove_empty_cells\n    * @param {Number} col The column where the group of cells begin.\n    * @param {Number} row The row where the group of cells begin.\n    * @param {Number} size_x The number of columns that the group of cells\n    * occupy.\n    * @param {Number} size_y The number of rows that the group of cells\n    * occupy.\n    * @param {HTMLElement} exclude Exclude widgets from being moved.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.remove_empty_cells = function(col, row, size_x, size_y, exclude) {\n        var $nexts = this.widgets_below({\n            col: col,\n            row: row,\n            size_x: size_x,\n            size_y: size_y\n        });\n\n        $nexts.not(exclude).each($.proxy(function(i, widget) {\n            this.move_widget_up( $(widget), size_y );\n        }, this));\n\n        this.set_dom_grid_height();\n\n        return this;\n    };\n\n\n    /**\n    * Get the most left column below to add a new widget.\n    *\n    * @method next_position\n    * @param {Number} size_x The n of rows the widget occupies horizontally.\n    * @param {Number} size_y The n of columns the widget occupies vertically.\n    * @return {Object} Returns a grid coords object representing the future\n    *  widget coords.\n    */\n    fn.next_position = function(size_x, size_y) {\n        size_x || (size_x = 1);\n        size_y || (size_y = 1);\n        var ga = this.gridmap;\n        var cols_l = ga.length;\n        var valid_pos = [];\n        var rows_l;\n\n        for (var c = 1; c < cols_l; c++) {\n            rows_l = ga[c].length;\n            for (var r = 1; r <= rows_l; r++) {\n                var can_move_to = this.can_move_to({\n                    size_x: size_x,\n                    size_y: size_y\n                }, c, r);\n\n                if (can_move_to) {\n                    valid_pos.push({\n                        col: c,\n                        row: r,\n                        size_y: size_y,\n                        size_x: size_x\n                    });\n                }\n            }\n        }\n\n        if (valid_pos.length) {\n            return Gridster.sort_by_row_and_col_asc(valid_pos)[0];\n        }\n        return false;\n    };\n\n\n    /**\n    * Remove a widget from the grid.\n    *\n    * @method remove_widget\n    * @param {HTMLElement} el The jQuery wrapped HTMLElement you want to remove.\n    * @param {Boolean|Function} silent If true, widgets below the removed one\n    * will not move up. If a Function is passed it will be used as callback.\n    * @param {Function} callback Function executed when the widget is removed.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.remove_widget = function(el, silent, callback) {\n        var $el = el instanceof $ ? el : $(el);\n        var wgd = $el.coords().grid;\n\n        // if silent is a function assume it's a callback\n        if ($.isFunction(silent)) {\n            callback = silent;\n            silent = false;\n        }\n\n        this.cells_occupied_by_placeholder = {};\n        this.$widgets = this.$widgets.not($el);\n\n        var $nexts = this.widgets_below($el);\n\n        this.remove_from_gridmap(wgd);\n\n        $el.fadeOut($.proxy(function() {\n            $el.remove();\n\n            if (!silent) {\n                $nexts.each($.proxy(function(i, widget) {\n                    this.move_widget_up( $(widget), wgd.size_y );\n                }, this));\n            }\n\n            this.set_dom_grid_height();\n\n            if (callback) {\n                callback.call(this, el);\n            }\n        }, this));\n\n        return this;\n    };\n\n\n    /**\n    * Remove all widgets from the grid.\n    *\n    * @method remove_all_widgets\n    * @param {Function} callback Function executed for each widget removed.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.remove_all_widgets = function(callback) {\n        this.$widgets.each($.proxy(function(i, el){\n              this.remove_widget(el, true, callback);\n        }, this));\n\n        return this;\n    };\n\n\n    /**\n    * Returns a serialized array of the widgets in the grid.\n    *\n    * @method serialize\n    * @param {HTMLElement} [$widgets] The collection of jQuery wrapped\n    *  HTMLElements you want to serialize. If no argument is passed all widgets\n    *  will be serialized.\n    * @return {Array} Returns an Array of Objects with the data specified in\n    *  the serialize_params option.\n    */\n    fn.serialize = function($widgets) {\n        $widgets || ($widgets = this.$widgets);\n\n        return $widgets.map($.proxy(function(i, widget) {\n            var $w = $(widget);\n            return this.options.serialize_params($w, $w.coords().grid);\n        }, this)).get();\n    };\n\n\n    /**\n    * Returns a serialized array of the widgets that have changed their\n    *  position.\n    *\n    * @method serialize_changed\n    * @return {Array} Returns an Array of Objects with the data specified in\n    *  the serialize_params option.\n    */\n    fn.serialize_changed = function() {\n        return this.serialize(this.$changed);\n    };\n\n\n    /**\n    * Convert widgets from DOM elements to \"widget grid data\" Objects.\n    *\n    * @method dom_to_coords\n    * @param {HTMLElement} $widget The widget to be converted.\n    */\n    fn.dom_to_coords = function($widget) {\n        return {\n            'col': parseInt($widget.attr('data-col'), 10),\n            'row': parseInt($widget.attr('data-row'), 10),\n            'size_x': parseInt($widget.attr('data-sizex'), 10) || 1,\n            'size_y': parseInt($widget.attr('data-sizey'), 10) || 1,\n            'max_size_x': parseInt($widget.attr('data-max-sizex'), 10) || false,\n            'max_size_y': parseInt($widget.attr('data-max-sizey'), 10) || false,\n            'min_size_x': parseInt($widget.attr('data-min-sizex'), 10) || false,\n            'min_size_y': parseInt($widget.attr('data-min-sizey'), 10) || false,\n            'el': $widget\n        };\n    };\n\n\n    /**\n    * Creates the grid coords object representing the widget an add it to the\n    * mapped array of positions.\n    *\n    * @method register_widget\n    * @param {HTMLElement|Object} $el jQuery wrapped HTMLElement representing\n    *  the widget, or an \"widget grid data\" Object with (col, row, el ...).\n    * @return {Boolean} Returns true if the widget final position is different\n    *  than the original.\n    */\n    fn.register_widget = function($el) {\n        var isDOM = $el instanceof jQuery;\n        var wgd = isDOM ? this.dom_to_coords($el) : $el;\n        var posChanged = false;\n        isDOM || ($el = wgd.el);\n\n        var empty_upper_row = this.can_go_widget_up(wgd);\n        if (empty_upper_row) {\n            wgd.row = empty_upper_row;\n            $el.attr('data-row', empty_upper_row);\n            this.$el.trigger('gridster:positionchanged', [wgd]);\n            posChanged = true;\n        }\n\n        if (this.options.avoid_overlapped_widgets &&\n            !this.can_move_to(\n             {size_x: wgd.size_x, size_y: wgd.size_y}, wgd.col, wgd.row)\n        ) {\n            $.extend(wgd, this.next_position(wgd.size_x, wgd.size_y));\n            $el.attr({\n                'data-col': wgd.col,\n                'data-row': wgd.row,\n                'data-sizex': wgd.size_x,\n                'data-sizey': wgd.size_y\n            });\n            posChanged = true;\n        }\n\n        // attach Coord object to player data-coord attribute\n        $el.data('coords', $el.coords());\n        // Extend Coord object with grid position info\n        $el.data('coords').grid = wgd;\n\n        this.add_to_gridmap(wgd, $el);\n\n        this.options.resize.enabled && this.add_resize_handle($el);\n\n        return posChanged;\n    };\n\n\n    /**\n    * Update in the mapped array of positions the value of cells represented by\n    * the grid coords object passed in the `grid_data` param.\n    *\n    * @param {Object} grid_data The grid coords object representing the cells\n    *  to update in the mapped array.\n    * @param {HTMLElement|Boolean} value Pass `false` or the jQuery wrapped\n    *  HTMLElement, depends if you want to delete an existing position or add\n    *  a new one.\n    * @method update_widget_position\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.update_widget_position = function(grid_data, value) {\n        this.for_each_cell_occupied(grid_data, function(col, row) {\n            if (!this.gridmap[col]) { return this; }\n            this.gridmap[col][row] = value;\n        });\n        return this;\n    };\n\n\n    /**\n    * Remove a widget from the mapped array of positions.\n    *\n    * @method remove_from_gridmap\n    * @param {Object} grid_data The grid coords object representing the cells\n    *  to update in the mapped array.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.remove_from_gridmap = function(grid_data) {\n        return this.update_widget_position(grid_data, false);\n    };\n\n\n    /**\n    * Add a widget to the mapped array of positions.\n    *\n    * @method add_to_gridmap\n    * @param {Object} grid_data The grid coords object representing the cells\n    *  to update in the mapped array.\n    * @param {HTMLElement|Boolean} value The value to set in the specified\n    *  position .\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.add_to_gridmap = function(grid_data, value) {\n        this.update_widget_position(grid_data, value || grid_data.el);\n\n        if (grid_data.el) {\n            var $widgets = this.widgets_below(grid_data.el);\n            $widgets.each($.proxy(function(i, widget) {\n                this.move_widget_up( $(widget));\n            }, this));\n        }\n    };\n\n\n    /**\n    * Make widgets draggable.\n    *\n    * @uses Draggable\n    * @method draggable\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.draggable = function() {\n        var self = this;\n        var draggable_options = $.extend(true, {}, this.options.draggable, {\n            offset_left: this.options.widget_margins[0],\n            offset_top: this.options.widget_margins[1],\n            container_width: this.cols * this.min_widget_width,\n            limit: true,\n            start: function(event, ui) {\n                self.$widgets.filter('.player-revert')\n                    .removeClass('player-revert');\n\n                self.$player = $(this);\n                self.$helper = $(ui.$helper);\n\n                self.helper = !self.$helper.is(self.$player);\n\n                self.on_start_drag.call(self, event, ui);\n                self.$el.trigger('gridster:dragstart');\n            },\n            stop: function(event, ui) {\n                self.on_stop_drag.call(self, event, ui);\n                self.$el.trigger('gridster:dragstop');\n            },\n            drag: throttle(function(event, ui) {\n                self.on_drag.call(self, event, ui);\n                self.$el.trigger('gridster:drag');\n            }, 60)\n          });\n\n        this.drag_api = this.$el.drag(draggable_options);\n        return this;\n    };\n\n\n    /**\n    * Bind resize events to get resize working.\n    *\n    * @method resizable\n    * @return {Class} Returns instance of gridster Class.\n    */\n    fn.resizable = function() {\n        this.resize_api = this.$el.drag({\n            items: '.' + this.options.resize.handle_class,\n            offset_left: this.options.widget_margins[0],\n            container_width: this.container_width,\n            move_element: false,\n            resize: true,\n            limit: this.options.autogrow_cols ? false : true,\n            start: $.proxy(this.on_start_resize, this),\n            stop: $.proxy(function(event, ui) {\n                delay($.proxy(function() {\n                    this.on_stop_resize(event, ui);\n                }, this), 120);\n            }, this),\n            drag: throttle($.proxy(this.on_resize, this), 60)\n        });\n\n        return this;\n    };\n\n\n    /**\n    * Setup things required for resizing. Like build templates for drag handles.\n    *\n    * @method setup_resize\n    * @return {Class} Returns instance of gridster Class.\n    */\n    fn.setup_resize = function() {\n        this.resize_handle_class = this.options.resize.handle_class;\n        var axes = this.options.resize.axes;\n        var handle_tpl = '<span class=\"' + this.resize_handle_class + ' ' +\n            this.resize_handle_class + '-{type}\" />';\n\n        this.resize_handle_tpl = $.map(axes, function(type) {\n            return handle_tpl.replace('{type}', type);\n        }).join('');\n\n        if ($.isArray(this.options.draggable.ignore_dragging)) {\n            this.options.draggable.ignore_dragging.push(\n                '.' + this.resize_handle_class);\n        }\n\n        return this;\n    };\n\n\n    /**\n    * This function is executed when the player begins to be dragged.\n    *\n    * @method on_start_drag\n    * @param {Event} event The original browser event\n    * @param {Object} ui A prepared ui object with useful drag-related data\n    */\n    fn.on_start_drag = function(event, ui) {\n        this.$helper.add(this.$player).add(this.$wrapper).addClass('dragging');\n\n        this.highest_col = this.get_highest_occupied_cell().col;\n\n        this.$player.addClass('player');\n        this.player_grid_data = this.$player.coords().grid;\n        this.placeholder_grid_data = $.extend({}, this.player_grid_data);\n\n        this.set_dom_grid_height(this.$el.height() +\n            (this.player_grid_data.size_y * this.min_widget_height));\n\n        this.set_dom_grid_width(this.cols);\n\n        var pgd_sizex = this.player_grid_data.size_x;\n        var cols_diff = this.cols - this.highest_col;\n\n        if (this.options.autogrow_cols && cols_diff <= pgd_sizex) {\n            this.add_faux_cols(Math.min(pgd_sizex - cols_diff, 1));\n        }\n\n        var colliders = this.faux_grid;\n        var coords = this.$player.data('coords').coords;\n\n        this.cells_occupied_by_player = this.get_cells_occupied(\n            this.player_grid_data);\n        this.cells_occupied_by_placeholder = this.get_cells_occupied(\n            this.placeholder_grid_data);\n\n        this.last_cols = [];\n        this.last_rows = [];\n\n        // see jquery.collision.js\n        this.collision_api = this.$helper.collision(\n            colliders, this.options.collision);\n\n        this.$preview_holder = $('<' + this.$player.get(0).tagName + ' />', {\n              'class': 'preview-holder',\n              'data-row': this.$player.attr('data-row'),\n              'data-col': this.$player.attr('data-col'),\n              css: {\n                  width: coords.width,\n                  height: coords.height\n              }\n        }).appendTo(this.$el);\n\n        if (this.options.draggable.start) {\n          this.options.draggable.start.call(this, event, ui);\n        }\n    };\n\n\n    /**\n    * This function is executed when the player is being dragged.\n    *\n    * @method on_drag\n    * @param {Event} event The original browser event\n    * @param {Object} ui A prepared ui object with useful drag-related data\n    */\n    fn.on_drag = function(event, ui) {\n        //break if dragstop has been fired\n        if (this.$player === null) {\n            return false;\n        }\n\n        var abs_offset = {\n            left: ui.position.left + this.baseX,\n            top: ui.position.top + this.baseY\n        };\n\n        // auto grow cols\n        if (this.options.autogrow_cols) {\n            var prcol = this.placeholder_grid_data.col +\n                this.placeholder_grid_data.size_x - 1;\n\n            // \"- 1\" due to adding at least 1 column in on_start_drag\n            if (prcol >= this.cols - 1 && this.options.max_cols >= this.cols + 1) {\n                this.add_faux_cols(1);\n                this.set_dom_grid_width(this.cols + 1);\n                this.drag_api.set_limits(this.container_width);\n            }\n\n            this.collision_api.set_colliders(this.faux_grid);\n        }\n\n        this.colliders_data = this.collision_api.get_closest_colliders(\n            abs_offset);\n\n        this.on_overlapped_column_change(\n            this.on_start_overlapping_column, this.on_stop_overlapping_column);\n\n        this.on_overlapped_row_change(\n            this.on_start_overlapping_row, this.on_stop_overlapping_row);\n\n\n        if (this.helper && this.$player) {\n            this.$player.css({\n                'left': ui.position.left,\n                'top': ui.position.top\n            });\n        }\n\n        if (this.options.draggable.drag) {\n            this.options.draggable.drag.call(this, event, ui);\n        }\n    };\n\n\n    /**\n    * This function is executed when the player stops being dragged.\n    *\n    * @method on_stop_drag\n    * @param {Event} event The original browser event\n    * @param {Object} ui A prepared ui object with useful drag-related data\n    */\n    fn.on_stop_drag = function(event, ui) {\n        this.$helper.add(this.$player).add(this.$wrapper)\n            .removeClass('dragging');\n\n        ui.position.left = ui.position.left + this.baseX;\n        ui.position.top = ui.position.top + this.baseY;\n        this.colliders_data = this.collision_api.get_closest_colliders(\n            ui.position);\n\n        this.on_overlapped_column_change(\n            this.on_start_overlapping_column,\n            this.on_stop_overlapping_column\n        );\n\n        this.on_overlapped_row_change(\n            this.on_start_overlapping_row,\n            this.on_stop_overlapping_row\n        );\n\n        this.$player.addClass('player-revert').removeClass('player')\n            .attr({\n                'data-col': this.placeholder_grid_data.col,\n                'data-row': this.placeholder_grid_data.row\n            }).css({\n                'left': '',\n                'top': ''\n            });\n\n        this.$changed = this.$changed.add(this.$player);\n\n        this.cells_occupied_by_player = this.get_cells_occupied(\n            this.placeholder_grid_data);\n        this.set_cells_player_occupies(\n            this.placeholder_grid_data.col, this.placeholder_grid_data.row);\n\n        this.$player.coords().grid.row = this.placeholder_grid_data.row;\n        this.$player.coords().grid.col = this.placeholder_grid_data.col;\n\n        if (this.options.draggable.stop) {\n          this.options.draggable.stop.call(this, event, ui);\n        }\n\n        this.$preview_holder.remove();\n\n        this.$player = null;\n        this.$helper = null;\n        this.placeholder_grid_data = {};\n        this.player_grid_data = {};\n        this.cells_occupied_by_placeholder = {};\n        this.cells_occupied_by_player = {};\n\n        this.set_dom_grid_height();\n        this.set_dom_grid_width();\n\n        if (this.options.autogrow_cols) {\n            this.drag_api.set_limits(this.cols * this.min_widget_width);\n        }\n    };\n\n\n    /**\n    * This function is executed every time a widget starts to be resized.\n    *\n    * @method on_start_resize\n    * @param {Event} event The original browser event\n    * @param {Object} ui A prepared ui object with useful drag-related data\n    */\n    fn.on_start_resize = function(event, ui) {\n        this.$resized_widget = ui.$player.closest('.gs-w');\n        this.resize_coords = this.$resized_widget.coords();\n        this.resize_wgd = this.resize_coords.grid;\n        this.resize_initial_width = this.resize_coords.coords.width;\n        this.resize_initial_height = this.resize_coords.coords.height;\n        this.resize_initial_sizex = this.resize_coords.grid.size_x;\n        this.resize_initial_sizey = this.resize_coords.grid.size_y;\n        this.resize_initial_col = this.resize_coords.grid.col;\n        this.resize_last_sizex = this.resize_initial_sizex;\n        this.resize_last_sizey = this.resize_initial_sizey;\n\n        this.resize_max_size_x = Math.min(this.resize_wgd.max_size_x ||\n            this.options.resize.max_size[0],\n            this.options.max_cols - this.resize_initial_col + 1);\n        this.resize_max_size_y = this.resize_wgd.max_size_y ||\n            this.options.resize.max_size[1];\n\n        this.resize_min_size_x = (this.resize_wgd.min_size_x ||\n            this.options.resize.min_size[0] || 1);\n        this.resize_min_size_y = (this.resize_wgd.min_size_y ||\n            this.options.resize.min_size[1] || 1);\n\n        this.resize_initial_last_col = this.get_highest_occupied_cell().col;\n\n        this.set_dom_grid_width(this.cols);\n\n        this.resize_dir = {\n            right: ui.$player.is('.' + this.resize_handle_class + '-x'),\n            bottom: ui.$player.is('.' + this.resize_handle_class + '-y')\n        };\n\n        this.$resized_widget.css({\n            'min-width': this.options.widget_base_dimensions[0],\n            'min-height': this.options.widget_base_dimensions[1]\n        });\n\n        var nodeName = this.$resized_widget.get(0).tagName;\n        this.$resize_preview_holder = $('<' + nodeName + ' />', {\n              'class': 'preview-holder resize-preview-holder',\n              'data-row': this.$resized_widget.attr('data-row'),\n              'data-col': this.$resized_widget.attr('data-col'),\n              'css': {\n                  'width': this.resize_initial_width,\n                  'height': this.resize_initial_height\n              }\n        }).appendTo(this.$el);\n\n        this.$resized_widget.addClass('resizing');\n\n\t\tif (this.options.resize.start) {\n            this.options.resize.start.call(this, event, ui, this.$resized_widget);\n        }\n\n        this.$el.trigger('gridster:resizestart');\n    };\n\n\n    /**\n    * This function is executed every time a widget stops being resized.\n    *\n    * @method on_stop_resize\n    * @param {Event} event The original browser event\n    * @param {Object} ui A prepared ui object with useful drag-related data\n    */\n    fn.on_stop_resize = function(event, ui) {\n        this.$resized_widget\n            .removeClass('resizing')\n            .css({\n                'width': '',\n                'height': ''\n            });\n\n        delay($.proxy(function() {\n            this.$resize_preview_holder\n                .remove()\n                .css({\n                    'min-width': '',\n                    'min-height': ''\n                });\n\n            if (this.options.resize.stop) {\n                this.options.resize.stop.call(this, event, ui, this.$resized_widget);\n            }\n\n            this.$el.trigger('gridster:resizestop');\n        }, this), 300);\n\n        this.set_dom_grid_width();\n\n        if (this.options.autogrow_cols) {\n            this.drag_api.set_limits(this.cols * this.min_widget_width);\n        }\n    };\n\n\n    /**\n    * This function is executed when a widget is being resized.\n    *\n    * @method on_resize\n    * @param {Event} event The original browser event\n    * @param {Object} ui A prepared ui object with useful drag-related data\n    */\n    fn.on_resize = function(event, ui) {\n        var rel_x = (ui.pointer.diff_left);\n        var rel_y = (ui.pointer.diff_top);\n        var wbd_x = this.options.widget_base_dimensions[0];\n        var wbd_y = this.options.widget_base_dimensions[1];\n        var margin_x = this.options.widget_margins[0];\n        var margin_y = this.options.widget_margins[1];\n        var max_size_x = this.resize_max_size_x;\n        var min_size_x = this.resize_min_size_x;\n        var max_size_y = this.resize_max_size_y;\n        var min_size_y = this.resize_min_size_y;\n        var autogrow = this.options.autogrow_cols;\n        var width;\n        var max_width = Infinity;\n        var max_height = Infinity;\n\n        var inc_units_x = Math.ceil((rel_x / (wbd_x + margin_x * 2)) - 0.2);\n        var inc_units_y = Math.ceil((rel_y / (wbd_y + margin_y * 2)) - 0.2);\n\n        var size_x = Math.max(1, this.resize_initial_sizex + inc_units_x);\n        var size_y = Math.max(1, this.resize_initial_sizey + inc_units_y);\n\n        var max_cols = (this.container_width / this.min_widget_width) -\n            this.resize_initial_col + 1;\n        var limit_width = ((max_cols * this.min_widget_width) - margin_x * 2);\n\n        size_x = Math.max(Math.min(size_x, max_size_x), min_size_x);\n        size_x = Math.min(max_cols, size_x);\n        width = (max_size_x * wbd_x) + ((size_x - 1) * margin_x * 2);\n        max_width = Math.min(width, limit_width);\n        min_width = (min_size_x * wbd_x) + ((size_x - 1) * margin_x * 2);\n\n        size_y = Math.max(Math.min(size_y, max_size_y), min_size_y);\n        max_height = (max_size_y * wbd_y) + ((size_y - 1) * margin_y * 2);\n        min_height = (min_size_y * wbd_y) + ((size_y - 1) * margin_y * 2);\n\n        if (this.resize_dir.right) {\n            size_y = this.resize_initial_sizey;\n        } else if (this.resize_dir.bottom) {\n            size_x = this.resize_initial_sizex;\n        }\n\n        if (autogrow) {\n            var last_widget_col = this.resize_initial_col + size_x - 1;\n            if (autogrow && this.resize_initial_last_col <= last_widget_col) {\n                this.set_dom_grid_width(Math.max(last_widget_col + 1, this.cols));\n\n                if (this.cols < last_widget_col) {\n                    this.add_faux_cols(last_widget_col - this.cols);\n                }\n            }\n        }\n\n        var css_props = {};\n        !this.resize_dir.bottom && (css_props.width = Math.max(Math.min(\n            this.resize_initial_width + rel_x, max_width), min_width));\n        !this.resize_dir.right && (css_props.height = Math.max(Math.min(\n            this.resize_initial_height + rel_y, max_height), min_height));\n\n        this.$resized_widget.css(css_props);\n\n        if (size_x !== this.resize_last_sizex ||\n            size_y !== this.resize_last_sizey) {\n\n            this.resize_widget(this.$resized_widget, size_x, size_y);\n            this.set_dom_grid_width(this.cols);\n\n            this.$resize_preview_holder.css({\n                'width': '',\n                'height': ''\n            }).attr({\n                'data-row': this.$resized_widget.attr('data-row'),\n                'data-sizex': size_x,\n                'data-sizey': size_y\n            });\n        }\n\n        if (this.options.resize.resize) {\n            this.options.resize.resize.call(this, event, ui, this.$resized_widget);\n        }\n\n        this.$el.trigger('gridster:resize');\n\n        this.resize_last_sizex = size_x;\n        this.resize_last_sizey = size_y;\n    };\n\n\n    /**\n    * Executes the callbacks passed as arguments when a column begins to be\n    * overlapped or stops being overlapped.\n    *\n    * @param {Function} start_callback Function executed when a new column\n    *  begins to be overlapped. The column is passed as first argument.\n    * @param {Function} stop_callback Function executed when a column stops\n    *  being overlapped. The column is passed as first argument.\n    * @method on_overlapped_column_change\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.on_overlapped_column_change = function(start_callback, stop_callback) {\n        if (!this.colliders_data.length) {\n            return this;\n        }\n        var cols = this.get_targeted_columns(\n            this.colliders_data[0].el.data.col);\n\n        var last_n_cols = this.last_cols.length;\n        var n_cols = cols.length;\n        var i;\n\n        for (i = 0; i < n_cols; i++) {\n            if ($.inArray(cols[i], this.last_cols) === -1) {\n                (start_callback || $.noop).call(this, cols[i]);\n            }\n        }\n\n        for (i = 0; i< last_n_cols; i++) {\n            if ($.inArray(this.last_cols[i], cols) === -1) {\n                (stop_callback || $.noop).call(this, this.last_cols[i]);\n            }\n        }\n\n        this.last_cols = cols;\n\n        return this;\n    };\n\n\n    /**\n    * Executes the callbacks passed as arguments when a row starts to be\n    * overlapped or stops being overlapped.\n    *\n    * @param {Function} start_callback Function executed when a new row begins\n    *  to be overlapped. The row is passed as first argument.\n    * @param {Function} end_callback Function executed when a row stops being\n    *  overlapped. The row is passed as first argument.\n    * @method on_overlapped_row_change\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.on_overlapped_row_change = function(start_callback, end_callback) {\n        if (!this.colliders_data.length) {\n            return this;\n        }\n        var rows = this.get_targeted_rows(this.colliders_data[0].el.data.row);\n        var last_n_rows = this.last_rows.length;\n        var n_rows = rows.length;\n        var i;\n\n        for (i = 0; i < n_rows; i++) {\n            if ($.inArray(rows[i], this.last_rows) === -1) {\n                (start_callback || $.noop).call(this, rows[i]);\n            }\n        }\n\n        for (i = 0; i < last_n_rows; i++) {\n            if ($.inArray(this.last_rows[i], rows) === -1) {\n                (end_callback || $.noop).call(this, this.last_rows[i]);\n            }\n        }\n\n        this.last_rows = rows;\n    };\n\n\n    /**\n    * Sets the current position of the player\n    *\n    * @param {Number} col\n    * @param {Number} row\n    * @param {Boolean} no_player\n    * @method set_player\n    * @return {object}\n    */\n    fn.set_player = function(col, row, no_player) {\n        var self = this;\n        if (!no_player) {\n            this.empty_cells_player_occupies();\n        }\n        var cell = !no_player ? self.colliders_data[0].el.data : {col: col};\n        var to_col = cell.col;\n        var to_row = row || cell.row;\n\n        this.player_grid_data = {\n            col: to_col,\n            row: to_row,\n            size_y : this.player_grid_data.size_y,\n            size_x : this.player_grid_data.size_x\n        };\n\n        this.cells_occupied_by_player = this.get_cells_occupied(\n            this.player_grid_data);\n\n        var $overlapped_widgets = this.get_widgets_overlapped(\n            this.player_grid_data);\n\n        var constraints = this.widgets_constraints($overlapped_widgets);\n\n        this.manage_movements(constraints.can_go_up, to_col, to_row);\n        this.manage_movements(constraints.can_not_go_up, to_col, to_row);\n\n        /* if there is not widgets overlapping in the new player position,\n         * update the new placeholder position. */\n        if (!$overlapped_widgets.length) {\n            var pp = this.can_go_player_up(this.player_grid_data);\n            if (pp !== false) {\n                to_row = pp;\n            }\n            this.set_placeholder(to_col, to_row);\n        }\n\n        return {\n            col: to_col,\n            row: to_row\n        };\n    };\n\n\n    /**\n    * See which of the widgets in the $widgets param collection can go to\n    * a upper row and which not.\n    *\n    * @method widgets_contraints\n    * @param {jQuery} $widgets A jQuery wrapped collection of\n    * HTMLElements.\n    * @return {object} Returns a literal Object with two keys: `can_go_up` &\n    * `can_not_go_up`. Each contains a set of HTMLElements.\n    */\n    fn.widgets_constraints = function($widgets) {\n        var $widgets_can_go_up = $([]);\n        var $widgets_can_not_go_up;\n        var wgd_can_go_up = [];\n        var wgd_can_not_go_up = [];\n\n        $widgets.each($.proxy(function(i, w) {\n            var $w = $(w);\n            var wgd = $w.coords().grid;\n            if (this.can_go_widget_up(wgd)) {\n                $widgets_can_go_up = $widgets_can_go_up.add($w);\n                wgd_can_go_up.push(wgd);\n            } else {\n                wgd_can_not_go_up.push(wgd);\n            }\n        }, this));\n\n        $widgets_can_not_go_up = $widgets.not($widgets_can_go_up);\n\n        return {\n            can_go_up: Gridster.sort_by_row_asc(wgd_can_go_up),\n            can_not_go_up: Gridster.sort_by_row_desc(wgd_can_not_go_up)\n        };\n    };\n\n\n    /**\n    * Sorts an Array of grid coords objects (representing the grid coords of\n    * each widget) in descending way.\n    *\n    * @method manage_movements\n    * @param {jQuery} $widgets A jQuery collection of HTMLElements\n    *  representing the widgets you want to move.\n    * @param {Number} to_col The column to which we want to move the widgets.\n    * @param {Number} to_row The row to which we want to move the widgets.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.manage_movements = function($widgets, to_col, to_row) {\n        $.each($widgets, $.proxy(function(i, w) {\n            var wgd = w;\n            var $w = wgd.el;\n\n            var can_go_widget_up = this.can_go_widget_up(wgd);\n\n            if (can_go_widget_up) {\n                //target CAN go up\n                //so move widget up\n                this.move_widget_to($w, can_go_widget_up);\n                this.set_placeholder(to_col, can_go_widget_up + wgd.size_y);\n\n            } else {\n                //target can't go up\n                var can_go_player_up = this.can_go_player_up(\n                    this.player_grid_data);\n\n                if (!can_go_player_up) {\n                    // target can't go up\n                    // player cant't go up\n                    // so we need to move widget down to a position that dont\n                    // overlaps player\n                    var y = (to_row + this.player_grid_data.size_y) - wgd.row;\n\n                    this.move_widget_down($w, y);\n                    this.set_placeholder(to_col, to_row);\n                }\n            }\n        }, this));\n\n        return this;\n    };\n\n    /**\n    * Determines if there is a widget in the row and col given. Or if the\n    * HTMLElement passed as first argument is the player.\n    *\n    * @method is_player\n    * @param {Number|HTMLElement} col_or_el A jQuery wrapped collection of\n    * HTMLElements.\n    * @param {Number} [row] The column to which we want to move the widgets.\n    * @return {Boolean} Returns true or false.\n    */\n    fn.is_player = function(col_or_el, row) {\n        if (row && !this.gridmap[col_or_el]) { return false; }\n        var $w = row ? this.gridmap[col_or_el][row] : col_or_el;\n        return $w && ($w.is(this.$player) || $w.is(this.$helper));\n    };\n\n\n    /**\n    * Determines if the widget that is being dragged is currently over the row\n    * and col given.\n    *\n    * @method is_player_in\n    * @param {Number} col The column to check.\n    * @param {Number} row The row to check.\n    * @return {Boolean} Returns true or false.\n    */\n    fn.is_player_in = function(col, row) {\n        var c = this.cells_occupied_by_player || {};\n        return $.inArray(col, c.cols) >= 0 && $.inArray(row, c.rows) >= 0;\n    };\n\n\n    /**\n    * Determines if the placeholder is currently over the row and col given.\n    *\n    * @method is_placeholder_in\n    * @param {Number} col The column to check.\n    * @param {Number} row The row to check.\n    * @return {Boolean} Returns true or false.\n    */\n    fn.is_placeholder_in = function(col, row) {\n        var c = this.cells_occupied_by_placeholder || {};\n        return this.is_placeholder_in_col(col) && $.inArray(row, c.rows) >= 0;\n    };\n\n\n    /**\n    * Determines if the placeholder is currently over the column given.\n    *\n    * @method is_placeholder_in_col\n    * @param {Number} col The column to check.\n    * @return {Boolean} Returns true or false.\n    */\n    fn.is_placeholder_in_col = function(col) {\n        var c = this.cells_occupied_by_placeholder || [];\n        return $.inArray(col, c.cols) >= 0;\n    };\n\n\n    /**\n    * Determines if the cell represented by col and row params is empty.\n    *\n    * @method is_empty\n    * @param {Number} col The column to check.\n    * @param {Number} row The row to check.\n    * @return {Boolean} Returns true or false.\n    */\n    fn.is_empty = function(col, row) {\n        if (typeof this.gridmap[col] !== 'undefined') {\n\t\t\tif(typeof this.gridmap[col][row] !== 'undefined' &&\n\t\t\t\t this.gridmap[col][row] === false\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n    };\n\n\n    /**\n    * Determines if the cell represented by col and row params is occupied.\n    *\n    * @method is_occupied\n    * @param {Number} col The column to check.\n    * @param {Number} row The row to check.\n    * @return {Boolean} Returns true or false.\n    */\n    fn.is_occupied = function(col, row) {\n        if (!this.gridmap[col]) {\n            return false;\n        }\n\n        if (this.gridmap[col][row]) {\n            return true;\n        }\n        return false;\n    };\n\n\n    /**\n    * Determines if there is a widget in the cell represented by col/row params.\n    *\n    * @method is_widget\n    * @param {Number} col The column to check.\n    * @param {Number} row The row to check.\n    * @return {Boolean|HTMLElement} Returns false if there is no widget,\n    * else returns the jQuery HTMLElement\n    */\n    fn.is_widget = function(col, row) {\n        var cell = this.gridmap[col];\n        if (!cell) {\n            return false;\n        }\n\n        cell = cell[row];\n\n        if (cell) {\n            return cell;\n        }\n\n        return false;\n    };\n\n\n    /**\n    * Determines if there is a widget in the cell represented by col/row\n    * params and if this is under the widget that is being dragged.\n    *\n    * @method is_widget_under_player\n    * @param {Number} col The column to check.\n    * @param {Number} row The row to check.\n    * @return {Boolean} Returns true or false.\n    */\n    fn.is_widget_under_player = function(col, row) {\n        if (this.is_widget(col, row)) {\n            return this.is_player_in(col, row);\n        }\n        return false;\n    };\n\n\n    /**\n    * Get widgets overlapping with the player or with the object passed\n    * representing the grid cells.\n    *\n    * @method get_widgets_under_player\n    * @return {HTMLElement} Returns a jQuery collection of HTMLElements\n    */\n    fn.get_widgets_under_player = function(cells) {\n        cells || (cells = this.cells_occupied_by_player || {cols: [], rows: []});\n        var $widgets = $([]);\n\n        $.each(cells.cols, $.proxy(function(i, col) {\n            $.each(cells.rows, $.proxy(function(i, row) {\n                if(this.is_widget(col, row)) {\n                    $widgets = $widgets.add(this.gridmap[col][row]);\n                }\n            }, this));\n        }, this));\n\n        return $widgets;\n    };\n\n\n    /**\n    * Put placeholder at the row and column specified.\n    *\n    * @method set_placeholder\n    * @param {Number} col The column to which we want to move the\n    *  placeholder.\n    * @param {Number} row The row to which we want to move the\n    *  placeholder.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.set_placeholder = function(col, row) {\n        var phgd = $.extend({}, this.placeholder_grid_data);\n        var $nexts = this.widgets_below({\n                col: phgd.col,\n                row: phgd.row,\n                size_y: phgd.size_y,\n                size_x: phgd.size_x\n            });\n\n        // Prevents widgets go out of the grid\n        var right_col = (col + phgd.size_x - 1);\n        if (right_col > this.cols) {\n            col = col - (right_col - col);\n        }\n\n        var moved_down = this.placeholder_grid_data.row < row;\n        var changed_column = this.placeholder_grid_data.col !== col;\n\n        this.placeholder_grid_data.col = col;\n        this.placeholder_grid_data.row = row;\n\n        this.cells_occupied_by_placeholder = this.get_cells_occupied(\n            this.placeholder_grid_data);\n\n        this.$preview_holder.attr({\n            'data-row' : row,\n            'data-col' : col\n        });\n\n        if (moved_down || changed_column) {\n            $nexts.each($.proxy(function(i, widget) {\n                this.move_widget_up(\n                 $(widget), this.placeholder_grid_data.col - col + phgd.size_y);\n            }, this));\n        }\n\n        var $widgets_under_ph = this.get_widgets_under_player(\n            this.cells_occupied_by_placeholder);\n\n        if ($widgets_under_ph.length) {\n            $widgets_under_ph.each($.proxy(function(i, widget) {\n                var $w = $(widget);\n                this.move_widget_down(\n                 $w, row + phgd.size_y - $w.data('coords').grid.row);\n            }, this));\n        }\n\n    };\n\n\n    /**\n    * Determines whether the player can move to a position above.\n    *\n    * @method can_go_player_up\n    * @param {Object} widget_grid_data The actual grid coords object of the\n    *  player.\n    * @return {Number|Boolean} If the player can be moved to an upper row\n    *  returns the row number, else returns false.\n    */\n    fn.can_go_player_up = function(widget_grid_data) {\n        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;\n        var result = true;\n        var upper_rows = [];\n        var min_row = 10000;\n        var $widgets_under_player = this.get_widgets_under_player();\n\n        /* generate an array with columns as index and array with upper rows\n         * empty as value */\n        this.for_each_column_occupied(widget_grid_data, function(tcol) {\n            var grid_col = this.gridmap[tcol];\n            var r = p_bottom_row + 1;\n            upper_rows[tcol] = [];\n\n            while (--r > 0) {\n                if (this.is_empty(tcol, r) || this.is_player(tcol, r) ||\n                    this.is_widget(tcol, r) &&\n                    grid_col[r].is($widgets_under_player)\n                ) {\n                    upper_rows[tcol].push(r);\n                    min_row = r < min_row ? r : min_row;\n                } else {\n                    break;\n                }\n            }\n\n            if (upper_rows[tcol].length === 0) {\n                result = false;\n                return true; //break\n            }\n\n            upper_rows[tcol].sort(function(a, b) {\n                return a - b;\n            });\n        });\n\n        if (!result) { return false; }\n\n        return this.get_valid_rows(widget_grid_data, upper_rows, min_row);\n    };\n\n\n    /**\n    * Determines whether a widget can move to a position above.\n    *\n    * @method can_go_widget_up\n    * @param {Object} widget_grid_data The actual grid coords object of the\n    *  widget we want to check.\n    * @return {Number|Boolean} If the widget can be moved to an upper row\n    *  returns the row number, else returns false.\n    */\n    fn.can_go_widget_up = function(widget_grid_data) {\n        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;\n        var result = true;\n        var upper_rows = [];\n        var min_row = 10000;\n\n        /* generate an array with columns as index and array with topmost rows\n         * empty as value */\n        this.for_each_column_occupied(widget_grid_data, function(tcol) {\n            var grid_col = this.gridmap[tcol];\n            upper_rows[tcol] = [];\n\n            var r = p_bottom_row + 1;\n            // iterate over each row\n            while (--r > 0) {\n                if (this.is_widget(tcol, r) && !this.is_player_in(tcol, r)) {\n                    if (!grid_col[r].is(widget_grid_data.el)) {\n                        break;\n                    }\n                }\n\n                if (!this.is_player(tcol, r) &&\n                    !this.is_placeholder_in(tcol, r) &&\n                    !this.is_player_in(tcol, r)) {\n                    upper_rows[tcol].push(r);\n                }\n\n                if (r < min_row) {\n                    min_row = r;\n                }\n            }\n\n            if (upper_rows[tcol].length === 0) {\n                result = false;\n                return true; //break\n            }\n\n            upper_rows[tcol].sort(function(a, b) {\n                return a - b;\n            });\n        });\n\n        if (!result) { return false; }\n\n        return this.get_valid_rows(widget_grid_data, upper_rows, min_row);\n    };\n\n\n    /**\n    * Search a valid row for the widget represented by `widget_grid_data' in\n    * the `upper_rows` array. Iteration starts from row specified in `min_row`.\n    *\n    * @method get_valid_rows\n    * @param {Object} widget_grid_data The actual grid coords object of the\n    *  player.\n    * @param {Array} upper_rows An array with columns as index and arrays\n    *  of valid rows as values.\n    * @param {Number} min_row The upper row from which the iteration will start.\n    * @return {Number|Boolean} Returns the upper row valid from the `upper_rows`\n    *  for the widget in question.\n    */\n    fn.get_valid_rows = function(widget_grid_data, upper_rows, min_row) {\n        var p_top_row = widget_grid_data.row;\n        var p_bottom_row = widget_grid_data.row + widget_grid_data.size_y - 1;\n        var size_y = widget_grid_data.size_y;\n        var r = min_row - 1;\n        var valid_rows = [];\n\n        while (++r <= p_bottom_row ) {\n            var common = true;\n            $.each(upper_rows, function(col, rows) {\n                if ($.isArray(rows) && $.inArray(r, rows) === -1) {\n                    common = false;\n                }\n            });\n\n            if (common === true) {\n                valid_rows.push(r);\n                if (valid_rows.length === size_y) {\n                    break;\n                }\n            }\n        }\n\n        var new_row = false;\n        if (size_y === 1) {\n            if (valid_rows[0] !== p_top_row) {\n                new_row = valid_rows[0] || false;\n            }\n        } else {\n            if (valid_rows[0] !== p_top_row) {\n                new_row = this.get_consecutive_numbers_index(\n                    valid_rows, size_y);\n            }\n        }\n\n        return new_row;\n    };\n\n\n    fn.get_consecutive_numbers_index = function(arr, size_y) {\n        var max = arr.length;\n        var result = [];\n        var first = true;\n        var prev = -1; // or null?\n\n        for (var i=0; i < max; i++) {\n            if (first || arr[i] === prev + 1) {\n                result.push(i);\n                if (result.length === size_y) {\n                    break;\n                }\n                first = false;\n            } else {\n                result = [];\n                first = true;\n            }\n\n            prev = arr[i];\n        }\n\n        return result.length >= size_y ? arr[result[0]] : false;\n    };\n\n\n    /**\n    * Get widgets overlapping with the player.\n    *\n    * @method get_widgets_overlapped\n    * @return {jQuery} Returns a jQuery collection of HTMLElements.\n    */\n    fn.get_widgets_overlapped = function() {\n        var $w;\n        var $widgets = $([]);\n        var used = [];\n        var rows_from_bottom = this.cells_occupied_by_player.rows.slice(0);\n        rows_from_bottom.reverse();\n\n        $.each(this.cells_occupied_by_player.cols, $.proxy(function(i, col) {\n            $.each(rows_from_bottom, $.proxy(function(i, row) {\n                // if there is a widget in the player position\n                if (!this.gridmap[col]) { return true; } //next iteration\n                var $w = this.gridmap[col][row];\n                if (this.is_occupied(col, row) && !this.is_player($w) &&\n                    $.inArray($w, used) === -1\n                ) {\n                    $widgets = $widgets.add($w);\n                    used.push($w);\n                }\n\n            }, this));\n        }, this));\n\n        return $widgets;\n    };\n\n\n    /**\n    * This callback is executed when the player begins to collide with a column.\n    *\n    * @method on_start_overlapping_column\n    * @param {Number} col The collided column.\n    * @return {jQuery} Returns a jQuery collection of HTMLElements.\n    */\n    fn.on_start_overlapping_column = function(col) {\n        this.set_player(col, false);\n    };\n\n\n    /**\n    * A callback executed when the player begins to collide with a row.\n    *\n    * @method on_start_overlapping_row\n    * @param {Number} row The collided row.\n    * @return {jQuery} Returns a jQuery collection of HTMLElements.\n    */\n    fn.on_start_overlapping_row = function(row) {\n        this.set_player(false, row);\n    };\n\n\n    /**\n    * A callback executed when the the player ends to collide with a column.\n    *\n    * @method on_stop_overlapping_column\n    * @param {Number} col The collided row.\n    * @return {jQuery} Returns a jQuery collection of HTMLElements.\n    */\n    fn.on_stop_overlapping_column = function(col) {\n        this.set_player(col, false);\n\n        var self = this;\n        this.for_each_widget_below(col, this.cells_occupied_by_player.rows[0],\n            function(tcol, trow) {\n                self.move_widget_up(this, self.player_grid_data.size_y);\n        });\n    };\n\n\n    /**\n    * This callback is executed when the player ends to collide with a row.\n    *\n    * @method on_stop_overlapping_row\n    * @param {Number} row The collided row.\n    * @return {jQuery} Returns a jQuery collection of HTMLElements.\n    */\n    fn.on_stop_overlapping_row = function(row) {\n        this.set_player(false, row);\n\n        var self = this;\n        var cols = this.cells_occupied_by_player.cols;\n        for (var c = 0, cl = cols.length; c < cl; c++) {\n            this.for_each_widget_below(cols[c], row, function(tcol, trow) {\n                self.move_widget_up(this, self.player_grid_data.size_y);\n            });\n        }\n    };\n\n\n    /**\n    * Move a widget to a specific row. The cell or cells must be empty.\n    * If the widget has widgets below, all of these widgets will be moved also\n    * if they can.\n    *\n    * @method move_widget_to\n    * @param {HTMLElement} $widget The jQuery wrapped HTMLElement of the\n    * widget is going to be moved.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.move_widget_to = function($widget, row) {\n        var self = this;\n        var widget_grid_data = $widget.coords().grid;\n        var diff = row - widget_grid_data.row;\n        var $next_widgets = this.widgets_below($widget);\n\n        var can_move_to_new_cell = this.can_move_to(\n            widget_grid_data, widget_grid_data.col, row, $widget);\n\n        if (can_move_to_new_cell === false) {\n            return false;\n        }\n\n        this.remove_from_gridmap(widget_grid_data);\n        widget_grid_data.row = row;\n        this.add_to_gridmap(widget_grid_data);\n        $widget.attr('data-row', row);\n        this.$changed = this.$changed.add($widget);\n\n\n        $next_widgets.each(function(i, widget) {\n            var $w = $(widget);\n            var wgd = $w.coords().grid;\n            var can_go_up = self.can_go_widget_up(wgd);\n            if (can_go_up && can_go_up !== wgd.row) {\n                self.move_widget_to($w, can_go_up);\n            }\n        });\n\n        return this;\n    };\n\n\n    /**\n    * Move up the specified widget and all below it.\n    *\n    * @method move_widget_up\n    * @param {HTMLElement} $widget The widget you want to move.\n    * @param {Number} [y_units] The number of cells that the widget has to move.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.move_widget_up = function($widget, y_units) {\n        var el_grid_data = $widget.coords().grid;\n        var actual_row = el_grid_data.row;\n        var moved = [];\n        var can_go_up = true;\n        y_units || (y_units = 1);\n\n        if (!this.can_go_up($widget)) { return false; } //break;\n\n        this.for_each_column_occupied(el_grid_data, function(col) {\n            // can_go_up\n            if ($.inArray($widget, moved) === -1) {\n                var widget_grid_data = $widget.coords().grid;\n                var next_row = actual_row - y_units;\n                next_row = this.can_go_up_to_row(\n                    widget_grid_data, col, next_row);\n\n                if (!next_row) {\n                    return true;\n                }\n\n                var $next_widgets = this.widgets_below($widget);\n\n                this.remove_from_gridmap(widget_grid_data);\n                widget_grid_data.row = next_row;\n                this.add_to_gridmap(widget_grid_data);\n                $widget.attr('data-row', widget_grid_data.row);\n                this.$changed = this.$changed.add($widget);\n\n                moved.push($widget);\n\n                $next_widgets.each($.proxy(function(i, widget) {\n                    this.move_widget_up($(widget), y_units);\n                }, this));\n            }\n        });\n\n    };\n\n\n    /**\n    * Move down the specified widget and all below it.\n    *\n    * @method move_widget_down\n    * @param {jQuery} $widget The jQuery object representing the widget\n    *  you want to move.\n    * @param {Number} y_units The number of cells that the widget has to move.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.move_widget_down = function($widget, y_units) {\n        var el_grid_data, actual_row, moved, y_diff;\n\n        if (y_units <= 0) { return false; }\n\n        el_grid_data = $widget.coords().grid;\n        actual_row = el_grid_data.row;\n        moved = [];\n        y_diff = y_units;\n\n        if (!$widget) { return false; }\n\n        if ($.inArray($widget, moved) === -1) {\n\n            var widget_grid_data = $widget.coords().grid;\n            var next_row = actual_row + y_units;\n            var $next_widgets = this.widgets_below($widget);\n\n            this.remove_from_gridmap(widget_grid_data);\n\n            $next_widgets.each($.proxy(function(i, widget) {\n                var $w = $(widget);\n                var wd = $w.coords().grid;\n                var tmp_y = this.displacement_diff(\n                             wd, widget_grid_data, y_diff);\n\n                if (tmp_y > 0) {\n                    this.move_widget_down($w, tmp_y);\n                }\n            }, this));\n\n            widget_grid_data.row = next_row;\n            this.update_widget_position(widget_grid_data, $widget);\n            $widget.attr('data-row', widget_grid_data.row);\n            this.$changed = this.$changed.add($widget);\n\n            moved.push($widget);\n        }\n    };\n\n\n    /**\n    * Check if the widget can move to the specified row, else returns the\n    * upper row possible.\n    *\n    * @method can_go_up_to_row\n    * @param {Number} widget_grid_data The current grid coords object of the\n    *  widget.\n    * @param {Number} col The target column.\n    * @param {Number} row The target row.\n    * @return {Boolean|Number} Returns the row number if the widget can move\n    *  to the target position, else returns false.\n    */\n    fn.can_go_up_to_row = function(widget_grid_data, col, row) {\n        var ga = this.gridmap;\n        var result = true;\n        var urc = []; // upper_rows_in_columns\n        var actual_row = widget_grid_data.row;\n        var r;\n\n        /* generate an array with columns as index and array with\n         * upper rows empty in the column */\n        this.for_each_column_occupied(widget_grid_data, function(tcol) {\n            var grid_col = ga[tcol];\n            urc[tcol] = [];\n\n            r = actual_row;\n            while (r--) {\n                if (this.is_empty(tcol, r) &&\n                    !this.is_placeholder_in(tcol, r)\n                ) {\n                    urc[tcol].push(r);\n                } else {\n                    break;\n                }\n            }\n\n            if (!urc[tcol].length) {\n                result = false;\n                return true;\n            }\n\n        });\n\n        if (!result) { return false; }\n\n        /* get common rows starting from upper position in all the columns\n         * that widget occupies */\n        r = row;\n        for (r = 1; r < actual_row; r++) {\n            var common = true;\n\n            for (var uc = 0, ucl = urc.length; uc < ucl; uc++) {\n                if (urc[uc] && $.inArray(r, urc[uc]) === -1) {\n                    common = false;\n                }\n            }\n\n            if (common === true) {\n                result = r;\n                break;\n            }\n        }\n\n        return result;\n    };\n\n\n    fn.displacement_diff = function(widget_grid_data, parent_bgd, y_units) {\n        var actual_row = widget_grid_data.row;\n        var diffs = [];\n        var parent_max_y = parent_bgd.row + parent_bgd.size_y;\n\n        this.for_each_column_occupied(widget_grid_data, function(col) {\n            var temp_y_units = 0;\n\n            for (var r = parent_max_y; r < actual_row; r++) {\n                if (this.is_empty(col, r)) {\n                    temp_y_units = temp_y_units + 1;\n                }\n            }\n\n            diffs.push(temp_y_units);\n        });\n\n        var max_diff = Math.max.apply(Math, diffs);\n        y_units = (y_units - max_diff);\n\n        return y_units > 0 ? y_units : 0;\n    };\n\n\n    /**\n    * Get widgets below a widget.\n    *\n    * @method widgets_below\n    * @param {HTMLElement} $el The jQuery wrapped HTMLElement.\n    * @return {jQuery} A jQuery collection of HTMLElements.\n    */\n    fn.widgets_below = function($el) {\n        var el_grid_data = $.isPlainObject($el) ? $el : $el.coords().grid;\n        var self = this;\n        var ga = this.gridmap;\n        var next_row = el_grid_data.row + el_grid_data.size_y - 1;\n        var $nexts = $([]);\n\n        this.for_each_column_occupied(el_grid_data, function(col) {\n            self.for_each_widget_below(col, next_row, function(tcol, trow) {\n                if (!self.is_player(this) && $.inArray(this, $nexts) === -1) {\n                    $nexts = $nexts.add(this);\n                    return true; // break\n                }\n            });\n        });\n\n        return Gridster.sort_by_row_asc($nexts);\n    };\n\n\n    /**\n    * Update the array of mapped positions with the new player position.\n    *\n    * @method set_cells_player_occupies\n    * @param {Number} col The new player col.\n    * @param {Number} col The new player row.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.set_cells_player_occupies = function(col, row) {\n        this.remove_from_gridmap(this.placeholder_grid_data);\n        this.placeholder_grid_data.col = col;\n        this.placeholder_grid_data.row = row;\n        this.add_to_gridmap(this.placeholder_grid_data, this.$player);\n        return this;\n    };\n\n\n    /**\n    * Remove from the array of mapped positions the reference to the player.\n    *\n    * @method empty_cells_player_occupies\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.empty_cells_player_occupies = function() {\n        this.remove_from_gridmap(this.placeholder_grid_data);\n        return this;\n    };\n\n\n    fn.can_go_up = function($el) {\n        var el_grid_data = $el.coords().grid;\n        var initial_row = el_grid_data.row;\n        var prev_row = initial_row - 1;\n        var ga = this.gridmap;\n        var upper_rows_by_column = [];\n\n        var result = true;\n        if (initial_row === 1) { return false; }\n\n        this.for_each_column_occupied(el_grid_data, function(col) {\n            var $w = this.is_widget(col, prev_row);\n\n            if (this.is_occupied(col, prev_row) ||\n                this.is_player(col, prev_row) ||\n                this.is_placeholder_in(col, prev_row) ||\n                this.is_player_in(col, prev_row)\n            ) {\n                result = false;\n                return true; //break\n            }\n        });\n\n        return result;\n    };\n\n\n    /**\n    * Check if it's possible to move a widget to a specific col/row. It takes\n    * into account the dimensions (`size_y` and `size_x` attrs. of the grid\n    *  coords object) the widget occupies.\n    *\n    * @method can_move_to\n    * @param {Object} widget_grid_data The grid coords object that represents\n    *  the widget.\n    * @param {Object} col The col to check.\n    * @param {Object} row The row to check.\n    * @param {Number} [max_row] The max row allowed.\n    * @return {Boolean} Returns true if all cells are empty, else return false.\n    */\n    fn.can_move_to = function(widget_grid_data, col, row, max_row) {\n        var ga = this.gridmap;\n        var $w = widget_grid_data.el;\n        var future_wd = {\n            size_y: widget_grid_data.size_y,\n            size_x: widget_grid_data.size_x,\n            col: col,\n            row: row\n        };\n        var result = true;\n\n        //Prevents widgets go out of the grid\n        var right_col = col + widget_grid_data.size_x - 1;\n        if (right_col > this.cols) {\n            return false;\n        }\n\n        if (max_row && max_row < row + widget_grid_data.size_y - 1) {\n            return false;\n        }\n\n        this.for_each_cell_occupied(future_wd, function(tcol, trow) {\n            var $tw = this.is_widget(tcol, trow);\n            if ($tw && (!widget_grid_data.el || $tw.is($w))) {\n                result = false;\n            }\n        });\n\n        return result;\n    };\n\n\n    /**\n    * Given the leftmost column returns all columns that are overlapping\n    *  with the player.\n    *\n    * @method get_targeted_columns\n    * @param {Number} [from_col] The leftmost column.\n    * @return {Array} Returns an array with column numbers.\n    */\n    fn.get_targeted_columns = function(from_col) {\n        var max = (from_col || this.player_grid_data.col) +\n            (this.player_grid_data.size_x - 1);\n        var cols = [];\n        for (var col = from_col; col <= max; col++) {\n            cols.push(col);\n        }\n        return cols;\n    };\n\n\n    /**\n    * Given the upper row returns all rows that are overlapping with the player.\n    *\n    * @method get_targeted_rows\n    * @param {Number} [from_row] The upper row.\n    * @return {Array} Returns an array with row numbers.\n    */\n    fn.get_targeted_rows = function(from_row) {\n        var max = (from_row || this.player_grid_data.row) +\n            (this.player_grid_data.size_y - 1);\n        var rows = [];\n        for (var row = from_row; row <= max; row++) {\n            rows.push(row);\n        }\n        return rows;\n    };\n\n    /**\n    * Get all columns and rows that a widget occupies.\n    *\n    * @method get_cells_occupied\n    * @param {Object} el_grid_data The grid coords object of the widget.\n    * @return {Object} Returns an object like `{ cols: [], rows: []}`.\n    */\n    fn.get_cells_occupied = function(el_grid_data) {\n        var cells = { cols: [], rows: []};\n        var i;\n        if (arguments[1] instanceof $) {\n            el_grid_data = arguments[1].coords().grid;\n        }\n\n        for (i = 0; i < el_grid_data.size_x; i++) {\n            var col = el_grid_data.col + i;\n            cells.cols.push(col);\n        }\n\n        for (i = 0; i < el_grid_data.size_y; i++) {\n            var row = el_grid_data.row + i;\n            cells.rows.push(row);\n        }\n\n        return cells;\n    };\n\n\n    /**\n    * Iterate over the cells occupied by a widget executing a function for\n    * each one.\n    *\n    * @method for_each_cell_occupied\n    * @param {Object} el_grid_data The grid coords object that represents the\n    *  widget.\n    * @param {Function} callback The function to execute on each column\n    *  iteration. Column and row are passed as arguments.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.for_each_cell_occupied = function(grid_data, callback) {\n        this.for_each_column_occupied(grid_data, function(col) {\n            this.for_each_row_occupied(grid_data, function(row) {\n                callback.call(this, col, row);\n            });\n        });\n        return this;\n    };\n\n\n    /**\n    * Iterate over the columns occupied by a widget executing a function for\n    * each one.\n    *\n    * @method for_each_column_occupied\n    * @param {Object} el_grid_data The grid coords object that represents\n    *  the widget.\n    * @param {Function} callback The function to execute on each column\n    *  iteration. The column number is passed as first argument.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.for_each_column_occupied = function(el_grid_data, callback) {\n        for (var i = 0; i < el_grid_data.size_x; i++) {\n            var col = el_grid_data.col + i;\n            callback.call(this, col, el_grid_data);\n        }\n    };\n\n\n    /**\n    * Iterate over the rows occupied by a widget executing a function for\n    * each one.\n    *\n    * @method for_each_row_occupied\n    * @param {Object} el_grid_data The grid coords object that represents\n    *  the widget.\n    * @param {Function} callback The function to execute on each column\n    *  iteration. The row number is passed as first argument.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.for_each_row_occupied = function(el_grid_data, callback) {\n        for (var i = 0; i < el_grid_data.size_y; i++) {\n            var row = el_grid_data.row + i;\n            callback.call(this, row, el_grid_data);\n        }\n    };\n\n\n\n    fn._traversing_widgets = function(type, direction, col, row, callback) {\n        var ga = this.gridmap;\n        if (!ga[col]) { return; }\n\n        var cr, max;\n        var action = type + '/' + direction;\n        if (arguments[2] instanceof $) {\n            var el_grid_data = arguments[2].coords().grid;\n            col = el_grid_data.col;\n            row = el_grid_data.row;\n            callback = arguments[3];\n        }\n        var matched = [];\n        var trow = row;\n\n\n        var methods = {\n            'for_each/above': function() {\n                while (trow--) {\n                    if (trow > 0 && this.is_widget(col, trow) &&\n                        $.inArray(ga[col][trow], matched) === -1\n                    ) {\n                        cr = callback.call(ga[col][trow], col, trow);\n                        matched.push(ga[col][trow]);\n                        if (cr) { break; }\n                    }\n                }\n            },\n            'for_each/below': function() {\n                for (trow = row + 1, max = ga[col].length; trow < max; trow++) {\n                    if (this.is_widget(col, trow) &&\n                        $.inArray(ga[col][trow], matched) === -1\n                    ) {\n                        cr = callback.call(ga[col][trow], col, trow);\n                        matched.push(ga[col][trow]);\n                        if (cr) { break; }\n                    }\n                }\n            }\n        };\n\n        if (methods[action]) {\n            methods[action].call(this);\n        }\n    };\n\n\n    /**\n    * Iterate over each widget above the column and row specified.\n    *\n    * @method for_each_widget_above\n    * @param {Number} col The column to start iterating.\n    * @param {Number} row The row to start iterating.\n    * @param {Function} callback The function to execute on each widget\n    *  iteration. The value of `this` inside the function is the jQuery\n    *  wrapped HTMLElement.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.for_each_widget_above = function(col, row, callback) {\n        this._traversing_widgets('for_each', 'above', col, row, callback);\n        return this;\n    };\n\n\n    /**\n    * Iterate over each widget below the column and row specified.\n    *\n    * @method for_each_widget_below\n    * @param {Number} col The column to start iterating.\n    * @param {Number} row The row to start iterating.\n    * @param {Function} callback The function to execute on each widget\n    *  iteration. The value of `this` inside the function is the jQuery wrapped\n    *  HTMLElement.\n    * @return {Class} Returns the instance of the Gridster Class.\n    */\n    fn.for_each_widget_below = function(col, row, callback) {\n        this._traversing_widgets('for_each', 'below', col, row, callback);\n        return this;\n    };\n\n\n    /**\n    * Returns the highest occupied cell in the grid.\n    *\n    * @method get_highest_occupied_cell\n    * @return {Object} Returns an object with `col` and `row` numbers.\n    */\n    fn.get_highest_occupied_cell = function() {\n        var r;\n        var gm = this.gridmap;\n        var rl = gm[1].length;\n        var rows = [], cols = [];\n        var row_in_col = [];\n        for (var c = gm.length - 1; c >= 1; c--) {\n            for (r = rl - 1; r >= 1; r--) {\n                if (this.is_widget(c, r)) {\n                    rows.push(r);\n                    cols.push(c);\n                    break;\n                }\n            }\n        }\n\n        return {\n            col: Math.max.apply(Math, cols),\n            row: Math.max.apply(Math, rows)\n        };\n    };\n\n\n    fn.get_widgets_from = function(col, row) {\n        var ga = this.gridmap;\n        var $widgets = $();\n\n        if (col) {\n            $widgets = $widgets.add(\n                this.$widgets.filter(function() {\n                    var tcol = $(this).attr('data-col');\n                    return (tcol === col || tcol > col);\n                })\n            );\n        }\n\n        if (row) {\n            $widgets = $widgets.add(\n                this.$widgets.filter(function() {\n                    var trow = $(this).attr('data-row');\n                    return (trow === row || trow > row);\n                })\n            );\n        }\n\n        return $widgets;\n    };\n\n\n    /**\n    * Set the current height of the parent grid.\n    *\n    * @method set_dom_grid_height\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.set_dom_grid_height = function(height) {\n        if (typeof height === 'undefined') {\n            var r = this.get_highest_occupied_cell().row;\n            height = r * this.min_widget_height;\n        }\n\n        this.container_height = height;\n        this.$el.css('height', this.container_height);\n        return this;\n    };\n\n    /**\n    * Set the current width of the parent grid.\n    *\n    * @method set_dom_grid_width\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.set_dom_grid_width = function(cols) {\n        if (typeof cols === 'undefined') {\n            cols = this.get_highest_occupied_cell().col;\n        }\n\n        var max_cols = (this.options.autogrow_cols ? this.options.max_cols :\n            this.cols);\n\n        cols = Math.min(max_cols, Math.max(cols, this.options.min_cols));\n        this.container_width = cols * this.min_widget_width;\n        this.$el.css('width', this.container_width);\n        return this;\n    };\n\n\n    /**\n    * It generates the neccessary styles to position the widgets.\n    *\n    * @method generate_stylesheet\n    * @param {Number} rows Number of columns.\n    * @param {Number} cols Number of rows.\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.generate_stylesheet = function(opts) {\n        var styles = '';\n        var max_size_x = this.options.max_size_x || this.cols;\n        var max_rows = 0;\n        var max_cols = 0;\n        var i;\n        var rules;\n\n        opts || (opts = {});\n        opts.cols || (opts.cols = this.cols);\n        opts.rows || (opts.rows = this.rows);\n        opts.namespace || (opts.namespace = this.options.namespace);\n        opts.widget_base_dimensions ||\n            (opts.widget_base_dimensions = this.options.widget_base_dimensions);\n        opts.widget_margins ||\n            (opts.widget_margins = this.options.widget_margins);\n        opts.min_widget_width = (opts.widget_margins[0] * 2) +\n            opts.widget_base_dimensions[0];\n        opts.min_widget_height = (opts.widget_margins[1] * 2) +\n            opts.widget_base_dimensions[1];\n\n        // don't duplicate stylesheets for the same configuration\n        var serialized_opts = $.param(opts);\n        if ($.inArray(serialized_opts, Gridster.generated_stylesheets) >= 0) {\n            return false;\n        }\n\n        this.generated_stylesheets.push(serialized_opts);\n        Gridster.generated_stylesheets.push(serialized_opts);\n\n        /* generate CSS styles for cols */\n        for (i = opts.cols; i >= 0; i--) {\n            styles += (opts.namespace + ' [data-col=\"'+ (i + 1) + '\"] { left:' +\n                ((i * opts.widget_base_dimensions[0]) +\n                (i * opts.widget_margins[0]) +\n                ((i + 1) * opts.widget_margins[0])) + 'px; }\\n');\n        }\n\n        /* generate CSS styles for rows */\n        for (i = opts.rows; i >= 0; i--) {\n            styles += (opts.namespace + ' [data-row=\"' + (i + 1) + '\"] { top:' +\n                ((i * opts.widget_base_dimensions[1]) +\n                (i * opts.widget_margins[1]) +\n                ((i + 1) * opts.widget_margins[1]) ) + 'px; }\\n');\n        }\n\n        for (var y = 1; y <= opts.rows; y++) {\n            styles += (opts.namespace + ' [data-sizey=\"' + y + '\"] { height:' +\n                (y * opts.widget_base_dimensions[1] +\n                (y - 1) * (opts.widget_margins[1] * 2)) + 'px; }\\n');\n        }\n\n        for (var x = 1; x <= max_size_x; x++) {\n            styles += (opts.namespace + ' [data-sizex=\"' + x + '\"] { width:' +\n                (x * opts.widget_base_dimensions[0] +\n                (x - 1) * (opts.widget_margins[0] * 2)) + 'px; }\\n');\n        }\n\n        this.remove_style_tags();\n\n        return this.add_style_tag(styles);\n    };\n\n\n    /**\n    * Injects the given CSS as string to the head of the document.\n    *\n    * @method add_style_tag\n    * @param {String} css The styles to apply.\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.add_style_tag = function(css) {\n        var d = document;\n        var tag = d.createElement('style');\n\n        d.getElementsByTagName('head')[0].appendChild(tag);\n        tag.setAttribute('type', 'text/css');\n\n        if (tag.styleSheet) {\n            tag.styleSheet.cssText = css;\n        } else {\n            tag.appendChild(document.createTextNode(css));\n        }\n\n        this.$style_tags = this.$style_tags.add(tag);\n\n        return this;\n    };\n\n\n    /**\n    * Remove the style tag with the associated id from the head of the document\n    *\n    * @method  remove_style_tag\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.remove_style_tags = function() {\n        var all_styles = Gridster.generated_stylesheets;\n        var ins_styles = this.generated_stylesheets;\n\n        this.$style_tags.remove();\n\n        Gridster.generated_stylesheets = $.map(all_styles, function(s) {\n            if ($.inArray(s, ins_styles) === -1) { return s; }\n        });\n    };\n\n\n    /**\n    * Generates a faux grid to collide with it when a widget is dragged and\n    * detect row or column that we want to go.\n    *\n    * @method generate_faux_grid\n    * @param {Number} rows Number of columns.\n    * @param {Number} cols Number of rows.\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.generate_faux_grid = function(rows, cols) {\n        this.faux_grid = [];\n        this.gridmap = [];\n        var col;\n        var row;\n        for (col = cols; col > 0; col--) {\n            this.gridmap[col] = [];\n            for (row = rows; row > 0; row--) {\n                this.add_faux_cell(row, col);\n            }\n        }\n        return this;\n    };\n\n\n    /**\n    * Add cell to the faux grid.\n    *\n    * @method add_faux_cell\n    * @param {Number} row The row for the new faux cell.\n    * @param {Number} col The col for the new faux cell.\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.add_faux_cell = function(row, col) {\n        var coords = $({\n                        left: this.baseX + ((col - 1) * this.min_widget_width),\n                        top: this.baseY + (row -1) * this.min_widget_height,\n                        width: this.min_widget_width,\n                        height: this.min_widget_height,\n                        col: col,\n                        row: row,\n                        original_col: col,\n                        original_row: row\n                    }).coords();\n\n        if (!$.isArray(this.gridmap[col])) {\n            this.gridmap[col] = [];\n        }\n\n        this.gridmap[col][row] = false;\n        this.faux_grid.push(coords);\n\n        return this;\n    };\n\n\n    /**\n    * Add rows to the faux grid.\n    *\n    * @method add_faux_rows\n    * @param {Number} rows The number of rows you want to add to the faux grid.\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.add_faux_rows = function(rows) {\n        var actual_rows = this.rows;\n        var max_rows = actual_rows + (rows || 1);\n\n        for (var r = max_rows; r > actual_rows; r--) {\n            for (var c = this.cols; c >= 1; c--) {\n                this.add_faux_cell(r, c);\n            }\n        }\n\n        this.rows = max_rows;\n\n        if (this.options.autogenerate_stylesheet) {\n            this.generate_stylesheet();\n        }\n\n        return this;\n    };\n\n     /**\n    * Add cols to the faux grid.\n    *\n    * @method add_faux_cols\n    * @param {Number} cols The number of cols you want to add to the faux grid.\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.add_faux_cols = function(cols) {\n        var actual_cols = this.cols;\n        var max_cols = actual_cols + (cols || 1);\n        max_cols = Math.min(max_cols, this.options.max_cols);\n\n        for (var c = actual_cols + 1; c <= max_cols; c++) {\n            for (var r = this.rows; r >= 1; r--) {\n                this.add_faux_cell(r, c);\n            }\n        }\n\n        this.cols = max_cols;\n\n        if (this.options.autogenerate_stylesheet) {\n            this.generate_stylesheet();\n        }\n\n        return this;\n    };\n\n\n    /**\n    * Recalculates the offsets for the faux grid. You need to use it when\n    * the browser is resized.\n    *\n    * @method recalculate_faux_grid\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.recalculate_faux_grid = function() {\n        var aw = this.$wrapper.width();\n        this.baseX = ($(window).width() - aw) / 2;\n        this.baseY = this.$wrapper.offset().top;\n\n        $.each(this.faux_grid, $.proxy(function(i, coords) {\n            this.faux_grid[i] = coords.update({\n                left: this.baseX + (coords.data.col -1) * this.min_widget_width,\n                top: this.baseY + (coords.data.row -1) * this.min_widget_height\n            });\n        }, this));\n\n        return this;\n    };\n\n\n    /**\n    * Get all widgets in the DOM and register them.\n    *\n    * @method get_widgets_from_DOM\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.get_widgets_from_DOM = function() {\n        var widgets_coords = this.$widgets.map($.proxy(function(i, widget) {\n            var $w = $(widget);\n            return this.dom_to_coords($w);\n        }, this));\n\n        widgets_coords = Gridster.sort_by_row_and_col_asc(widgets_coords);\n\n        var changes = $(widgets_coords).map($.proxy(function(i, wgd) {\n            return this.register_widget(wgd) || null;\n        }, this));\n\n        if (changes.length) {\n            this.$el.trigger('gridster:positionschanged');\n        }\n\n        return this;\n    };\n\n\n    /**\n    * Calculate columns and rows to be set based on the configuration\n    *  parameters, grid dimensions, etc ...\n    *\n    * @method generate_grid_and_stylesheet\n    * @return {Object} Returns the instance of the Gridster class.\n    */\n    fn.generate_grid_and_stylesheet = function() {\n        var aw = this.$wrapper.width();\n        var max_cols = this.options.max_cols;\n\n        var cols = Math.floor(aw / this.min_widget_width) +\n                   this.options.extra_cols;\n\n        var actual_cols = this.$widgets.map(function() {\n            return $(this).attr('data-col');\n        }).get();\n\n        //needed to pass tests with phantomjs\n        actual_cols.length || (actual_cols = [0]);\n\n        var min_cols = Math.max.apply(Math, actual_cols);\n\n        this.cols = Math.max(min_cols, cols, this.options.min_cols);\n\n        if (max_cols !== Infinity && max_cols >= min_cols && max_cols < this.cols) {\n            this.cols = max_cols;\n        }\n\n        // get all rows that could be occupied by the current widgets\n        var max_rows = this.options.extra_rows;\n        this.$widgets.each(function(i, w) {\n            max_rows += (+$(w).attr('data-sizey'));\n        });\n\n        this.rows = Math.max(max_rows, this.options.min_rows);\n\n        this.baseX = ($(window).width() - aw) / 2;\n        this.baseY = this.$wrapper.offset().top;\n\n        if (this.options.autogenerate_stylesheet) {\n            this.generate_stylesheet();\n        }\n\n        return this.generate_faux_grid(this.rows, this.cols);\n    };\n\n    /**\n     * Destroy this gridster by removing any sign of its presence, making it easy to avoid memory leaks\n     *\n     * @method destroy\n     * @param {Boolean} remove If true, remove gridster from DOM.\n     * @return {Object} Returns the instance of the Gridster class.\n     */\n    fn.destroy = function(remove) {\n        this.$el.removeData('gridster');\n\n        // remove bound callback on window resize\n        $(window).unbind('.gridster');\n\n        if (this.drag_api) {\n            this.drag_api.destroy();\n        }\n\n        this.remove_style_tags();\n\n        remove && this.$el.remove();\n\n        return this;\n    };\n\n\n    //jQuery adapter\n    $.fn.gridster = function(options) {\n        return this.each(function() {\n            if (! $(this).data('gridster')) {\n                $(this).data('gridster', new Gridster( this, options ));\n            }\n        });\n    };\n\n    return Gridster;\n\n}));\n"

/***/ },
/* 727 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);
	__webpack_require__(206);
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(728);
	__webpack_require__(670);
	__webpack_require__(330);
	__webpack_require__(474);
	__webpack_require__(449);
	__webpack_require__(650);
	__webpack_require__(731);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var moment = __webpack_require__(226);
	  var $ = __webpack_require__(206);
	  __webpack_require__(214).get('app/dashboard').directive('dashboardPanel', function (savedVisualizations, savedSearches, Notifier, Private, $injector) {
	    var _ = __webpack_require__(192);
	    var loadPanel = Private(__webpack_require__(728));
	    var filterManager = Private(__webpack_require__(670));
	    var notify = new Notifier();

	    var services = __webpack_require__(330).all().map(function (serviceObj) {
	      var service = $injector.get(serviceObj.service);
	      return {
	        type: service.type,
	        name: serviceObj.service
	      };
	    });

	    __webpack_require__(474);
	    __webpack_require__(449);

	    var brushEvent = Private(__webpack_require__(650));

	    return {
	      restrict: 'E',
	      template: __webpack_require__(731),
	      requires: '^dashboardGrid',
	      link: function link($scope, $el) {
	        // using $scope inheritance, panels are available in AppState
	        var $state = $scope.state;

	        // receives $scope.panel from the dashboard grid directive, seems like should be isolate?
	        $scope.$watch('id', function () {
	          if (!$scope.panel.id || !$scope.panel.type) return;

	          loadPanel($scope.panel, $scope).then(function (panelConfig) {
	            // These could be done in loadPanel, putting them here to make them more explicit
	            $scope.savedObj = panelConfig.savedObj;
	            $scope.editUrl = panelConfig.editUrl;
	            $scope.$on('$destroy', panelConfig.savedObj.destroy);

	            $scope.filter = function (field, value, operator) {
	              var index = $scope.savedObj.searchSource.get('index').id;
	              filterManager.add(field, value, operator, index);
	            };
	          })['catch'](function (e) {
	            $scope.error = e.message;

	            // If the savedObjectType matches the panel type, this means the object itself has been deleted,
	            // so we shouldn't even have an edit link. If they don't match, it means something else is wrong
	            // with the object (but the object still exists), so we link to the object editor instead.
	            var objectItselfDeleted = e.savedObjectType === $scope.panel.type;
	            if (objectItselfDeleted) return;

	            var type = $scope.panel.type;
	            var id = $scope.panel.id;
	            var service = _.find(services, { type: type });
	            if (!service) return;

	            $scope.editUrl = '#settings/objects/' + service.name + '/' + id + '?notFound=' + e.savedObjectType;
	          });
	        });

	        $scope.remove = function () {
	          _.pull($state.panels, $scope.panel);
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 728 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(729);
	__webpack_require__(730);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function loadPanelFunction(Private) {
	    // Inject services here
	    return function (panel, $scope) {
	      // Function parameters here
	      var panelTypes = {
	        visualization: Private(__webpack_require__(729)),
	        search: Private(__webpack_require__(730))
	      };

	      try {
	        return panelTypes[panel.type](panel, $scope);
	      } catch (e) {
	        throw new Error('Loader not found for unknown panel type: ' + panel.type);
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 729 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(650);
	__webpack_require__(700);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function visualizationLoader(savedVisualizations, Private) {
	    // Inject services here
	    var brushEvent = Private(__webpack_require__(650));
	    var filterBarClickHandler = Private(__webpack_require__(700));

	    return function (panel, $scope) {
	      // Function parameters here
	      return savedVisualizations.get(panel.id).then(function (savedVis) {
	        // $scope.state comes via $scope inheritence from the dashboard app. Don't love this.
	        savedVis.vis.listeners.click = filterBarClickHandler($scope.state);
	        savedVis.vis.listeners.brush = brushEvent;

	        return {
	          savedObj: savedVis,
	          panel: panel,
	          editUrl: savedVisualizations.urlFor(panel.id)
	        };
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 730 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function searchLoader(savedSearches, Private) {
	    // Inject services here
	    return function (panel, $scope) {
	      // Function parameters here
	      return savedSearches.get(panel.id).then(function (savedSearch) {
	        panel.columns = panel.columns || savedSearch.columns;
	        panel.sort = panel.sort || savedSearch.sort;

	        $scope.$watchCollection('panel.columns', function () {
	          $scope.state.save();
	        });

	        $scope.$watchCollection('panel.sort', function () {
	          $scope.state.save();
	        });

	        return {
	          savedObj: savedSearch,
	          panel: panel,
	          editUrl: savedSearches.urlFor(panel.id)
	        };
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 731 */
/***/ function(module, exports) {

	module.exports = "<div class=\"panel panel-default\" ng-switch on=\"panel.type\" ng-if=\"savedObj || error\">\n  <div class=\"panel-heading\">\n    <span class=\"panel-title\">\n      <i\n        class=\"fa\"\n        ng-class=\"savedObj.vis.type.icon\"\n        aria-label=\"{{savedObj.vis.type.title}} Icon\"\n        title=\"{{savedObj.vis.type.title}}\">\n      </i>\n      {{savedObj.title}}\n    </span>\n    <div class=\"btn-group\">\n      <a aria-label=\"Edit\" ng-show=\"chrome.getVisible() && editUrl\" ng-href=\"{{editUrl}}\">\n        <i aria-hidden=\"true\" class=\"fa fa-pencil\"></i>\n      </a>\n      <a aria-label=\"Remove\" ng-show=\"chrome.getVisible()\" ng-click=\"remove()\">\n        <i aria-hidden=\"true\" class=\"fa fa-times\"></i>\n      </a>\n    </div>\n    <div class=\"clearfix\"></div>\n  </div>\n\n  <div ng-if=\"error\" class=\"load-error\">\n    <i aria-hidden=\"true\" class=\"fa fa-exclamation-triangle\"></i>\n    <span ng-bind=\"error\"></span>\n  </div>\n\n  <visualize ng-switch-when=\"visualization\"\n    vis=\"savedObj.vis\"\n    search-source=\"savedObj.searchSource\"\n    class=\"panel-content\">\n  </visualize>\n\n  <doc-table ng-switch-when=\"search\"\n    search-source=\"savedObj.searchSource\"\n    sorting=\"panel.sort\"\n    columns=\"panel.columns\"\n    class=\"panel-content\"\n    filter=\"filter\">\n  </doc-table>\n</div>\n"

/***/ },
/* 732 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(733);
	__webpack_require__(330);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('app/dashboard');
	  var _ = __webpack_require__(192);
	  // bring in the factory
	  __webpack_require__(733);

	  // Register this service with the saved object registry so it can be
	  // edited by the object editor.
	  __webpack_require__(330).register({
	    service: 'savedDashboards',
	    title: 'dashboards'
	  });

	  // This is the only thing that gets injected into controllers
	  module.service('savedDashboards', function (Promise, SavedDashboard, kbnIndex, es, kbnUrl) {
	    this.type = SavedDashboard.type;
	    this.Class = SavedDashboard;

	    this.loaderProperties = {
	      name: 'dashboards',
	      noun: 'Dashboard',
	      nouns: 'dashboards'
	    };

	    // Returns a single dashboard by ID, should be the name of the dashboard
	    this.get = function (id) {

	      // Returns a promise that contains a dashboard which is a subclass of docSource
	      return new SavedDashboard(id).init();
	    };

	    this.urlFor = function (id) {
	      return kbnUrl.eval('#/dashboard/{{id}}', { id: id });
	    };

	    this['delete'] = function (ids) {
	      ids = !_.isArray(ids) ? [ids] : ids;
	      return Promise.map(ids, function (id) {
	        return new SavedDashboard(id)['delete']();
	      });
	    };

	    this.find = function (searchString) {
	      var size = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];

	      var self = this;
	      var body;
	      if (searchString) {
	        body = {
	          query: {
	            simple_query_string: {
	              query: searchString + '*',
	              fields: ['title^3', 'description'],
	              default_operator: 'AND'
	            }
	          }
	        };
	      } else {
	        body = { query: { match_all: {} } };
	      }

	      return es.search({
	        index: kbnIndex,
	        type: 'dashboard',
	        body: body,
	        size: size
	      }).then(function (resp) {
	        return {
	          total: resp.hits.total,
	          hits: resp.hits.hits.map(function (hit) {
	            var source = hit._source;
	            source.id = hit._id;
	            source.url = self.urlFor(hit._id);
	            return source;
	          })
	        };
	      });
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 733 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(209);
	__webpack_require__(192);
	__webpack_require__(226);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('app/dashboard');
	  var angular = __webpack_require__(209);
	  var _ = __webpack_require__(192);
	  var moment = __webpack_require__(226);

	  // Used only by the savedDashboards service, usually no reason to change this
	  module.factory('SavedDashboard', function (courier, config) {
	    // SavedDashboard constructor. Usually you'd interact with an instance of this.
	    // ID is option, without it one will be generated on save.
	    _['class'](SavedDashboard).inherits(courier.SavedObject);
	    function SavedDashboard(id) {
	      // Gives our SavedDashboard the properties of a SavedObject
	      courier.SavedObject.call(this, {
	        type: SavedDashboard.type,
	        mapping: SavedDashboard.mapping,
	        searchSource: SavedDashboard.searchsource,

	        // if this is null/undefined then the SavedObject will be assigned the defaults
	        id: id,

	        // default values that will get assigned if the doc is new
	        defaults: {
	          title: 'New Dashboard',
	          hits: 0,
	          description: '',
	          panelsJSON: '[]',
	          optionsJSON: angular.toJson({
	            darkTheme: config.get('dashboard:defaultDarkTheme')
	          }),
	          version: 1,
	          timeRestore: false,
	          timeTo: undefined,
	          timeFrom: undefined
	        },

	        // if an indexPattern was saved with the searchsource of a SavedDashboard
	        // object, clear it. It was a mistake
	        clearSavedIndexPattern: true
	      });
	    }

	    // save these objects with the 'dashboard' type
	    SavedDashboard.type = 'dashboard';

	    // if type:dashboard has no mapping, we push this mapping into ES
	    SavedDashboard.mapping = {
	      title: 'string',
	      hits: 'integer',
	      description: 'string',
	      panelsJSON: 'string',
	      optionsJSON: 'string',
	      version: 'integer',
	      timeRestore: 'boolean',
	      timeTo: 'string',
	      timeFrom: 'string'
	    };

	    SavedDashboard.searchsource = true;

	    return SavedDashboard;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 734 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 735 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function savedDashboardFn(savedDashboards) {
	    return savedDashboards;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 736 */
/***/ function(module, exports) {

	module.exports = "<div dashboard-app class=\"app-container dashboard-container\">\n  <navbar ng-show=\"chrome.getVisible()\">\n    <span class=\"name\" ng-if=\"dash.id\" bindonce bo-bind=\"dash.title\" tooltip=\"{{dash.title}}\"></span>\n\n    <form name=\"queryInput\"\n      class=\"fill inline-form\"\n      ng-submit=\"filterResults()\"\n      role=\"form\">\n\n      <div class=\"typeahead\" kbn-typeahead=\"dashboard\">\n        <div class=\"input-group\"\n          ng-class=\"queryInput.$invalid ? 'has-error' : ''\">\n\n          <input type=\"text\"\n            placeholder=\"Filter...\"\n            aria-label=\"Filter input\"\n            class=\"form-control\"\n            ng-model=\"state.query\"\n            input-focus\n            kbn-typeahead-input\n            validate-query>\n          <button type=\"submit\" class=\"btn btn-default\" ng-disabled=\"queryInput.$invalid\" aria-label=\"Filter dashboards\">\n            <span aria-hidden=\"true\" class=\"fa fa-search\"></span>\n          </button>\n        </div>\n\n        <kbn-typeahead-items></kbn-typeahead-items>\n      </div>\n\n    </form>\n\n    <div class=\"button-group\" role=\"toolbar\">\n      <kbn-tooltip text=\"New Dashboard\" placement=\"bottom\" append-to-body=\"1\">\n        <button ng-click=\"newDashboard()\" aria-label=\"New Dashboard\"><i aria-hidden=\"true\" class=\"fa fa-file-new-o\"></i></button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Save Dashboard\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          aria-label=\"Save Dashboard\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('save') }}\"\n          ng-class=\"{active: configTemplate.is('save')}\"\n          ng-click=\"configTemplate.toggle('save');\">\n          <i aria-hidden=\"true\" class=\"fa fa-save\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Load Saved Dashboard\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          aria-label=\"Load Saved Dashboard\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('load') }}\"\n          ng-class=\"{active: configTemplate.is('load')}\"\n          ng-click=\"configTemplate.toggle('load');\">\n          <i aria-hidden=\"true\" class=\"fa fa-folder-open-o\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Share\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          aria-label=\"Share Dashboard\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('share') }}\"\n          ng-class=\"{active: configTemplate.is('share')}\"\n          ng-click=\"configTemplate.toggle('share');\">\n          <i aria-hidden=\"true\" class=\"fa fa-external-link\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Add Visualization\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          aria-label=\"Add Visualization\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('pickVis') }}\"\n          ng-class=\"{active: configTemplate.is('pickVis')}\"\n          ng-click=\"configTemplate.toggle('pickVis');\">\n          <i aria-hidden=\"true\" class=\"fa fa-plus-circle\"></i>\n        </button>\n      </kbn-tooltip>\n      <kbn-tooltip text=\"Options\" placement=\"bottom\" append-to-body=\"1\">\n        <button\n          aria-label=\"Options\"\n          aria-haspopup=\"true\"\n          aria-expanded=\"{{ configTemplate.is('options') }}\"\n          ng-class=\"{active: configTemplate.is('options')}\"\n          ng-click=\"configTemplate.toggle('options');\">\n          <i aria-hidden=\"true\" class=\"fa fa-gear\"></i>\n        </button>\n      </kbn-tooltip>\n    </div>\n  </navbar>\n\n  <config config-template=\"configTemplate\" config-object=\"opts\"></config>\n\n  <filter-bar state=\"state\"></filter-bar>\n\n  <div ng-show=\"!state.panels.length\" class=\"text-center start-screen\">\n    <h2>Ready to get started?</h2>\n    <p>Click the <a class=\"btn btn-xs navbtn-inverse\" ng-click=\"configTemplate.open('pickVis'); toggleAddVisualization = !toggleAddVisualization\" aria-label=\"Add visualization\"><i aria-hidden=\"true\" class=\"fa fa-plus-circle\"></i></a> button in the menu bar above to add a visualization to the dashboard. <br/>If you haven't setup a visualization yet visit the <a href=\"#/visualize\" title=\"Visualize\">\"Visualize\"</a> tab to create your first visualization.</p>\n  </div>\n\n  <dashboard-grid></dashboard-grid>\n</div>\n"

/***/ },
/* 737 */
/***/ function(module, exports) {

	module.exports = "<form ng-submit=\"opts.save()\" role=\"form\">\n  <div class=\"form-group\">\n    <label for=\"dashboardTitle\">Save As</label>\n    <input id=\"dashboardTitle\" type=\"text\" ng-model=\"opts.dashboard.title\" class=\"form-control\" placeholder=\"Dashboard title\" input-focus=\"select\">\n  </div>\n  <div class=\"form-group\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"opts.dashboard.timeRestore\" ng-checked=\"opts.dashboard.timeRestore\">\n      Store time with dashboard\n      <kbn-info info=\"Change the time filter to the currently selected time each time this dashboard is loaded\"></kbn-info>\n    </label>\n  </div>\n  <button type=\"submit\" ng-disabled=\"!opts.dashboard.title\" class=\"btn btn-primary\" aria-label=\"Save dashboard\">Save</button>\n</form>\n"

/***/ },
/* 738 */
/***/ function(module, exports) {

	module.exports = "<saved-object-finder type=\"dashboards\"></saved-object-finder>"

/***/ },
/* 739 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" class=\"vis-share\">\n\n  <p>\n    <div class=\"input-group\">\n      <label>\n        Embed this dashboard\n        <small>Add to your html source. Note all clients must still be able to access kibana</small>\n      </label>\n      <div class=\"form-control\" disabled>{{opts.shareData().embed}}</div>\n    </div>\n  </p>\n\n  <p>\n    <div class=\"input-group\">\n      <label>\n        Share a link\n      </label>\n      <div class=\"form-control\" disabled>{{opts.shareData().link}}</div>\n    </div>\n  </p>\n</form>"

/***/ },
/* 740 */
/***/ function(module, exports) {

	module.exports = "<div ng-switch on=\"mode\" ng-init=\"mode = 'visualization'\" class=\"dashboard-panel-picker\">\n  <ul class=\"nav nav-tabs\">\n    <li ng-class=\"{active: mode == 'visualization'}\"><a ng-click=\"mode='visualization'\" title=\"Visualizations\">Visualizations</a></li>\n    <li ng-class=\"{active: mode == 'search'}\"><a ng-click=\"mode='search'\" title=\"Searches\">Searches</a></li>\n  </ul>\n\n  <div class=\"list-group-item\" ng-switch-when=\"visualization\">\n    <saved-object-finder title=\"Choose a visualization\" type=\"visualizations\" on-choose=\"opts.addVis\"></saved-object-finder>\n  </div>\n\n  <div class=\"list-group-item\" ng-switch-when=\"search\">\n    <saved-object-finder title=\"Choose a search\" type=\"searches\" on-choose=\"opts.addSearch\"></saved-object-finder>\n  </div>\n</div>\n"

/***/ },
/* 741 */
/***/ function(module, exports) {

	module.exports = "<form role=\"form\" class=\"options\">\n  <p>\n    <div class=\"input-group\">\n      <label>\n        <input type=\"checkbox\" ng-model=\"opts.ui.darkTheme\" ng-checked=\"opts.ui.darkTheme\">\n        Use dark theme\n      </label>\n    </div>\n  </p>\n</form>\n"

/***/ },
/* 742 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(743);
	__webpack_require__(802);
	__webpack_require__(803);
	__webpack_require__(216);
	__webpack_require__(804);
	__webpack_require__(214);
	__webpack_require__(805);
	__webpack_require__(770);
	__webpack_require__(751);
	__webpack_require__(758);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, module, exports) {
	  var _ = __webpack_require__(192);

	  var sections = __webpack_require__(743);
	  __webpack_require__(802);
	  __webpack_require__(803);

	  __webpack_require__(216).when('/settings', {
	    redirectTo: '/settings/indices'
	  });

	  __webpack_require__(804)({
	    notRequiredRe: /^\/settings\//,
	    whenMissingRedirectTo: '/settings/indices'
	  });

	  __webpack_require__(214).get('apps/settings').directive('kbnSettingsApp', function (Private, $route, timefilter) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(805),
	      transclude: true,
	      scope: {
	        sectionName: '@section'
	      },
	      link: function link($scope, $el) {
	        timefilter.enabled = false;
	        $scope.sections = sections;
	        $scope.section = _.find($scope.sections, { name: $scope.sectionName });

	        $scope.sections.forEach(function (section) {
	          section['class'] = section === $scope.section ? 'active' : void 0;
	        });
	      }
	    };
	  });

	  // preload
	  __webpack_require__(770);
	  __webpack_require__(751);
	  __webpack_require__(758);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 743 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(744);
	__webpack_require__(783);
	__webpack_require__(791);
	__webpack_require__(799);
	__webpack_require__(800);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // each of these private modules returns an object defining that section, their properties
	  // are used to create the nav bar
	  return [__webpack_require__(744), __webpack_require__(783), __webpack_require__(791), __webpack_require__(799), __webpack_require__(800)];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 744 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(745);
	__webpack_require__(750);
	__webpack_require__(769);
	__webpack_require__(216);
	__webpack_require__(214);
	__webpack_require__(782);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(745);
	  __webpack_require__(750);
	  __webpack_require__(769);

	  // add a dependency to all of the subsection routes
	  __webpack_require__(216).defaults(/settings\/indices/, {
	    resolve: {
	      indexPatternIds: function indexPatternIds(courier) {
	        return courier.indexPatterns.getIds();
	      }
	    }
	  });

	  // wrapper directive, which sets some global stuff up like the left nav
	  __webpack_require__(214).get('apps/settings').directive('kbnSettingsIndices', function ($route, config, kbnUrl) {
	    return {
	      restrict: 'E',
	      transclude: true,
	      template: __webpack_require__(782),
	      link: function link($scope) {
	        $scope.edittingId = $route.current.params.indexPatternId;
	        config.$bind($scope, 'defaultIndex');

	        $scope.$watch('defaultIndex', function () {
	          var ids = $route.current.locals.indexPatternIds;
	          $scope.indexPatternList = ids.map(function (id) {
	            return {
	              id: id,
	              url: kbnUrl.eval('#/settings/indices/{{id}}', { id: id }),
	              'class': 'sidebar-item-title ' + ($scope.edittingId === id ? 'active' : ''),
	              'default': $scope.defaultIndex === id
	            };
	          });
	        });

	        $scope.$emit('application.load');
	      }
	    };
	  });

	  return {
	    name: 'indices',
	    display: 'Indices',
	    url: '#/settings/indices'
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 745 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(226);
	__webpack_require__(220);
	__webpack_require__(746);
	__webpack_require__(747);
	__webpack_require__(216);
	__webpack_require__(748);
	__webpack_require__(214);
	__webpack_require__(749);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var moment = __webpack_require__(226);

	  var _require = __webpack_require__(220);

	  var IndexPatternMissingIndices = _require.IndexPatternMissingIndices;

	  __webpack_require__(746);
	  __webpack_require__(747);

	  __webpack_require__(216).when('/settings/indices/', {
	    template: __webpack_require__(748)
	  });

	  __webpack_require__(214).get('apps/settings').controller('settingsIndicesCreate', function ($scope, kbnUrl, Private, Notifier, indexPatterns, es, config, Promise) {
	    var notify = new Notifier();
	    var refreshKibanaIndex = Private(__webpack_require__(749));
	    var intervals = indexPatterns.intervals;
	    var samplePromise;

	    // this and child scopes will write pattern vars here
	    var index = $scope.index = {
	      name: 'logstash-*',

	      isTimeBased: true,
	      nameIsPattern: false,
	      sampleCount: 5,
	      nameIntervalOptions: intervals,

	      fetchFieldsError: 'Loading'
	    };

	    index.nameInterval = _.find(index.nameIntervalOptions, { name: 'daily' });
	    index.timeField = null;

	    $scope.refreshFieldList = function () {
	      fetchFieldList().then(updateFieldList);
	    };

	    $scope.createIndexPattern = function () {
	      // get an empty indexPattern to start
	      indexPatterns.get().then(function (indexPattern) {
	        // set both the id and title to the index index
	        indexPattern.id = indexPattern.title = index.name;
	        if (index.isTimeBased) {
	          indexPattern.timeFieldName = index.timeField.name;
	          if (index.nameIsPattern) {
	            indexPattern.intervalName = index.nameInterval.name;
	          }
	        }

	        // fetch the fields
	        return indexPattern.create().then(function (id) {
	          if (id) {
	            refreshKibanaIndex().then(function () {
	              if (!config.get('defaultIndex')) {
	                config.set('defaultIndex', indexPattern.id);
	              }
	              indexPatterns.cache.clear(indexPattern.id);
	              kbnUrl.change('/settings/indices/' + indexPattern.id);
	            });
	          }
	        });

	        // refreshFields calls save() after a successfull fetch, no need to save again
	        // .then(function () { indexPattern.save(); })
	      })['catch'](function (err) {
	        if (err instanceof IndexPatternMissingIndices) {
	          notify.error('Could not locate any indices matching that pattern. Please add the index to Elasticsearch');
	        } else notify.fatal(err);
	      });
	    };

	    $scope.$watchMulti(['index.isTimeBased', 'index.nameIsPattern', 'index.nameInterval.name'], function (newVal, oldVal) {
	      var isTimeBased = newVal[0];
	      var nameIsPattern = newVal[1];
	      var newDefault = getPatternDefault(newVal[2]);
	      var oldDefault = getPatternDefault(oldVal[2]);

	      if (index.name === oldDefault) {
	        index.name = newDefault;
	      }

	      if (!isTimeBased) {
	        index.nameIsPattern = false;
	      }

	      if (!nameIsPattern) {
	        delete index.nameInterval;
	        delete index.timeField;
	      } else {
	        index.nameInterval = index.nameInterval || intervals.byName.days;
	        index.name = index.name || getPatternDefault(index.nameInterval);
	      }
	    });

	    $scope.moreSamples = function (andUpdate) {
	      index.sampleCount += 5;
	      if (andUpdate) updateSamples();
	    };

	    $scope.$watchMulti(['index.name', 'index.nameInterval'], function (newVal, oldVal) {
	      var lastPromise;
	      resetIndex();
	      samplePromise = lastPromise = updateSamples().then(function () {
	        promiseMatch(lastPromise, function () {
	          index.samples = null;
	          index.patternErrors = [];
	        });
	      })['catch'](function (errors) {
	        promiseMatch(lastPromise, function () {
	          index.existing = null;
	          index.patternErrors = errors;
	        });
	      })['finally'](function () {
	        // prevent running when no change happened (ie, first watcher call)
	        if (!_.isEqual(newVal, oldVal)) {
	          fetchFieldList().then(function (results) {
	            if (lastPromise === samplePromise) {
	              updateFieldList(results);
	              samplePromise = null;
	            }
	          });
	        }
	      });
	    });

	    $scope.$watchMulti(['index.isTimeBased', 'index.sampleCount'], $scope.refreshFieldList);

	    function updateSamples() {
	      var patternErrors = [];

	      if (!index.nameInterval || !index.name) {
	        return Promise.resolve();
	      }

	      var pattern = mockIndexPattern(index);

	      return indexPatterns.mapper.getIndicesForIndexPattern(pattern)['catch'](function (err) {
	        if (err instanceof IndexPatternMissingIndices) return;
	        notify.error(err);
	      }).then(function (existing) {
	        var all = _.get(existing, 'all', []);
	        var matches = _.get(existing, 'matches', []);
	        if (all.length) {
	          index.existing = {
	            'class': 'success',
	            all: all,
	            matches: matches,
	            matchPercent: Math.round(matches.length / all.length * 100) + '%',
	            failures: _.difference(all, matches)
	          };
	          return;
	        }

	        patternErrors.push('Pattern does not match any existing indices');
	        var radius = Math.round(index.sampleCount / 2);
	        var samples = intervals.toIndexList(index.name, index.nameInterval, -radius, radius);

	        if (_.uniq(samples).length !== samples.length) {
	          patternErrors.push('Invalid pattern, interval does not create unique index names');
	        } else {
	          index.samples = samples;
	        }

	        throw patternErrors;
	      });
	    }

	    function fetchFieldList() {
	      index.dateFields = index.timeField = index.listUsed = null;
	      var useIndexList = index.isTimeBased && index.nameIsPattern;
	      var fetchFieldsError;
	      var dateFields;

	      // we don't have enough info to continue
	      if (!index.name) {
	        fetchFieldsError = 'Set an index name first';
	        return;
	      }

	      if (useIndexList && !index.nameInterval) {
	        fetchFieldsError = 'Select the interval at which your indices are populated.';
	        return;
	      }

	      return indexPatterns.mapper.clearCache(index.name).then(function () {
	        var pattern = mockIndexPattern(index);

	        return indexPatterns.mapper.getFieldsForIndexPattern(pattern, true)['catch'](function (err) {
	          // TODO: we should probably display a message of some kind
	          if (err instanceof IndexPatternMissingIndices) {
	            fetchFieldsError = 'Unable to fetch mapping. Do you have indices matching the pattern?';
	            return [];
	          }

	          throw err;
	        });
	      }).then(function (fields) {
	        if (fields.length > 0) {
	          fetchFieldsError = null;
	          dateFields = fields.filter(function (field) {
	            return field.type === 'date';
	          });
	        }

	        return {
	          fetchFieldsError: fetchFieldsError,
	          dateFields: dateFields
	        };
	      }, notify.fatal);
	    }

	    function updateFieldList(results) {
	      index.fetchFieldsError = results.fetchFieldsError;
	      index.dateFields = results.dateFields;
	    }

	    function promiseMatch(lastPromise, cb) {
	      if (lastPromise === samplePromise) {
	        cb();
	      } else if (samplePromise != null) {
	        // haven't hit the last promise yet, reset index params
	        resetIndex();
	      }
	    }

	    function resetIndex() {
	      index.patternErrors = [];
	      index.samples = null;
	      index.existing = null;
	      index.fetchFieldsError = 'Loading';
	    }

	    function getPatternDefault(interval) {
	      switch (interval) {
	        case 'hours':
	          return '[logstash-]YYYY.MM.DD.HH';
	        case 'days':
	          return '[logstash-]YYYY.MM.DD';
	        case 'weeks':
	          return '[logstash-]GGGG.WW';
	        case 'months':
	          return '[logstash-]YYYY.MM';
	        case 'years':
	          return '[logstash-]YYYY';
	        default:
	          return 'logstash-*';
	      }
	    }

	    function mockIndexPattern(index) {
	      // trick the mapper into thinking this is an indexPattern
	      return {
	        id: index.name,
	        intervalName: index.nameInterval
	      };
	    }
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 746 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	// See https://github.com/elastic/elasticsearch/issues/6736
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').directive('validateIndexName', function () {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      scope: {
	        'ngModel': '='
	      },
	      link: function link($scope, elem, attr, ngModel) {
	        var illegalCharacters = ['\\', '/', '?', '"', '<', '>', '|', ' ', ','];
	        var isValid = function isValid(input) {
	          if (input == null || input === '' || input === '.' || input === '..') return false;

	          var match = _.find(illegalCharacters, function (character) {
	            return input.indexOf(character) >= 0;
	          });
	          return !match;
	        };

	        // From User
	        ngModel.$parsers.unshift(function (value) {
	          var valid = isValid(value);
	          ngModel.$setValidity('indexNameInput', valid);
	          return valid ? value : undefined;
	        });

	        // To user
	        ngModel.$formatters.unshift(function (value) {
	          ngModel.$setValidity('indexNameInput', isValid(value));
	          return value;
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 747 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');

	  module.directive('autoSelectIfOnlyOne', function ($parse) {
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      link: function link(scope, element, attributes, ngModelCtrl) {
	        attributes.$observe('autoSelectIfOnlyOne', function (result) {
	          var options = $parse(result)(scope);
	          if (options && options.length === 1) {
	            ngModelCtrl.$setViewValue(options[0]);
	            ngModelCtrl.$render();
	          }
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 748 */
/***/ function(module, exports) {

	module.exports = "<kbn-settings-app section=\"indices\">\n  <kbn-settings-indices>\n    <div ng-controller=\"settingsIndicesCreate\" class=\"kbn-settings-indices-create\">\n      <div class=\"page-header\">\n        <h1>Configure an index pattern</h1>\n        In order to use Kibana you must configure at least one index pattern. Index patterns are\n        used to identify the Elasticsearch index to run search and analytics against. They are also\n        used to configure fields.\n      </div>\n      <div>\n        <form name=\"form\" role=\"form\" class=\"well\" ng-submit=\"createIndexPattern()\">\n          <div class=\"form-group time-and-pattern\">\n            <label>\n              <input\n                ng-model=\"index.isTimeBased\"\n                type=\"checkbox\">\n              Index contains time-based events\n            </label>\n            <br>\n            <label ng-if=\"index.isTimeBased\">\n              <input ng-model=\"index.nameIsPattern\" type=\"checkbox\">\n              Use event times to create index names\n            </label>\n          </div>\n\n          <div class=\"form-group\" ng-if=\"index.isTimeBased && index.nameIsPattern\">\n            <label>\n              Index pattern interval&nbsp;\n              <kbn-info info=\"The interval at which index names rotate.\"></kbn-info>\n            </label>\n            <select\n              required\n              ng-options=\"opt.display for opt in index.nameIntervalOptions\"\n              ng-model=\"index.nameInterval\"\n              class=\"form-control\">\n            </select>\n          </div>\n\n          <div class=\"form-group\">\n            <label>\n              Index name or pattern\n            </label>\n            <p class=\"help-block\" ng-if=\"!index.nameIsPattern\">Patterns allow you to define dynamic index names using * as a wildcard. Example: logstash-*</p>\n            <p class=\"help-block\" ng-if=\"index.isTimeBased && index.nameIsPattern\">Patterns allow you to define dynamic index names. Static text in an index name is denoted using brackets. Example: [logstash-]YYYY.MM.DD. Please note that weeks are setup to use ISO weeks which start on Monday. &mdash;\n              <small><a target=\"_blank\" href=\"http://momentjs.com/docs/#/displaying/format/\">Date Format Documentation</a></small></p>\n            <input\n              ng-model=\"index.name\"\n              ng-attr-placeholder=\"{{index.defaultName}}\"\n              ng-model-options=\"{ updateOn: 'default blur', debounce: {'default': 2500, 'blur': 0} }\"\n              validate-index-name\n              name=\"name\"\n              required\n              type=\"text\"\n              class=\"form-control\">\n              <small ng-show=\"index.nameInterval.name == 'weeks'\">\n                <strong>Note: </strong>\n                I noticed you're using weekly indices. Kibana requires ISO weeks be used in your index creation.\n                See <a href=\"https://en.wikipedia.org/wiki/ISO_week_date\" target=\"_blank\" title=\"Wikipedia: ISO Week Date\">Wikipedia: ISO Week Date</a>\n              </small>\n            </div>\n\n          <section>\n            <div class=\"alert alert-danger\" ng-repeat=\"err in index.patternErrors\">\n              {{err}}\n            </div>\n\n            <div class=\"alert alert-info\" ng-if=\"index.samples\">\n              Attempted to match the following indices and aliases:\n              <ul>\n                <li ng-repeat=\"sample in index.samples\">{{sample}}</li>\n              </ul>\n              <button type=\"button\" ng-click=\"moreSamples(true)\" class=\"btn btn-default\">\n                Expand Search\n              </button>\n            </div>\n\n            <div class=\"alert alert-{{index.existing.class}}\" ng-if=\"index.existing\">\n              Pattern matches {{index.existing.matchPercent}} of existing indices and aliases\n              <ul>\n                <li ng-repeat=\"match in index.existing.matches | orderBy:'toString()'| limitTo: index.sampleCount\">{{match}}</li>\n              </ul>\n              <button\n                ng-if=\"index.sampleCount < index.existing.matches.length\"\n                ng-click=\"moreSamples()\"\n                type=\"button\"\n                class=\"btn btn-default\">\n                Expand Search\n              </button>\n            </div>\n\n            <div class=\"alert alert-info\" ng-if=\"index.existing.failures.length\">\n              Indices and aliases that were found, but did not match the pattern:\n              <ul>\n                <li ng-repeat=\"match in index.existing.failures | limitTo: index.sampleCount\">{{match}}</li>\n              </ul>\n              <a\n                ng-if=\"index.sampleCount < index.existing.matches.length\"\n                ng-click=\"moreSamples()\"\n                class=\"alert-link\">\n                more\n              </a>\n            </div>\n          </section>\n\n          <div class=\"form-group\" ng-if=\"index.isTimeBased && !index.fetchFieldsError\">\n            <label>\n              Time-field name\n              &nbsp;\n              <kbn-info info=\"This field will be used to filter events with the global time filter\"></kbn-info>\n              &nbsp;\n              <small>\n                <a ng-click=\"refreshFieldList();\"> refresh fields</a>\n              </small>\n            </label>\n            <select\n              required\n              ng-if=\"!index.fetchFieldsError\"\n              ng-options=\"field.name for field in index.dateFields\"\n              ng-model=\"index.timeField\"\n              auto-select-if-only-one=\"index.dateFields\"\n              class=\"form-control\">\n            </select>\n          </div>\n\n          <button\n            ng-disabled=\"form.$invalid || index.fetchFieldsError\"\n            ng-class=\"index.fetchFieldsError ? 'btn-default' : 'btn-success'\"\n            type=\"submit\"\n            class=\"btn\">\n            <span ng-hide=\"form.name.$error.indexNameInput\">{{index.fetchFieldsError || \"Create\" }}</span>\n            <span ng-show=\"form.name.$error.indexNameInput\">Invalid index name pattern.</span>\n          </button>\n        </form>\n      </div>\n    </div>\n  </kbn-settings-indices>\n</kbn-settings-app>\n"

/***/ },
/* 749 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function RefreshKibanaIndexFn(es, kbnIndex) {
	    return function () {
	      return es.indices.refresh({
	        index: kbnIndex
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 750 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(751);
	__webpack_require__(758);
	__webpack_require__(762);
	__webpack_require__(216);
	__webpack_require__(764);
	__webpack_require__(214);
	__webpack_require__(749);
	__webpack_require__(765);
	__webpack_require__(768);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  __webpack_require__(751);
	  __webpack_require__(758);
	  __webpack_require__(762);

	  __webpack_require__(216).when('/settings/indices/:indexPatternId', {
	    template: __webpack_require__(764),
	    resolve: {
	      indexPattern: function indexPattern($route, courier) {
	        return courier.indexPatterns.get($route.current.params.indexPatternId)['catch'](courier.redirectWhenMissing('/settings/indices'));
	      }
	    }
	  });

	  __webpack_require__(214).get('apps/settings').controller('settingsIndicesEdit', function ($scope, $location, $route, config, courier, Notifier, Private, AppState, docTitle) {

	    var notify = new Notifier();
	    var $state = $scope.state = new AppState();
	    var refreshKibanaIndex = Private(__webpack_require__(749));

	    $scope.kbnUrl = Private(__webpack_require__(765));
	    $scope.indexPattern = $route.current.locals.indexPattern;
	    docTitle.change($scope.indexPattern.id);
	    var otherIds = _.without($route.current.locals.indexPatternIds, $scope.indexPattern.id);

	    var fieldTypes = Private(__webpack_require__(768));
	    $scope.$watch('indexPattern.fields', function () {
	      $scope.fieldTypes = fieldTypes($scope.indexPattern);
	    });

	    $scope.changeTab = function (obj) {
	      $state.tab = obj.index;
	      $state.save();
	    };

	    $scope.$watch('state.tab', function (tab) {
	      if (!tab) $scope.changeTab($scope.fieldTypes[0]);
	    });

	    $scope.$watchCollection('indexPattern.fields', function () {
	      $scope.conflictFields = _.filter($scope.indexPattern.fields, { type: 'conflict' });
	    });

	    $scope.refreshFields = function () {
	      $scope.indexPattern.refreshFields();
	    };

	    $scope.removePattern = function () {
	      if ($scope.indexPattern.id === config.get('defaultIndex')) {
	        config['delete']('defaultIndex');
	        if (otherIds.length) {
	          config.set('defaultIndex', otherIds[0]);
	        }
	      }

	      courier.indexPatterns['delete']($scope.indexPattern).then(refreshKibanaIndex).then(function () {
	        $location.url('/settings/indices');
	      })['catch'](notify.fatal);
	    };

	    $scope.setDefaultPattern = function () {
	      config.set('defaultIndex', $scope.indexPattern.id);
	    };

	    $scope.setIndexPatternsTimeField = function (field) {
	      if (field.type !== 'date') {
	        notify.error('That field is a ' + field.type + ' not a date.');
	        return;
	      }
	      $scope.indexPattern.timeFieldName = field.name;
	      return $scope.indexPattern.save();
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 751 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(752);
	__webpack_require__(214);
	__webpack_require__(754);
	__webpack_require__(755);
	__webpack_require__(756);
	__webpack_require__(757);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  __webpack_require__(752);

	  __webpack_require__(214).get('apps/settings').directive('indexedFields', function ($filter) {
	    var yesTemplate = '<i class="fa fa-check" aria-label="yes"></i>';
	    var noTemplate = '';
	    var nameHtml = __webpack_require__(754);
	    var typeHtml = __webpack_require__(755);
	    var controlsHtml = __webpack_require__(756);
	    var filter = $filter('filter');

	    return {
	      restrict: 'E',
	      template: __webpack_require__(757),
	      scope: true,
	      link: function link($scope) {
	        var rowScopes = []; // track row scopes, so they can be destroyed as needed
	        $scope.perPage = 25;
	        $scope.columns = [{ title: 'name' }, { title: 'type' }, { title: 'format' }, { title: 'analyzed', info: 'Analyzed fields may require extra memory to visualize' }, { title: 'indexed', info: 'Fields that are not indexed are unavailable for search' }, { title: 'controls', sortable: false }];

	        $scope.$watchMulti(['[]indexPattern.fields', 'fieldFilter'], refreshRows);

	        function refreshRows() {
	          // clear and destroy row scopes
	          _.invoke(rowScopes.splice(0), '$destroy');

	          var fields = filter($scope.indexPattern.getNonScriptedFields(), $scope.fieldFilter);
	          _.find($scope.fieldTypes, { index: 'indexedFields' }).count = fields.length; // Update the tab count

	          $scope.rows = fields.map(function (field) {
	            var childScope = _.assign($scope.$new(), { field: field });
	            rowScopes.push(childScope);

	            return [{
	              markup: nameHtml,
	              scope: childScope,
	              value: field.displayName
	            }, {
	              markup: typeHtml,
	              scope: childScope,
	              value: field.type
	            }, _.get($scope.indexPattern, ['fieldFormatMap', field.name, 'type', 'title']), {
	              markup: field.analyzed ? yesTemplate : noTemplate,
	              value: field.analyzed
	            }, {
	              markup: field.indexed ? yesTemplate : noTemplate,
	              value: field.indexed
	            }, {
	              markup: controlsHtml,
	              scope: childScope
	            }];
	          });
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 752 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(753);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana').directive('paginatedTable', function ($filter) {
	    var _ = __webpack_require__(192);
	    var orderBy = $filter('orderBy');

	    return {
	      restrict: 'E',
	      template: __webpack_require__(753),
	      transclude: true,
	      scope: {
	        rows: '=',
	        columns: '=',
	        perPage: '=?',
	        sortHandler: '=?',
	        showSelector: '=?'
	      },
	      controllerAs: 'paginatedTable',
	      controller: function controller($scope) {
	        var self = this;
	        self.sort = {
	          columnIndex: null,
	          direction: null
	        };

	        self.sortColumn = function (colIndex) {
	          var col = $scope.columns[colIndex];

	          if (!col) return;
	          if (col.sortable === false) return;

	          var sortDirection;

	          if (self.sort.columnIndex !== colIndex) {
	            sortDirection = 'asc';
	          } else {
	            var directions = {
	              'null': 'asc',
	              'asc': 'desc',
	              'desc': null
	            };
	            sortDirection = directions[self.sort.direction];
	          }

	          self.sort.columnIndex = colIndex;
	          self.sort.direction = sortDirection;
	          self._setSortGetter(colIndex);
	        };

	        self._setSortGetter = function (index) {
	          if (_.isFunction($scope.sortHandler)) {
	            // use custom sort handler
	            self.sort.getter = $scope.sortHandler(index);
	          } else {
	            // use generic sort handler
	            self.sort.getter = function (row) {
	              var value = row[index];
	              if (value && value.value != null) return value.value;
	              return value;
	            };
	          }
	        };

	        // update the sordedRows result
	        $scope.$watchMulti(['rows', 'columns', '[]paginatedTable.sort'], function resortRows() {
	          if (!$scope.rows || !$scope.columns) {
	            $scope.sortedRows = false;
	            return;
	          }

	          var sort = self.sort;
	          if (sort.direction == null) {
	            $scope.sortedRows = $scope.rows.slice(0);
	          } else {
	            $scope.sortedRows = orderBy($scope.rows, sort.getter, sort.direction === 'desc');
	          }
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 753 */
/***/ function(module, exports) {

	module.exports = "<paginate\n  ng-if=\"sortedRows.length\"\n  list=\"sortedRows\"\n  per-page-prop=\"perPage\"\n  class=\"agg-table\">\n  <div class=\"agg-table-paginated\">\n    <table class=\"table table-condensed\">\n      <thead>\n        <tr bindonce>\n          <th\n            ng-repeat=\"col in columns\"\n            ng-click=\"paginatedTable.sortColumn($index)\"\n            class=\"{{ col.class }}\">\n            <span bo-text=\"col.title\"></span>\n            <kbn-info ng-if=\"col.info\" info=\"{{ col.info }}\" placement=\"top\"></kbn-info>\n            <i\n              ng-if=\"col.sortable !== false\"\n              class=\"fa\"\n              ng-class=\"{\n                'fa-sort-asc': paginatedTable.sort.columnIndex === $index && paginatedTable.sort.direction === 'asc',\n                'fa-sort-desc': paginatedTable.sort.columnIndex === $index && paginatedTable.sort.direction === 'desc',\n                'fa-sort': paginatedTable.sort.columnIndex !== $index || paginatedTable.sort.direction === null\n              }\">\n            </i>\n            <i aria-label=\"Click on a cell to filter\" ng-if=\"col.filterable\" class=\"fa fa-search\" ng-click=\"$event.stopPropagation()\" tooltip=\"Click on a cell to filter\"></i>\n          </th>\n        </tr>\n      </thead>\n      <tbody kbn-rows=\"page\" kbn-rows-min=\"perPage\"></tbody>\n    </table>\n  </div>\n\n  <!-- auto-inserted by the paginate directive... -->\n  <!-- <paginate-controls></paginate-controls> -->\n  <div class=\"pagination-container\" ng-transclude></div>\n\n</paginate>\n"

/***/ },
/* 754 */
/***/ function(module, exports) {

	module.exports = "<span>{{field.displayName}}</span>\n&nbsp;\n<span\n  ng-if=\"indexPattern.timeFieldName === field.name\"\n  tooltip=\"This field represents the time that events occurred.\"\n  class=\"label label-default\">\n  <i aria-hidden=\"true\" class=\"fa fa-clock-o\"></i>\n</span>\n"

/***/ },
/* 755 */
/***/ function(module, exports) {

	module.exports = "<span>{{field.type}}</span>\n<i\n  aria-label=\"The type of this field changes across indices. It is unavailable for many analysis functions.\"\n  ng-if=\"field.type == 'conflict'\"\n  tooltip=\"The type of this field changes across indices. It is unavailable for many analysis functions.\"\n  class=\"fa fa-warning text-color-warning\">\n</i>\n"

/***/ },
/* 756 */
/***/ function(module, exports) {

	module.exports = "<div class=\"actions\">\n  <a ng-href=\"{{ kbnUrl.getRouteHref(field, 'edit') }}\" aria-label=\"Edit\" class=\"btn btn-xs btn-default\">\n    <span class=\"sr-only\">Edit</span>\n    <i aria-hidden=\"true\" class=\"fa fa-pencil\"></i>\n  </a>\n\n  <button\n    ng-if=\"field.scripted\"\n    confirm-click=\"remove(field)\"\n    confirmation=\"Are you sure want to delete '{{field.name}}'? This action is irreversible!\"\n    class=\"btn btn-xs btn-danger\"\n    aria-label=\"Delete\">\n    <i aria-hidden=\"true\" class=\"fa fa-trash\"></i>\n  </button>\n</div>\n"

/***/ },
/* 757 */
/***/ function(module, exports) {

	module.exports = "<paginated-table\n  columns=\"columns\"\n  rows=\"rows\"\n  per-page=\"perPage\">\n</paginated-table>\n\n<p class=\"text-center default-message\" ng-if=\"rows.length === 0\">No matching fields found.</p>\n"

/***/ },
/* 758 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(752);
	__webpack_require__(214);
	__webpack_require__(759);
	__webpack_require__(756);
	__webpack_require__(760);
	__webpack_require__(761);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  __webpack_require__(752);

	  __webpack_require__(214).get('apps/settings').directive('scriptedFields', function (kbnUrl, Notifier, $filter) {
	    var rowScopes = []; // track row scopes, so they can be destroyed as needed
	    var popularityHtml = __webpack_require__(759);
	    var controlsHtml = __webpack_require__(756);
	    var filter = $filter('filter');

	    var notify = new Notifier();

	    return {
	      restrict: 'E',
	      template: __webpack_require__(760),
	      scope: true,
	      link: function link($scope) {
	        var dateScripts = __webpack_require__(761);

	        var fieldCreatorPath = '/settings/indices/{{ indexPattern }}/scriptedField';
	        var fieldEditorPath = fieldCreatorPath + '/{{ fieldName }}';

	        $scope.perPage = 25;
	        $scope.columns = [{ title: 'name' }, { title: 'script' }, { title: 'format' }, { title: 'controls', sortable: false }];

	        $scope.$watchMulti(['[]indexPattern.fields', 'fieldFilter'], refreshRows);

	        function refreshRows() {
	          _.invoke(rowScopes, '$destroy');
	          rowScopes.length = 0;

	          var fields = filter($scope.indexPattern.getScriptedFields(), $scope.fieldFilter);
	          _.find($scope.fieldTypes, { index: 'scriptedFields' }).count = fields.length; // Update the tab count

	          $scope.rows = fields.map(function (field) {
	            var rowScope = $scope.$new();
	            rowScope.field = field;
	            rowScopes.push(rowScope);

	            return [field.name, field.script, _.get($scope.indexPattern, ['fieldFormatMap', field.name, 'type', 'title']), {
	              markup: controlsHtml,
	              scope: rowScope
	            }];
	          });
	        }

	        $scope.addDateScripts = function () {
	          var conflictFields = [];
	          var fieldsAdded = 0;
	          _.each(dateScripts($scope.indexPattern), function (script, field) {
	            try {
	              $scope.indexPattern.addScriptedField(field, script, 'number');
	              fieldsAdded++;
	            } catch (e) {
	              conflictFields.push(field);
	            }
	          });

	          if (fieldsAdded > 0) {
	            notify.info(fieldsAdded + ' script fields created');
	          }

	          if (conflictFields.length > 0) {
	            notify.info('Not adding ' + conflictFields.length + ' duplicate fields: ' + conflictFields.join(', '));
	          }
	        };

	        $scope.create = function () {
	          var params = {
	            indexPattern: $scope.indexPattern.id
	          };

	          kbnUrl.change(fieldCreatorPath, params);
	        };

	        $scope.edit = function (field) {
	          var params = {
	            indexPattern: $scope.indexPattern.id,
	            fieldName: field.name
	          };

	          kbnUrl.change(fieldEditorPath, params);
	        };

	        $scope.remove = function (field) {
	          $scope.indexPattern.removeScriptedField(field.name);
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 759 */
/***/ function(module, exports) {

	module.exports = "<div ng-mouseover=\"popularityField.name = field.name\" ng-mouseout=\"popularityField.name = null\">\n  <span>{{ field.count }}</span>\n  <span class=\"field-popularize\" ng-show=\"popularityField.name == field.name\">\n    <span aria-label=\"Plus\" ng-click=\"indexPattern.popularizeField(field.name, 1)\"\n      class=\"label label-default\"><i  aria-hidden=\"true\" class=\"fa fa-plus\"></i></span>\n    <span aria-label=\"Minus\" ng-click=\"indexPattern.popularizeField(field.name, -1)\"\n      class=\"label label-default\"><i  aria-hidden=\"true\" class=\"fa fa-minus\"></i></span>\n  </span>\n</div>"

/***/ },
/* 760 */
/***/ function(module, exports) {

	module.exports = "<h3>Scripted fields</h3>\n<p>These scripted fields are computed on the fly from your data. They can be used in visualizations and displayed in your documents, however they can not be searched. You can manage them here and add new ones as you see fit, but be careful, scripts can be tricky! <!-- If you need some examples, why not let Kibana <a ng-click=\"addDateScripts()\"><strong>create a few examples from your date fields.</strong></a --></p>\n\n<header>\n  <a\n    ng-href=\"{{ kbnUrl.getRouteHref(indexPattern, 'addField') }}\"\n    class=\"btn btn-info\"\n    aria-label=\"Add Scripted Field\">\n    <i aria-hidden=\"true\" class=\"fa fa-plus\"></i>\n    Add Scripted Field\n  </a>\n</header>\n\n<paginated-table\n  columns=\"columns\"\n  rows=\"rows\"\n  per-page=\"perPage\">\n</paginated-table>\n\n<p class=\"text-center\" ng-if=\"rows.length === 0\">No matching scripted fields found.</p>\n"

/***/ },
/* 761 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function (indexPattern) {
	    var dateScripts = {};
	    var scripts = {
	      __dayOfMonth: 'dayOfMonth',
	      __dayOfWeek: 'dayOfWeek',
	      __dayOfYear: 'dayOfYear',
	      __hourOfDay: 'hourOfDay',
	      __minuteOfDay: 'minuteOfDay',
	      __minuteOfHour: 'minuteOfHour',
	      __monthOfYear: 'monthOfYear',
	      __weekOfYear: 'weekOfWeekyear',
	      __year: 'year'
	    };

	    _.each(indexPattern.fields.byType.date, function (field) {
	      if (field.indexed) {
	        _.each(scripts, function (value, key) {
	          dateScripts[field.name + '.' + key] = 'doc["' + field.name + '"].date.' + value;
	        });
	      }
	    });

	    return dateScripts;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 762 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(763);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('apps/settings').directive('kbnSettingsIndexHeader', function (config) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(763),
	      scope: {
	        indexPattern: '=',
	        setDefault: '&',
	        refreshFields: '&',
	        'delete': '&'
	      },
	      link: function link($scope, $el, attrs) {
	        $scope['delete'] = attrs['delete'] ? $scope['delete'] : null;
	        $scope.setDefault = attrs.setDefault ? $scope.setDefault : null;
	        $scope.refreshFields = attrs.refreshFields ? $scope.refreshFields : null;
	        config.$bind($scope, 'defaultIndex');
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 763 */
/***/ function(module, exports) {

	module.exports = "<div class=\"index-pattern-name\">\n  <h1 class=\"title\" css-truncate>\n    <i aria-hidden=\"true\" ng-if=\"defaultIndex === indexPattern.id\" class=\"fa fa-star\"></i>\n    {{indexPattern.id}}\n  </h1>\n  <div class=\"controls\">\n    <button\n      ng-if=\"setDefault\"\n      ng-click=\"setDefault()\"\n      tooltip=\"Set as default index\"\n      class=\"btn btn-success\">\n      <span class=\"sr-only\">Set as default index</span>\n      <i aria-hidden=\"true\" class=\"fa fa-star\"></i>\n    </button>\n    <button\n      ng-if=\"refreshFields\"\n      confirm-click=\"refreshFields()\"\n      confirmation=\"This will reset the field popularity counters. Are you sure you want to reload your fields?\"\n      tooltip=\"Reload field list\"\n      class=\"btn btn-warning\">\n      <span class=\"sr-only\">Reload field list</span>\n      <i aria-hidden=\"true\" class=\"fa fa-refresh\"></i>\n    </button>\n    <button\n      ng-if=\"delete\"\n      confirm-click=\"delete()\"\n      aria-label=\"Remove index pattern\"\n      confirmation=\"Are you sure you want to remove this index pattern?\"\n      tooltip=\"Remove index pattern\"\n      class=\"btn btn-danger\">\n      <span class=\"sr-only\">Remove index pattern</span>\n      <i aria-hidden=\"true\" class=\"fa fa-trash\"></i>\n    </button>\n  </div>\n</div>\n"

/***/ },
/* 764 */
/***/ function(module, exports) {

	module.exports = "<kbn-settings-app section=\"indices\">\n  <kbn-settings-indices>\n    <div ng-controller=\"settingsIndicesEdit\" bindonce>\n      <div class=\"page-header\">\n        <kbn-settings-index-header\n          index-pattern=\"indexPattern\"\n          set-default=\"setDefaultPattern()\"\n          refresh-fields=\"indexPattern.refreshFields()\"\n          delete=\"removePattern()\">\n        </kbn-settings-index-header>\n\n        <p>\n          This page lists every field in the <strong>{{indexPattern.id}}</strong>\n          index and the field's associated core type as recorded by Elasticsearch.\n          While this list allows you to view the core type of each field, changing\n          field types must be done using Elasticsearch's\n          <a target=\"_window\" href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html\">\n            Mapping API\n            <i aria-hidden=\"true\" class=\"fa-link fa\"></i>\n          </a>\n        </p>\n        <div ng-if=\"indexPattern.timeFieldName && indexPattern.intervalName\" class=\"alert alert-info\">\n          This index uses a <strong>Time-based index pattern</strong> which repeats <span bo-text=\"indexPattern.getInterval().display\"></span>\n        </div>\n        <div ng-if=\"conflictFields.length\" class=\"alert alert-warning\">\n          <strong>Mapping conflict!</strong> {{conflictFields.length > 1 ? conflictFields.length : 'A'}} field{{conflictFields.length > 1 ? 's' : ''}} {{conflictFields.length > 1 ? 'are' : 'is'}} defined as several types (string, integer, etc) across the indices that match this pattern. You may still be able to use these conflict fields in parts of Kibana, but they will be unavailable for functions that require Kibana to know their type. Correcting this issue will require reindexing your data.\n        </div>\n      </div>\n\n      <form role=\"form\">\n        <input aria-label=\"Filter\" ng-model=\"fieldFilter\" class=\"form-control span12\" type=\"text\" placeholder=\"Filter\" />\n      </form>\n\n      <br />\n\n      <ul class=\"nav nav-tabs\">\n        <li class=\"kbn-settings-tab\" ng-class=\"{ active: state.tab === fieldType.index }\" ng-repeat=\"fieldType in fieldTypes\">\n          <a ng-click=\"changeTab(fieldType)\">\n            {{ fieldType.title }}\n            <small>({{ fieldType.count }})</small>\n          </a>\n        </li>\n      </ul>\n\n      <indexed-fields ng-show=\"state.tab == 'indexedFields'\" class=\"fields indexed-fields\"></indexed-fields>\n      <scripted-fields ng-show=\"state.tab == 'scriptedFields'\" class=\"fields scripted-fields\"></scripted-fields>\n\n    </div>\n  </kbn-settings-indices>\n</kbn-settings-app>\n"

/***/ },
/* 765 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(766);
	__webpack_require__(767);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(766);
	  __webpack_require__(767);

	  __webpack_require__(214).get('kibana/url').service('kbnUrl', function (Private) {
	    return Private(KbnUrlProvider);
	  });

	  function KbnUrlProvider($route, $location, $rootScope, globalState, $parse, getAppState) {
	    var self = this;

	    /**
	     * Navigate to a url
	     *
	     * @param  {String} url - the new url, can be a template. See #eval
	     * @param  {Object} [paramObj] - optional set of parameters for the url template
	     * @return {undefined}
	     */
	    self.change = function (url, paramObj) {
	      self._changeLocation('url', url, paramObj);
	    };

	    /**
	     * Same as #change except only changes the url's path,
	     * leaving the search string and such intact
	     *
	     * @param  {String} path - the new path, can be a template. See #eval
	     * @param  {Object} [paramObj] - optional set of parameters for the path template
	     * @return {undefined}
	     */
	    self.changePath = function (path, paramObj) {
	      self._changeLocation('path', path, paramObj);
	    };

	    /**
	     * Same as #change except that it removes the current url from history
	     *
	     * @param  {String} url - the new url, can be a template. See #eval
	     * @param  {Object} [paramObj] - optional set of parameters for the url template
	     * @return {undefined}
	     */
	    self.redirect = function (url, paramObj) {
	      self._changeLocation('url', url, paramObj, true);
	    };

	    /**
	     * Same as #redirect except only changes the url's path,
	     * leaving the search string and such intact
	     *
	     * @param  {String} path - the new path, can be a template. See #eval
	     * @param  {Object} [paramObj] - optional set of parameters for the path template
	     * @return {undefined}
	     */
	    self.redirectPath = function (path, paramObj) {
	      self._changeLocation('path', path, paramObj, true);
	    };

	    /**
	     * Evaluate a url template. templates can contain double-curly wrapped
	     * expressions that are evaluated in the context of the paramObj
	     *
	     * @param  {String} template - the url template to evaluate
	     * @param  {Object} [paramObj] - the variables to expose to the template
	     * @return {String} - the evaluated result
	     * @throws {Error} If any of the expressions can't be parsed.
	     */
	    self.eval = function (template, paramObj) {
	      paramObj = paramObj || {};

	      return template.replace(/\{\{([^\}]+)\}\}/g, function (match, expr) {
	        // remove filters
	        var key = expr.split('|')[0].trim();

	        // verify that the expression can be evaluated
	        var p = $parse(key)(paramObj);

	        // if evaluation can't be made, throw
	        if (_.isUndefined(p)) {
	          throw new Error('Replacement failed, unresolved expression: ' + expr);
	        }

	        // append uriescape filter if not included
	        if (expr.indexOf('uriescape') === -1) {
	          expr += '|uriescape';
	        }

	        return $parse(expr)(paramObj);
	      });
	    };

	    /**
	     * convert an object's route to an href, compatible with
	     * window.location.href= and <a href="">
	     *
	     * @param  {Object} obj - any object that list's it's routes at obj.routes{}
	     * @param  {string} route - the route name
	     * @return {string} - the computed href
	     */
	    self.getRouteHref = function (obj, route) {
	      return '#' + self.getRouteUrl(obj, route);
	    };

	    /**
	     * convert an object's route to a url, compatible with url.change() or $location.url()
	     *
	     * @param  {Object} obj - any object that list's it's routes at obj.routes{}
	     * @param  {string} route - the route name
	     * @return {string} - the computed url
	     */
	    self.getRouteUrl = function (obj, route) {
	      var template = obj && obj.routes && obj.routes[route];
	      if (template) return self.eval(template, obj);
	    };

	    /**
	     * Similar to getRouteUrl, supports objects which list their routes,
	     * and redirects to the named route. See #redirect
	     *
	     * @param  {Object} obj - any object that list's it's routes at obj.routes{}
	     * @param  {string} route - the route name
	     * @return {undefined}
	     */
	    self.redirectToRoute = function (obj, route) {
	      self.redirect(self.getRouteUrl(obj, route));
	    };

	    /**
	     * Similar to getRouteUrl, supports objects which list their routes,
	     * and changes the url to the named route. See #change
	     *
	     * @param  {Object} obj - any object that list's it's routes at obj.routes{}
	     * @param  {string} route - the route name
	     * @return {undefined}
	     */
	    self.changeToRoute = function (obj, route) {
	      self.change(self.getRouteUrl(obj, route));
	    };

	    /////
	    // private api
	    /////
	    var reloading;

	    self._changeLocation = function (type, url, paramObj, replace) {
	      var prev = {
	        path: $location.path(),
	        search: $location.search()
	      };

	      url = self.eval(url, paramObj);
	      $location[type](url);
	      if (replace) $location.replace();

	      var next = {
	        path: $location.path(),
	        search: $location.search()
	      };

	      if (self._shouldAutoReload(next, prev)) {
	        var appState = getAppState();
	        if (appState) appState.destroy();

	        reloading = $rootScope.$on('$locationChangeSuccess', function () {
	          // call the "unlisten" function returned by $on
	          reloading();
	          reloading = false;

	          $route.reload();
	        });
	      }
	    };

	    self._shouldAutoReload = function (next, prev) {
	      if (reloading) return false;

	      var route = $route.current && $route.current.$$route;
	      if (!route) return false;

	      if (next.path !== prev.path) return false;

	      var reloadOnSearch = route.reloadOnSearch;
	      var searchSame = _.isEqual(next.search, prev.search);

	      return reloadOnSearch && searchSame || !reloadOnSearch;
	    };
	  }

	  return KbnUrlProvider;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 766 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana').filter('uriescape', function () {
	    return function (str) {
	      return encodeURIComponent(str);
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 767 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(250);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var rison = __webpack_require__(250);
	  var module = __webpack_require__(214).get('kibana');

	  module.filter('rison', function () {
	    return function (str) {
	      return rison.encode(str);
	    };
	  });

	  module.filter('risonDecode', function () {
	    return function (str) {
	      return rison.decode(str);
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 768 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function GetFieldTypes() {
	    var _ = __webpack_require__(192);

	    return function (indexPattern) {
	      var fieldCount = _.countBy(indexPattern.fields, function (field) {
	        return field.scripted ? 'scripted' : 'indexed';
	      });

	      _.defaults(fieldCount, {
	        indexed: 0,
	        scripted: 0
	      });

	      return [{
	        title: 'fields',
	        index: 'indexedFields',
	        count: fieldCount.indexed
	      }, {
	        title: 'scripted fields',
	        index: 'scriptedFields',
	        count: fieldCount.scripted
	      }];
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 769 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(770);
	__webpack_require__(762);
	__webpack_require__(216);
	__webpack_require__(781);
	__webpack_require__(435);
	__webpack_require__(765);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(770);
	  __webpack_require__(762);

	  __webpack_require__(216).when('/settings/indices/:indexPatternId/field/:fieldName', { mode: 'edit' }).when('/settings/indices/:indexPatternId/create-field/', { mode: 'create' }).defaults(/settings\/indices\/[^\/]+\/(field|create-field)(\/|$)/, {
	    template: __webpack_require__(781),
	    resolve: {
	      indexPattern: function indexPattern($route, courier) {
	        return courier.indexPatterns.get($route.current.params.indexPatternId)['catch'](courier.redirectWhenMissing('/settings/indices'));
	      }
	    },
	    controllerAs: 'fieldSettings',
	    controller: function FieldEditorPageController($route, Private, Notifier, docTitle) {
	      var Field = Private(__webpack_require__(435));
	      var notify = new Notifier({ location: 'Field Editor' });
	      var kbnUrl = Private(__webpack_require__(765));

	      this.mode = $route.current.mode;
	      this.indexPattern = $route.current.locals.indexPattern;

	      if (this.mode === 'edit') {
	        var fieldName = $route.current.params.fieldName;
	        this.field = this.indexPattern.fields.byName[fieldName];

	        if (!this.field) {
	          notify.error(this.indexPattern + ' does not have a "' + fieldName + '" field.');
	          kbnUrl.redirectToRoute(this.indexPattern, 'edit');
	          return;
	        }
	      } else if (this.mode === 'create') {
	        this.field = new Field(this.indexPattern, {
	          scripted: true,
	          type: 'number'
	        });
	      } else {
	        throw new Error('unknown fieldSettings mode ' + this.mode);
	      }

	      docTitle.change([this.field.name || 'New Scripted Field', this.indexPattern.id]);
	      this.goBack = function () {
	        kbnUrl.changeToRoute(this.indexPattern, 'edit');
	      };
	    }
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 770 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(771);
	__webpack_require__(774);
	__webpack_require__(201);
	__webpack_require__(777);
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(443);
	__webpack_require__(435);
	__webpack_require__(778);
	__webpack_require__(779);
	__webpack_require__(780);

	'use strict';

	var _Object$getOwnPropertyNames = __webpack_require__(771)['default'];

	var _Object$getOwnPropertyDescriptor = __webpack_require__(774)['default'];

	var _Object$create = __webpack_require__(201)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

	  __webpack_require__(777);

	  __webpack_require__(214).get('kibana').directive('fieldEditor', function (Private, $sce) {
	    var _ = __webpack_require__(192);
	    var fieldFormats = Private(__webpack_require__(443));
	    var Field = Private(__webpack_require__(435));
	    var scriptingInfo = $sce.trustAsHtml(__webpack_require__(778));
	    var scriptingWarning = $sce.trustAsHtml(__webpack_require__(779));

	    return {
	      restrict: 'E',
	      template: __webpack_require__(780),
	      scope: {
	        getIndexPattern: '&indexPattern',
	        getField: '&field'
	      },
	      controllerAs: 'editor',
	      controller: function controller($scope, Notifier, kbnUrl) {
	        var self = this;
	        var notify = new Notifier({ location: 'Field Editor' });

	        self.scriptingInfo = scriptingInfo;
	        self.scriptingWarning = scriptingWarning;

	        self.indexPattern = $scope.getIndexPattern();
	        self.field = shadowCopy($scope.getField());
	        self.formatParams = self.field.format.params();

	        // only init on first create
	        self.creating = !self.indexPattern.fields.byName[self.field.name];
	        self.selectedFormatId = _.get(self.indexPattern, ['fieldFormatMap', self.field.name, 'type', 'id']);
	        self.defFormatType = initDefaultFormat();
	        self.fieldFormatTypes = [self.defFormatType].concat(fieldFormats.byFieldType[self.field.type] || []);

	        self.cancel = redirectAway;
	        self.save = function () {
	          var indexPattern = self.indexPattern;
	          var fields = indexPattern.fields;
	          var field = self.field.toActualField();

	          fields.remove({ name: field.name });
	          fields.push(field);

	          if (!self.selectedFormatId) {
	            delete indexPattern.fieldFormatMap[field.name];
	          } else {
	            indexPattern.fieldFormatMap[field.name] = self.field.format;
	          }

	          return indexPattern.save().then(function () {
	            notify.info('Saved Field "' + self.field.name + '"');
	            redirectAway();
	          });
	        };

	        self['delete'] = function () {
	          var indexPattern = self.indexPattern;
	          var field = self.field;

	          indexPattern.fields.remove({ name: field.name });
	          return indexPattern.save().then(function () {
	            notify.info('Deleted Field "' + field.name + '"');
	            redirectAway();
	          });
	        };

	        $scope.$watch('editor.selectedFormatId', function (cur, prev) {
	          var format = self.field.format;
	          var changedFormat = cur !== prev;
	          var missingFormat = cur && (!format || format.type.id !== cur);

	          if (!changedFormat || !missingFormat) return;

	          // reset to the defaults, but make sure it's an object
	          self.formatParams = _.assign({}, getFieldFormatType().paramDefaults);
	        });

	        $scope.$watch('editor.formatParams', function () {
	          var FieldFormat = getFieldFormatType();
	          self.field.format = new FieldFormat(self.formatParams);
	        }, true);

	        // copy the defined properties of the field to a plain object
	        // which is mutable, and capture the changed seperately.
	        function shadowCopy(field) {
	          var changes = {};
	          var shadowProps = {
	            toActualField: {
	              // bring the shadow copy out of the shadows
	              value: function toActualField() {
	                return new Field(self.indexPattern, _.defaults({}, changes, field.$$spec));
	              }
	            }
	          };

	          _Object$getOwnPropertyNames(field).forEach(function (prop) {
	            var desc = _Object$getOwnPropertyDescriptor(field, prop);
	            shadowProps[prop] = {
	              enumerable: desc.enumerable,
	              get: function get() {
	                return _.has(changes, prop) ? changes[prop] : field[prop];
	              },
	              set: function set(v) {
	                changes[prop] = v;
	              }
	            };
	          });

	          return _Object$create(null, shadowProps);
	        }

	        function redirectAway() {
	          kbnUrl.changeToRoute(self.indexPattern, self.field.scripted ? 'scriptedFields' : 'indexedFields');
	        }

	        function getFieldFormatType() {
	          if (self.selectedFormatId) return fieldFormats.getType(self.selectedFormatId);else return fieldFormats.getDefaultType(self.field.type);
	        }

	        function initDefaultFormat() {
	          var def = _Object$create(fieldFormats.getDefaultType(self.field.type));

	          // explicitly set to undefined to prevent inheritting the prototypes id
	          def.id = undefined;
	          def.resolvedTitle = def.title;
	          def.title = '- default - ';

	          return def;
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 771 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(772), __esModule: true };

/***/ },
/* 772 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(203);
	__webpack_require__(773);
	module.exports = function getOwnPropertyNames(it){
	  return $.getNames(it);
	};

/***/ },
/* 773 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(233)('getOwnPropertyNames', function(){
	  return __webpack_require__(616).get;
	});

/***/ },
/* 774 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(775), __esModule: true };

/***/ },
/* 775 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(203);
	__webpack_require__(776);
	module.exports = function getOwnPropertyDescriptor(it, key){
	  return $.getDesc(it, key);
	};

/***/ },
/* 776 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(277);

	__webpack_require__(233)('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 777 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);

	  __webpack_require__(214).get('app/settings').directive('fieldFormatEditor', function (Private, $compile) {
	    return {
	      restrict: 'A',
	      scope: {
	        getField: '&field',
	        getFormatParams: '&formatParams'
	      },
	      controllerAs: 'editor',
	      controller: function controller($scope) {
	        var self = this;

	        // bind the scope values to the controller, down with $scope.values
	        $scope.editor = this;
	        $scope.$bind('editor.field', 'getField()', $scope);
	        $scope.$bind('editor.formatParams', 'getFormatParams()', $scope);

	        /**
	         * Read the FieldFormat's editor property and convert it into
	         * a "pseudoDirective". For clarity I'm reusing the directive def
	         * object api, but for simplicity not implementing the entire thing.
	         *
	         * possible configs:
	         *   string:
	         *     - used as an angular template
	         *   directive def object, with support for the following opts:
	         *     - template
	         *     - compile or link
	         *     - scope (creates isolate, reads from parent scope, not attributes)
	         *     - controller
	         *     - controllerAs
	         *
	         * @param  {angular.element} $el - template
	         * @param  {object} directiveDef - the directive definition object
	         * @return {undefined}
	         */
	        $scope.$watch('editor.field.format.type', function (FieldFormat) {
	          var opts = FieldFormat && FieldFormat.editor;

	          if (!opts) {
	            delete self.$$pseudoDirective;
	            return;
	          }

	          if (typeof opts === 'string') {
	            self.$$pseudoDirective = {
	              template: opts
	            };
	            return;
	          }

	          self.$$pseudoDirective = {
	            template: opts.template,
	            compile: opts.compile || function () {
	              return opts.link;
	            },
	            scope: opts.scope || false,
	            controller: opts.controller,
	            controllerAs: opts.controllerAs
	          };
	        });
	      },
	      link: function link($scope, $el) {
	        var scopesToTeardown = [];

	        function setupScope(opts) {
	          if (typeof opts !== 'object') {
	            return scopesToTeardown[scopesToTeardown.push($scope.$new()) - 1];
	          }

	          var isolate = scopesToTeardown[scopesToTeardown.push($scope.$new(true)) - 1];
	          _.forOwn(opts, function (from, to) {
	            isolate.$bind(to, from, $scope);
	          });
	          return isolate;
	        }

	        $scope.$watch('editor.$$pseudoDirective', function (directive) {
	          $el.empty();
	          _.invoke(scopesToTeardown.splice(0), '$destroy');

	          if (!directive) return $el.hide();else $el.show();

	          var askedForChild = !!directive.scope;
	          var reuseScope = !askedForChild && !directive.controller;

	          var $formatEditor = $('<div>').html(directive.template);
	          var $formatEditorScope = reuseScope ? $scope : setupScope(directive.scope);

	          if (directive.controller) {
	            // bind the controller to the injected element
	            var cntrlAs = directive.controllerAs ? ' as ' + directive.controllerAs : '';
	            $formatEditorScope.Controller = directive.controller;
	            $formatEditor.attr('ng-controller', 'Controller' + cntrlAs);
	          }

	          var attrs = {};
	          var linkFns = directive.compile && directive.compile($el, attrs);
	          if (!linkFns || _.isFunction(linkFns)) {
	            linkFns = {
	              pre: _.noop,
	              post: linkFns || _.noop
	            };
	          }

	          $el.html($formatEditor);
	          linkFns.pre($formatEditorScope, $formatEditor, attrs);
	          $compile($formatEditor)($formatEditorScope);
	          linkFns.post($formatEditorScope, $formatEditor, attrs);
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 778 */
/***/ function(module, exports) {

	module.exports = "<h4>\n  <i class=\"fa fa-question-circle text-info\"></i> Scripting Help\n</h4>\n\n<p>\n  By default, Elasticsearch scripts use <a target=\"_window\" href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html#_lucene_expressions_scripts\">Lucene Expressions <i class=\"fa-link fa\"></i></a>, which is a lot like JavaScript, but limited to basic arithmetic, bitwise and comparison operations. We'll let you do some reading on <a target=\"_window\" href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html#_lucene_expressions_scripts\">Lucene Expressions<i class=\"fa-link fa\"></i></a> To access values in the document use the following format:\n</p>\n\n<p><code>doc['some_field'].value</code></p>\n\n<p>\n  There are a few limitations when using Lucene Expressions:\n</p>\n<ul>\n  <li>Only numeric fields may be accessed</li>\n  <li> Stored fields are not available </li>\n  <li> If a field is sparse (only some documents contain a value), documents missing the field will have a value of 0 </li>\n</ul>\n\n<p>\n  Here are all the operations available to scripted fields:\n</p>\n<ul>\n <li> Arithmetic operators: + - * / % </li>\n <li> Bitwise operators: | & ^ ~ << >> >>> </li>\n <li> Boolean operators (including the ternary operator): && || ! ?: </li>\n <li> Comparison operators: < <= == >= > </li>\n <li> Common mathematic functions: abs ceil exp floor ln log10 logn max min sqrt pow </li>\n <li> Trigonometric library functions: acosh acos asinh asin atanh atan atan2 cosh cos sinh sin tanh tan </li>\n <li> Distance functions: haversin </li>\n <li> Miscellaneous functions: min, max </li>\n</ul>\n"

/***/ },
/* 779 */
/***/ function(module, exports) {

	module.exports = "<h4>\n  <i class=\"fa fa-warning text-warning\"></i> Proceed with caution\n</h4>\n\n<p>\n  Please familiarize yourself with <a target=\"_window\" href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-script-fields.html#search-request-script-fields\">script fields <i class=\"fa-link fa\"></i></a> and with <a target=\"_window\" href=\"http://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-script\">scripts in aggregations <i class=\"fa-link fa\"></i></a> before using scripted fields.\n</p>\n\n<p>\n  Scripted fields can be used to display and aggregate calculated values. As such, they can be very slow, and if done incorrectly, can cause Kibana to be unusable. There's no safety net here. If you make a typo, unexpected exceptions will be thrown all over the place!\n</p>\n"

/***/ },
/* 780 */
/***/ function(module, exports) {

	module.exports = "<form ng-submit=\"editor.save()\" name=\"form\">\n  <div ng-if=\"editor.creating\" class=\"form-group\">\n    <label>Name</label>\n    <input\n      ng-model=\"editor.field.name\"\n      required\n      placeholder=\"New Scripted Field\"\n      input-focus\n      class=\"form-control\">\n  </div>\n  <div ng-if=\"editor.creating && editor.indexPattern.fields.byName[editor.field.name]\" class=\"hintbox\">\n    <p>\n      <i class=\"fa fa-danger text-danger\"></i>\n      <strong>Mapping Conflict:</strong>\n      You already have a field with the name {{ editor.field.name }}. Naming your scripted\n      field with the same name means you won't be able to query both fields at the same time.\n    </p>\n  </div>\n\n  <div class=\"form-group\">\n    <label>Type</label>\n    <input\n      ng-model=\"editor.field.type\"\n      readonly\n      class=\"form-control\">\n  </div>\n\n  <div class=\"form-group\">\n    <span class=\"pull-right text-warning hintbox-label\" ng-click=\"editor.showFormatHelp = !editor.showFormatHelp\">\n      <i class=\"fa fa-warning\"></i> Warning\n    </span>\n\n    <label>Format <small>(Default: <i>{{editor.defFormatType.resolvedTitle}}</i>)</small></label>\n\n    <div class=\"hintbox\" ng-if=\"editor.showFormatHelp\">\n      <h4 class=\"hintbox-heading\">\n        <i class=\"fa fa-warning text-warning\"></i> Format Warning\n      </h4>\n\n      <p>\n        Formatting allows you to control the way that specific values are displayed. It can also cause values to be completely changed and prevent highlighting in Discover from working.\n      </p>\n    </div>\n\n    <select\n      ng-model=\"editor.selectedFormatId\"\n      ng-options=\"format.id as format.title for format in editor.fieldFormatTypes\"\n      class=\"form-control\">\n    </select>\n    <fieldset\n      field-format-editor\n      ng-if=\"editor.selectedFormatId\"\n      field=\"editor.field\"\n      format-params=\"editor.formatParams\">\n    </fieldset>\n  </div>\n\n  <div class=\"form-group\">\n    <label for=\"editor.field.count\">Popularity</label>\n    <div class=\"input-group\">\n\n      <input\n        ng-model=\"editor.field.count\"\n        type=\"number\"\n        class=\"form-control\">\n\n      <span class=\"input-group-btn\">\n        <button\n          type=\"button\"\n          ng-click=\"editor.field.count = editor.field.count + 1\"\n          aria-label=\"Plus\"\n          class=\"btn btn-default\">\n          <i aria-hidden=\"true\" class=\"fa fa-plus\"></i>\n        </button>\n        <button\n          type=\"button\"\n          ng-click=\"editor.field.count = editor.field.count - 1\"\n          aria-label=\"Minus\"\n          class=\"btn btn-default\">\n          <i aria-hidden=\"true\" class=\"fa fa-minus\"></i>\n        </button>\n      </span>\n    </div>\n  </div>\n\n  <div ng-if=\"editor.field.scripted\">\n    <div class=\"form-group\">\n      <label>Script</label>\n      <textarea required class=\"form-control text-monospace\" ng-model=\"editor.field.script\"></textarea>\n    </div>\n\n    <div class=\"form-group\">\n      <div ng-bind-html=\"editor.scriptingWarning\" class=\"hintbox\"></div>\n    </div>\n\n    <div class=\"form-group\">\n      <div ng-bind-html=\"editor.scriptingInfo\" class=\"hintbox\"></div>\n    </div>\n\n  </div>\n\n  <div class=\"form-group\">\n    <button\n      type=\"button\"\n      ng-click=\"editor.cancel()\"\n      aria-label=\"Cancel\"\n      class=\"btn btn-primary\">\n      Cancel\n    </button>\n    <button\n      type=\"button\"\n      ng-if=\"editor.field.scripted && !editor.creating\"\n      confirm-click=\"editor.delete()\"\n      confirmation=\"Are you sure want to delete '{{ editor.field.name }}'? This action is irreversible!\"\n      aria-label=\"Delete\"\n      class=\"btn btn-danger\">\n      Delete Field\n    </button>\n    <button\n      ng-disabled=\"form.$invalid\"\n      type=\"submit\"\n      aria-label=\"{{ editor.creating ? 'Create' : 'Update' }} Field\"\n      class=\"btn btn-success\">\n      {{ editor.creating ? 'Create' : 'Update' }} Field\n    </button>\n  </div>\n</form>\n"

/***/ },
/* 781 */
/***/ function(module, exports) {

	module.exports = "<kbn-settings-app section=\"indices\">\n  <kbn-settings-indices>\n    <div class=\"page-header\">\n      <kbn-settings-index-header index-pattern=\"fieldSettings.indexPattern\"></kbn-settings-index-header>\n\n      <h2 ng-if=\"fieldSettings.mode === 'create'\">\n        Create {{ fieldSettings.field.scripted ? 'Scripted ' : '' }}Field\n      </h2>\n\n      <h2 ng-if=\"fieldSettings.mode === 'edit'\">\n        {{ fieldSettings.field.name }}\n      </h2>\n    </div>\n\n    <field-editor index-pattern=\"fieldSettings.indexPattern\" field=\"fieldSettings.field\"></field-editor>\n\n  </kbn-settings-indices>\n</kbn-settings-app>\n"

/***/ },
/* 782 */
/***/ function(module, exports) {

	module.exports = "<div class=\"col-md-2 sidebar-container\" bindonce=\"indexPatternList\">\n  <div class=\"sidebar-list\">\n    <div class=\"sidebar-list-header\">\n      <h5>\n        Index Patterns&nbsp;\n        <a\n          ng-if=\"edittingId\"\n          href=\"#/settings/indices\"\n          class=\"btn btn-primary btn-xs\"\n          aria-label=\"Add New\">\n          <span class=\"sr-only\">Add New</span>\n          <i aria-hidden=\"true\" class=\"fa fa-plus\"></i> Add New\n        </a>\n      </h5>\n    </div>\n    <ul class=\"list-unstyled\">\n      <li\n        ng-if=\"!defaultIndex\"\n        class=\"sidebar-item\">\n        <div class=\"sidebar-item-title full-title\">\n            <span class=\"label label-warning\">Warning</span> No default index pattern. You must select or create one to continue.\n        </div>\n      </li>\n      <li\n        ng-repeat=\"pattern in indexPatternList | orderBy:['-default','id'] track by pattern.id \"\n        class=\"sidebar-item\">\n        <a bo-href=\"pattern.url\">\n          <div bo-class=\"pattern.class\">\n            <i aria-hidden=\"true\" ng-if=\"pattern.default\" class=\"fa fa-star\"></i>\n            <span bo-text=\"pattern.id\"></span>\n          </div>\n        </a>\n      </li>\n    </ul>\n  </div>\n</div>\n\n<div class=\"col-md-10\" ng-transclude></div>\n"

/***/ },
/* 783 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(241);
	__webpack_require__(192);
	__webpack_require__(784);
	__webpack_require__(787);
	__webpack_require__(216);
	__webpack_require__(790);
	__webpack_require__(214);
	__webpack_require__(713);

	'use strict';

	var _Object$keys = __webpack_require__(241)['default'];

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var toEditableConfig = __webpack_require__(784);

	  __webpack_require__(787);

	  __webpack_require__(216).when('/settings/advanced', {
	    template: __webpack_require__(790)
	  });

	  __webpack_require__(214).get('apps/settings').directive('kbnSettingsAdvanced', function (config, Notifier, Private, $rootScope) {
	    return {
	      restrict: 'E',
	      link: function link($scope) {
	        var configDefaults = Private(__webpack_require__(713));
	        var keyCodes = {
	          ESC: 27
	        };

	        function isTypeComplex(conf) {
	          return !(conf.json || conf.array || conf.bool || conf.normal);
	        }

	        function notDefaultConfig(configName) {
	          return !(configName in configDefaults);
	        }

	        function readConfigVals() {
	          var configVals = config._vals();

	          var customConfig = _Object$keys(configVals).filter(notDefaultConfig).map(function (name) {
	            return toEditableConfig(false, name, configVals[name]);
	          });

	          $scope.configs = _(configDefaults).map(function (def, name) {
	            return toEditableConfig(def, name, configVals[name]);
	          }).reject('readonly').concat(customConfig).value();
	        }

	        // react to changes of the config values
	        var unhook = $rootScope.$on('change:config', readConfigVals);
	        $scope.$on('$destroy', unhook);

	        // initial config setup
	        readConfigVals();
	      }
	    };
	  });

	  return {
	    order: 2,
	    name: 'advanced',
	    display: 'Advanced',
	    url: '#/settings/advanced'
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 784 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(785);
	__webpack_require__(786);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var getValType = __webpack_require__(785);
	  var getEditorType = __webpack_require__(786);

	  /**
	   * @param {object} advanced setting definition object
	   * @param {object} name of setting
	   * @param {object} current value of setting
	   * @returns {object} the editable config object
	   */
	  function toEditableConfig(def, name, value) {
	    var isCustom = !def;
	    if (isCustom) def = {};

	    var conf = {
	      name: name,
	      value: value,
	      isCustom: isCustom,
	      readonly: !!def.readonly,
	      defVal: def.value,
	      type: getValType(def, value),
	      description: def.description,
	      options: def.options
	    };

	    var editor = getEditorType(conf);
	    conf.json = editor === 'json';
	    conf.select = editor === 'select';
	    conf.bool = editor === 'boolean';
	    conf.array = editor === 'array';
	    conf.normal = editor === 'normal';
	    conf.tooComplex = !editor;

	    return conf;
	  }

	  return toEditableConfig;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 785 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  /**
	   * @param {object} advanced setting definition object
	   * @param {?} current value of the setting
	   * @returns {string} the type to use for determining the display and editor
	   */
	  function getValType(def, value) {
	    if (def.type) {
	      return def.type;
	    }

	    if (_.isArray(value) || _.isArray(def.value)) {
	      return 'array';
	    }

	    return def.value != null ? typeof def.value : typeof value;
	  }

	  return getValType;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 786 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  var NAMED_EDITORS = ['json', 'array', 'boolean', 'select'];
	  var NORMAL_EDITOR = ['number', 'string', 'null', 'undefined'];

	  /**
	   * @param {object} advanced setting configuration object
	   * @returns {string} the editor type to use when editing value
	   */
	  function getEditorType(conf) {
	    if (_.contains(NAMED_EDITORS, conf.type)) return conf.type;
	    if (_.contains(NORMAL_EDITOR, conf.type)) return 'normal';
	  }

	  return getEditorType;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 787 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(788);
	__webpack_require__(214);
	__webpack_require__(789);
	__webpack_require__(713);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  __webpack_require__(788);

	  __webpack_require__(214).get('apps/settings').directive('advancedRow', function (config, Notifier, Private) {
	    return {
	      restrict: 'A',
	      replace: true,
	      template: __webpack_require__(789),
	      scope: {
	        conf: '=advancedRow',
	        configs: '='
	      },
	      link: function link($scope) {
	        var configDefaults = Private(__webpack_require__(713));
	        var notify = new Notifier();
	        var keyCodes = {
	          ESC: 27
	        };

	        // To allow passing form validation state back
	        $scope.forms = {};

	        // setup loading flag, run async op, then clear loading and editting flag (just in case)
	        var loading = function loading(conf, fn) {
	          conf.loading = true;
	          fn()['finally'](function () {
	            conf.loading = conf.editting = false;
	          })['catch'](notify.fatal);
	        };

	        $scope.maybeCancel = function ($event, conf) {
	          if ($event.keyCode === keyCodes.ESC) {
	            $scope.cancelEdit(conf);
	          }
	        };

	        $scope.edit = function (conf) {
	          conf.unsavedValue = conf.value == null ? conf.defVal : conf.value;
	          $scope.configs.forEach(function (c) {
	            c.editting = c === conf;
	          });
	        };

	        $scope.save = function (conf) {
	          loading(conf, function () {
	            if (conf.unsavedValue === conf.defVal) {
	              return config.clear(conf.name);
	            }

	            return config.set(conf.name, conf.unsavedValue);
	          });
	        };

	        $scope.cancelEdit = function (conf) {
	          conf.editting = false;
	        };

	        $scope.clear = function (conf) {
	          return loading(conf, function () {
	            return config.clear(conf.name);
	          });
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 788 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var NL_RE = /\n/g;
	  var events = 'keydown keypress keyup change';

	  __webpack_require__(214).get('kibana').directive('elasticTextarea', function () {
	    return {
	      restrict: 'A',
	      link: function link($scope, $el) {

	        function resize() {
	          $el.attr('rows', _.size($el.val().match(NL_RE)) + 1);
	        }

	        $el.on(events, resize);
	        $scope.$evalAsync(resize);
	        $scope.$on('$destroy', function () {
	          $el.off(events, resize);
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 789 */
/***/ function(module, exports) {

	module.exports = "<tr ng-class=\"conf.value === undefined ? 'default' : 'custom'\">\n  <td class=\"name\">\n    <b>{{conf.name}}</b>\n    <span class=\"smaller\" ng-show=\"!conf.isCustom && conf.value !== undefined\">\n      (Default: <i>{{conf.defVal == undefined ? 'null' : conf.defVal}}</i>)\n    </span>\n    <span class=\"smaller\" ng-show=\"conf.isCustom\">\n      (Custom setting)\n    </span>\n    <br>\n    <span class=\"smaller\" ng-bind-html=\"conf.description | trustAsHtml\"></span>\n  </td>\n  <td class=\"value\">\n\n\n    <!-- Settings editors -->\n    <form\n      name=\"forms.configEdit\"\n      ng-if=\"conf.editting\"\n      ng-submit=\"save(conf)\"\n      role=\"form\">\n\n      <input\n        ng-show=\"conf.normal\"\n        ng-model=\"conf.unsavedValue\"\n        ng-keyup=\"maybeCancel($event, conf)\"\n        placeholder=\"{{conf.value || conf.defVal}}\"\n        type=\"text\"\n        class=\"form-control\">\n\n      <textarea\n        ng-if=\"conf.json\"\n        type=\"text\"\n        class=\"form-control\"\n        ng-model=\"conf.unsavedValue\"\n        ng-keyup=\"maybeCancel($event, conf)\"\n        elastic-textarea\n        validate-json\n        ></textarea>\n      <small ng-show=\"forms.configEdit.$error.jsonInput\">Invalid JSON syntax</small>\n\n      <input\n        ng-show=\"conf.array\"\n        ng-list=\",\"\n        ng-model=\"conf.unsavedValue\"\n        ng-keyup=\"maybeCancel($event, conf)\"\n        placeholder=\"{{(conf.value || conf.defVal).join(', ')}}\"\n        type=\"text\"\n        class=\"form-control\">\n\n      <input\n        ng-show=\"conf.bool\"\n        ng-model=\"conf.unsavedValue\"\n        type=\"checkbox\"\n        class=\"form-control\">\n\n      <select\n        ng-show=\"conf.select\"\n        name=\"conf.name\"\n        ng-model=\"conf.unsavedValue\"\n        ng-options=\"option as option for option in conf.options\"\n        class=\"form-control\">\n      </select>\n    </form>\n\n    <!-- Setting display formats -->\n    <span ng-if=\"!conf.editting\">\n      <span ng-show=\"(conf.normal || conf.json || conf.select)\">{{conf.value || conf.defVal}}</span>\n      <span ng-show=\"conf.array\">{{(conf.value || conf.defVal).join(', ')}}</span>\n      <span ng-show=\"conf.bool\">{{conf.value === undefined ? conf.defVal : conf.value}}</span>\n    </span>\n\n  </td>\n  <td class=\"actions\">\n    <button\n      ng-if=\"!conf.editting\"\n      ng-click=\"edit(conf)\"\n      class=\"btn btn-default\"\n      ng-disabled=\"conf.tooComplex\"\n      aria-label=\"Edit\">\n      <span class=\"sr-only\">Edit</span>\n      <i aria-hidden=\"true\" class=\"fa fa-pencil\"></i>\n    </button>\n\n    <button\n      ng-if=\"conf.editting\"\n      ng-click=\"save(conf)\"\n      class=\"btn btn-success\"\n      ng-disabled=\"conf.loading || conf.tooComplex || forms.configEdit.$invalid\"\n      aria-label=\"Save\">\n      <span class=\"sr-only\">Save</span>\n      <i aria-hidden=\"true\" ng-if=\"!conf.loading\" class=\"fa fa-save\"></i>\n      <i aria-hidden=\"true\" ng-if=\"conf.loading\" class=\"fa fa-spinner\"></i>\n    </button>\n\n    <button\n      ng-if=\"!conf.editting\"\n      ng-click=\"clear(conf)\"\n      ng-hide=\"conf.value === undefined\"\n      class=\"btn btn-danger\"\n      aria-label=\"Clear\">\n      <span class=\"sr-only\">Clear</span>\n      <i aria-hidden=\"true\" class=\"fa fa-trash-o\"></i>\n    </button>\n\n    <button\n      ng-if=\"conf.editting\"\n      ng-click=\"cancelEdit(conf)\"\n      class=\"btn btn-default\"\n      aria-label=\"Cancel edit\">\n      <span class=\"sr-only\">Cancel Edit</span>\n      <i aria-hidden=\"true\" class=\"fa fa-times\"></i>\n    </button>\n  </td>\n</tr>\n"

/***/ },
/* 790 */
/***/ function(module, exports) {

	module.exports = "<kbn-settings-app section=\"advanced\">\n  <kbn-settings-advanced class=\"container\">\n    <div class=\"bs-callout bs-callout-warning\">\n      <h4>Caution: You can break stuff here</h4>\n      Be careful in here, these settings are for very advanced users only.\n      Tweaks you make here can break large portionsof Kibana. Some of these\n      settings may be undocumented, unsupported or experimental. If a field has\n      a default value, blanking the field will reset it to its default which\n      may be unacceptable given other configuration directives. Deleting a\n      custom setting will permanently remove it from Kibana's config.\n    </div>\n    <form role=\"form\">\n      <input aria-label=\"Filter\" ng-model=\"advancedFilter\" class=\"form-control span12\" type=\"text\" placeholder=\"Filter\"/>\n    </form>\n    <table class=\"table\">\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Value</th>\n          <th>Actions <kbn-info info=\"Edit or restore the default value.\"></kbn-info></th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr ng-repeat=\"conf in configs | filter:advancedFilter\" advanced-row=\"conf\" configs=\"configs\"></tr>\n      </tbody>\n    </table>\n  </kbn-settings-advanced>\n</kbn-settings-app>\n"

/***/ },
/* 791 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(792);
	__webpack_require__(794);
	__webpack_require__(459);
	__webpack_require__(798);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(792);
	  __webpack_require__(794);

	  __webpack_require__(459);
	  __webpack_require__(798);

	  // add the module deps to this module
	  __webpack_require__(214).get('apps/settings');

	  return {
	    name: 'objects',
	    display: 'Objects',
	    url: '#/settings/objects'
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 792 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(250);
	__webpack_require__(330);
	__webpack_require__(793);
	__webpack_require__(216);
	__webpack_require__(214);
	__webpack_require__(506);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  var rison = __webpack_require__(250);
	  var registry = __webpack_require__(330);
	  var objectViewHTML = __webpack_require__(793);

	  __webpack_require__(216).when('/settings/objects/:service/:id', {
	    template: objectViewHTML
	  });

	  __webpack_require__(214).get('apps/settings').directive('kbnSettingsObjectsView', function (kbnIndex, Notifier) {
	    return {
	      restrict: 'E',
	      controller: function controller($scope, $injector, $routeParams, $location, $window, $rootScope, es, Private) {
	        var notify = new Notifier({ location: 'SavedObject view' });
	        var castMappingType = Private(__webpack_require__(506));
	        var serviceObj = registry.get($routeParams.service);
	        var service = $injector.get(serviceObj.service);

	        /**
	         * Creates a field definition and pushes it to the memo stack. This function
	         * is designed to be used in conjunction with _.reduce(). If the
	         * values is plain object it will recurse through all the keys till it hits
	         * a string, number or an array.
	         *
	         * @param {array} memo The stack of fields
	         * @param {mixed} value The value of the field
	         * @param {string} key The key of the field
	         * @param {object} collection This is a reference the collection being reduced
	         * @param {array} parents The parent keys to the field
	         * @returns {array}
	         */
	        var createField = function createField(memo, val, key, collection, parents) {
	          if (_.isArray(parents)) {
	            parents.push(key);
	          } else {
	            parents = [key];
	          }

	          var field = { type: 'text', name: parents.join('.'), value: val };

	          if (_.isString(field.value)) {
	            try {
	              field.value = angular.toJson(JSON.parse(field.value), true);
	              field.type = 'json';
	            } catch (err) {
	              field.value = field.value;
	            }
	          } else if (_.isNumeric(field.value)) {
	            field.type = 'number';
	          } else if (_.isArray(field.value)) {
	            field.type = 'array';
	            field.value = angular.toJson(field.value, true);
	          } else if (_.isBoolean(field.value)) {
	            field.type = 'boolean';
	            field.value = field.value;
	          } else if (_.isPlainObject(field.value)) {
	            // do something recursive
	            return _.reduce(field.value, _.partialRight(createField, parents), memo);
	          }

	          memo.push(field);

	          // once the field is added to the object you need to pop the parents
	          // to remove it since we've hit the end of the branch.
	          parents.pop();
	          return memo;
	        };

	        var readObjectClass = function readObjectClass(fields, Class) {
	          var fieldMap = _.indexBy(fields, 'name');

	          _.forOwn(Class.mapping, function (esType, name) {
	            if (fieldMap[name]) return;

	            fields.push({
	              name: name,
	              type: (function () {
	                switch (castMappingType(esType)) {
	                  case 'string':
	                    return 'text';
	                  case 'number':
	                    return 'number';
	                  case 'boolean':
	                    return 'boolean';
	                  default:
	                    return 'json';
	                }
	              })()
	            });
	          });

	          if (Class.searchSource && !fieldMap['kibanaSavedObjectMeta.searchSourceJSON']) {
	            fields.push({
	              name: 'kibanaSavedObjectMeta.searchSourceJSON',
	              type: 'json',
	              value: '{}'
	            });
	          }
	        };

	        $scope.notFound = $routeParams.notFound;

	        $scope.title = service.type;

	        es.get({
	          index: kbnIndex,
	          type: service.type,
	          id: $routeParams.id
	        }).then(function (obj) {
	          $scope.obj = obj;
	          $scope.link = service.urlFor(obj._id);

	          var fields = _.reduce(obj._source, createField, []);
	          if (service.Class) readObjectClass(fields, service.Class);
	          $scope.fields = _.sortBy(fields, 'name');
	        })['catch'](notify.fatal);

	        // This handles the validation of the Ace Editor. Since we don't have any
	        // other hooks into the editors to tell us if the content is valid or not
	        // we need to use the annotations to see if they have any errors. If they
	        // do then we push the field.name to aceInvalidEditor variable.
	        // Otherwise we remove it.
	        var loadedEditors = [];
	        $scope.aceInvalidEditors = [];

	        $scope.aceLoaded = function (editor) {
	          if (_.contains(loadedEditors, editor)) return;
	          loadedEditors.push(editor);

	          editor.$blockScrolling = Infinity;

	          var session = editor.getSession();
	          var fieldName = editor.container.id;

	          session.setTabSize(2);
	          session.setUseSoftTabs(true);
	          session.on('changeAnnotation', function () {
	            var annotations = session.getAnnotations();
	            if (_.some(annotations, { type: 'error' })) {
	              if (!_.contains($scope.aceInvalidEditors, fieldName)) {
	                $scope.aceInvalidEditors.push(fieldName);
	              }
	            } else {
	              $scope.aceInvalidEditors = _.without($scope.aceInvalidEditors, fieldName);
	            }

	            if ($rootScope.$$phase) $scope.$apply();
	          });
	        };

	        $scope.cancel = function () {
	          $window.history.back();
	          return false;
	        };

	        /**
	         * Deletes an object and sets the notification
	         * @param {type} name description
	         * @returns {type} description
	         */
	        $scope['delete'] = function () {
	          es['delete']({
	            index: kbnIndex,
	            type: service.type,
	            id: $routeParams.id
	          }).then(function (resp) {
	            return redirectHandler('deleted');
	          })['catch'](notify.fatal);
	        };

	        $scope.submit = function () {
	          var source = _.cloneDeep($scope.obj._source);

	          _.each($scope.fields, function (field) {
	            var value = field.value;

	            if (field.type === 'number') {
	              value = Number(field.value);
	            }

	            if (field.type === 'array') {
	              value = JSON.parse(field.value);
	            }

	            _.set(source, field.name, value);
	          });

	          es.index({
	            index: kbnIndex,
	            type: service.type,
	            id: $routeParams.id,
	            body: source
	          }).then(function (resp) {
	            return redirectHandler('updated');
	          })['catch'](notify.fatal);
	        };

	        function redirectHandler(action) {
	          return es.indices.refresh({
	            index: kbnIndex
	          }).then(function (resp) {
	            var msg = 'You successfully ' + action + ' the "' + $scope.obj._source.title + '" ' + $scope.title.toLowerCase() + ' object';

	            $location.path('/settings/objects').search({
	              _a: rison.encode({
	                tab: serviceObj.title
	              })
	            });
	            notify.info(msg);
	          });
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 793 */
/***/ function(module, exports) {

	module.exports = "<kbn-settings-app section=\"objects\">\n  <kbn-settings-objects-view class=\"container\">\n    <div class=\"pull-right\" style=\"margin-top: 20px;\">\n      <a href=\"{{ link }}\" class=\"btn btn-primary\">View {{ title }}</a>\n      <a confirm-click=\"delete()\" class=\"btn btn-danger\"><i class=\"fa fa-trash-o\"></i> Delete {{ title }} Object</a>\n    </div>\n    <h1>Edit {{ title }} Object</h1>\n    <div class=\"bs-callout bs-callout-danger\" ng-if=\"notFound\">\n      <h4>There is a problem with that saved object</h4>\n\n      <p ng-if=\"notFound === 'search'\">The saved search associated with this object no longer exists.</p>\n      <p ng-if=\"notFound === 'index-pattern'\">The index pattern associated with this object no longer exists.</p>\n      <p ng-if=\"notFound === 'index-pattern-field'\">A field associated with this object no longer exists in the index pattern.</p>\n\n      <p>If you know what this error means, go ahead and fix it - otherwise click the delete button above.</p>\n    </div>\n    <div class=\"bs-callout bs-callout-warning\">\n      <h4>Proceed with caution</h4>\n\n      <p>Modifying objects is for advanced users only. Object properties are not validated and invalid objects could cause errors, data loss, or worse. Unless someone with intimate knowledge of the code told you to be in here, you probably shouldn't be.</p>\n    </div>\n    <form role=\"form\" name=\"objectForm\" ng-submit=\"submit()\">\n      <div class=\"form-group\" ng-repeat=\"field in fields\">\n        <label>{{ field.name }}</label>\n        <textarea rows=\"1\" msd-elastic=\" \" ng-if=\"field.type === 'text'\" ng-model=\"field.value\" class=\"form-control span12\"/>\n        <input ng-if=\"field.type === 'number'\"  type=\"number\" ng-model=\"field.value\" class=\"form-control span12\"/>\n        <div ng-if=\"field.type === 'json' || field.type === 'array'\" ui-ace=\"{ onLoad: aceLoaded, mode: 'json' }\" id=\"{{field.name}}\" ng-model=\"field.value\" class=\"form-control\"></div>\n        <input ng-if=\"field.type === 'boolean'\" type=\"checkbox\" ng-model=\"field.value\" ng-checked=\"field.value\">\n      </div>\n    </form>\n    <div class=\"form-group\">\n      <button aria-label=\"Cancel\" class=\"btn btn-primary\" ng-click=\"cancel()\">Cancel</button>\n      <button aria-label=\"Save {{ title }} Object\" class=\"btn btn-success\" ng-click=\"submit()\" ng-disabled=\"objectForm.$invalid || aceInvalidEditors.length !==0\">Save {{ title }} Object</button>\n    </div>\n  </kbn-settings-objects-view>\n</kbn-settings-app>"

/***/ },
/* 794 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(795);
	__webpack_require__(330);
	__webpack_require__(796);
	__webpack_require__(797);
	__webpack_require__(216);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  var saveAs = __webpack_require__(795).saveAs;
	  var registry = __webpack_require__(330);
	  var objectIndexHTML = __webpack_require__(796);
	  var MAX_SIZE = Math.pow(2, 31) - 1;

	  __webpack_require__(797);

	  __webpack_require__(216).when('/settings/objects', {
	    template: objectIndexHTML
	  });

	  __webpack_require__(214).get('apps/settings').directive('kbnSettingsObjects', function (kbnIndex, Notifier, Private, kbnUrl, Promise) {
	    return {
	      restrict: 'E',
	      controller: function controller($scope, $injector, $q, AppState, es) {
	        var notify = new Notifier({ location: 'Saved Objects' });

	        var $state = $scope.state = new AppState();
	        $scope.currentTab = null;
	        $scope.selectedItems = [];

	        var getData = function getData(filter) {
	          var services = registry.all().map(function (obj) {
	            var service = $injector.get(obj.service);
	            return service.find(filter).then(function (data) {
	              return {
	                service: service,
	                serviceName: obj.service,
	                title: obj.title,
	                type: service.type,
	                data: data.hits,
	                total: data.total
	              };
	            });
	          });

	          $q.all(services).then(function (data) {
	            $scope.services = _.sortBy(data, 'title');
	            var tab = $scope.services[0];
	            if ($state.tab) $scope.currentTab = tab = _.find($scope.services, { title: $state.tab });

	            $scope.$watch('state.tab', function (tab) {
	              if (!tab) $scope.changeTab($scope.services[0]);
	            });
	          });
	        };

	        $scope.toggleAll = function () {
	          if ($scope.selectedItems.length === $scope.currentTab.data.length) {
	            $scope.selectedItems.length = 0;
	          } else {
	            $scope.selectedItems = [].concat($scope.currentTab.data);
	          }
	        };

	        $scope.toggleItem = function (item) {
	          var i = $scope.selectedItems.indexOf(item);
	          if (i >= 0) {
	            $scope.selectedItems.splice(i, 1);
	          } else {
	            $scope.selectedItems.push(item);
	          }
	        };

	        $scope.open = function (item) {
	          kbnUrl.change(item.url.substr(1));
	        };

	        $scope.edit = function (service, item) {
	          var params = {
	            service: service.serviceName,
	            id: item.id
	          };

	          kbnUrl.change('/settings/objects/{{ service }}/{{ id }}', params);
	        };

	        $scope.bulkDelete = function () {
	          $scope.currentTab.service['delete'](_.pluck($scope.selectedItems, 'id')).then(refreshData).then(function () {
	            $scope.selectedItems.length = 0;
	          });
	        };

	        $scope.bulkExport = function () {
	          var objs = $scope.selectedItems.map(_.partialRight(_.extend, { type: $scope.currentTab.type }));
	          retrieveAndExportDocs(objs);
	        };

	        $scope.exportAll = function () {
	          Promise.map($scope.services, function (service) {
	            return service.service.find('', MAX_SIZE).then(function (results) {
	              return results.hits.map(function (hit) {
	                return _.extend(hit, { type: service.type });
	              });
	            });
	          }).then(function (results) {
	            return retrieveAndExportDocs(_.flattenDeep(results));
	          });
	        };

	        function retrieveAndExportDocs(objs) {
	          es.mget({
	            index: kbnIndex,
	            body: { docs: objs.map(transformToMget) }
	          }).then(function (response) {
	            saveToFile(response.docs.map(_.partialRight(_.pick, '_id', '_type', '_source')));
	          });
	        }

	        // Takes an object and returns the associated data needed for an mget API request
	        function transformToMget(obj) {
	          return { _id: obj.id, _type: obj.type };
	        }

	        function saveToFile(results) {
	          var blob = new Blob([angular.toJson(results, true)], { type: 'application/json' });
	          saveAs(blob, 'export.json');
	        }

	        $scope.importAll = function (fileContents) {
	          var docs;
	          try {
	            docs = JSON.parse(fileContents);
	          } catch (e) {
	            notify.error('The file could not be processed.');
	          }

	          return Promise.map(docs, function (doc) {
	            var service = _.find($scope.services, { type: doc._type }).service;
	            return service.get().then(function (obj) {
	              obj.id = doc._id;
	              return obj.applyESResp(doc).then(function () {
	                return obj.save();
	              });
	            });
	          }).then(refreshIndex).then(refreshData, notify.error);
	        };

	        function refreshIndex() {
	          return es.indices.refresh({
	            index: kbnIndex
	          });
	        }

	        function refreshData() {
	          return getData($scope.advancedFilter);
	        }

	        $scope.changeTab = function (tab) {
	          $scope.currentTab = tab;
	          $scope.selectedItems.length = 0;
	          $state.tab = tab.title;
	          $state.save();
	        };

	        $scope.$watch('advancedFilter', function (filter) {
	          getData(filter);
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 795 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js
	 * A saveAs() FileSaver implementation.
	 * 1.1.20150716
	 *
	 * By Eli Grey, http://eligrey.com
	 * License: X11/MIT
	 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
	 */

	/*global self */
	/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

	/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

	var saveAs = saveAs || (function(view) {
		"use strict";
		// IE <10 is explicitly unsupported
		if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
			return;
		}
		var
			  doc = view.document
			  // only get URL when necessary in case Blob.js hasn't overridden it yet
			, get_URL = function() {
				return view.URL || view.webkitURL || view;
			}
			, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
			, can_use_save_link = "download" in save_link
			, click = function(node) {
				var event = new MouseEvent("click");
				node.dispatchEvent(event);
			}
			, webkit_req_fs = view.webkitRequestFileSystem
			, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
			, throw_outside = function(ex) {
				(view.setImmediate || view.setTimeout)(function() {
					throw ex;
				}, 0);
			}
			, force_saveable_type = "application/octet-stream"
			, fs_min_size = 0
			// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
			// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
			// for the reasoning behind the timeout and revocation flow
			, arbitrary_revoke_timeout = 500 // in ms
			, revoke = function(file) {
				var revoker = function() {
					if (typeof file === "string") { // file is an object URL
						get_URL().revokeObjectURL(file);
					} else { // file is a File
						file.remove();
					}
				};
				if (view.chrome) {
					revoker();
				} else {
					setTimeout(revoker, arbitrary_revoke_timeout);
				}
			}
			, dispatch = function(filesaver, event_types, event) {
				event_types = [].concat(event_types);
				var i = event_types.length;
				while (i--) {
					var listener = filesaver["on" + event_types[i]];
					if (typeof listener === "function") {
						try {
							listener.call(filesaver, event || filesaver);
						} catch (ex) {
							throw_outside(ex);
						}
					}
				}
			}
			, auto_bom = function(blob) {
				// prepend BOM for UTF-8 XML and text/* types (including HTML)
				if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
					return new Blob(["\ufeff", blob], {type: blob.type});
				}
				return blob;
			}
			, FileSaver = function(blob, name, no_auto_bom) {
				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				// First try a.download, then web filesystem, then object URLs
				var
					  filesaver = this
					, type = blob.type
					, blob_changed = false
					, object_url
					, target_view
					, dispatch_all = function() {
						dispatch(filesaver, "writestart progress write writeend".split(" "));
					}
					// on any filesys errors revert to saving with object URLs
					, fs_error = function() {
						// don't create more object URLs than needed
						if (blob_changed || !object_url) {
							object_url = get_URL().createObjectURL(blob);
						}
						if (target_view) {
							target_view.location.href = object_url;
						} else {
							var new_tab = view.open(object_url, "_blank");
							if (new_tab == undefined && typeof safari !== "undefined") {
								//Apple do not allow window.open, see http://bit.ly/1kZffRI
								view.location.href = object_url
							}
						}
						filesaver.readyState = filesaver.DONE;
						dispatch_all();
						revoke(object_url);
					}
					, abortable = function(func) {
						return function() {
							if (filesaver.readyState !== filesaver.DONE) {
								return func.apply(this, arguments);
							}
						};
					}
					, create_if_not_found = {create: true, exclusive: false}
					, slice
				;
				filesaver.readyState = filesaver.INIT;
				if (!name) {
					name = "download";
				}
				if (can_use_save_link) {
					object_url = get_URL().createObjectURL(blob);
					save_link.href = object_url;
					save_link.download = name;
					setTimeout(function() {
						click(save_link);
						dispatch_all();
						revoke(object_url);
						filesaver.readyState = filesaver.DONE;
					});
					return;
				}
				// Object and web filesystem URLs have a problem saving in Google Chrome when
				// viewed in a tab, so I force save with application/octet-stream
				// http://code.google.com/p/chromium/issues/detail?id=91158
				// Update: Google errantly closed 91158, I submitted it again:
				// https://code.google.com/p/chromium/issues/detail?id=389642
				if (view.chrome && type && type !== force_saveable_type) {
					slice = blob.slice || blob.webkitSlice;
					blob = slice.call(blob, 0, blob.size, force_saveable_type);
					blob_changed = true;
				}
				// Since I can't be sure that the guessed media type will trigger a download
				// in WebKit, I append .download to the filename.
				// https://bugs.webkit.org/show_bug.cgi?id=65440
				if (webkit_req_fs && name !== "download") {
					name += ".download";
				}
				if (type === force_saveable_type || webkit_req_fs) {
					target_view = view;
				}
				if (!req_fs) {
					fs_error();
					return;
				}
				fs_min_size += blob.size;
				req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
					fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
						var save = function() {
							dir.getFile(name, create_if_not_found, abortable(function(file) {
								file.createWriter(abortable(function(writer) {
									writer.onwriteend = function(event) {
										target_view.location.href = file.toURL();
										filesaver.readyState = filesaver.DONE;
										dispatch(filesaver, "writeend", event);
										revoke(file);
									};
									writer.onerror = function() {
										var error = writer.error;
										if (error.code !== error.ABORT_ERR) {
											fs_error();
										}
									};
									"writestart progress write abort".split(" ").forEach(function(event) {
										writer["on" + event] = filesaver["on" + event];
									});
									writer.write(blob);
									filesaver.abort = function() {
										writer.abort();
										filesaver.readyState = filesaver.DONE;
									};
									filesaver.readyState = filesaver.WRITING;
								}), fs_error);
							}), fs_error);
						};
						dir.getFile(name, {create: false}, abortable(function(file) {
							// delete file if it already exists
							file.remove();
							save();
						}), abortable(function(ex) {
							if (ex.code === ex.NOT_FOUND_ERR) {
								save();
							} else {
								fs_error();
							}
						}));
					}), fs_error);
				}), fs_error);
			}
			, FS_proto = FileSaver.prototype
			, saveAs = function(blob, name, no_auto_bom) {
				return new FileSaver(blob, name, no_auto_bom);
			}
		;
		// IE 10+ (native saveAs)
		if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
			return function(blob, name, no_auto_bom) {
				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				return navigator.msSaveOrOpenBlob(blob, name || "download");
			};
		}

		FS_proto.abort = function() {
			var filesaver = this;
			filesaver.readyState = filesaver.DONE;
			dispatch(filesaver, "abort");
		};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;

		FS_proto.error =
		FS_proto.onwritestart =
		FS_proto.onprogress =
		FS_proto.onwrite =
		FS_proto.onabort =
		FS_proto.onerror =
		FS_proto.onwriteend =
			null;

		return saveAs;
	}(
		   typeof self !== "undefined" && self
		|| typeof window !== "undefined" && window
		|| this.content
	));
	// `self` is undefined in Firefox for Android content script context
	// while `this` is nsIContentFrameMessageManager
	// with an attribute `content` that corresponds to the window

	if (typeof module !== "undefined" && module.exports) {
	  module.exports.saveAs = saveAs;
	} else if (("function" !== "undefined" && __webpack_require__(461) !== null) && (__webpack_require__(399) != null)) {
	  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    return saveAs;
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}


/***/ },
/* 796 */
/***/ function(module, exports) {

	module.exports = "<kbn-settings-app section=\"objects\">\n  <kbn-settings-objects class=\"container\">\n    <div class=\"header\">\n      <h2 class=\"title\">Edit Saved Objects</h2>\n      <button class=\"btn btn-default controls\" ng-click=\"exportAll()\"><i aria-hidden=\"true\" class=\"fa fa-download\"></i> Export Everything</button>\n      <button file-upload=\"importAll(fileContents)\" class=\"btn btn-default controls\" ng-click><i aria-hidden=\"true\" class=\"fa fa-upload\"></i> Import</button>\n    </div>\n    <p>\n      From here you can delete saved objects, such as saved searches. You can also edit the raw data of saved objects. Typically objects are only modified via their associated application, which is probably what you should use instead of this screen. Each tab is limited to 100 results. You can use the filter to find objects not in the default list.\n    </p>\n    <form role=\"form\">\n      <input aria-label=\"Filter\" ng-model=\"advancedFilter\" class=\"form-control span12\" type=\"text\" placeholder=\"Filter\"/>\n    </form>\n\n    <ul class=\"nav nav-tabs\">\n      <li class=\"kbn-settings-tab\" ng-class=\"{ active: state.tab === service.title }\" ng-repeat=\"service in services\">\n        <a title=\"{{ service.title }}\" ng-click=\"changeTab(service)\">{{ service.title }}\n          <small>\n          ({{service.data.length}}<span ng-show=\"service.total > service.data.length\"> of {{service.total}}</span>)\n          </small>\n        </a>\n      </li>\n    </ul>\n    <div class=\"tab-content\">\n      <div class=\"action-bar\">\n        <label>\n          <input type=\"checkbox\" ng-checked=\"currentTab.data.length > 0 && selectedItems.length == currentTab.data.length\" ng-click=\"toggleAll()\" />\n          Select All\n        </label>\n        <a ng-disabled=\"selectedItems.length == 0\"\n          confirm-click=\"bulkDelete()\"\n          confirmation=\"Are you sure want to delete the selected {{currentTab.title}}? This action is irreversible!\"\n          class=\"btn btn-xs btn-danger\" aria-label=\"Delete\"><i aria-hidden=\"true\" class=\"fa fa-trash\"></i> Delete</a>\n        <a ng-disabled=\"selectedItems.length == 0\"\n          ng-click=\"bulkExport()\"\n          class=\"btn btn-xs btn-default\" aria-label=\"Export\"><i aria-hidden=\"true\" class=\"fa fa-download\"></i> Export</a>\n      </div>\n      <div ng-repeat=\"service in services\" ng-class=\"{ active: state.tab === service.title }\" class=\"tab-pane\">\n        <ul class=\"list-unstyled\">\n          <li class=\"item\" ng-repeat=\"item in service.data | orderBy:'title'\">\n            <div class=\"actions pull-right\">\n              <button\n                ng-click=\"edit(service, item)\"\n                class=\"btn btn-default\"\n                aria-label=\"Edit\">\n                <span class=\"sr-only\">Edit</span>\n                <i aria-hidden=\"true\" class=\"fa fa-pencil\"></i>\n              </button>\n\n              <button\n                ng-click=\"open(item)\"\n                class=\"btn btn-info\"\n                aria-label=\"Hide\">\n                <span class=\"sr-only\">Hide</span>\n                <i aria-hidden=\"true\" class=\"fa fa-eye\"></i>\n              </button>\n            </div>\n\n            <div class=\"pull-left\">\n              <input\n                ng-click=\"toggleItem(item)\"\n                ng-checked=\"selectedItems.indexOf(item) >= 0\"\n                type=\"checkbox\" >\n            </div>\n\n            <div class=\"item-title\">\n              <a ng-click=\"edit(service, item)\">{{ item.title }}</a>\n            </div>\n          </li>\n          <li ng-if=\"!service.data.length\" class=\"empty\">No \"{{service.title}}\" found.</li>\n        </ul>\n      </div>\n    </div>\n\n  </kbn-settings-objects>\n</kbn-settings-app>\n"

/***/ },
/* 797 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(206);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var $ = __webpack_require__(206);

	  module.directive('fileUpload', function ($parse) {
	    return {
	      restrict: 'A',
	      link: function link($scope, $elem, attrs) {
	        var onUpload = $parse(attrs.fileUpload);

	        var $fileInput = $('<input type="file" style="opacity: 0" id="testfile" />');
	        $elem.after($fileInput);

	        $fileInput.on('change', function (e) {
	          var reader = new FileReader();
	          reader.onload = function (e) {
	            $scope.$apply(function () {
	              onUpload($scope, { fileContents: e.target.result });
	            });
	          };

	          var target = e.srcElement || e.target;
	          if (target && target.files && target.files.length) reader.readAsText(target.files[0]);
	        });

	        $elem.on('click', function (e) {
	          $fileInput.val(null);
	          $fileInput.trigger('click');
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 798 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana').directive('confirmClick', function () {
	    return {
	      restrict: 'A',
	      link: function link($scope, $elem, attrs) {
	        $elem.bind('click', function () {
	          var message = attrs.confirmation || 'Are you sure?';
	          if (window.confirm(message)) {
	            // eslint-disable-line no-alert
	            var action = attrs.confirmClick;
	            if (action) {
	              $scope.$apply($scope.$eval(action));
	            }
	          }
	        });

	        $scope.$on('$destroy', function () {
	          $elem.unbind('click');
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 799 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return {
	    order: 3,
	    name: 'status',
	    display: 'Status',
	    url: '/status'
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 800 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(216);
	__webpack_require__(801);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(216).when('/settings/about', {
	    template: __webpack_require__(801)
	  });

	  __webpack_require__(214).get('apps/settings').controller('settingsAbout', function ($scope, kbnVersion, buildNum, buildSha) {
	    $scope.kbnVersion = kbnVersion;
	    $scope.buildNum = buildNum;
	    $scope.buildSha = buildSha;
	  });

	  return {
	    order: Infinity,
	    name: 'about',
	    display: 'About',
	    url: '#/settings/about'
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 801 */
/***/ function(module, exports) {

	module.exports = "<kbn-settings-app section=\"about\">\n  <div class=\"kbn-settings-about container\" ng-controller=\"settingsAbout\">\n    <div class=\"col-md-4 col-md-offset-4 jumbotron\">\n      <center>\n        <img src='/plugins/kibana/settings/sections/about/barcode.svg' alt=\"Kibana Barcode Logo\" width=\"128\" height=\"128\"><br>\n        <h1>Kibana</h1>\n        <p>\n          <table class=\"table table-condensed kbn-settings-about-versions\">\n            <tr>\n              <td>Version</td>\n              <td>{{kbnVersion}}</td>\n            </tr>\n\n            <tr>\n              <td>Build</td>\n              <td>{{buildNum}}</td>\n            </tr>\n\n            <tr>\n              <td>Commit SHA</td>\n              <td>{{buildSha | limitTo:7}}</td>\n            </tr>\n\n          </table>\n        </p>\n        <small> 2015 All Rights Reserved - Elasticsearch</small>\n      </center>\n    </div>\n  </div>\n</kbn-settings-app>\n"

/***/ },
/* 802 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 803 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(214).get('kibana').filter('startFrom', function () {
	    return function (input, start) {
	      if (!input) return [];
	      start = +start; //parse to int
	      return input.slice(start);
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 804 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(192);

	var _require = __webpack_require__(220);

	var NoDefaultIndexPattern = _require.NoDefaultIndexPattern;
	var NoDefinedIndexPatterns = _require.NoDefinedIndexPatterns;

	var Notifier = __webpack_require__(239);
	var notify = new Notifier({
	  location: 'Index Patterns'
	});

	module.exports = function (opts) {
	  opts = opts || {};
	  var notRequiredRe = opts.notRequiredRe || null;
	  var whenMissingRedirectTo = opts.whenMissingRedirectTo || null;
	  var defaultRequiredToasts = null;

	  __webpack_require__(216).addSetupWork(function loadDefaultIndexPattern(Private, Promise, $route, config, indexPatterns) {
	    var getIds = Private(__webpack_require__(502));
	    var rootSearchSource = Private(__webpack_require__(540));
	    var path = _.get($route, 'current.$$route.originalPath');

	    return config.init().then(function () {
	      return getIds();
	    }).then(function (patterns) {
	      var defaultId = config.get('defaultIndex');
	      var defined = !!defaultId;
	      var exists = _.contains(patterns, defaultId);
	      var required = !notRequiredRe || !path.match(notRequiredRe);

	      if (defined && !exists) {
	        config.clear('defaultIndex');
	        defaultId = defined = false;
	      }

	      if (!defined && required) {
	        throw new NoDefaultIndexPattern();
	      }

	      return notify.event('loading default index pattern', function () {
	        return indexPatterns.get(defaultId).then(function (pattern) {
	          rootSearchSource.getGlobalSource().set('index', pattern);
	          notify.log('index pattern set to', defaultId);
	        });
	      });
	    });
	  }).afterWork(
	  // success
	  null,

	  // failure
	  function (err, kbnUrl) {
	    var hasDefault = !(err instanceof NoDefaultIndexPattern);
	    if (hasDefault || !whenMissingRedirectTo) throw err; // rethrow

	    kbnUrl.change(whenMissingRedirectTo);
	    if (!defaultRequiredToasts) defaultRequiredToasts = [];else defaultRequiredToasts.push(notify.error(err));
	  });
	};

/***/ },
/* 805 */
/***/ function(module, exports) {

	module.exports = "<div class=\"app-container\">\n  <nav class=\"navbar navbar-default navbar-static-top subnav\">\n    <div class=\"container-fluid\">\n      <ul class=\"nav navbar-nav\">\n        <li ng-repeat=\"section in sections\" ng-class=\"section.class\">\n          <a class=\"navbar-link\" ng-href=\"{{section.url}}\">{{section.display}}</a>\n        </li>\n      </ul>\n    </div>\n  </nav>\n\n  <div role=\"main\" class=\"settings-section-container {{section.name}}-settings\" ng-transclude></div>\n</div>\n"

/***/ },
/* 806 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(807);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, module, exports) {
	  __webpack_require__(807);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 807 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(308);
	__webpack_require__(496);
	__webpack_require__(458);
	__webpack_require__(500);
	__webpack_require__(214);
	__webpack_require__(808);
	__webpack_require__(216);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);

	  __webpack_require__(308);
	  __webpack_require__(496);
	  __webpack_require__(458);
	  __webpack_require__(500);

	  var app = __webpack_require__(214).get('apps/doc', ['kibana/notify', 'kibana/courier', 'kibana/index_patterns']);

	  var html = __webpack_require__(808);

	  var resolveIndexPattern = {
	    indexPattern: function indexPattern(courier, savedSearches, $route) {
	      return courier.indexPatterns.get($route.current.params.indexPattern);
	    }
	  };

	  __webpack_require__(216).when('/doc/:indexPattern/:index/:type/:id', {
	    template: html,
	    resolve: resolveIndexPattern
	  }).when('/doc/:indexPattern/:index/:type', {
	    template: html,
	    resolve: resolveIndexPattern
	  });

	  app.controller('doc', function ($scope, $route, es, timefilter) {

	    timefilter.enabled = false;

	    // Pretty much only need this for formatting, not actually using it for fetching anything.
	    $scope.indexPattern = $route.current.locals.indexPattern;

	    var computedFields = $scope.indexPattern.getComputedFields();

	    es.search({
	      index: $route.current.params.index,
	      body: {
	        query: {
	          ids: {
	            type: $route.current.params.type,
	            values: [$route.current.params.id]
	          }
	        },
	        fields: computedFields.fields,
	        script_fields: computedFields.scriptFields,
	        fielddata_fields: computedFields.fielddataFields
	      }
	    }).then(function (resp) {
	      if (resp.hits) {
	        if (resp.hits.total < 1) {
	          $scope.status = 'notFound';
	        } else {
	          $scope.status = 'found';
	          $scope.hit = resp.hits.hits[0];
	        }
	      }
	    })['catch'](function (err) {
	      if (err.status === 404) {
	        $scope.status = 'notFound';
	      } else {
	        $scope.status = 'error';
	        $scope.resp = err;
	      }
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 808 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"doc\" class=\"app-container\">\n\n  <div class=\"container-fluid\">\n    <div class=\"row\">\n\n      <!-- no results -->\n      <div class=\"col-md-12\" ng-if=\"status === 'notFound'\">\n          <div class=\"col-md-12\">\n            <h1>Failed to locate document. <i aria-hidden=\"true\" class=\"fa fa-meh-o\"></i></h1>\n\n            <p>\n              Unfortunately I could not find any documents matching that id, of that type, in that index. I tried really hard. I wanted it to be there. Sometimes I swear documents grow legs and just walk out of the index. Sneaky. I wish I could offer some advice here, something to make you feel better\n            </p>\n\n          </div>\n      </div>\n\n            <!-- no results -->\n      <div class=\"col-md-12\" ng-if=\"status === 'error'\">\n          <div class=\"col-md-12\">\n            <h1>This is bad. <i aria-hidden=\"true\" class=\"fa fa-meh-o\"></i></h1>\n\n            <p>\n              Oh no. Something went very wrong. Its not just that I couldn't find your document, I couldn't even try. The index was missing, or the type. Go check out Elasticsearch, something isn't quite right here.\n            </p>\n\n          </div>\n      </div>\n\n      <!-- loading -->\n      <div class=\"col-md-12\" ng-if=\"status === undefined\">\n        <div class=\"discover-overlay\">\n          <h2>Searching</h2>\n          <div class=\"spinner large\"></div>\n          <div ng-show=\"fetchStatus\">{{fetchStatus.complete}}/{{fetchStatus.total}}</div>\n        </div>\n      </div>\n\n      <!-- result -->\n      <div class=\"col-md-12\" ng-if=\"status === 'found'\">\n        <h2><b>Doc:</b> {{hit._index}}/{{hit._type}}/{{hit._id | uriescape}}</h2>\n\n        <doc-viewer hit=\"hit\" index-pattern=\"indexPattern\"></doc-viewer>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 809 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPwAAAAtCAYAAACKyQbtAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAS1wAAEtcBxMSTEgAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABAoSURBVHic7Z15UJPX18e/SUwIxhLCIhEimyBLsY5SQKmiFlusgEBxGctYtWIFBYuidVxw1FdhREstQxm36U9LR+tSFcYFrUyV4oIo1lpQitYGGTUoCkZMCJq8f1gclpDnZkfzfP7j5txzD0+ek+fcc8+9D+P/KkQqqKEwM+lZq7Rvv67tOVMPKEZ4/MtR16edvYxPKv7HiAnq2v68qen8teKjoe1/H37giw/kNppUqaXvtOAHvDlhQiq5hw8f4tNPP9Vavza4u7ujoKCAUm7ChAloaWkBAPj7+2Pbtm0a5evq6pCQkGAQG2lo2mGa2wAdYZjbABqaN5E31eFpaGh0gHZ4GhoLgnZ4GhoLgnZ4GhoLgnZ4GhoLoo+5DXjTaWxsxKZNmyjlFAqFCayhodEM7fB6IpVKUVRUZG4zaGiIoEN6GhoLgn7Cv6FwuVw4OTnB2toaKpUKcrkc9+7dQ1tbm0nG5/F46N+/PwQCAZjMV88NuVwOmUyGBw8evK4qNAf29vbo378/eDwelEolpFIpGhsb8fjxY6OOy2KxYG9vD0dHR1hbWwMAlEolWlpa8PTpU0gkEiiVSqPaQAXt8B0IDQ2FlZUVkWx1dTUkEgn4fD6ioqIo5ffv36+3MwqFQkyaNAmjR4+Gq6vra0drR6lUoq6uDhUVFTh58iRqamr0Gq8jDg4OCAsLQ0hICHx8fGBvb69R/tGjR/jnn39QUVGBixcv4t9//yUaRygUIjg4WKPMjRs3UFtb26nNx8cH0dHRCA0NhaOjo9p+DQ0NuH79Ok6ePIny8nK9nY/JZGL48OEYNWoUhgwZAk9PT/Tp07NLKRQKiMViVFVVoby8HFeuXIFMJtPLBm2hHf4/ZsyYgS+//JJI9tKlSygrKwMACAQCJCUlUfY5cuSIzg7PZDIxe/ZsJCQkgM1ma5Rzd3eHu7s7pkyZgitXriAvLw+3bt3SaVwAcHFxwdy5czFmzBiNN3NXHBwc4ODggODgYCxYsAA1NTU4ePAgSkpKNF4HLy8vLF26VKPubdu2vXZ4Pp+P1NRUREREUNrUv39/hIeHIzw8HPX19diyZQvKy8uJ/6d2mEwmoqKikJCQAGdnZ+J+HA4H3t7e8Pb2RmxsLGQyGYqLi3Hw4EHU1dVpbYcu0HN4AOPHj8fcuXOJZG/cuIFVq1aZLHTm8/n45ptvMGvWLI3Oro7AwEBs374dU6ZM0Wns+Ph4/PjjjwgPD9fK2dXh4+ODlStXoqCgAMOHD9dLVzv29vbIy8sjcvauiEQibNq0Cenp6Vr9b46OjsjPz8fSpUu1cnZ1WFtbIy4uDgUFBUhPTyeOLvXB4h1+6NChWLFiBRgM6v04YrEYS5cuNVkYxuVysXnzZrz//vs662Cz2Vi4cCFRFNKR5ORkpKWlgcPRuDFSa1xcXJCTk4Pw8HC99PTr1w95eXlwd3fXWQeDwUBsbCxWr15N9P27uLhgx44dePfdd3UeUx1MJhOxsbHYsmULuFyuQXV3G8uo2ns5rq6uyMzMJHpyNjQ0YPHixWhubjaBZa9uglWrVsHX19cg+hISEoif9JGRkfjss88MMq46WCwWVq5cqZezLlu2DCKRyCD2jBs3Dp988olGGS6Xi02bNlHmLvQhICAA6enpRtMPWLDD29raIjs7GzY21Pvxm5ubkZ6ejoaGBhNY9gqRSIQxY8YYVOf8+fPh5+enUcbBwQGpqakGHVcdbDYbycnJOvWNiIjA2LFjDWrP7NmzNf7wz5kzBwMHDjTomOqIiIiAj4+P0fRbpMNbWVkhKysLLi4ulLJyuRxff/01cZa5N9OnTx8sW7asW3a/I9OmTQOPxzOJPSNGjOgxo64JfSKDnhAKhQgLC1P7mUAgQHx8vMHHVAeDwcCkSZOMpt/isvRMJhMZGRkICAiglG1ra8PKlStRXV1tAsvIaGpqgkQigVQqBY/Hg4eHh1bzvkGDBiEiIgInTpzo9hmHw0FkZCSlDpVKhd9++w3FxcWoqamBVCoFh8OBQCCAk5MTQkNDER0d/XotuieYTCaCg4Nx7NgxYvvV0dbWhjNnzqCqqgoSiQQqlQqOjo4ICQnBiBEjiJNygYGBKCkp6dYeFRVFPO3bv38/Ll26hIaGBigUCvD5fNja2sLX1xfR0dHw9/en1EO1LKkPFufwSUlJRKGyUqlEZmYmLl26ZAKrNKNSqVBcXIw9e/Z0izQ4HA7GjBmDxMRE4qxxXFycWocPCAjAO++8Q9k/OzsbR48e7dTW1taGlpYW1NfX48qVKygqKsK2bdsoowVPT08im3vi7NmzyMnJUVtUc+TIEfj6+mL9+vVwcnKi1DVs2DC17SNHjqTsW1tbi7S0NDx9+rRT+6NHj/Do0SPcunULx48fx+LFixETE6NRl1AoBI/HM0rxkkWF9HFxcZg+fTqRbG5uLk6fPm1ki6hRKpVYt24dMjMz1U4rFAoFfv31V3zxxRe4du0akU4/Pz94e3t3aydZLrt48WI3Z1eHWCwmenLrkwQrKyvD6tWrNVbQ3bx5ExkZGXj58iWlvgEDBnTL1ltZWVHmPVQqFTZv3tzN2buiVCqxY8cOIlscHBwoZXTBYhx+5MiRSEtLI5LdvXs3fvnlFyNbRMbWrVuJfnhaWlqwfPlyPHz4kEjvhAkTurWRZL0PHz5MpB8A7ty5QylDFfb3xPPnz5GTk0NULXfjxg1cvnyZUo7FYnWLSAYMGEA5JaipqSGe9jU3NxOV+BprTd4iQvrBgwdj7dq1GpNV7RQWFmLnzp0msIoasViMffv2EctLpVJs3boVGRkZlLJDhgzp1iaTyTSW46pUKuIoAgBRGE2y/q2Oo0ePEv+4AcD58+cREhJCKWdjY4Nnz569/rtv376UJcraRIJcLpdoZYjkXtWFt97hnZycsHHjRqInyZkzZ5CTk2MCq8g4fPiw1vXeJSUlWLBgAezs7DTKeXl5gcPhdNqnv3HjRp3sVIenpyfi4uIMpq8rFy9e1Er+3r17RHJdk3PV1dVITEzUaqyeYDKZSElJMUlFXU+81Q7P4XCQnZ1NNB+qrKzEunXrzL6bqSOlpaVa93n58iXOnTuH6OhojXJsNhteXl4GXYGws7ODr68vRo8ejYiICK1LgUl58eIF/vjjD636mKpgqitsNhtubm4IDAzExIkT9U5S6stb7fB8Ph98Pp9I9uHDhyarjyehoaFBq5C1I9evX6d0eAA6rYHz+Xx4eHjA1dUVIpEITk5OEAqFEIlERKGqIWhubtb6u3r+/LmRrHk19x84cCDc3Nzg6uoKoVAIoVCIAQMGwNnZGSwWy2hja8tb7fDa8PHHH6OoqAh//vmnuU0BANy/f1/nvvX19URyJEtwbDYbQUFBGD16NIYOHWqSajMqzPW07oizszPGjRuHoKAg+Pv765x8NDW0w/8Hg8FAWloaEhMTe0VYL5VKde5LtTzUTr9+3d4k9houl4upU6di6tSpxFGSqdDn2uhLQEAAZs+ebdTiGGNCO3wHvL29ERMTo9XSk7HQ56Ym7dvTU8nPzw9r1qzRe/unsVCp1L4O0aiwWCykpKQgPj5e55WF3oDFrMOTkpiY2CueaPpswSWdr6obY9iwYcjNzdXb2R8/fqzT4RK9ERaLhQ0bNmDy5Ml6ObtKpUJZWVmnZT9TQz/hu2BjY4N58+YhOzvbrHboMyck7dv1xnNycsKGDRt03pNdX1+Pa9euobKyEqWlpRg/fjzR2ndvJzk5GR988IFOfeVyOaqrq3H16lWUlZXh1q1bOHTokMbplDGxKIevrKwkKh+NjIxEUVERbt68aQKr1KNPxpskGQd0D/1TUlKI+8pkMlRWVuKvv/5CVVUVamtrzfrkMhZeXl5anRh0584dXL16FVVVVbh58ybq6+t7RU6oHYtx+GPHjmHjxo3IycmhPEGGyWRi0aJFSE5ONtuXpc96rZubG5FcxxJPkUjU4/bQjshkMuzYsQPHjx8368m0pmL69OlEVW8VFRXYuXMnUV2DOXMAFjGHP336NLKzs6FSqfD9998TObG/vz/lKSjGRCgUUlbL9QTJAQpKpbLT4ZZjx46lvLEVCgVSU1Nx4MABImc31bq8sWCz2Rg1ahSlXElJCZYsWUJcxEQaRRmDt97hS0tLsX79+tdO3r5NkYR58+aZba7FYDB0PtWFZPuvWCzulLQjOR+gsLBQq6OvjXkclCkYNGgQ+vbtq1Gmra0N3333HXEk2K9fP7OW1r7VDt/c3Iw1a9Z02464c+dOoiy4QCAwWB21LsTExGi9iSIgIIDoRJiu+QmSnXIVFRVa2UJy2ENvhuSa1NbW4smTJ8Q6zX1N3mqHVygUakswGxsbsWfPHiIdsbGxGDRokKFNI8LT05PoBJp2GAwG8Tlxv//+e6e/ScJMbSrc7OzszH5z6wtJdEda5NQOyRTBmLzVDq+Jn3/+mahWncViYdGiRWZLtCxcuJDyAIZ25s6di/fee49SrqmpCRcuXOjURnIogzY5hcTERKNt8TQVJNdEIBAQ63N2diZ6S5ExebO/ET2Qy+XYvn07kezQoUMxfvx4I1ukHi6Xi2+//RZRUVE9/uhYWVkhLS0NM2bMINJ56tQpvHjxolNbU1MTZT+So56AVy+wIL2xe9PGkq6QXBMvLy+iTUh2dnbIysoi3kForOtiMcty6jh16hSmTJmCwYMHU8rOnz8f586dM+quq57g8XhYtmwZZs6cibNnz6Kurg7Nzc2wsbGBl5cXPvzwQ9ja2hLpam1txYEDB7q1SyQStcdedWTixIm4cOHC69dsdUUoFCIpKUmrl0z0Zod/8OABpQyLxcLy5cuRkZGhduWCyWTio48+QlJSklbHVtEObwSUSiXy8vKQm5tLKevg4IBZs2YhPz/fBJapRygUYtq0aXrp+Omnn9TeyJcvX6acX/bp0wdZWVkoLy9HWVkZ7t+/DzabjYEDByIwMBBBQUFah/G92eFv376NpqYmyh/ToKAg7Nu3D4WFhbh9+zaePXsGgUAAPz8/hIWF6bQNmXZ4I9Fe8kiSTJk8eTKOHTsGsVhsdLtUKpXB8wb379/H3r171X5WVlaGBQsWEIWcISEhBiuZNfSrrAyJUqlEaWkp0TnxfD4fn3/+ucHGNtZ1sdg5fEfy8/O7zWnV0f6eNlNQUVHR7ZXI+iCXy7Fq1Sq0traq/VwikaCoqMhg4wHAiRMnKHe26fL0MyW7d+/u8ZrpwpMnT3D+/HlKOWNdF9rhAdy9exdHjhwhkg0ODjb4K6DU0draihUrVmi1xtsTbW1tWLt2Lf7++2+Ncj/88IPBope9e/ciKyuLMvHl6OgIDw8Pg4xpDBoaGgw2jZNIJEhNTSU6jy8oKMggY3aFdvj/2LVrF/E+8pSUFKO/5RN4lTRauHAhGhsbddbR1NSEr776qsdEW0eePn2KJUuWQCKR6DyeTCbDmjVrkJ+fD5VKRfTe87Vr15r9rDdNHDp0CLt27dJLR3l5OebMmQOxWIy7d+9Syo8bNw4zZ840+Fz+/wEfLobZIrniRAAAAABJRU5ErkJggg=="

/***/ },
/* 810 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(206);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);

	  module.directive('clickFocus', function () {
	    return {
	      scope: {
	        clickFocus: '='
	      },
	      restrict: 'A',
	      link: function link($scope, $elem) {
	        function handler() {
	          var focusElem = $.find('input[name=' + $scope.clickFocus + ']');
	          if (focusElem[0]) focusElem[0].focus();
	        }

	        $elem.bind('click', handler);
	        $scope.$on('$destroy', _.bindKey($elem, 'unbind', 'click', handler));
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 811 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(812);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var html = __webpack_require__(812);

	  __webpack_require__(214).get('kibana').directive('kbnInfo', function () {
	    return {
	      restrict: 'E',
	      scope: {
	        info: '@',
	        placement: '@'
	      },
	      template: html,
	      link: function link($scope) {
	        $scope.placement = $scope.placement || 'top';
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 812 */
/***/ function(module, exports) {

	module.exports = "<i aria-label=\"{{info}}\" class=\"fa fa-info-circle\"\n    tooltip=\"{{info}}\"\n    tooltip-placement=\"{{placement}}\"\n    tooltip-popup-delay=\"250\"></i>"

/***/ },
/* 813 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(814);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  var PER_PAGE_DEFAULT = 10;

	  __webpack_require__(214).get('kibana').directive('paginate', function ($parse, $compile) {
	    return {
	      restrict: 'E',
	      scope: true,
	      link: {
	        pre: function pre($scope, $el, attrs) {
	          if (_.isUndefined(attrs.bottomControls)) attrs.bottomControls = true;
	          if ($el.find('paginate-controls.paginate-bottom').size() === 0 && attrs.bottomControls) {
	            $el.append($compile('<paginate-controls class="paginate-bottom">')($scope));
	          }
	        },
	        post: function post($scope, $el, attrs) {
	          if (_.isUndefined(attrs.topControls)) attrs.topControls = false;
	          if ($el.find('paginate-controls.paginate-top').size() === 0 && attrs.topControls) {
	            $el.prepend($compile('<paginate-controls class="paginate-top">')($scope));
	          }

	          var paginate = $scope.paginate;

	          // add some getters to the controller powered by attributes
	          paginate.getList = $parse(attrs.list);
	          paginate.perPageProp = attrs.perPageProp;

	          if (attrs.perPage) {
	            paginate.perPage = attrs.perPage;
	            $scope.showSelector = false;
	          } else {
	            $scope.showSelector = true;
	          }

	          paginate.otherWidthGetter = $parse(attrs.otherWidth);

	          paginate.init();
	        }
	      },
	      controllerAs: 'paginate',
	      controller: function controller($scope) {
	        var self = this;
	        var ALL = 0;

	        self.sizeOptions = [{ title: '10', value: 10 }, { title: '25', value: 25 }, { title: '100', value: 100 }, { title: 'All', value: ALL }];

	        // setup the watchers, called in the post-link function
	        self.init = function () {

	          self.perPage = _.parseInt(self.perPage) || $scope[self.perPageProp];

	          $scope.$watchMulti(['paginate.perPage', self.perPageProp, self.otherWidthGetter], function (vals, oldVals) {
	            var intChanges = vals[0] !== oldVals[0];
	            var extChanges = vals[1] !== oldVals[1];

	            if (intChanges) {
	              if (!setPerPage(self.perPage)) {
	                // if we are not able to set the external value,
	                // render now, otherwise wait for the external value
	                // to trigger the watcher again
	                self.renderList();
	              }
	              return;
	            }

	            self.perPage = _.parseInt(self.perPage) || $scope[self.perPageProp];
	            if (self.perPage == null) {
	              self.perPage = ALL;
	              return;
	            }

	            self.renderList();
	          });

	          $scope.$watch('page', self.changePage);
	          $scope.$watchCollection(self.getList, function (list) {
	            $scope.list = list;
	            self.renderList();
	          });
	        };

	        self.goToPage = function (number) {
	          if (number) {
	            if (number.hasOwnProperty('number')) number = number.number;
	            $scope.page = $scope.pages[number - 1] || $scope.pages[0];
	          }
	        };

	        self.renderList = function () {
	          $scope.pages = [];
	          if (!$scope.list) return;

	          var perPage = _.parseInt(self.perPage);
	          var count = perPage ? Math.ceil($scope.list.length / perPage) : 1;

	          _.times(count, function (i) {
	            var page;

	            if (perPage) {
	              var start = perPage * i;
	              page = $scope.list.slice(start, start + perPage);
	            } else {
	              page = $scope.list.slice(0);
	            }

	            page.number = i + 1;
	            page.i = i;

	            page.count = count;
	            page.first = page.number === 1;
	            page.last = page.number === count;

	            page.prev = $scope.pages[i - 1];
	            if (page.prev) page.prev.next = page;

	            $scope.pages.push(page);
	          });

	          // set the new page, or restore the previous page number
	          if ($scope.page && $scope.page.i < $scope.pages.length) {
	            $scope.page = $scope.pages[$scope.page.i];
	          } else {
	            $scope.page = $scope.pages[0];
	          }
	        };

	        self.changePage = function (page) {
	          if (!page) {
	            $scope.otherPages = null;
	            return;
	          }

	          // setup the list of the other pages to link to
	          $scope.otherPages = [];
	          var width = +self.otherWidthGetter($scope) || 5;
	          var left = page.i - Math.round((width - 1) / 2);
	          var right = left + width - 1;

	          // shift neg count from left to right
	          if (left < 0) {
	            right += 0 - left;
	            left = 0;
	          }

	          // shift extra right nums to left
	          var lastI = page.count - 1;
	          if (right > lastI) {
	            right = lastI;
	            left = right - width + 1;
	          }

	          for (var i = left; i <= right; i++) {
	            var other = $scope.pages[i];

	            if (!other) continue;

	            $scope.otherPages.push(other);
	            if (other.last) $scope.otherPages.containsLast = true;
	            if (other.first) $scope.otherPages.containsFirst = true;
	          }
	        };

	        function setPerPage(val) {
	          var $ppParent = $scope;

	          while ($ppParent && !_.has($ppParent, self.perPageProp)) {
	            $ppParent = $ppParent.$parent;
	          }

	          if ($ppParent) {
	            $ppParent[self.perPageProp] = val;
	            return true;
	          }
	        }
	      }
	    };
	  }).directive('paginateControls', function () {
	    // this directive is automatically added by paginate if not found within it's $el
	    return {
	      restrict: 'E',
	      template: __webpack_require__(814)
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 814 */
/***/ function(module, exports) {

	module.exports = "<div class=\"pagination-other-pages\">\n  <ul class=\"pagination-other-pages-list pagination-sm\" ng-if=\"page.count > 1\">\n    <li ng-hide=\"page.first\">\n      <a ng-click=\"paginate.goToPage(page.prev)\"></a>\n    </li>\n\n    <li ng-if=\"!otherPages.containsFirst\">\n      <a ng-click=\"paginate.goToPage(1)\">1...</a>\n    </li>\n\n    <li\n      ng-repeat=\"other in otherPages\"\n      ng-class=\"{ active: other.number === page.number }\">\n      <a ng-click=\"paginate.goToPage(other)\">{{other.number}}</a>\n    </li>\n\n    <li ng-if=\"!otherPages.containsLast\">\n      <a ng-click=\"paginate.goToPage(page.count)\">...{{page.count}}</a>\n    </li>\n\n    <li ng-hide=\"page.last\">\n      <a ng-click=\"paginate.goToPage(page.next)\"></a>\n    </li>\n  </ul>\n</div>\n\n<form class=\"form-inline pagination-size\" ng-if=\"showSelector\">\n  <div class=\"form-group\">\n    <label>Page Size</label>\n    <select ng-model=\"paginate.perPage\" ng-options=\"opt.value as opt.title for opt in paginate.sizeOptions\">\n    </select>\n  </div>\n</form>\n"

/***/ },
/* 815 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(228);
	__webpack_require__(226);
	__webpack_require__(485);
	__webpack_require__(487);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var module = __webpack_require__(214).get('kibana');
	  var _ = __webpack_require__(192);
	  var dateMath = __webpack_require__(228);
	  var moment = __webpack_require__(226);

	  __webpack_require__(485);
	  __webpack_require__(487);

	  module.directive('prettyDuration', function (config, quickRanges, timeUnits) {
	    return {
	      restrict: 'E',
	      scope: {
	        from: '=',
	        to: '='
	      },
	      link: function link($scope, $elem) {
	        var dateFormat = config.get('dateFormat');

	        var lookupByRange = {};
	        _.each(quickRanges, function (frame) {
	          lookupByRange[frame.from + ' to ' + frame.to] = frame;
	        });

	        function stringify() {
	          var text;
	          // If both parts are date math, try to look up a reasonable string
	          if ($scope.from && $scope.to && !moment.isMoment($scope.from) && !moment.isMoment($scope.to)) {
	            var tryLookup = lookupByRange[$scope.from.toString() + ' to ' + $scope.to.toString()];
	            if (tryLookup) {
	              $elem.text(tryLookup.display);
	            } else {
	              var fromParts = $scope.from.toString().split('-');
	              if ($scope.to.toString() === 'now' && fromParts[0] === 'now' && fromParts[1]) {
	                var rounded = fromParts[1].split('/');
	                text = 'Last ' + rounded[0];
	                if (rounded[1]) {
	                  text = text + ' rounded to the ' + timeUnits[rounded[1]];
	                }
	                $elem.text(text);
	              } else {
	                cantLookup();
	              }
	            }
	            // If at least one part is a moment, try to make pretty strings by parsing date math
	          } else {
	              cantLookup();
	            }
	        };

	        function cantLookup() {
	          var display = {};
	          _.each(['from', 'to'], function (time) {
	            if (moment.isMoment($scope[time])) {
	              display[time] = $scope[time].format(dateFormat);
	            } else {
	              if ($scope[time] === 'now') {
	                display[time] = 'now';
	              } else {
	                var tryParse = dateMath.parse($scope[time], time === 'to' ? true : false);
	                display[time] = moment.isMoment(tryParse) ? '~ ' + tryParse.fromNow() : $scope[time];
	              }
	            }
	          });
	          $elem.text(display.from + ' to ' + display.to);
	        };

	        $scope.$watch('from', stringify);
	        $scope.$watch('to', stringify);
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 816 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(817);
	__webpack_require__(700);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var $ = __webpack_require__(206);
	  var _ = __webpack_require__(192);
	  var module = __webpack_require__(214).get('kibana');
	  var AggConfigResult = __webpack_require__(817);

	  module.directive('kbnRows', function ($compile, $rootScope, getAppState, Private) {
	    var filterBarClickHandler = Private(__webpack_require__(700));
	    return {
	      restrict: 'A',
	      link: function link($scope, $el, attr) {
	        function addCell($tr, contents) {
	          var $cell = $(document.createElement('td'));

	          // TODO: It would be better to actually check the type of the field, but we don't have
	          // access to it here. This may become a problem with the switch to BigNumber
	          if (_.isNumeric(contents)) $cell.addClass('numeric-value');

	          var createAggConfigResultCell = function createAggConfigResultCell(aggConfigResult) {
	            var $cell = $(document.createElement('td'));
	            var $state = getAppState();
	            var clickHandler = filterBarClickHandler($state);
	            $cell.scope = $scope.$new();
	            $cell.addClass('cell-hover');
	            $cell.attr('ng-click', 'clickHandler($event)');
	            $cell.scope.clickHandler = function (event) {
	              if ($(event.target).is('a')) return; // Don't add filter if a link was clicked
	              clickHandler({ point: { aggConfigResult: aggConfigResult } });
	            };
	            return $compile($cell)($cell.scope);
	          };

	          if (contents instanceof AggConfigResult) {
	            if (contents.type === 'bucket' && contents.aggConfig.field() && contents.aggConfig.field().filterable) {
	              $cell = createAggConfigResultCell(contents);
	            }
	            contents = contents.toString('html');
	          }

	          if (_.isObject(contents)) {
	            if (contents.attr) {
	              $cell.attr(contents.attr);
	            }

	            if (contents['class']) {
	              $cell.addClass(contents['class']);
	            }

	            if (contents.scope) {
	              $cell = $compile($cell.html(contents.markup))(contents.scope);
	            } else {
	              $cell.html(contents.markup);
	            }
	          } else {
	            if (contents === '') {
	              $cell.html('&nbsp;');
	            } else {
	              $cell.html(contents);
	            }
	          }

	          $tr.append($cell);
	        }

	        function maxRowSize(max, row) {
	          return Math.max(max, row.length);
	        }

	        $scope.$watchMulti([attr.kbnRows, attr.kbnRowsMin], function (vals) {
	          var rows = vals[0];
	          var min = vals[1];

	          $el.empty();

	          if (!_.isArray(rows)) rows = [];
	          var width = rows.reduce(maxRowSize, 0);

	          if (isFinite(min) && rows.length < min) {
	            // clone the rows so that we can add elements to it without upsetting the original
	            rows = _.clone(rows);
	            // crate the empty row which will be pushed into the row list over and over
	            var emptyRow = new Array(width);
	            // fill the empty row with values
	            _.times(width, function (i) {
	              emptyRow[i] = '';
	            });
	            // push as many empty rows into the row array as needed
	            _.times(min - rows.length, function () {
	              rows.push(emptyRow);
	            });
	          }

	          rows.forEach(function (row) {
	            var $tr = $(document.createElement('tr')).appendTo($el);
	            row.forEach(function (cell) {
	              addCell($tr, cell);
	            });
	          });
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 817 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  var i = 0;

	  function AggConfigResult(aggConfig, parent, value, key) {
	    this.key = key;
	    this.value = value;
	    this.aggConfig = aggConfig;
	    this.$parent = parent;
	    this.$order = ++i;

	    if (aggConfig.schema.group === 'buckets') {
	      this.type = 'bucket';
	    } else {
	      this.type = 'metric';
	    }
	  }

	  /**
	   * Returns an array of the aggConfigResult and parents up the branch
	   * @returns {array} Array of aggConfigResults
	   */
	  AggConfigResult.prototype.getPath = function () {
	    return (function walk(_x, _x2) {
	      var _again = true;

	      _function: while (_again) {
	        var result = _x,
	            path = _x2;
	        _again = false;

	        path.unshift(result);
	        if (result.$parent) {
	          _x = result.$parent;
	          _x2 = path;
	          _again = true;
	          continue _function;
	        }
	        return path;
	      }
	    })(this, []);
	  };

	  /**
	   * Returns an Elasticsearch filter that represents the result.
	   * @returns {object} Elasticsearch filter
	   */
	  AggConfigResult.prototype.createFilter = function () {
	    return this.aggConfig.createFilter(this.key);
	  };

	  AggConfigResult.prototype.toString = function (contentType) {
	    return this.aggConfig.fieldFormatter(contentType)(this.value);
	  };

	  AggConfigResult.prototype.valueOf = function () {
	    return this.value;
	  };

	  return AggConfigResult;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 818 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var html = '<div class="bounce1"></div> <div class="bounce2"></div> <div class="bounce3"></div>';
	  var module = __webpack_require__(214).get('kibana');

	  module.directive('spinner', function () {
	    return {
	      restrict: 'C',
	      template: html
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 819 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').filter('commaList', function () {
	    /**
	     * Angular filter that accepts either an array or a comma-seperated string
	     * and outputs either an array, or a comma-seperated string for presentation.
	     *
	     * @param {String|Array} input - The comma-seperated list or array
	     * @param {Boolean} inclusive - Should the list be joined with an "and"?
	     * @return {String}
	     */
	    return function (input, inclusive) {
	      var list = _.commaSeperatedList(input);
	      if (list.length < 2) {
	        return list.join('');
	      }

	      var conj = inclusive ? ' and ' : ' or ';
	      return list.slice(0, -1).join(', ') + conj + _.last(list);
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */,
/* 831 */,
/* 832 */,
/* 833 */,
/* 834 */,
/* 835 */,
/* 836 */,
/* 837 */,
/* 838 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(304);
	__webpack_require__(214);
	__webpack_require__(839);
	__webpack_require__(840);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var ConfigTemplate = __webpack_require__(304);

	  __webpack_require__(214).get('kibana').directive('chromeContext', function (timefilter, globalState) {

	    var listenForUpdates = _.once(function ($scope) {
	      $scope.$listen(timefilter, 'update', function (newVal, oldVal) {
	        globalState.time = _.clone(timefilter.time);
	        globalState.refreshInterval = _.clone(timefilter.refreshInterval);
	        globalState.save();
	      });
	    });

	    return {
	      link: function link($scope) {
	        listenForUpdates($scope);

	        // chrome is responsible for timepicker ui and state transfer...
	        $scope.timefilter = timefilter;
	        $scope.pickerTemplate = new ConfigTemplate({
	          filter: __webpack_require__(839),
	          interval: __webpack_require__(840)
	        });

	        $scope.toggleRefresh = function () {
	          timefilter.refreshInterval.pause = !timefilter.refreshInterval.pause;
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 839 */
/***/ function(module, exports) {

	module.exports = "<kbn-timepicker\n  from=\"timefilter.time.from\"\n  to=\"timefilter.time.to\"\n  mode=\"timefilter.time.mode\"\n  active-tab=\"'filter'\"\n  interval=\"timefilter.refreshInterval\">\n</kbn-timepicker>\n"

/***/ },
/* 840 */
/***/ function(module, exports) {

	module.exports = "<kbn-timepicker\n  from=\"timefilter.time.from\"\n  to=\"timefilter.time.to\"\n  mode=\"timefilter.time.mode\"\n  active-tab=\"'interval'\"\n  interval=\"timefilter.refreshInterval\">\n</kbn-timepicker>\n"

/***/ },
/* 841 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);

	  __webpack_require__(214).get('kibana').config(function ($provide) {

	    function strictEquality(a, b) {
	      // are the values equal? or, are they both NaN?
	      return a === b || a !== a && b !== b;
	    }

	    function errorNotAssignable(source, target) {
	      throw Error('Unable to accept change to bound $scope property "' + source + '"' + ' because source expression "' + target + '" is not assignable!');
	    }

	    $provide.decorator('$rootScope', function ($delegate, $parse) {
	      /**
	       * Two-way bind a value from scope to another property on scope. This
	       * allow values on scope that work like they do in an isolate scope, but
	       * without requiring one.
	       *
	       * @param  {expression} to - the location on scope to bind to
	       * @param  {expression} from - the location on scope to bind from
	       * @param  {Scope} $sourceScope - the scope to read "from" expression from
	       * @return {undefined}
	       */
	      $delegate.constructor.prototype.$bind = function (to, from, $sourceScope) {
	        var $source = $sourceScope || this.$parent;
	        var $target = this;

	        // parse expressions
	        var $to = $parse(to);
	        if (!$to.assign) errorNotAssignable(to, from);
	        var $from = $parse(from);

	        // bind scopes to expressions
	        var getTarget = function getTarget() {
	          return $to($target);
	        };
	        var setTarget = function setTarget(v) {
	          return $to.assign($target, v);
	        };
	        var getSource = function getSource() {
	          return $from($source);
	        };
	        var setSource = function setSource(v) {
	          return $from.assignOrFail($source, v);
	        };

	        // to support writing from the child to the parent we need to know
	        // which source has changed. Track the source value and anytime it
	        // changes (even if the target value changed too) push from source
	        // to target. If the source hasn't changed then the change is from
	        // the target and push accordingly
	        var lastSourceVal = getSource();

	        $from.assignOrFail = $from.assign || function () {
	          // revert the change and throw an error, child writes aren't supported
	          $to($target, lastSourceVal = $from($source));
	          errorNotAssignable(from, to);
	        };

	        // if we are syncing down a literal, then we use loose equality check
	        var strict = !$from.literal;
	        var compare = strict ? strictEquality : angular.equals;

	        // push the initial value down, start off in sync
	        setTarget(lastSourceVal);

	        $target.$watch(function () {
	          var sourceVal = getSource();
	          var targetVal = getTarget();

	          var outOfSync = !compare(sourceVal, targetVal);
	          var sourceChanged = outOfSync && !compare(sourceVal, lastSourceVal);

	          if (sourceChanged) setTarget(sourceVal);else if (outOfSync) setSource(targetVal);

	          return lastSourceVal = sourceVal;
	        }, null, !strict);
	      };

	      return $delegate;
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 842 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function BoundToConfigObjProvider($rootScope, config) {
	    var _ = __webpack_require__(192);

	    /**
	     * Create an object with properties that may be bound to config values.
	     * The input object is basically cloned unless one of it's own properties
	     * resolved to a string value that starts with an equal sign. When that is
	     * found, that property is forever bound to the corresponding config key.
	     *
	     * example:
	     *
	     * // name is cloned, height is bound to the defaultHeight config key
	     * { name: 'john', height: '=defaultHeight' };
	     *
	     * @param  {Object} input
	     * @return {Object}
	     */
	    function BoundToConfigObj(input) {
	      var self = this;

	      _.forOwn(input, function (val, prop) {
	        if (!_.isString(val) || val.charAt(0) !== '=') {
	          self[prop] = val;
	          return;
	        }

	        var configKey = val.substr(1);

	        update();
	        $rootScope.$on('init:config', update);
	        $rootScope.$on('change:config.' + configKey, update);
	        function update() {
	          self[prop] = config.get(configKey);
	        }
	      });
	    }

	    return BoundToConfigObj;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 843 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(844);
	__webpack_require__(845);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);

	  var KbnFormController = __webpack_require__(844);
	  var KbnModelController = __webpack_require__(845);

	  __webpack_require__(214).get('kibana').config(function ($provide) {
	    function decorateDirectiveController(DecorativeController) {
	      return function ($delegate, $injector) {
	        // directive providers are arrays
	        $delegate.forEach(function (directive) {
	          // get metadata about all init fns
	          var chain = [directive.controller, DecorativeController].map(function (fn) {
	            var deps = $injector.annotate(fn);
	            return { deps: deps, fn: _.isArray(fn) ? _.last(fn) : fn };
	          });

	          // replace the controller with one that will setup the actual controller
	          directive.controller = function stub() {
	            var allDeps = _.toArray(arguments);
	            return chain.reduce(function (controller, link, i) {
	              var deps = allDeps.splice(0, link.deps.length);
	              return link.fn.apply(controller, deps) || controller;
	            }, this);
	          };

	          // set the deps of our new controller to be the merged deps of every fn
	          directive.controller.$inject = chain.reduce(function (deps, link) {
	            return deps.concat(link.deps);
	          }, []);
	        });

	        return $delegate;
	      };
	    }

	    $provide.decorator('formDirective', decorateDirectiveController(KbnFormController));
	    $provide.decorator('ngFormDirective', decorateDirectiveController(KbnFormController));
	    $provide.decorator('ngModelDirective', decorateDirectiveController(KbnModelController));
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 844 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  /**
	   * Extension of Angular's FormController class
	   * that provides helpers for error handling/validation.
	   *
	   * @param {$scope} $scope
	   */
	  function KbnFormController($scope, $element) {
	    var self = this;

	    self.errorCount = function (predicate) {
	      return self.$$invalidModels().length;
	    };

	    // same as error count, but filters out untouched and pristine models
	    self.softErrorCount = function () {
	      return self.$$invalidModels(function (model) {
	        return model.$touched || model.$dirty;
	      }).length;
	    };

	    self.describeErrors = function () {
	      var count = self.softErrorCount();
	      return count + ' Error' + (count === 1 ? '' : 's');
	    };

	    self.$$invalidModels = function (predicate) {
	      predicate = _.callback(predicate);

	      var invalid = [];

	      _.forOwn(self.$error, function collect(models) {
	        if (!models) return;

	        models.forEach(function (model) {
	          if (model.$$invalidModels) {
	            // recurse into child form
	            _.forOwn(model.$error, collect);
	          } else {
	            if (predicate(model)) {
	              // prevent dups
	              var len = invalid.length;
	              while (len--) if (invalid[len] === model) return;

	              invalid.push(model);
	            }
	          }
	        });
	      });

	      return invalid;
	    };

	    self.$setTouched = function () {
	      self.$$invalidModels().forEach(function (model) {
	        // only kbnModels have $setTouched
	        if (model.$setTouched) model.$setTouched();
	      });
	    };

	    function filterSubmits(event) {
	      if (self.errorCount()) {
	        event.preventDefault();
	        event.stopImmediatePropagation();
	        self.$setTouched();
	      }
	    }

	    $element.on('submit', filterSubmits);
	    $scope.$on('$destroy', function () {
	      $element.off('submit', filterSubmits);
	    });
	  }

	  return KbnFormController;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 845 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var angular = __webpack_require__(209);
	  var PRISTINE_CLASS = 'ng-pristine';
	  var DIRTY_CLASS = 'ng-dirty';
	  var UNTOUCHED_CLASS = 'ng-untouched';
	  var TOUCHED_CLASS = 'ng-touched';

	  // http://goo.gl/eJofve
	  var nullFormCtrl = {
	    $addControl: _.noop,
	    $removeControl: _.noop,
	    $setValidity: _.noop,
	    $setDirty: _.noop,
	    $setPristine: _.noop
	  };

	  /**
	   * Extension of Angular's NgModelController class
	   * that ensures models are marked "dirty" after
	   * they move from an invalid state to valid.
	   *
	   * @param {$scope} $scope
	   */
	  function KbnModelController($scope, $element, $animate) {
	    var ngModel = this;

	    // verify that angular works the way we are assuming it does
	    if (angular.version.full !== '1.2.28') {
	      throw new Error('angular version has updated but KbnModelController has not!');
	    }

	    /**
	     * Get the form a model belongs to
	     *
	     * @return {NgFormController} - the parent controller of a noop controller
	     */
	    ngModel.$getForm = function () {
	      return $element.inheritedData('$formController') || nullFormCtrl;
	    };

	    /**
	     * Update the ngModel to be "dirty" if it is pristine.
	     *
	     * @return {undefined}
	     */
	    ngModel.$setDirty = function () {
	      ngModel.$setTouched();
	      $$setDirty();
	    };

	    function $$setDirty() {
	      if (ngModel.$dirty) return;

	      ngModel.$dirty = true;
	      ngModel.$pristine = false;
	      $animate.removeClass($element, PRISTINE_CLASS);
	      $animate.addClass($element, DIRTY_CLASS);
	      ngModel.$getForm().$setDirty();
	    }

	    ngModel.$setTouched = toggleTouched(true);
	    ngModel.$setUntouched = toggleTouched(false);
	    function toggleTouched(val) {
	      return function () {
	        if (ngModel.$touched === val) return;

	        ngModel.$touched = val;
	        ngModel.$untouched = !val;
	        $animate.addClass($element, val ? TOUCHED_CLASS : UNTOUCHED_CLASS);
	        $animate.removeClass($element, val ? UNTOUCHED_CLASS : TOUCHED_CLASS);
	      };
	    }

	    /**
	     * While the model is pristine, ensure that the model
	     * gets set to dirty if it becomes invalid. If the model
	     * becomes dirty of other reasons stop watching and
	     * waitForPristine()
	     *
	     * @return {undefined}
	     */
	    function watchForDirtyOrInvalid() {
	      var unwatch = $scope.$watch(get, react);

	      function get() {
	        return ngModel.$dirty || ngModel.$invalid;
	      }

	      function react(is, was) {
	        if (is === was) return;
	        unwatch();
	        waitForPristine();
	        $$setDirty();
	      }
	    }

	    /**
	     * Once a model becomes dirty, there is no longer a need
	     * for a watcher. Instead, we will react to the $setPristine
	     * method being called. This is the only way for a model to go
	     * from dirty -> pristine.
	     *
	     * @return {[type]} [description]
	     */
	    function waitForPristine() {
	      var fn = ngModel.$setPristine;
	      ngModel.$setPristine = function () {
	        var ret = fn.apply(this, arguments);
	        if (ngModel.$pristine) {
	          ngModel.$setPristine = fn;
	          watchForDirtyOrInvalid();
	        }
	        return ret;
	      };
	    }

	    ngModel.$setUntouched();
	    $element.one('blur', function () {
	      ngModel.$setTouched();
	      $scope.$apply();
	    });
	    $scope.$on('$destroy', function () {
	      $element.off('blur', ngModel.$setTouched);
	    });

	    // wait for child scope to init before watching validity
	    $scope.$evalAsync(function () {
	      if (ngModel.$dirty) waitForPristine();else watchForDirtyOrInvalid();
	    });
	  }

	  return KbnModelController;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 846 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(847);
	__webpack_require__(226);
	__webpack_require__(658);
	__webpack_require__(848);
	__webpack_require__(849);
	__webpack_require__(850);
	__webpack_require__(851);
	__webpack_require__(852);
	__webpack_require__(652);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var module = __webpack_require__(214).get('kibana');
	  var template = __webpack_require__(847);
	  var moment = __webpack_require__(226);

	  module.directive('filterBar', function (Private, Promise, getAppState) {
	    var mapAndFlattenFilters = Private(__webpack_require__(658));
	    var mapFlattenAndWrapFilters = Private(__webpack_require__(848));
	    var extractTimeFilter = Private(__webpack_require__(849));
	    var filterOutTimeBasedFilter = Private(__webpack_require__(850));
	    var filterAppliedAndUnwrap = __webpack_require__(851);
	    var changeTimeFilter = Private(__webpack_require__(852));
	    var queryFilter = Private(__webpack_require__(652));

	    return {
	      restrict: 'E',
	      template: template,
	      scope: {},
	      link: function link($scope, $el, attrs) {
	        // bind query filter actions to the scope
	        ['addFilters', 'toggleFilter', 'toggleAll', 'pinFilter', 'pinAll', 'invertFilter', 'invertAll', 'removeFilter', 'removeAll'].forEach(function (method) {
	          $scope[method] = queryFilter[method];
	        });

	        $scope.state = getAppState();

	        $scope.applyFilters = function (filters) {
	          // add new filters
	          $scope.addFilters(filterAppliedAndUnwrap(filters));
	          $scope.newFilters = [];

	          // change time filter
	          if ($scope.changeTimeFilter && $scope.changeTimeFilter.meta && $scope.changeTimeFilter.meta.apply) {
	            changeTimeFilter($scope.changeTimeFilter);
	          }
	        };

	        $scope.clearFilterBar = function () {
	          $scope.newFilters = [];
	          $scope.changeTimeFilter = null;
	        };

	        // update the scope filter list on filter changes
	        $scope.$listen(queryFilter, 'update', function () {
	          updateFilters();
	        });

	        // when appState changes, update scope's state
	        $scope.$watch(getAppState, function (appState) {
	          $scope.state = appState;
	        });

	        $scope.$watch('state.$newFilters', function (filters) {
	          if (!filters) return;

	          // If filters is not undefined and the length is greater than
	          // one we need to set the newFilters attribute and allow the
	          // users to decide what they want to apply.
	          if (filters.length > 1) {
	            return mapFlattenAndWrapFilters(filters).then(function (results) {
	              extractTimeFilter(results).then(function (filter) {
	                $scope.changeTimeFilter = filter;
	              });
	              return results;
	            }).then(filterOutTimeBasedFilter).then(function (results) {
	              $scope.newFilters = results;
	            });
	          }

	          // Just add single filters to the state.
	          if (filters.length === 1) {
	            Promise.resolve(filters).then(function (filters) {
	              extractTimeFilter(filters).then(function (timeFilter) {
	                if (timeFilter) changeTimeFilter(timeFilter);
	              });
	              return filters;
	            }).then(filterOutTimeBasedFilter).then($scope.addFilters);
	          }
	        });

	        function updateFilters() {
	          var filters = queryFilter.getFilters();
	          mapAndFlattenFilters(filters).then(function (results) {
	            // used to display the current filters in the state
	            $scope.filters = _.sortBy(results, function (filter) {
	              return !filter.meta.pinned;
	            });
	            $scope.$emit('filterbar:updated');
	          });
	        }

	        updateFilters();
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 847 */
/***/ function(module, exports) {

	module.exports = "<div class=\"confirm\" ng-show=\"newFilters.length\">\n  <form ng-submit=\"applyFilters(newFilters)\">\n  <ul class=\"list-unstyled\">\n    <li>Apply these filters?</li>\n    <li ng-repeat=\"filter in newFilters\" class=\"filter\" ng-click=\"filter.meta.apply = !filter.meta.apply\"><input type=\"checkbox\" ng-checked=\"filter.meta.apply\"/> {{ filter.meta.key }}: {{ filter.meta.value }}</li>\n    <li ng-if=\"changeTimeFilter\" class=\"changeTimeFilter filter\" ng-click=\"changeTimeFilter.meta.apply = !changeTimeFilter.meta.apply\"><input type=\"checkbox\" ng-checked=\"changeTimeFilter.meta.apply\"/> <strong>Change time to:</strong> {{changeTimeFilter.meta.value}} </li>\n    <li><button class=\"btn btn-xs btn-primary\">Apply Now</button> or <a ng-click=\"clearFilterBar();\">Cancel</a></li>\n  </ul>\n  </form>\n</div>\n\n<div class=\"bar\" ng-show=\"filters.length\">\n  <div class=\"filter\" ng-class=\"{ negate: filter.meta.negate, disabled: filter.meta.disabled }\" ng-repeat=\"filter in filters\">\n    <div class=\"filter-description\">\n      <span ng-if=\"filter.$state.store == 'globalState'\"><i class=\"fa fa-fw fa-thumb-tack pinned\"></i></span>\n      <span>{{ filter.meta.key }}:</span>\n      <span>\"{{ filter.meta.value }}\"</span>\n    </div>\n    <div class=\"filter-actions\">\n      <a class=\"action filter-toggle\" ng-click=\"toggleFilter(filter)\">\n        <i ng-show=\"filter.meta.disabled\" class=\"fa fa-fw fa-square-o disabled\"></i>\n        <i ng-hide=\"filter.meta.disabled\" class=\"fa fa-fw fa-check-square-o enabled\"></i>\n      </a>\n      <a class=\"action filter-pin\" ng-click=\"pinFilter(filter)\">\n        <i ng-show=\"filter.$state.store == 'globalState'\" class=\"fa fa-fw fa-thumb-tack pinned\"></i>\n        <i ng-hide=\"filter.$state.store == 'globalState'\" class=\"fa fa-fw fa-thumb-tack fa-rotate-270 unpinned\"></i>\n      </a>\n      <a class=\"action filter-invert\" ng-click=\"invertFilter(filter)\">\n        <i ng-show=\"filter.meta.negate\" class=\"fa fa-fw fa-search-plus negative\"></i>\n        <i ng-hide=\"filter.meta.negate\" class=\"fa fa-fw fa-search-minus positive\"></i>\n      </a>\n      <a class=\"action filter-remove\" ng-click=\"removeFilter(filter)\">\n        <i class=\"fa fa-fw fa-trash\"></i>\n      </a>\n    </div>\n  </div>\n  <div class=\"filter-link\">\n    <div class=\"filter-description small\">\n      <a ng-click=\"showFilterActions = !showFilterActions\">\n        Actions\n        <i class=\"fa\"\n        ng-class=\"{'fa-caret-down': showFilterActions, 'fa-caret-right': !showFilterActions}\"></i>\n      </a>\n    </div>\n  </div>\n</div>\n\n<div class=\"bar bar-condensed\" ng-show=\"filters.length && showFilterActions\">\n  <div class=\"filter-actions-all\">\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><strong>All filters:</strong></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"toggleAll(false)\">Enable</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"toggleAll(true)\">Disable</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"pinAll(true)\">Pin</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"pinAll(false)\">Unpin</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"invertAll()\">Invert</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"toggleAll()\">Toggle</a></div>\n    </div>\n    <div class=\"filter-link\">\n      <div class=\"filter-description\"><a ng-click=\"removeAll()\">Remove</a></div>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 848 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(658);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function mapFlattenAndWrapFilters(Private) {
	    var mapAndFlattenFilters = Private(__webpack_require__(658));
	    return function (filters) {
	      return mapAndFlattenFilters(filters).then(function (filters) {
	        return _.map(filters, function (filter) {
	          filter.meta = filter.meta || {};
	          filter.meta.apply = true;
	          return filter;
	        });
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 849 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function extractTimeFilterProvider(courier, Promise) {
	    return Promise.method(function (filters) {
	      // Assume all the index patterns are the same since they will be added
	      // from the same visualization.
	      var id = _.get(filters, '[0].meta.index');
	      if (id == null) return;

	      return courier.indexPatterns.get(id).then(function (indexPattern) {
	        var filter = _.find(filters, function (obj) {
	          var key = _.keys(obj.range)[0];
	          return key === indexPattern.timeFieldName;
	        });
	        if (filter && filter.range) {
	          return filter;
	        }
	      });
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 850 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function filterOutTimeBaseFilter(courier, Promise) {
	    return Promise.method(function (filters) {
	      var id = _.get(filters, '[0].meta.index');
	      if (id == null) return;

	      return courier.indexPatterns.get(id).then(function (indexPattern) {
	        return _.filter(filters, function (filter) {
	          return !(filter.range && filter.range[indexPattern.timeFieldName]);
	        });
	      });
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 851 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function (filters) {
	    return _.filter(filters, 'meta.apply');
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 852 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var moment = __webpack_require__(226);
	  var _ = __webpack_require__(192);
	  return function changeTimeFilterProvider(timefilter) {
	    return function (filter) {
	      var key = _.keys(filter.range)[0];
	      var values = filter.range[key];
	      timefilter.time.from = moment(values.gt || values.gte);
	      timefilter.time.to = moment(values.lt || values.lte);
	      timefilter.time.mode = 'absolute';
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 853 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').run(function ($rootScope) {

	    /**
	     * Helper that registers an event listener, and removes that listener when
	     * the $scope is destroyed.
	     *
	     * @param  {EventEmitter} emitter - the event emitter to listen to
	     * @param  {string} eventName - the event name
	     * @param  {Function} handler - the event handler
	     * @return {undefined}
	     */
	    $rootScope.constructor.prototype.$listen = function (emitter, eventName, handler) {
	      emitter.on(eventName, handler);
	      this.$on('$destroy', function () {
	        emitter.off(eventName, handler);
	      });
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 854 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var modules = __webpack_require__(214);
	  var _ = __webpack_require__(192);

	  modules.get('kibana/persisted_log').factory('PersistedLog', function ($window, localStorage) {
	    function PersistedLog(name, options) {
	      options = options || {};
	      this.name = name;
	      this.maxLength = parseInt(options.maxLength, 10);
	      this.filterDuplicates = options.filterDuplicates || false;
	      this.items = localStorage.get(this.name) || [];
	      if (!isNaN(this.maxLength)) this.items = _.take(this.items, this.maxLength);
	    }

	    PersistedLog.prototype.add = function (val) {
	      if (val == null) {
	        return this.items;
	      }

	      // remove any matching items from the stack if option is set
	      if (this.filterDuplicates) {
	        _.remove(this.items, function (item) {
	          return _.isEqual(item, val);
	        });
	      }

	      this.items.unshift(val);

	      // if maxLength is set, truncate the stack
	      if (!isNaN(this.maxLength)) this.items = _.take(this.items, this.maxLength);

	      // persist the stack
	      localStorage.set(this.name, this.items);
	      return this.items;
	    };

	    PersistedLog.prototype.get = function () {
	      return this.items;
	    };

	    return PersistedLog;
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 855 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var modules = __webpack_require__(214);
	  var angular = __webpack_require__(209);

	  function Storage(store) {
	    var self = this;
	    self.store = store;

	    self.get = function (key) {
	      try {
	        return JSON.parse(self.store.getItem(key));
	      } catch (e) {
	        return null;
	      }
	    };

	    self.set = function (key, value) {
	      try {
	        return self.store.setItem(key, angular.toJson(value));
	      } catch (e) {
	        return false;
	      }
	    };

	    self.remove = function (key) {
	      return self.store.removeItem(key);
	    };

	    self.clear = function () {
	      return self.store.clear();
	    };
	  }

	  var createService = function createService(type) {
	    return function ($window) {
	      return new Storage($window[type]);
	    };
	  };

	  modules.get('kibana/storage').service('localStorage', createService('localStorage')).service('sessionStorage', createService('sessionStorage'));
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 856 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(443);
	__webpack_require__(857);
	__webpack_require__(863);
	__webpack_require__(869);
	__webpack_require__(871);
	__webpack_require__(872);
	__webpack_require__(873);
	__webpack_require__(874);
	__webpack_require__(876);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var fieldFormats = __webpack_require__(443);
	  fieldFormats.register(__webpack_require__(857));
	  fieldFormats.register(__webpack_require__(863));
	  fieldFormats.register(__webpack_require__(869));
	  fieldFormats.register(__webpack_require__(871));
	  fieldFormats.register(__webpack_require__(872));
	  fieldFormats.register(__webpack_require__(873));
	  fieldFormats.register(__webpack_require__(874));
	  fieldFormats.register(__webpack_require__(876));
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 857 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(436);
	__webpack_require__(858);
	__webpack_require__(862);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function UrlFormatProvider(Private, highlightFilter) {
	    var _ = __webpack_require__(192);

	    var FieldFormat = Private(__webpack_require__(436));
	    __webpack_require__(858);

	    _['class'](Url).inherits(FieldFormat);
	    function Url(params) {
	      Url.Super.call(this, params);
	      this._compileTemplate = _.memoize(this._compileTemplate);
	    }

	    Url.id = 'url';
	    Url.title = 'Url';
	    Url.fieldType = ['number', 'boolean', 'date', 'ip', 'string', 'murmur3', 'unknown', 'conflict'];

	    Url.editor = {
	      template: __webpack_require__(862),
	      controllerAs: 'url',
	      controller: function controller($scope) {
	        var iconPattern = 'ui/stringify/icons/{{value}}.png';

	        this.samples = {
	          a: ['john', '/some/pathname/asset.png', 1234],
	          img: ['go', 'stop', ['de', 'ne', 'us', 'ni'], 'cv']
	        };

	        $scope.$watch('editor.formatParams.type', function (type, prev) {
	          var params = $scope.editor.formatParams;
	          if (type === 'img' && type !== prev && !params.urlTemplate) {
	            params.urlTemplate = iconPattern;
	          }
	        });
	      }
	    };

	    Url.templateMatchRE = /{{([\s\S]+?)}}/g;
	    Url.paramDefaults = {
	      type: 'a',
	      urlTemplate: null,
	      labelTemplate: null
	    };

	    Url.urlTypes = [{ id: 'a', name: 'Link' }, { id: 'img', name: 'Image' }];

	    Url.prototype._formatUrl = function (value) {
	      var template = this.param('urlTemplate');
	      if (!template) return value;

	      return this._compileTemplate(template)({
	        value: encodeURIComponent(value),
	        rawValue: value
	      });
	    };

	    Url.prototype._formatLabel = function (value, url) {
	      var template = this.param('labelTemplate');
	      if (url == null) url = this._formatUrl(value);
	      if (!template) return url;

	      return this._compileTemplate(template)({
	        value: value,
	        url: url
	      });
	    };

	    Url.prototype._convert = {
	      text: function text(value) {
	        return this._formatLabel(value);
	      },

	      html: function html(rawValue, field, hit) {
	        var url = _.escape(this._formatUrl(rawValue));
	        var label = _.escape(this._formatLabel(rawValue, url));

	        switch (this.param('type')) {
	          case 'img':
	            return '<img src="' + url + '" alt="' + label + '" title="' + label + '">';
	          default:
	            if (hit && hit.highlight && hit.highlight[field.name]) {
	              label = highlightFilter(label, hit.highlight[field.name]);
	            }

	            return '<a href="' + url + '" target="_blank">' + label + '</a>';
	        }
	      }
	    };

	    Url.prototype._compileTemplate = function (template) {
	      var parts = template.split(Url.templateMatchRE).map(function (part, i) {
	        // trim all the odd bits, the variable names
	        return i % 2 ? part.trim() : part;
	      });

	      return function (locals) {
	        // replace all the odd bits with their local var
	        var output = '';
	        var i = -1;
	        while (++i < parts.length) {
	          if (i % 2) {
	            if (locals.hasOwnProperty(parts[i])) {
	              var local = locals[parts[i]];
	              output += local == null ? '' : local;
	            }
	          } else {
	            output += parts[i];
	          }
	        }

	        return output;
	      };
	    };

	    return Url;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 858 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(859);
	__webpack_require__(214);
	__webpack_require__(861);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(859);

	  __webpack_require__(214).get('kibana').directive('fieldFormatEditorPattern', function () {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(861),
	      require: ['ngModel', '^fieldEditor'],
	      scope: true,
	      link: function link($scope, $el, attrs, cntrls) {
	        var ngModelCntrl = cntrls[0];

	        $scope.$bind('inputs', attrs.inputs);
	        $scope.$bind('placeholder', attrs.placeholder);

	        // bind our local model with the outside ngModel
	        $scope.$watch('model', ngModelCntrl.$setViewValue);
	        ngModelCntrl.$render = function () {
	          $scope.model = ngModelCntrl.$viewValue;
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 859 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(860);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').directive('fieldFormatEditorSamples', function ($sce, Promise) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(860),
	      require: ['?^ngModel', '^fieldEditor'],
	      scope: true,
	      link: function link($scope, $el, attrs, cntrls) {
	        var ngModelCntrl = cntrls[0];

	        $scope.samples = null;
	        $scope.$bind('inputs', attrs.inputs);

	        $scope.$watchMulti(['editor.field.format', '[]inputs'], function () {
	          $scope.samples = null;
	          var field = $scope.editor.field;

	          if (!field || !field.format) {
	            return;
	          }

	          Promise['try'](function () {
	            var converter = field.format.getConverterFor('html');
	            $scope.samples = _.map($scope.inputs, function (input) {
	              return [input, $sce.trustAsHtml(converter(input))];
	            });
	          }).then(validity, validity);
	        });

	        function validity(err) {
	          $scope.error = err;
	          ngModelCntrl && ngModelCntrl.$setValidity('patternExecutes', !err);
	        }
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 860 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group hintbox\" ng-if=\"error\">\n  <h4 class=\"hintbox-heading\">\n    <i class=\"fa fa-danger text-danger\"></i> Format error\n  </h4>\n  <p>\n    An error occured while trying to use this format configuration.\n  </p>\n  <pre>{{ error.message }}</pre>\n</div>\n\n<div class=\"form-group\" ng-if=\"samples\">\n  <hr>\n  <label>Samples</label>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th>\n          Input\n        </th>\n        <th>\n          Formatted\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-repeat=\"sample in samples\">\n        <td ng-bind=\"sample[0]\"></td>\n        <td ng-bind-html=\"sample[1]\"></td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n"

/***/ },
/* 861 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <input\n    ng-model=\"model\"\n    placeholder=\"{{ placeholder }}\"\n    class=\"form-control\">\n</div>\n\n<field-format-editor-samples\n  ng-model=\"model\"\n  inputs=\"inputs\">\n</field-format-editor-samples>\n"

/***/ },
/* 862 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Type</label>\n  <select\n    ng-model=\"editor.formatParams.type\"\n    ng-options=\"type.id as type.name for type in editor.field.format.type.urlTypes\"\n    class=\"form-control\">\n  </select>\n</div>\n\n<div class=\"form-group\">\n  <span class=\"pull-right text-info hintbox-label\" ng-click=\"editor.showUrlTmplHelp = !editor.showUrlTmplHelp\">\n    <i class=\"fa fa-info\"></i> Url Template Help\n  </span>\n\n  <label>Url Template</label>\n  <div class=\"hintbox\" ng-if=\"editor.showUrlTmplHelp\">\n    <h4 class=\"hintbox-heading\">\n      <i class=\"fa fa-question-circle text-info\"></i> Url Template Help\n    </h4>\n\n    <p>\n      If a field only contains part of a url then a \"Url Template\" can be used to format the value as a complete url. The format is a string which uses double curly brace notation <code>{&shy;{ }&shy;}</code> to inject values. The following values can be accessed:\n    </p>\n\n    <ul>\n      <li>\n        <strong>value</strong> &mdash; The uri-escaped value\n      </li>\n      <li>\n        <strong>rawValue</strong> &mdash; The unescaped value\n      </li>\n    </ul>\n\n    <table class=\"table table-striped table-bordered\">\n      <caption>Examples</caption>\n      <thead>\n        <tr>\n          <th>Value</th>\n          <th>Template</th>\n          <th>Result</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>1234</td>\n          <td>http://company.net/profiles?user_id={&shy;{value}&shy;}</td>\n          <td>http://company.net/profiles?user_id=1234</td>\n        </tr>\n        <tr>\n          <td>users/admin</td>\n          <td>http://company.net/groups?id={&shy;{value}&shy;}</td>\n          <td>http://company.net/groups?id=users%2Fadmin</td>\n        </tr>\n        <tr>\n          <td>/images/favicon.ico</td>\n          <td>http://www.site.com{&shy;{rawValue}&shy;}</td>\n          <td>http://www.site.com/images/favicon.ico</td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n\n  <input ng-model=\"editor.formatParams.urlTemplate\" class=\"form-control\">\n</div>\n\n<div class=\"form-group\">\n  <span class=\"pull-right text-info hintbox-label\" ng-click=\"editor.showLabelTmplHelp = !editor.showLabelTmplHelp\">\n    <i class=\"fa fa-info\"></i> Label Template Help\n  </span>\n\n  <label>Label Template</label>\n  <div class=\"hintbox\" ng-if=\"editor.showLabelTmplHelp\">\n    <h4 class=\"hintbox-heading\">\n      <i class=\"fa fa-question-circle text-info\"></i> Label Template Help\n    </h4>\n\n    <p>\n      If the url in this field is large, it might be useful to provide an alternate template for the text version of the url. This will be displayed instead of the url, but will still link to the url. The format is a string which uses double curly brace notation <code>{&shy;{ }&shy;}</code> to inject values. The following values can be accessed:\n    </p>\n\n    <ul>\n      <li>\n        <strong>value</strong> &mdash; The fields value\n      </li>\n      <li>\n        <strong>url</strong> &mdash; The formatted url\n      </li>\n    </ul>\n\n    <table class=\"table table-striped table-bordered\">\n      <caption>Examples</caption>\n      <thead>\n        <tr>\n          <th>Value</th>\n          <th>Url Template</th>\n          <th>Label Template</th>\n          <th>Result</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>1234</td>\n          <td>http://company.net/profiles?user_id={&shy;{value}&shy;}</td>\n          <td>User #{&shy;{value}&shy;}</td>\n          <td>\n            <a href=\"http://company.net/profiles?user_id=1234\">User #1234</a>\n          </td>\n        </tr>\n        <tr>\n          <td>/assets/main.css</td>\n          <td>http://site.com{&shy;{rawValue}&shy;}</td>\n          <td>View Asset</td>\n          <td>\n            <a href=\"http://site.com/assets/main.css\">View Asset</a>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n\n  <input ng-model=\"editor.formatParams.labelTemplate\" class=\"form-control\">\n</div>\n\n<field-format-editor-samples inputs=\"url.samples[editor.formatParams.type]\"></field-format-editor-samples>\n"

/***/ },
/* 863 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(864);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function BytesFormatProvider(Private) {
	    var Numeral = Private(__webpack_require__(864));
	    return Numeral.factory({
	      id: 'bytes',
	      title: 'Bytes',
	      sampleInputs: [1024, 5150000, 1990000000]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 864 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(436);
	__webpack_require__(842);
	__webpack_require__(865);
	__webpack_require__(867);
	__webpack_require__(868);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AbstractNumeralFormatProvider(Private) {
	    var _ = __webpack_require__(192);
	    var FieldFormat = Private(__webpack_require__(436));
	    var BoundToConfigObj = Private(__webpack_require__(842));
	    var numeral = __webpack_require__(865)();
	    __webpack_require__(867);

	    _['class'](Numeral).inherits(FieldFormat);
	    function Numeral(params) {
	      Numeral.Super.call(this, params);
	    }

	    Numeral.prototype._convert = function (val) {
	      if (val === -Infinity) return '-';
	      if (val === +Infinity) return '+';
	      if (typeof val !== 'number') {
	        val = parseFloat(val);
	      }

	      if (isNaN(val)) return '';

	      return numeral.set(val).format(this.param('pattern'));
	    };

	    Numeral.factory = function (opts) {
	      _['class'](Class).inherits(Numeral);
	      function Class(params) {
	        Class.Super.call(this, params);
	      }

	      Class.id = opts.id;
	      Class.title = opts.title;
	      Class.fieldType = 'number';

	      Class.paramDefaults = opts.paramDefaults || new BoundToConfigObj({
	        pattern: '=format:' + opts.id + ':defaultPattern'
	      });

	      Class.editor = {
	        template: opts.editorTemplate || __webpack_require__(868),
	        controllerAs: 'cntrl',
	        controller: opts.controller || function () {
	          this.sampleInputs = opts.sampleInputs;
	        }
	      };

	      if (opts.prototype) {
	        _.assign(Class.prototype, opts.prototype);
	      }

	      return Class;
	    };

	    return Numeral;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 865 */,
/* 866 */,
/* 867 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(858);
	__webpack_require__(214);
	__webpack_require__(868);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(858);

	  __webpack_require__(214).get('kibana').directive('fieldEditorNumeral', function () {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(868)
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 868 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <small class=\"pull-right\">\n    <a ng-href=\"https://adamwdraper.github.io/Numeral-js/\" target=\"_blank\">\n      Docs <i class=\"fa fa-link\"></i>\n    </a>\n  </small>\n\n  <label>\n    Numeral.js format pattern\n    <small>\n      (Default: \"{{ editor.field.format.type.paramDefaults.pattern }}\")\n    </small>\n  </label>\n</div>\n\n<field-format-editor-pattern\n  ng-model=\"editor.formatParams.pattern\"\n  placeholder=\"editor.field.format.type.paramDefaults.pattern\"\n  inputs=\"cntrl.sampleInputs\">\n</field-format-editor-pattern>\n\n"

/***/ },
/* 869 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(436);
	__webpack_require__(842);
	__webpack_require__(226);
	__webpack_require__(858);
	__webpack_require__(870);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function DateTimeFormatProvider(Private) {
	    var _ = __webpack_require__(192);
	    var FieldFormat = Private(__webpack_require__(436));
	    var BoundToConfigObj = Private(__webpack_require__(842));
	    var moment = __webpack_require__(226);

	    __webpack_require__(858);

	    _['class'](DateTime).inherits(FieldFormat);
	    function DateTime(params) {
	      DateTime.Super.call(this, params);
	    }

	    DateTime.id = 'date';
	    DateTime.title = 'Date';
	    DateTime.fieldType = 'date';

	    DateTime.paramDefaults = new BoundToConfigObj({
	      pattern: '=dateFormat'
	    });

	    DateTime.editor = {
	      template: __webpack_require__(870),
	      controllerAs: 'cntrl',
	      controller: function controller($interval, $scope) {
	        var self = this;
	        self.sampleInputs = [Date.now(), +moment().startOf('year'), +moment().endOf('year')];

	        $scope.$on('$destroy', $interval(function () {
	          self.sampleInputs[0] = Date.now();
	        }, 1000));
	      }
	    };

	    DateTime.prototype._convert = function (val) {
	      // don't give away our ref to converter so
	      // we can hot-swap when config changes
	      var pattern = this.param('pattern');

	      if (this._memoizedPattern !== pattern) {
	        this._memoizedPattern = pattern;
	        this._memoizedConverter = _.memoize(function converter(val) {
	          if (val === null || val === undefined) {
	            return '-';
	          }
	          return moment(val).format(pattern);
	        });
	      }
	      return this._memoizedConverter(val);
	    };

	    return DateTime;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 870 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <small class=\"pull-right\">\n    <a ng-href=\"http://momentjs.com/\" target=\"_blank\">\n      Docs <i class=\"fa fa-link\"></i>\n    </a>\n  </small>\n\n  <label>\n    moment.js format pattern\n    <small>\n      (Default: \"{{ editor.field.format.type.paramDefaults.pattern }}\")\n    </small>\n  </label>\n\n  <field-format-editor-pattern\n    ng-model=\"editor.formatParams.pattern\"\n    inputs=\"cntrl.sampleInputs\"\n  ></field-format-editor-pattern>\n\n</div>\n"

/***/ },
/* 871 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(436);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function IpFormatProvider(Private) {
	    var _ = __webpack_require__(192);
	    var FieldFormat = Private(__webpack_require__(436));

	    _['class'](Ip).inherits(FieldFormat);
	    function Ip(params) {
	      Ip.Super.call(this, params);
	    }

	    Ip.id = 'ip';
	    Ip.title = 'IP Address';
	    Ip.fieldType = 'ip';

	    Ip.prototype._convert = function (val) {
	      if (!isFinite(val)) return val;

	      // shazzam!
	      return [val >>> 24, val >>> 16 & 0xFF, val >>> 8 & 0xFF, val & 0xFF].join('.');
	    };

	    return Ip;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 872 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(864);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function NumberFormatProvider(Private) {
	    var Numeral = Private(__webpack_require__(864));
	    return Numeral.factory({
	      id: 'number',
	      title: 'Number',
	      sampleInputs: [10000, 12.345678, -1, -999, 0.52]
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 873 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(842);
	__webpack_require__(864);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function NumberFormatProvider(Private) {
	    var _ = __webpack_require__(192);
	    var BoundToConfigObj = Private(__webpack_require__(842));
	    var Numeral = Private(__webpack_require__(864));

	    return Numeral.factory({
	      id: 'percent',
	      title: 'Percentage',
	      paramDefaults: new BoundToConfigObj({
	        pattern: '=format:percent:defaultPattern',
	        fractional: true
	      }),
	      sampleInputs: [0.10, 0.99999, 1, 100, 1000],
	      prototype: {
	        _convert: _.compose(Numeral.prototype._convert, function (val) {
	          return this.param('fractional') ? val : val / 100;
	        })
	      }
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 874 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(436);
	__webpack_require__(859);
	__webpack_require__(875);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function _StringProvider(Private) {
	    var _ = __webpack_require__(192);
	    var FieldFormat = Private(__webpack_require__(436));

	    __webpack_require__(859);

	    _['class'](_String).inherits(FieldFormat);
	    function _String(params) {
	      _String.Super.call(this, params);
	    }

	    _String.id = 'string';
	    _String.title = 'String';
	    _String.fieldType = ['number', 'boolean', 'date', 'ip', 'attachment', 'geo_point', 'geo_shape', 'string', 'murmur3', 'unknown', 'conflict'];

	    _String.paramDefaults = {
	      transform: false
	    };

	    _String.editor = __webpack_require__(875);

	    _String.transformOpts = [{ id: false, name: '- none -' }, { id: 'lower', name: 'Lower Case' }, { id: 'upper', name: 'Upper Case' }, { id: 'short', name: 'Short Dots' }, { id: 'base64', name: 'Base64 Decode' }];

	    _String.sampleInputs = ['A Quick Brown Fox.', 'com.organizations.project.ClassName', 'hostname.net', 'SGVsbG8gd29ybGQ='];

	    _String.prototype._base64Decode = function (val) {
	      try {
	        return window.atob(val);
	      } catch (e) {
	        return _.asPrettyString(val);
	      }
	    };

	    _String.prototype._convert = function (val) {
	      switch (this.param('transform')) {
	        case 'lower':
	          return String(val).toLowerCase();
	        case 'upper':
	          return String(val).toUpperCase();
	        case 'short':
	          return _.shortenDottedString(val);
	        case 'base64':
	          return this._base64Decode(val);
	        default:
	          return _.asPrettyString(val);
	      }
	    };

	    return _String;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 875 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Transform</label>\n  <select\n    ng-model=\"editor.formatParams.transform\"\n    ng-options=\"opt.id as opt.name for opt in editor.field.format.type.transformOpts\"\n    class=\"form-control\">\n  </select>\n</div>\n\n<field-format-editor-samples inputs=\"editor.field.format.type.sampleInputs\"></field-format-editor-samples>\n"

/***/ },
/* 876 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(436);
	__webpack_require__(469);
	__webpack_require__(877);
	__webpack_require__(209);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function _SourceProvider(Private, shortDotsFilter) {
	    var _ = __webpack_require__(192);
	    var FieldFormat = Private(__webpack_require__(436));
	    var noWhiteSpace = __webpack_require__(469);
	    var template = _.template(noWhiteSpace(__webpack_require__(877)));
	    var angular = __webpack_require__(209);

	    _['class'](Source).inherits(FieldFormat);
	    function Source(params) {
	      Source.Super.call(this, params);
	    }

	    Source.id = '_source';
	    Source.title = '_source';
	    Source.fieldType = '_source';

	    Source.prototype._convert = {
	      text: angular.toJson,
	      html: function sourceToHtml(source, field, hit) {
	        if (!field) return this.getConverter('text')(source, field, hit);

	        var highlights = hit && hit.highlight || {};
	        var formatted = field.indexPattern.formatHit(hit);
	        var highlightPairs = [];
	        var sourcePairs = [];

	        _.keys(formatted).forEach(function (key) {
	          var pairs = highlights[key] ? highlightPairs : sourcePairs;
	          var field = shortDotsFilter(key);
	          var val = formatted[key];
	          pairs.push([field, val]);
	        }, []);

	        return template({ defPairs: highlightPairs.concat(sourcePairs) });
	      }
	    };

	    return Source;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 877 */
/***/ function(module, exports) {

	module.exports = "<dl class=\"source truncate-by-height\">\n  <% defPairs.forEach(function (def) { %>\n    <dt><%- def[0] %>:</dt>\n    <dd><%= def[1] %></dd>\n    <%= ' ' %>\n  <% }); %>\n</dl>\n"

/***/ },
/* 878 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(712);
	__webpack_require__(214);
	__webpack_require__(879);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var $style = $('<style>').appendTo('head').attr('id', 'style-compile');

	  __webpack_require__(712);

	  __webpack_require__(214).get('kibana').run(function ($rootScope, $compile, config) {
	    var truncateGradientHeight = 15;
	    var template = _.template(__webpack_require__(879));
	    var locals = {};

	    // watch the value of the truncate:maxHeight config param
	    $rootScope.$watch(function () {
	      return config.get('truncate:maxHeight');
	    }, function (maxHeight) {
	      if (maxHeight > 0) {
	        locals.truncateMaxHeight = maxHeight + 'px !important';
	        locals.truncateGradientTop = maxHeight - truncateGradientHeight + 'px';
	      } else {
	        locals.truncateMaxHeight = 'none';
	        locals.truncateGradientTop = '-' + truncateGradientHeight + 'px';
	      }

	      $style.html(template(locals));
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 879 */
/***/ function(module, exports) {

	module.exports = ".truncate-by-height {\n  max-height: <%= truncateMaxHeight %>;\n  display: inline-block;\n}\n.truncate-by-height:before {\n  top: <%= truncateGradientTop %>;\n}\n"

/***/ },
/* 880 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(881);
	__webpack_require__(882);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var html = __webpack_require__(881);

	  __webpack_require__(882).config(function ($tooltipProvider) {
	    $tooltipProvider.options({
	      placement: 'bottom',
	      animation: true,
	      popupDelay: 150,
	      appendToBody: false
	    });
	  }).directive('kbnTooltip', function () {
	    return {
	      restrict: 'E',
	      template: html,
	      transclude: true,
	      replace: true,
	      scope: true,
	      link: function link($scope, $el, attr) {
	        $scope.text = attr.text;
	        $scope.placement = attr.placement || 'top';
	        $scope.delay = attr.delay || 400;
	        $scope.appendToBody = attr.appendToBody || 0;
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 881 */
/***/ function(module, exports) {

	module.exports = "<span\n  tooltip=\"{{text}}\"\n  tooltip-placement=\"{{placement}}\"\n  tooltip-popup-delay=\"{{delay}}\"\n  tooltip-append-to-body=\"{{appendToBody}}\"\n  ng-transclude></span>"

/***/ },
/* 882 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(209);
	  __webpack_require__(883);

	  return __webpack_require__(214).get('kibana', ['ui.bootstrap']).config(function ($tooltipProvider) {
	    $tooltipProvider.setTriggers({ 'mouseenter': 'mouseleave click' });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 883 */
/***/ function(module, exports) {

	/*
	 * angular-ui-bootstrap
	 * http://angular-ui.github.io/bootstrap/

	 * Version: 0.10.0 - 2014-01-13
	 * License: MIT
	 */
	angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition","ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdownToggle","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
	angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/popup.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
	angular.module('ui.bootstrap.transition', [])

	/**
	 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
	 * @param  {DOMElement} element  The DOMElement that will be animated.
	 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
	 *   - As a string, it represents the css class to be added to the element.
	 *   - As an object, it represents a hash of style attributes to be applied to the element.
	 *   - As a function, it represents a function to be called that will cause the transition to occur.
	 * @return {Promise}  A promise that is resolved when the transition finishes.
	 */
	.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {

	  var $transition = function(element, trigger, options) {
	    options = options || {};
	    var deferred = $q.defer();
	    var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];

	    var transitionEndHandler = function(event) {
	      $rootScope.$apply(function() {
	        element.unbind(endEventName, transitionEndHandler);
	        deferred.resolve(element);
	      });
	    };

	    if (endEventName) {
	      element.bind(endEventName, transitionEndHandler);
	    }

	    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
	    $timeout(function() {
	      if ( angular.isString(trigger) ) {
	        element.addClass(trigger);
	      } else if ( angular.isFunction(trigger) ) {
	        trigger(element);
	      } else if ( angular.isObject(trigger) ) {
	        element.css(trigger);
	      }
	      //If browser does not support transitions, instantly resolve
	      if ( !endEventName ) {
	        deferred.resolve(element);
	      }
	    });

	    // Add our custom cancel function to the promise that is returned
	    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
	    // i.e. it will therefore never raise a transitionEnd event for that transition
	    deferred.promise.cancel = function() {
	      if ( endEventName ) {
	        element.unbind(endEventName, transitionEndHandler);
	      }
	      deferred.reject('Transition cancelled');
	    };

	    return deferred.promise;
	  };

	  // Work out the name of the transitionEnd event
	  var transElement = document.createElement('trans');
	  var transitionEndEventNames = {
	    'WebkitTransition': 'webkitTransitionEnd',
	    'MozTransition': 'transitionend',
	    'OTransition': 'oTransitionEnd',
	    'transition': 'transitionend'
	  };
	  var animationEndEventNames = {
	    'WebkitTransition': 'webkitAnimationEnd',
	    'MozTransition': 'animationend',
	    'OTransition': 'oAnimationEnd',
	    'transition': 'animationend'
	  };
	  function findEndEventName(endEventNames) {
	    for (var name in endEventNames){
	      if (transElement.style[name] !== undefined) {
	        return endEventNames[name];
	      }
	    }
	  }
	  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
	  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
	  return $transition;
	}]);

	angular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition'])

	  .directive('collapse', ['$transition', function ($transition, $timeout) {

	    return {
	      link: function (scope, element, attrs) {

	        var initialAnimSkip = true;
	        var currentTransition;

	        function doTransition(change) {
	          var newTransition = $transition(element, change);
	          if (currentTransition) {
	            currentTransition.cancel();
	          }
	          currentTransition = newTransition;
	          newTransition.then(newTransitionDone, newTransitionDone);
	          return newTransition;

	          function newTransitionDone() {
	            // Make sure it's this transition, otherwise, leave it alone.
	            if (currentTransition === newTransition) {
	              currentTransition = undefined;
	            }
	          }
	        }

	        function expand() {
	          if (initialAnimSkip) {
	            initialAnimSkip = false;
	            expandDone();
	          } else {
	            element.removeClass('collapse').addClass('collapsing');
	            doTransition({ height: element[0].scrollHeight + 'px' }).then(expandDone);
	          }
	        }

	        function expandDone() {
	          element.removeClass('collapsing');
	          element.addClass('collapse in');
	          element.css({height: 'auto'});
	        }

	        function collapse() {
	          if (initialAnimSkip) {
	            initialAnimSkip = false;
	            collapseDone();
	            element.css({height: 0});
	          } else {
	            // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value
	            element.css({ height: element[0].scrollHeight + 'px' });
	            //trigger reflow so a browser realizes that height was updated from auto to a specific value
	            var x = element[0].offsetWidth;

	            element.removeClass('collapse in').addClass('collapsing');

	            doTransition({ height: 0 }).then(collapseDone);
	          }
	        }

	        function collapseDone() {
	          element.removeClass('collapsing');
	          element.addClass('collapse');
	        }

	        scope.$watch(attrs.collapse, function (shouldCollapse) {
	          if (shouldCollapse) {
	            collapse();
	          } else {
	            expand();
	          }
	        });
	      }
	    };
	  }]);

	angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

	.constant('accordionConfig', {
	  closeOthers: true
	})

	.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {

	  // This array keeps track of the accordion groups
	  this.groups = [];

	  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
	  this.closeOthers = function(openGroup) {
	    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
	    if ( closeOthers ) {
	      angular.forEach(this.groups, function (group) {
	        if ( group !== openGroup ) {
	          group.isOpen = false;
	        }
	      });
	    }
	  };
	  
	  // This is called from the accordion-group directive to add itself to the accordion
	  this.addGroup = function(groupScope) {
	    var that = this;
	    this.groups.push(groupScope);

	    groupScope.$on('$destroy', function (event) {
	      that.removeGroup(groupScope);
	    });
	  };

	  // This is called from the accordion-group directive when to remove itself
	  this.removeGroup = function(group) {
	    var index = this.groups.indexOf(group);
	    if ( index !== -1 ) {
	      this.groups.splice(this.groups.indexOf(group), 1);
	    }
	  };

	}])

	// The accordion directive simply sets up the directive controller
	// and adds an accordion CSS class to itself element.
	.directive('accordion', function () {
	  return {
	    restrict:'EA',
	    controller:'AccordionController',
	    transclude: true,
	    replace: false,
	    templateUrl: 'template/accordion/accordion.html'
	  };
	})

	// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
	.directive('accordionGroup', ['$parse', function($parse) {
	  return {
	    require:'^accordion',         // We need this directive to be inside an accordion
	    restrict:'EA',
	    transclude:true,              // It transcludes the contents of the directive into the template
	    replace: true,                // The element containing the directive will be replaced with the template
	    templateUrl:'template/accordion/accordion-group.html',
	    scope:{ heading:'@' },        // Create an isolated scope and interpolate the heading attribute onto this scope
	    controller: function() {
	      this.setHeading = function(element) {
	        this.heading = element;
	      };
	    },
	    link: function(scope, element, attrs, accordionCtrl) {
	      var getIsOpen, setIsOpen;

	      accordionCtrl.addGroup(scope);

	      scope.isOpen = false;
	      
	      if ( attrs.isOpen ) {
	        getIsOpen = $parse(attrs.isOpen);
	        setIsOpen = getIsOpen.assign;

	        scope.$parent.$watch(getIsOpen, function(value) {
	          scope.isOpen = !!value;
	        });
	      }

	      scope.$watch('isOpen', function(value) {
	        if ( value ) {
	          accordionCtrl.closeOthers(scope);
	        }
	        if ( setIsOpen ) {
	          setIsOpen(scope.$parent, value);
	        }
	      });
	    }
	  };
	}])

	// Use accordion-heading below an accordion-group to provide a heading containing HTML
	// <accordion-group>
	//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
	// </accordion-group>
	.directive('accordionHeading', function() {
	  return {
	    restrict: 'EA',
	    transclude: true,   // Grab the contents to be used as the heading
	    template: '',       // In effect remove this element!
	    replace: true,
	    require: '^accordionGroup',
	    compile: function(element, attr, transclude) {
	      return function link(scope, element, attr, accordionGroupCtrl) {
	        // Pass the heading to the accordion-group controller
	        // so that it can be transcluded into the right place in the template
	        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
	        accordionGroupCtrl.setHeading(transclude(scope, function() {}));
	      };
	    }
	  };
	})

	// Use in the accordion-group template to indicate where you want the heading to be transcluded
	// You must provide the property on the accordion-group controller that will hold the transcluded element
	// <div class="accordion-group">
	//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
	//   ...
	// </div>
	.directive('accordionTransclude', function() {
	  return {
	    require: '^accordionGroup',
	    link: function(scope, element, attr, controller) {
	      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
	        if ( heading ) {
	          element.html('');
	          element.append(heading);
	        }
	      });
	    }
	  };
	});

	angular.module("ui.bootstrap.alert", [])

	.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {
	  $scope.closeable = 'close' in $attrs;
	}])

	.directive('alert', function () {
	  return {
	    restrict:'EA',
	    controller:'AlertController',
	    templateUrl:'template/alert/alert.html',
	    transclude:true,
	    replace:true,
	    scope: {
	      type: '=',
	      close: '&'
	    }
	  };
	});

	angular.module('ui.bootstrap.bindHtml', [])

	  .directive('bindHtmlUnsafe', function () {
	    return function (scope, element, attr) {
	      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
	      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
	        element.html(value || '');
	      });
	    };
	  });
	angular.module('ui.bootstrap.buttons', [])

	.constant('buttonConfig', {
	  activeClass: 'active',
	  toggleEvent: 'click'
	})

	.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {
	  this.activeClass = buttonConfig.activeClass || 'active';
	  this.toggleEvent = buttonConfig.toggleEvent || 'click';
	}])

	.directive('btnRadio', function () {
	  return {
	    require: ['btnRadio', 'ngModel'],
	    controller: 'ButtonsController',
	    link: function (scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	      //model -> UI
	      ngModelCtrl.$render = function () {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
	      };

	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function () {
	        if (!element.hasClass(buttonsCtrl.activeClass)) {
	          scope.$apply(function () {
	            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
	            ngModelCtrl.$render();
	          });
	        }
	      });
	    }
	  };
	})

	.directive('btnCheckbox', function () {
	  return {
	    require: ['btnCheckbox', 'ngModel'],
	    controller: 'ButtonsController',
	    link: function (scope, element, attrs, ctrls) {
	      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

	      function getTrueValue() {
	        return getCheckboxValue(attrs.btnCheckboxTrue, true);
	      }

	      function getFalseValue() {
	        return getCheckboxValue(attrs.btnCheckboxFalse, false);
	      }
	      
	      function getCheckboxValue(attributeValue, defaultValue) {
	        var val = scope.$eval(attributeValue);
	        return angular.isDefined(val) ? val : defaultValue;
	      }

	      //model -> UI
	      ngModelCtrl.$render = function () {
	        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
	      };

	      //ui->model
	      element.bind(buttonsCtrl.toggleEvent, function () {
	        scope.$apply(function () {
	          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
	          ngModelCtrl.$render();
	        });
	      });
	    }
	  };
	});

	/**
	* @ngdoc overview
	* @name ui.bootstrap.carousel
	*
	* @description
	* AngularJS version of an image carousel.
	*
	*/
	angular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])
	.controller('CarouselController', ['$scope', '$timeout', '$transition', '$q', function ($scope, $timeout, $transition, $q) {
	  var self = this,
	    slides = self.slides = [],
	    currentIndex = -1,
	    currentTimeout, isPlaying;
	  self.currentSlide = null;

	  var destroyed = false;
	  /* direction: "prev" or "next" */
	  self.select = function(nextSlide, direction) {
	    var nextIndex = slides.indexOf(nextSlide);
	    //Decide direction if it's not given
	    if (direction === undefined) {
	      direction = nextIndex > currentIndex ? "next" : "prev";
	    }
	    if (nextSlide && nextSlide !== self.currentSlide) {
	      if ($scope.$currentTransition) {
	        $scope.$currentTransition.cancel();
	        //Timeout so ng-class in template has time to fix classes for finished slide
	        $timeout(goNext);
	      } else {
	        goNext();
	      }
	    }
	    function goNext() {
	      // Scope has been destroyed, stop here.
	      if (destroyed) { return; }
	      //If we have a slide to transition from and we have a transition type and we're allowed, go
	      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
	        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
	        nextSlide.$element.addClass(direction);
	        var reflow = nextSlide.$element[0].offsetWidth; //force reflow

	        //Set all other slides to stop doing their stuff for the new transition
	        angular.forEach(slides, function(slide) {
	          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});
	        });
	        angular.extend(nextSlide, {direction: direction, active: true, entering: true});
	        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});

	        $scope.$currentTransition = $transition(nextSlide.$element, {});
	        //We have to create new pointers inside a closure since next & current will change
	        (function(next,current) {
	          $scope.$currentTransition.then(
	            function(){ transitionDone(next, current); },
	            function(){ transitionDone(next, current); }
	          );
	        }(nextSlide, self.currentSlide));
	      } else {
	        transitionDone(nextSlide, self.currentSlide);
	      }
	      self.currentSlide = nextSlide;
	      currentIndex = nextIndex;
	      //every time you change slides, reset the timer
	      restartTimer();
	    }
	    function transitionDone(next, current) {
	      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});
	      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});
	      $scope.$currentTransition = null;
	    }
	  };
	  $scope.$on('$destroy', function () {
	    destroyed = true;
	  });

	  /* Allow outside people to call indexOf on slides array */
	  self.indexOfSlide = function(slide) {
	    return slides.indexOf(slide);
	  };

	  $scope.next = function() {
	    var newIndex = (currentIndex + 1) % slides.length;

	    //Prevent this user-triggered transition from occurring if there is already one in progress
	    if (!$scope.$currentTransition) {
	      return self.select(slides[newIndex], 'next');
	    }
	  };

	  $scope.prev = function() {
	    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;

	    //Prevent this user-triggered transition from occurring if there is already one in progress
	    if (!$scope.$currentTransition) {
	      return self.select(slides[newIndex], 'prev');
	    }
	  };

	  $scope.select = function(slide) {
	    self.select(slide);
	  };

	  $scope.isActive = function(slide) {
	     return self.currentSlide === slide;
	  };

	  $scope.slides = function() {
	    return slides;
	  };

	  $scope.$watch('interval', restartTimer);
	  $scope.$on('$destroy', resetTimer);

	  function restartTimer() {
	    resetTimer();
	    var interval = +$scope.interval;
	    if (!isNaN(interval) && interval>=0) {
	      currentTimeout = $timeout(timerFn, interval);
	    }
	  }

	  function resetTimer() {
	    if (currentTimeout) {
	      $timeout.cancel(currentTimeout);
	      currentTimeout = null;
	    }
	  }

	  function timerFn() {
	    if (isPlaying) {
	      $scope.next();
	      restartTimer();
	    } else {
	      $scope.pause();
	    }
	  }

	  $scope.play = function() {
	    if (!isPlaying) {
	      isPlaying = true;
	      restartTimer();
	    }
	  };
	  $scope.pause = function() {
	    if (!$scope.noPause) {
	      isPlaying = false;
	      resetTimer();
	    }
	  };

	  self.addSlide = function(slide, element) {
	    slide.$element = element;
	    slides.push(slide);
	    //if this is the first slide or the slide is set to active, select it
	    if(slides.length === 1 || slide.active) {
	      self.select(slides[slides.length-1]);
	      if (slides.length == 1) {
	        $scope.play();
	      }
	    } else {
	      slide.active = false;
	    }
	  };

	  self.removeSlide = function(slide) {
	    //get the index of the slide inside the carousel
	    var index = slides.indexOf(slide);
	    slides.splice(index, 1);
	    if (slides.length > 0 && slide.active) {
	      if (index >= slides.length) {
	        self.select(slides[index-1]);
	      } else {
	        self.select(slides[index]);
	      }
	    } else if (currentIndex > index) {
	      currentIndex--;
	    }
	  };

	}])

	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:carousel
	 * @restrict EA
	 *
	 * @description
	 * Carousel is the outer container for a set of image 'slides' to showcase.
	 *
	 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
	 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
	 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <carousel>
	      <slide>
	        <img src="http://placekitten.com/150/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>Beautiful!</p>
	        </div>
	      </slide>
	      <slide>
	        <img src="http://placekitten.com/100/150" style="margin:auto;">
	        <div class="carousel-caption">
	          <p>D'aww!</p>
	        </div>
	      </slide>
	    </carousel>
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	 */
	.directive('carousel', [function() {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    controller: 'CarouselController',
	    require: 'carousel',
	    templateUrl: 'template/carousel/carousel.html',
	    scope: {
	      interval: '=',
	      noTransition: '=',
	      noPause: '='
	    }
	  };
	}])

	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.carousel.directive:slide
	 * @restrict EA
	 *
	 * @description
	 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
	 *
	 * @param {boolean=} active Model binding, whether or not this slide is currently active.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	<div ng-controller="CarouselDemoCtrl">
	  <carousel>
	    <slide ng-repeat="slide in slides" active="slide.active">
	      <img ng-src="{{slide.image}}" style="margin:auto;">
	      <div class="carousel-caption">
	        <h4>Slide {{$index}}</h4>
	        <p>{{slide.text}}</p>
	      </div>
	    </slide>
	  </carousel>
	  <div class="row-fluid">
	    <div class="span6">
	      <ul>
	        <li ng-repeat="slide in slides">
	          <button class="btn btn-mini" ng-class="{'btn-info': !slide.active, 'btn-success': slide.active}" ng-disabled="slide.active" ng-click="slide.active = true">select</button>
	          {{$index}}: {{slide.text}}
	        </li>
	      </ul>
	      <a class="btn" ng-click="addSlide()">Add Slide</a>
	    </div>
	    <div class="span6">
	      Interval, in milliseconds: <input type="number" ng-model="myInterval">
	      <br />Enter a negative number to stop the interval.
	    </div>
	  </div>
	</div>
	  </file>
	  <file name="script.js">
	function CarouselDemoCtrl($scope) {
	  $scope.myInterval = 5000;
	  var slides = $scope.slides = [];
	  $scope.addSlide = function() {
	    var newWidth = 200 + ((slides.length + (25 * slides.length)) % 150);
	    slides.push({
	      image: 'http://placekitten.com/' + newWidth + '/200',
	      text: ['More','Extra','Lots of','Surplus'][slides.length % 4] + ' '
	        ['Cats', 'Kittys', 'Felines', 'Cutes'][slides.length % 4]
	    });
	  };
	  for (var i=0; i<4; i++) $scope.addSlide();
	}
	  </file>
	  <file name="demo.css">
	    .carousel-indicators {
	      top: auto;
	      bottom: 15px;
	    }
	  </file>
	</example>
	*/

	.directive('slide', ['$parse', function($parse) {
	  return {
	    require: '^carousel',
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    templateUrl: 'template/carousel/slide.html',
	    scope: {
	    },
	    link: function (scope, element, attrs, carouselCtrl) {
	      //Set up optional 'active' = binding
	      if (attrs.active) {
	        var getActive = $parse(attrs.active);
	        var setActive = getActive.assign;
	        var lastValue = scope.active = getActive(scope.$parent);
	        scope.$watch(function parentActiveWatch() {
	          var parentActive = getActive(scope.$parent);

	          if (parentActive !== scope.active) {
	            // we are out of sync and need to copy
	            if (parentActive !== lastValue) {
	              // parent changed and it has precedence
	              lastValue = scope.active = parentActive;
	            } else {
	              // if the parent can be assigned then do so
	              setActive(scope.$parent, parentActive = lastValue = scope.active);
	            }
	          }
	          return parentActive;
	        });
	      }

	      carouselCtrl.addSlide(scope, element);
	      //when the scope is destroyed then remove the slide from the current slides array
	      scope.$on('$destroy', function() {
	        carouselCtrl.removeSlide(scope);
	      });

	      scope.$watch('active', function(active) {
	        if (active) {
	          carouselCtrl.select(scope);
	        }
	      });
	    }
	  };
	}]);

	angular.module('ui.bootstrap.position', [])

	/**
	 * A set of utility methods that can be use to retrieve position of DOM elements.
	 * It is meant to be used where we need to absolute-position DOM elements in
	 * relation to other, existing elements (this is the case for tooltips, popovers,
	 * typeahead suggestions etc.).
	 */
	  .factory('$position', ['$document', '$window', function ($document, $window) {

	    function getStyle(el, cssprop) {
	      if (el.currentStyle) { //IE
	        return el.currentStyle[cssprop];
	      } else if ($window.getComputedStyle) {
	        return $window.getComputedStyle(el)[cssprop];
	      }
	      // finally try and get inline style
	      return el.style[cssprop];
	    }

	    /**
	     * Checks if a given element is statically positioned
	     * @param element - raw DOM element
	     */
	    function isStaticPositioned(element) {
	      return (getStyle(element, "position") || 'static' ) === 'static';
	    }

	    /**
	     * returns the closest, non-statically positioned parentOffset of a given element
	     * @param element
	     */
	    var parentOffsetEl = function (element) {
	      var docDomEl = $document[0];
	      var offsetParent = element.offsetParent || docDomEl;
	      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
	        offsetParent = offsetParent.offsetParent;
	      }
	      return offsetParent || docDomEl;
	    };

	    return {
	      /**
	       * Provides read-only equivalent of jQuery's position function:
	       * http://api.jquery.com/position/
	       */
	      position: function (element) {
	        var elBCR = this.offset(element);
	        var offsetParentBCR = { top: 0, left: 0 };
	        var offsetParentEl = parentOffsetEl(element[0]);
	        if (offsetParentEl != $document[0]) {
	          offsetParentBCR = this.offset(angular.element(offsetParentEl));
	          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
	          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
	        }

	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: elBCR.top - offsetParentBCR.top,
	          left: elBCR.left - offsetParentBCR.left
	        };
	      },

	      /**
	       * Provides read-only equivalent of jQuery's offset function:
	       * http://api.jquery.com/offset/
	       */
	      offset: function (element) {
	        var boundingClientRect = element[0].getBoundingClientRect();
	        return {
	          width: boundingClientRect.width || element.prop('offsetWidth'),
	          height: boundingClientRect.height || element.prop('offsetHeight'),
	          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
	          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft  || $document[0].documentElement.scrollLeft)
	        };
	      }
	    };
	  }]);

	angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.position'])

	.constant('datepickerConfig', {
	  dayFormat: 'dd',
	  monthFormat: 'MMMM',
	  yearFormat: 'yyyy',
	  dayHeaderFormat: 'EEE',
	  dayTitleFormat: 'MMMM yyyy',
	  monthTitleFormat: 'yyyy',
	  showWeeks: true,
	  startingDay: 0,
	  yearRange: 20,
	  minDate: null,
	  maxDate: null
	})

	.controller('DatepickerController', ['$scope', '$attrs', 'dateFilter', 'datepickerConfig', function($scope, $attrs, dateFilter, dtConfig) {
	  var format = {
	    day:        getValue($attrs.dayFormat,        dtConfig.dayFormat),
	    month:      getValue($attrs.monthFormat,      dtConfig.monthFormat),
	    year:       getValue($attrs.yearFormat,       dtConfig.yearFormat),
	    dayHeader:  getValue($attrs.dayHeaderFormat,  dtConfig.dayHeaderFormat),
	    dayTitle:   getValue($attrs.dayTitleFormat,   dtConfig.dayTitleFormat),
	    monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
	  },
	  startingDay = getValue($attrs.startingDay,      dtConfig.startingDay),
	  yearRange =   getValue($attrs.yearRange,        dtConfig.yearRange);

	  this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;
	  this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;

	  function getValue(value, defaultValue) {
	    return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
	  }

	  function getDaysInMonth( year, month ) {
	    return new Date(year, month, 0).getDate();
	  }

	  function getDates(startDate, n) {
	    var dates = new Array(n);
	    var current = startDate, i = 0;
	    while (i < n) {
	      dates[i++] = new Date(current);
	      current.setDate( current.getDate() + 1 );
	    }
	    return dates;
	  }

	  function makeDate(date, format, isSelected, isSecondary) {
	    return { date: date, label: dateFilter(date, format), selected: !!isSelected, secondary: !!isSecondary };
	  }

	  this.modes = [
	    {
	      name: 'day',
	      getVisibleDates: function(date, selected) {
	        var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);
	        var difference = startingDay - firstDayOfMonth.getDay(),
	        numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
	        firstDate = new Date(firstDayOfMonth), numDates = 0;

	        if ( numDisplayedFromPreviousMonth > 0 ) {
	          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );
	          numDates += numDisplayedFromPreviousMonth; // Previous
	        }
	        numDates += getDaysInMonth(year, month + 1); // Current
	        numDates += (7 - numDates % 7) % 7; // Next

	        var days = getDates(firstDate, numDates), labels = new Array(7);
	        for (var i = 0; i < numDates; i ++) {
	          var dt = new Date(days[i]);
	          days[i] = makeDate(dt, format.day, (selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear()), dt.getMonth() !== month);
	        }
	        for (var j = 0; j < 7; j++) {
	          labels[j] = dateFilter(days[j].date, format.dayHeader);
	        }
	        return { objects: days, title: dateFilter(date, format.dayTitle), labels: labels };
	      },
	      compare: function(date1, date2) {
	        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );
	      },
	      split: 7,
	      step: { months: 1 }
	    },
	    {
	      name: 'month',
	      getVisibleDates: function(date, selected) {
	        var months = new Array(12), year = date.getFullYear();
	        for ( var i = 0; i < 12; i++ ) {
	          var dt = new Date(year, i, 1);
	          months[i] = makeDate(dt, format.month, (selected && selected.getMonth() === i && selected.getFullYear() === year));
	        }
	        return { objects: months, title: dateFilter(date, format.monthTitle) };
	      },
	      compare: function(date1, date2) {
	        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );
	      },
	      split: 3,
	      step: { years: 1 }
	    },
	    {
	      name: 'year',
	      getVisibleDates: function(date, selected) {
	        var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;
	        for ( var i = 0; i < yearRange; i++ ) {
	          var dt = new Date(startYear + i, 0, 1);
	          years[i] = makeDate(dt, format.year, (selected && selected.getFullYear() === dt.getFullYear()));
	        }
	        return { objects: years, title: [years[0].label, years[yearRange - 1].label].join(' - ') };
	      },
	      compare: function(date1, date2) {
	        return date1.getFullYear() - date2.getFullYear();
	      },
	      split: 5,
	      step: { years: yearRange }
	    }
	  ];

	  this.isDisabled = function(date, mode) {
	    var currentMode = this.modes[mode || 0];
	    return ((this.minDate && currentMode.compare(date, this.minDate) < 0) || (this.maxDate && currentMode.compare(date, this.maxDate) > 0) || ($scope.dateDisabled && $scope.dateDisabled({date: date, mode: currentMode.name})));
	  };
	}])

	.directive( 'datepicker', ['dateFilter', '$parse', 'datepickerConfig', '$log', function (dateFilter, $parse, datepickerConfig, $log) {
	  return {
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/datepicker/datepicker.html',
	    scope: {
	      dateDisabled: '&'
	    },
	    require: ['datepicker', '?^ngModel'],
	    controller: 'DatepickerController',
	    link: function(scope, element, attrs, ctrls) {
	      var datepickerCtrl = ctrls[0], ngModel = ctrls[1];

	      if (!ngModel) {
	        return; // do nothing if no ng-model
	      }

	      // Configuration parameters
	      var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;

	      if (attrs.showWeeks) {
	        scope.$parent.$watch($parse(attrs.showWeeks), function(value) {
	          showWeeks = !! value;
	          updateShowWeekNumbers();
	        });
	      } else {
	        updateShowWeekNumbers();
	      }

	      if (attrs.min) {
	        scope.$parent.$watch($parse(attrs.min), function(value) {
	          datepickerCtrl.minDate = value ? new Date(value) : null;
	          refill();
	        });
	      }
	      if (attrs.max) {
	        scope.$parent.$watch($parse(attrs.max), function(value) {
	          datepickerCtrl.maxDate = value ? new Date(value) : null;
	          refill();
	        });
	      }

	      function updateShowWeekNumbers() {
	        scope.showWeekNumbers = mode === 0 && showWeeks;
	      }

	      // Split array into smaller arrays
	      function split(arr, size) {
	        var arrays = [];
	        while (arr.length > 0) {
	          arrays.push(arr.splice(0, size));
	        }
	        return arrays;
	      }

	      function refill( updateSelected ) {
	        var date = null, valid = true;

	        if ( ngModel.$modelValue ) {
	          date = new Date( ngModel.$modelValue );

	          if ( isNaN(date) ) {
	            valid = false;
	            $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	          } else if ( updateSelected ) {
	            selected = date;
	          }
	        }
	        ngModel.$setValidity('date', valid);

	        var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
	        angular.forEach(data.objects, function(obj) {
	          obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
	        });

	        ngModel.$setValidity('date-disabled', (!date || !datepickerCtrl.isDisabled(date)));

	        scope.rows = split(data.objects, currentMode.split);
	        scope.labels = data.labels || [];
	        scope.title = data.title;
	      }

	      function setMode(value) {
	        mode = value;
	        updateShowWeekNumbers();
	        refill();
	      }

	      ngModel.$render = function() {
	        refill( true );
	      };

	      scope.select = function( date ) {
	        if ( mode === 0 ) {
	          var dt = ngModel.$modelValue ? new Date( ngModel.$modelValue ) : new Date(0, 0, 0, 0, 0, 0, 0);
	          dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );
	          ngModel.$setViewValue( dt );
	          refill( true );
	        } else {
	          selected = date;
	          setMode( mode - 1 );
	        }
	      };
	      scope.move = function(direction) {
	        var step = datepickerCtrl.modes[mode].step;
	        selected.setMonth( selected.getMonth() + direction * (step.months || 0) );
	        selected.setFullYear( selected.getFullYear() + direction * (step.years || 0) );
	        refill();
	      };
	      scope.toggleMode = function() {
	        setMode( (mode + 1) % datepickerCtrl.modes.length );
	      };
	      scope.getWeekNumber = function(row) {
	        return ( mode === 0 && scope.showWeekNumbers && row.length === 7 ) ? getISO8601WeekNumber(row[0].date) : null;
	      };

	      function getISO8601WeekNumber(date) {
	        var checkDate = new Date(date);
	        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
	        var time = checkDate.getTime();
	        checkDate.setMonth(0); // Compare with Jan 1
	        checkDate.setDate(1);
	        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	      }
	    }
	  };
	}])

	.constant('datepickerPopupConfig', {
	  dateFormat: 'yyyy-MM-dd',
	  currentText: 'Today',
	  toggleWeeksText: 'Weeks',
	  clearText: 'Clear',
	  closeText: 'Done',
	  closeOnDateSelection: true,
	  appendToBody: false,
	  showButtonBar: true
	})

	.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'datepickerPopupConfig', 'datepickerConfig',
	function ($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig, datepickerConfig) {
	  return {
	    restrict: 'EA',
	    require: 'ngModel',
	    link: function(originalScope, element, attrs, ngModel) {
	      var scope = originalScope.$new(), // create a child scope so we are not polluting original one
	          dateFormat,
	          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? originalScope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
	          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? originalScope.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;

	      attrs.$observe('datepickerPopup', function(value) {
	          dateFormat = value || datepickerPopupConfig.dateFormat;
	          ngModel.$render();
	      });

	      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? originalScope.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

	      originalScope.$on('$destroy', function() {
	        $popup.remove();
	        scope.$destroy();
	      });

	      attrs.$observe('currentText', function(text) {
	        scope.currentText = angular.isDefined(text) ? text : datepickerPopupConfig.currentText;
	      });
	      attrs.$observe('toggleWeeksText', function(text) {
	        scope.toggleWeeksText = angular.isDefined(text) ? text : datepickerPopupConfig.toggleWeeksText;
	      });
	      attrs.$observe('clearText', function(text) {
	        scope.clearText = angular.isDefined(text) ? text : datepickerPopupConfig.clearText;
	      });
	      attrs.$observe('closeText', function(text) {
	        scope.closeText = angular.isDefined(text) ? text : datepickerPopupConfig.closeText;
	      });

	      var getIsOpen, setIsOpen;
	      if ( attrs.isOpen ) {
	        getIsOpen = $parse(attrs.isOpen);
	        setIsOpen = getIsOpen.assign;

	        originalScope.$watch(getIsOpen, function updateOpen(value) {
	          scope.isOpen = !! value;
	        });
	      }
	      scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false; // Initial state

	      function setOpen( value ) {
	        if (setIsOpen) {
	          setIsOpen(originalScope, !!value);
	        } else {
	          scope.isOpen = !!value;
	        }
	      }

	      var documentClickBind = function(event) {
	        if (scope.isOpen && event.target !== element[0]) {
	          scope.$apply(function() {
	            setOpen(false);
	          });
	        }
	      };

	      var elementFocusBind = function() {
	        scope.$apply(function() {
	          setOpen( true );
	        });
	      };

	      // popup element used to display calendar
	      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
	      popupEl.attr({
	        'ng-model': 'date',
	        'ng-change': 'dateSelection()'
	      });
	      var datepickerEl = angular.element(popupEl.children()[0]),
	          datepickerOptions = {};
	      if (attrs.datepickerOptions) {
	        datepickerOptions = originalScope.$eval(attrs.datepickerOptions);
	        datepickerEl.attr(angular.extend({}, datepickerOptions));
	      }

	      // TODO: reverse from dateFilter string to Date object
	      function parseDate(viewValue) {
	        if (!viewValue) {
	          ngModel.$setValidity('date', true);
	          return null;
	        } else if (angular.isDate(viewValue)) {
	          ngModel.$setValidity('date', true);
	          return viewValue;
	        } else if (angular.isString(viewValue)) {
	          var date = new Date(viewValue);
	          if (isNaN(date)) {
	            ngModel.$setValidity('date', false);
	            return undefined;
	          } else {
	            ngModel.$setValidity('date', true);
	            return date;
	          }
	        } else {
	          ngModel.$setValidity('date', false);
	          return undefined;
	        }
	      }
	      ngModel.$parsers.unshift(parseDate);

	      // Inner change
	      scope.dateSelection = function(dt) {
	        if (angular.isDefined(dt)) {
	          scope.date = dt;
	        }
	        ngModel.$setViewValue(scope.date);
	        ngModel.$render();

	        if (closeOnDateSelection) {
	          setOpen( false );
	        }
	      };

	      element.bind('input change keyup', function() {
	        scope.$apply(function() {
	          scope.date = ngModel.$modelValue;
	        });
	      });

	      // Outter change
	      ngModel.$render = function() {
	        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
	        element.val(date);
	        scope.date = ngModel.$modelValue;
	      };

	      function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
	        if (attribute) {
	          originalScope.$watch($parse(attribute), function(value){
	            scope[scopeProperty] = value;
	          });
	          datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);
	        }
	      }
	      addWatchableAttribute(attrs.min, 'min');
	      addWatchableAttribute(attrs.max, 'max');
	      if (attrs.showWeeks) {
	        addWatchableAttribute(attrs.showWeeks, 'showWeeks', 'show-weeks');
	      } else {
	        scope.showWeeks = 'show-weeks' in datepickerOptions ? datepickerOptions['show-weeks'] : datepickerConfig.showWeeks;
	        datepickerEl.attr('show-weeks', 'showWeeks');
	      }
	      if (attrs.dateDisabled) {
	        datepickerEl.attr('date-disabled', attrs.dateDisabled);
	      }

	      function updatePosition() {
	        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	        scope.position.top = scope.position.top + element.prop('offsetHeight');
	      }

	      var documentBindingInitialized = false, elementFocusInitialized = false;
	      scope.$watch('isOpen', function(value) {
	        if (value) {
	          updatePosition();
	          $document.bind('click', documentClickBind);
	          if(elementFocusInitialized) {
	            element.unbind('focus', elementFocusBind);
	          }
	          element[0].focus();
	          documentBindingInitialized = true;
	        } else {
	          if(documentBindingInitialized) {
	            $document.unbind('click', documentClickBind);
	          }
	          element.bind('focus', elementFocusBind);
	          elementFocusInitialized = true;
	        }

	        if ( setIsOpen ) {
	          setIsOpen(originalScope, value);
	        }
	      });

	      scope.today = function() {
	        scope.dateSelection(new Date());
	      };
	      scope.clear = function() {
	        scope.dateSelection(null);
	      };

	      var $popup = $compile(popupEl)(scope);
	      if ( appendToBody ) {
	        $document.find('body').append($popup);
	      } else {
	        element.after($popup);
	      }
	    }
	  };
	}])

	.directive('datepickerPopupWrap', function() {
	  return {
	    restrict:'EA',
	    replace: true,
	    transclude: true,
	    templateUrl: 'template/datepicker/popup.html',
	    link:function (scope, element, attrs) {
	      element.bind('click', function(event) {
	        event.preventDefault();
	        event.stopPropagation();
	      });
	    }
	  };
	});

	/*
	 * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js
	 * @restrict class or attribute
	 * @example:
	   <li class="dropdown">
	     <a class="dropdown-toggle">My Dropdown Menu</a>
	     <ul class="dropdown-menu">
	       <li ng-repeat="choice in dropChoices">
	         <a ng-href="{{choice.href}}">{{choice.text}}</a>
	       </li>
	     </ul>
	   </li>
	 */

	angular.module('ui.bootstrap.dropdownToggle', []).directive('dropdownToggle', ['$document', '$location', function ($document, $location) {
	  var openElement = null,
	      closeMenu   = angular.noop;
	  return {
	    restrict: 'CA',
	    link: function(scope, element, attrs) {
	      scope.$watch('$location.path', function() { closeMenu(); });
	      element.parent().bind('click', function() { closeMenu(); });
	      element.bind('click', function (event) {

	        var elementWasOpen = (element === openElement);

	        event.preventDefault();
	        event.stopPropagation();

	        if (!!openElement) {
	          closeMenu();
	        }

	        if (!elementWasOpen && !element.hasClass('disabled') && !element.prop('disabled')) {
	          element.parent().addClass('open');
	          openElement = element;
	          closeMenu = function (event) {
	            if (event) {
	              event.preventDefault();
	              event.stopPropagation();
	            }
	            $document.unbind('click', closeMenu);
	            element.parent().removeClass('open');
	            closeMenu = angular.noop;
	            openElement = null;
	          };
	          $document.bind('click', closeMenu);
	        }
	      });
	    }
	  };
	}]);

	angular.module('ui.bootstrap.modal', ['ui.bootstrap.transition'])

	/**
	 * A helper, internal data structure that acts as a map but also allows getting / removing
	 * elements in the LIFO order
	 */
	  .factory('$$stackedMap', function () {
	    return {
	      createNew: function () {
	        var stack = [];

	        return {
	          add: function (key, value) {
	            stack.push({
	              key: key,
	              value: value
	            });
	          },
	          get: function (key) {
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                return stack[i];
	              }
	            }
	          },
	          keys: function() {
	            var keys = [];
	            for (var i = 0; i < stack.length; i++) {
	              keys.push(stack[i].key);
	            }
	            return keys;
	          },
	          top: function () {
	            return stack[stack.length - 1];
	          },
	          remove: function (key) {
	            var idx = -1;
	            for (var i = 0; i < stack.length; i++) {
	              if (key == stack[i].key) {
	                idx = i;
	                break;
	              }
	            }
	            return stack.splice(idx, 1)[0];
	          },
	          removeTop: function () {
	            return stack.splice(stack.length - 1, 1)[0];
	          },
	          length: function () {
	            return stack.length;
	          }
	        };
	      }
	    };
	  })

	/**
	 * A helper directive for the $modal service. It creates a backdrop element.
	 */
	  .directive('modalBackdrop', ['$timeout', function ($timeout) {
	    return {
	      restrict: 'EA',
	      replace: true,
	      templateUrl: 'template/modal/backdrop.html',
	      link: function (scope) {

	        scope.animate = false;

	        //trigger CSS transitions
	        $timeout(function () {
	          scope.animate = true;
	        });
	      }
	    };
	  }])

	  .directive('modalWindow', ['$modalStack', '$timeout', function ($modalStack, $timeout) {
	    return {
	      restrict: 'EA',
	      scope: {
	        index: '@',
	        animate: '='
	      },
	      replace: true,
	      transclude: true,
	      templateUrl: 'template/modal/window.html',
	      link: function (scope, element, attrs) {
	        scope.windowClass = attrs.windowClass || '';

	        $timeout(function () {
	          // trigger CSS transitions
	          scope.animate = true;
	          // focus a freshly-opened modal
	          element[0].focus();
	        });

	        scope.close = function (evt) {
	          var modal = $modalStack.getTop();
	          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {
	            evt.preventDefault();
	            evt.stopPropagation();
	            $modalStack.dismiss(modal.key, 'backdrop click');
	          }
	        };
	      }
	    };
	  }])

	  .factory('$modalStack', ['$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',
	    function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {

	      var OPENED_MODAL_CLASS = 'modal-open';

	      var backdropDomEl, backdropScope;
	      var openedWindows = $$stackedMap.createNew();
	      var $modalStack = {};

	      function backdropIndex() {
	        var topBackdropIndex = -1;
	        var opened = openedWindows.keys();
	        for (var i = 0; i < opened.length; i++) {
	          if (openedWindows.get(opened[i]).value.backdrop) {
	            topBackdropIndex = i;
	          }
	        }
	        return topBackdropIndex;
	      }

	      $rootScope.$watch(backdropIndex, function(newBackdropIndex){
	        if (backdropScope) {
	          backdropScope.index = newBackdropIndex;
	        }
	      });

	      function removeModalWindow(modalInstance) {

	        var body = $document.find('body').eq(0);
	        var modalWindow = openedWindows.get(modalInstance).value;

	        //clean up the stack
	        openedWindows.remove(modalInstance);

	        //remove window DOM element
	        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, checkRemoveBackdrop);
	        body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
	      }

	      function checkRemoveBackdrop() {
	          //remove backdrop if no longer needed
	          if (backdropDomEl && backdropIndex() == -1) {
	            var backdropScopeRef = backdropScope;
	            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {
	              backdropScopeRef.$destroy();
	              backdropScopeRef = null;
	            });
	            backdropDomEl = undefined;
	            backdropScope = undefined;
	          }
	      }

	      function removeAfterAnimate(domEl, scope, emulateTime, done) {
	        // Closing animation
	        scope.animate = false;

	        var transitionEndEventName = $transition.transitionEndEventName;
	        if (transitionEndEventName) {
	          // transition out
	          var timeout = $timeout(afterAnimating, emulateTime);

	          domEl.bind(transitionEndEventName, function () {
	            $timeout.cancel(timeout);
	            afterAnimating();
	            scope.$apply();
	          });
	        } else {
	          // Ensure this call is async
	          $timeout(afterAnimating, 0);
	        }

	        function afterAnimating() {
	          if (afterAnimating.done) {
	            return;
	          }
	          afterAnimating.done = true;

	          domEl.remove();
	          if (done) {
	            done();
	          }
	        }
	      }

	      $document.bind('keydown', function (evt) {
	        var modal;

	        if (evt.which === 27) {
	          modal = openedWindows.top();
	          if (modal && modal.value.keyboard) {
	            $rootScope.$apply(function () {
	              $modalStack.dismiss(modal.key);
	            });
	          }
	        }
	      });

	      $modalStack.open = function (modalInstance, modal) {

	        openedWindows.add(modalInstance, {
	          deferred: modal.deferred,
	          modalScope: modal.scope,
	          backdrop: modal.backdrop,
	          keyboard: modal.keyboard
	        });

	        var body = $document.find('body').eq(0),
	            currBackdropIndex = backdropIndex();

	        if (currBackdropIndex >= 0 && !backdropDomEl) {
	          backdropScope = $rootScope.$new(true);
	          backdropScope.index = currBackdropIndex;
	          backdropDomEl = $compile('<div modal-backdrop></div>')(backdropScope);
	          body.append(backdropDomEl);
	        }
	          
	        var angularDomEl = angular.element('<div modal-window></div>');
	        angularDomEl.attr('window-class', modal.windowClass);
	        angularDomEl.attr('index', openedWindows.length() - 1);
	        angularDomEl.attr('animate', 'animate');
	        angularDomEl.html(modal.content);

	        var modalDomEl = $compile(angularDomEl)(modal.scope);
	        openedWindows.top().value.modalDomEl = modalDomEl;
	        body.append(modalDomEl);
	        body.addClass(OPENED_MODAL_CLASS);
	      };

	      $modalStack.close = function (modalInstance, result) {
	        var modalWindow = openedWindows.get(modalInstance).value;
	        if (modalWindow) {
	          modalWindow.deferred.resolve(result);
	          removeModalWindow(modalInstance);
	        }
	      };

	      $modalStack.dismiss = function (modalInstance, reason) {
	        var modalWindow = openedWindows.get(modalInstance).value;
	        if (modalWindow) {
	          modalWindow.deferred.reject(reason);
	          removeModalWindow(modalInstance);
	        }
	      };

	      $modalStack.dismissAll = function (reason) {
	        var topModal = this.getTop();
	        while (topModal) {
	          this.dismiss(topModal.key, reason);
	          topModal = this.getTop();
	        }
	      };

	      $modalStack.getTop = function () {
	        return openedWindows.top();
	      };

	      return $modalStack;
	    }])

	  .provider('$modal', function () {

	    var $modalProvider = {
	      options: {
	        backdrop: true, //can be also false or 'static'
	        keyboard: true
	      },
	      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',
	        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {

	          var $modal = {};

	          function getTemplatePromise(options) {
	            return options.template ? $q.when(options.template) :
	              $http.get(options.templateUrl, {cache: $templateCache}).then(function (result) {
	                return result.data;
	              });
	          }

	          function getResolvePromises(resolves) {
	            var promisesArr = [];
	            angular.forEach(resolves, function (value, key) {
	              if (angular.isFunction(value) || angular.isArray(value)) {
	                promisesArr.push($q.when($injector.invoke(value)));
	              }
	            });
	            return promisesArr;
	          }

	          $modal.open = function (modalOptions) {

	            var modalResultDeferred = $q.defer();
	            var modalOpenedDeferred = $q.defer();

	            //prepare an instance of a modal to be injected into controllers and returned to a caller
	            var modalInstance = {
	              result: modalResultDeferred.promise,
	              opened: modalOpenedDeferred.promise,
	              close: function (result) {
	                $modalStack.close(modalInstance, result);
	              },
	              dismiss: function (reason) {
	                $modalStack.dismiss(modalInstance, reason);
	              }
	            };

	            //merge and clean up options
	            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
	            modalOptions.resolve = modalOptions.resolve || {};

	            //verify options
	            if (!modalOptions.template && !modalOptions.templateUrl) {
	              throw new Error('One of template or templateUrl options is required.');
	            }

	            var templateAndResolvePromise =
	              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));


	            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

	              var modalScope = (modalOptions.scope || $rootScope).$new();
	              modalScope.$close = modalInstance.close;
	              modalScope.$dismiss = modalInstance.dismiss;

	              var ctrlInstance, ctrlLocals = {};
	              var resolveIter = 1;

	              //controllers
	              if (modalOptions.controller) {
	                ctrlLocals.$scope = modalScope;
	                ctrlLocals.$modalInstance = modalInstance;
	                angular.forEach(modalOptions.resolve, function (value, key) {
	                  ctrlLocals[key] = tplAndVars[resolveIter++];
	                });

	                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
	              }

	              $modalStack.open(modalInstance, {
	                scope: modalScope,
	                deferred: modalResultDeferred,
	                content: tplAndVars[0],
	                backdrop: modalOptions.backdrop,
	                keyboard: modalOptions.keyboard,
	                windowClass: modalOptions.windowClass
	              });

	            }, function resolveError(reason) {
	              modalResultDeferred.reject(reason);
	            });

	            templateAndResolvePromise.then(function () {
	              modalOpenedDeferred.resolve(true);
	            }, function () {
	              modalOpenedDeferred.reject(false);
	            });

	            return modalInstance;
	          };

	          return $modal;
	        }]
	    };

	    return $modalProvider;
	  });

	angular.module('ui.bootstrap.pagination', [])

	.controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function ($scope, $attrs, $parse, $interpolate) {
	  var self = this,
	      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

	  this.init = function(defaultItemsPerPage) {
	    if ($attrs.itemsPerPage) {
	      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
	        self.itemsPerPage = parseInt(value, 10);
	        $scope.totalPages = self.calculateTotalPages();
	      });
	    } else {
	      this.itemsPerPage = defaultItemsPerPage;
	    }
	  };

	  this.noPrevious = function() {
	    return this.page === 1;
	  };
	  this.noNext = function() {
	    return this.page === $scope.totalPages;
	  };

	  this.isActive = function(page) {
	    return this.page === page;
	  };

	  this.calculateTotalPages = function() {
	    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
	    return Math.max(totalPages || 0, 1);
	  };

	  this.getAttributeValue = function(attribute, defaultValue, interpolate) {
	    return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;
	  };

	  this.render = function() {
	    this.page = parseInt($scope.page, 10) || 1;
	    if (this.page > 0 && this.page <= $scope.totalPages) {
	      $scope.pages = this.getPages(this.page, $scope.totalPages);
	    }
	  };

	  $scope.selectPage = function(page) {
	    if ( ! self.isActive(page) && page > 0 && page <= $scope.totalPages) {
	      $scope.page = page;
	      $scope.onSelectPage({ page: page });
	    }
	  };

	  $scope.$watch('page', function() {
	    self.render();
	  });

	  $scope.$watch('totalItems', function() {
	    $scope.totalPages = self.calculateTotalPages();
	  });

	  $scope.$watch('totalPages', function(value) {
	    setNumPages($scope.$parent, value); // Readonly variable

	    if ( self.page > value ) {
	      $scope.selectPage(value);
	    } else {
	      self.render();
	    }
	  });
	}])

	.constant('paginationConfig', {
	  itemsPerPage: 10,
	  boundaryLinks: false,
	  directionLinks: true,
	  firstText: 'First',
	  previousText: 'Previous',
	  nextText: 'Next',
	  lastText: 'Last',
	  rotate: true
	})

	.directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {
	  return {
	    restrict: 'EA',
	    scope: {
	      page: '=',
	      totalItems: '=',
	      onSelectPage:' &'
	    },
	    controller: 'PaginationController',
	    templateUrl: 'template/pagination/pagination.html',
	    replace: true,
	    link: function(scope, element, attrs, paginationCtrl) {

	      // Setup configuration parameters
	      var maxSize,
	      boundaryLinks  = paginationCtrl.getAttributeValue(attrs.boundaryLinks,  config.boundaryLinks      ),
	      directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks     ),
	      firstText      = paginationCtrl.getAttributeValue(attrs.firstText,      config.firstText,     true),
	      previousText   = paginationCtrl.getAttributeValue(attrs.previousText,   config.previousText,  true),
	      nextText       = paginationCtrl.getAttributeValue(attrs.nextText,       config.nextText,      true),
	      lastText       = paginationCtrl.getAttributeValue(attrs.lastText,       config.lastText,      true),
	      rotate         = paginationCtrl.getAttributeValue(attrs.rotate,         config.rotate);

	      paginationCtrl.init(config.itemsPerPage);

	      if (attrs.maxSize) {
	        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
	          maxSize = parseInt(value, 10);
	          paginationCtrl.render();
	        });
	      }

	      // Create page object used in template
	      function makePage(number, text, isActive, isDisabled) {
	        return {
	          number: number,
	          text: text,
	          active: isActive,
	          disabled: isDisabled
	        };
	      }

	      paginationCtrl.getPages = function(currentPage, totalPages) {
	        var pages = [];

	        // Default page limits
	        var startPage = 1, endPage = totalPages;
	        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

	        // recompute if maxSize
	        if ( isMaxSized ) {
	          if ( rotate ) {
	            // Current page is displayed in the middle of the visible ones
	            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
	            endPage   = startPage + maxSize - 1;

	            // Adjust if limit is exceeded
	            if (endPage > totalPages) {
	              endPage   = totalPages;
	              startPage = endPage - maxSize + 1;
	            }
	          } else {
	            // Visible pages are paginated with maxSize
	            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

	            // Adjust last page if limit is exceeded
	            endPage = Math.min(startPage + maxSize - 1, totalPages);
	          }
	        }

	        // Add page number links
	        for (var number = startPage; number <= endPage; number++) {
	          var page = makePage(number, number, paginationCtrl.isActive(number), false);
	          pages.push(page);
	        }

	        // Add links to move between page sets
	        if ( isMaxSized && ! rotate ) {
	          if ( startPage > 1 ) {
	            var previousPageSet = makePage(startPage - 1, '...', false, false);
	            pages.unshift(previousPageSet);
	          }

	          if ( endPage < totalPages ) {
	            var nextPageSet = makePage(endPage + 1, '...', false, false);
	            pages.push(nextPageSet);
	          }
	        }

	        // Add previous & next links
	        if (directionLinks) {
	          var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
	          pages.unshift(previousPage);

	          var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
	          pages.push(nextPage);
	        }

	        // Add first & last links
	        if (boundaryLinks) {
	          var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
	          pages.unshift(firstPage);

	          var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
	          pages.push(lastPage);
	        }

	        return pages;
	      };
	    }
	  };
	}])

	.constant('pagerConfig', {
	  itemsPerPage: 10,
	  previousText: ' Previous',
	  nextText: 'Next ',
	  align: true
	})

	.directive('pager', ['pagerConfig', function(config) {
	  return {
	    restrict: 'EA',
	    scope: {
	      page: '=',
	      totalItems: '=',
	      onSelectPage:' &'
	    },
	    controller: 'PaginationController',
	    templateUrl: 'template/pagination/pager.html',
	    replace: true,
	    link: function(scope, element, attrs, paginationCtrl) {

	      // Setup configuration parameters
	      var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
	      nextText         = paginationCtrl.getAttributeValue(attrs.nextText,     config.nextText,     true),
	      align            = paginationCtrl.getAttributeValue(attrs.align,        config.align);

	      paginationCtrl.init(config.itemsPerPage);

	      // Create page object used in template
	      function makePage(number, text, isDisabled, isPrevious, isNext) {
	        return {
	          number: number,
	          text: text,
	          disabled: isDisabled,
	          previous: ( align && isPrevious ),
	          next: ( align && isNext )
	        };
	      }

	      paginationCtrl.getPages = function(currentPage) {
	        return [
	          makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),
	          makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)
	        ];
	      };
	    }
	  };
	}]);

	/**
	 * The following features are still outstanding: animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html tooltips, and selector delegation.
	 */
	angular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )

	/**
	 * The $tooltip service creates tooltip- and popover-like directives as well as
	 * houses global options for them.
	 */
	.provider( '$tooltip', function () {
	  // The default options tooltip and popover.
	  var defaultOptions = {
	    placement: 'top',
	    animation: true,
	    popupDelay: 0
	  };

	  // Default hide triggers for each show trigger
	  var triggerMap = {
	    'mouseenter': 'mouseleave',
	    'click': 'click',
	    'focus': 'blur'
	  };

	  // The options specified to the provider globally.
	  var globalOptions = {};
	  
	  /**
	   * `options({})` allows global configuration of all tooltips in the
	   * application.
	   *
	   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
	   *     // place tooltips left instead of top by default
	   *     $tooltipProvider.options( { placement: 'left' } );
	   *   });
	   */
		this.options = function( value ) {
			angular.extend( globalOptions, value );
		};

	  /**
	   * This allows you to extend the set of trigger mappings available. E.g.:
	   *
	   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
	   */
	  this.setTriggers = function setTriggers ( triggers ) {
	    angular.extend( triggerMap, triggers );
	  };

	  /**
	   * This is a helper function for translating camel-case to snake-case.
	   */
	  function snake_case(name){
	    var regexp = /[A-Z]/g;
	    var separator = '-';
	    return name.replace(regexp, function(letter, pos) {
	      return (pos ? separator : '') + letter.toLowerCase();
	    });
	  }

	  /**
	   * Returns the actual instance of the $tooltip service.
	   * TODO support multiple triggers
	   */
	  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {
	    return function $tooltip ( type, prefix, defaultTriggerShow ) {
	      var options = angular.extend( {}, defaultOptions, globalOptions );

	      /**
	       * Returns an object of show and hide triggers.
	       *
	       * If a trigger is supplied,
	       * it is used to show the tooltip; otherwise, it will use the `trigger`
	       * option passed to the `$tooltipProvider.options` method; else it will
	       * default to the trigger supplied to this directive factory.
	       *
	       * The hide trigger is based on the show trigger. If the `trigger` option
	       * was passed to the `$tooltipProvider.options` method, it will use the
	       * mapped trigger from `triggerMap` or the passed trigger if the map is
	       * undefined; otherwise, it uses the `triggerMap` value of the show
	       * trigger; else it will just use the show trigger.
	       */
	      function getTriggers ( trigger ) {
	        var show = trigger || options.trigger || defaultTriggerShow;
	        var hide = triggerMap[show] || show;
	        return {
	          show: show,
	          hide: hide
	        };
	      }

	      var directiveName = snake_case( type );

	      var startSym = $interpolate.startSymbol();
	      var endSym = $interpolate.endSymbol();
	      var template = 
	        '<div '+ directiveName +'-popup '+
	          'title="'+startSym+'tt_title'+endSym+'" '+
	          'content="'+startSym+'tt_content'+endSym+'" '+
	          'placement="'+startSym+'tt_placement'+endSym+'" '+
	          'animation="tt_animation" '+
	          'is-open="tt_isOpen"'+
	          '>'+
	        '</div>';

	      return {
	        restrict: 'EA',
	        scope: true,
	        compile: function (tElem, tAttrs) {
	          var tooltipLinker = $compile( template );

	          return function link ( scope, element, attrs ) {
	            var tooltip;
	            var transitionTimeout;
	            var popupTimeout;
	            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;
	            var triggers = getTriggers( undefined );
	            var hasRegisteredTriggers = false;
	            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);

	            var positionTooltip = function (){
	              var position,
	                ttWidth,
	                ttHeight,
	                ttPosition;
	              // Get the position of the directive element.
	              position = appendToBody ? $position.offset( element ) : $position.position( element );

	              // Get the height and width of the tooltip so we can center it.
	              ttWidth = tooltip.prop( 'offsetWidth' );
	              ttHeight = tooltip.prop( 'offsetHeight' );

	              // Calculate the tooltip's top and left coordinates to center it with
	              // this directive.
	              switch ( scope.tt_placement ) {
	                case 'right':
	                  ttPosition = {
	                    top: position.top + position.height / 2 - ttHeight / 2,
	                    left: position.left + position.width
	                  };
	                  break;
	                case 'bottom':
	                  ttPosition = {
	                    top: position.top + position.height,
	                    left: position.left + position.width / 2 - ttWidth / 2
	                  };
	                  break;
	                case 'left':
	                  ttPosition = {
	                    top: position.top + position.height / 2 - ttHeight / 2,
	                    left: position.left - ttWidth
	                  };
	                  break;
	                default:
	                  ttPosition = {
	                    top: position.top - ttHeight,
	                    left: position.left + position.width / 2 - ttWidth / 2
	                  };
	                  break;
	              }

	              ttPosition.top += 'px';
	              ttPosition.left += 'px';

	              // Now set the calculated positioning.
	              tooltip.css( ttPosition );

	            };

	            // By default, the tooltip is not open.
	            // TODO add ability to start tooltip opened
	            scope.tt_isOpen = false;

	            function toggleTooltipBind () {
	              if ( ! scope.tt_isOpen ) {
	                showTooltipBind();
	              } else {
	                hideTooltipBind();
	              }
	            }

	            // Show the tooltip with delay if specified, otherwise show it immediately
	            function showTooltipBind() {
	              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {
	                return;
	              }
	              if ( scope.tt_popupDelay ) {
	                popupTimeout = $timeout( show, scope.tt_popupDelay, false );
	                popupTimeout.then(function(reposition){reposition();});
	              } else {
	                show()();
	              }
	            }

	            function hideTooltipBind () {
	              scope.$apply(function () {
	                hide();
	              });
	            }

	            // Show the tooltip popup element.
	            function show() {


	              // Don't show empty tooltips.
	              if ( ! scope.tt_content ) {
	                return angular.noop;
	              }

	              createTooltip();

	              // If there is a pending remove transition, we must cancel it, lest the
	              // tooltip be mysteriously removed.
	              if ( transitionTimeout ) {
	                $timeout.cancel( transitionTimeout );
	              }

	              // Set the initial positioning.
	              tooltip.css({ top: 0, left: 0, display: 'block' });

	              // Now we add it to the DOM because need some info about it. But it's not 
	              // visible yet anyway.
	              if ( appendToBody ) {
	                  $document.find( 'body' ).append( tooltip );
	              } else {
	                element.after( tooltip );
	              }

	              positionTooltip();

	              // And show the tooltip.
	              scope.tt_isOpen = true;
	              scope.$digest(); // digest required as $apply is not called

	              // Return positioning function as promise callback for correct
	              // positioning after draw.
	              return positionTooltip;
	            }

	            // Hide the tooltip popup element.
	            function hide() {
	              // First things first: we don't show it anymore.
	              scope.tt_isOpen = false;

	              //if tooltip is going to be shown after delay, we must cancel this
	              $timeout.cancel( popupTimeout );

	              // And now we remove it from the DOM. However, if we have animation, we 
	              // need to wait for it to expire beforehand.
	              // FIXME: this is a placeholder for a port of the transitions library.
	              if ( scope.tt_animation ) {
	                transitionTimeout = $timeout(removeTooltip, 500);
	              } else {
	                removeTooltip();
	              }
	            }

	            function createTooltip() {
	              // There can only be one tooltip element per directive shown at once.
	              if (tooltip) {
	                removeTooltip();
	              }
	              tooltip = tooltipLinker(scope, function () {});

	              // Get contents rendered into the tooltip
	              scope.$digest();
	            }

	            function removeTooltip() {
	              if (tooltip) {
	                tooltip.remove();
	                tooltip = null;
	              }
	            }

	            /**
	             * Observe the relevant attributes.
	             */
	            attrs.$observe( type, function ( val ) {
	              scope.tt_content = val;

	              if (!val && scope.tt_isOpen ) {
	                hide();
	              }
	            });

	            attrs.$observe( prefix+'Title', function ( val ) {
	              scope.tt_title = val;
	            });

	            attrs.$observe( prefix+'Placement', function ( val ) {
	              scope.tt_placement = angular.isDefined( val ) ? val : options.placement;
	            });

	            attrs.$observe( prefix+'PopupDelay', function ( val ) {
	              var delay = parseInt( val, 10 );
	              scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;
	            });

	            var unregisterTriggers = function() {
	              if (hasRegisteredTriggers) {
	                element.unbind( triggers.show, showTooltipBind );
	                element.unbind( triggers.hide, hideTooltipBind );
	              }
	            };

	            attrs.$observe( prefix+'Trigger', function ( val ) {
	              unregisterTriggers();

	              triggers = getTriggers( val );

	              if ( triggers.show === triggers.hide ) {
	                element.bind( triggers.show, toggleTooltipBind );
	              } else {
	                element.bind( triggers.show, showTooltipBind );
	                element.bind( triggers.hide, hideTooltipBind );
	              }

	              hasRegisteredTriggers = true;
	            });

	            var animation = scope.$eval(attrs[prefix + 'Animation']);
	            scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;

	            attrs.$observe( prefix+'AppendToBody', function ( val ) {
	              appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;
	            });

	            // if a tooltip is attached to <body> we need to remove it on
	            // location change as its parent scope will probably not be destroyed
	            // by the change.
	            if ( appendToBody ) {
	              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {
	              if ( scope.tt_isOpen ) {
	                hide();
	              }
	            });
	            }

	            // Make sure tooltip is destroyed and removed.
	            scope.$on('$destroy', function onDestroyTooltip() {
	              $timeout.cancel( transitionTimeout );
	              $timeout.cancel( popupTimeout );
	              unregisterTriggers();
	              removeTooltip();
	            });
	          };
	        }
	      };
	    };
	  }];
	})

	.directive( 'tooltipPopup', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-popup.html'
	  };
	})

	.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {
	  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );
	}])

	.directive( 'tooltipHtmlUnsafePopup', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
	  };
	})

	.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {
	  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );
	}]);

	/**
	 * The following features are still outstanding: popup delay, animation as a
	 * function, placement as a function, inside, support for more triggers than
	 * just mouse enter/leave, html popovers, and selector delegatation.
	 */
	angular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )

	.directive( 'popoverPopup', function () {
	  return {
	    restrict: 'EA',
	    replace: true,
	    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
	    templateUrl: 'template/popover/popover.html'
	  };
	})

	.directive( 'popover', [ '$tooltip', function ( $tooltip ) {
	  return $tooltip( 'popover', 'popover', 'click' );
	}]);

	angular.module('ui.bootstrap.progressbar', ['ui.bootstrap.transition'])

	.constant('progressConfig', {
	  animate: true,
	  max: 100
	})

	.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', '$transition', function($scope, $attrs, progressConfig, $transition) {
	    var self = this,
	        bars = [],
	        max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max,
	        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

	    this.addBar = function(bar, element) {
	        var oldValue = 0, index = bar.$parent.$index;
	        if ( angular.isDefined(index) &&  bars[index] ) {
	            oldValue = bars[index].value;
	        }
	        bars.push(bar);

	        this.update(element, bar.value, oldValue);

	        bar.$watch('value', function(value, oldValue) {
	            if (value !== oldValue) {
	                self.update(element, value, oldValue);
	            }
	        });

	        bar.$on('$destroy', function() {
	            self.removeBar(bar);
	        });
	    };

	    // Update bar element width
	    this.update = function(element, newValue, oldValue) {
	        var percent = this.getPercentage(newValue);

	        if (animate) {
	            element.css('width', this.getPercentage(oldValue) + '%');
	            $transition(element, {width: percent + '%'});
	        } else {
	            element.css({'transition': 'none', 'width': percent + '%'});
	        }
	    };

	    this.removeBar = function(bar) {
	        bars.splice(bars.indexOf(bar), 1);
	    };

	    this.getPercentage = function(value) {
	        return Math.round(100 * value / max);
	    };
	}])

	.directive('progress', function() {
	    return {
	        restrict: 'EA',
	        replace: true,
	        transclude: true,
	        controller: 'ProgressController',
	        require: 'progress',
	        scope: {},
	        template: '<div class="progress" ng-transclude></div>'
	        //templateUrl: 'template/progressbar/progress.html' // Works in AngularJS 1.2
	    };
	})

	.directive('bar', function() {
	    return {
	        restrict: 'EA',
	        replace: true,
	        transclude: true,
	        require: '^progress',
	        scope: {
	            value: '=',
	            type: '@'
	        },
	        templateUrl: 'template/progressbar/bar.html',
	        link: function(scope, element, attrs, progressCtrl) {
	            progressCtrl.addBar(scope, element);
	        }
	    };
	})

	.directive('progressbar', function() {
	    return {
	        restrict: 'EA',
	        replace: true,
	        transclude: true,
	        controller: 'ProgressController',
	        scope: {
	            value: '=',
	            type: '@'
	        },
	        templateUrl: 'template/progressbar/progressbar.html',
	        link: function(scope, element, attrs, progressCtrl) {
	            progressCtrl.addBar(scope, angular.element(element.children()[0]));
	        }
	    };
	});
	angular.module('ui.bootstrap.rating', [])

	.constant('ratingConfig', {
	  max: 5,
	  stateOn: null,
	  stateOff: null
	})

	.controller('RatingController', ['$scope', '$attrs', '$parse', 'ratingConfig', function($scope, $attrs, $parse, ratingConfig) {

	  this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;
	  this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
	  this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

	  this.createRateObjects = function(states) {
	    var defaultOptions = {
	      stateOn: this.stateOn,
	      stateOff: this.stateOff
	    };

	    for (var i = 0, n = states.length; i < n; i++) {
	      states[i] = angular.extend({ index: i }, defaultOptions, states[i]);
	    }
	    return states;
	  };

	  // Get objects used in template
	  $scope.range = angular.isDefined($attrs.ratingStates) ?  this.createRateObjects(angular.copy($scope.$parent.$eval($attrs.ratingStates))): this.createRateObjects(new Array(this.maxRange));

	  $scope.rate = function(value) {
	    if ( $scope.value !== value && !$scope.readonly ) {
	      $scope.value = value;
	    }
	  };

	  $scope.enter = function(value) {
	    if ( ! $scope.readonly ) {
	      $scope.val = value;
	    }
	    $scope.onHover({value: value});
	  };

	  $scope.reset = function() {
	    $scope.val = angular.copy($scope.value);
	    $scope.onLeave();
	  };

	  $scope.$watch('value', function(value) {
	    $scope.val = value;
	  });

	  $scope.readonly = false;
	  if ($attrs.readonly) {
	    $scope.$parent.$watch($parse($attrs.readonly), function(value) {
	      $scope.readonly = !!value;
	    });
	  }
	}])

	.directive('rating', function() {
	  return {
	    restrict: 'EA',
	    scope: {
	      value: '=',
	      onHover: '&',
	      onLeave: '&'
	    },
	    controller: 'RatingController',
	    templateUrl: 'template/rating/rating.html',
	    replace: true
	  };
	});

	/**
	 * @ngdoc overview
	 * @name ui.bootstrap.tabs
	 *
	 * @description
	 * AngularJS version of the tabs directive.
	 */

	angular.module('ui.bootstrap.tabs', [])

	.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
	  var ctrl = this,
	      tabs = ctrl.tabs = $scope.tabs = [];

	  ctrl.select = function(tab) {
	    angular.forEach(tabs, function(tab) {
	      tab.active = false;
	    });
	    tab.active = true;
	  };

	  ctrl.addTab = function addTab(tab) {
	    tabs.push(tab);
	    if (tabs.length === 1 || tab.active) {
	      ctrl.select(tab);
	    }
	  };

	  ctrl.removeTab = function removeTab(tab) {
	    var index = tabs.indexOf(tab);
	    //Select a new tab if the tab to be removed is selected
	    if (tab.active && tabs.length > 1) {
	      //If this is the last tab, select the previous tab. else, the next tab.
	      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
	      ctrl.select(tabs[newActiveIndex]);
	    }
	    tabs.splice(index, 1);
	  };
	}])

	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabset
	 * @restrict EA
	 *
	 * @description
	 * Tabset is the outer container for the tabs directive
	 *
	 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
	 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab heading="Tab 1"><b>First</b> Content!</tab>
	      <tab heading="Tab 2"><i>Second</i> Content!</tab>
	    </tabset>
	    <hr />
	    <tabset vertical="true">
	      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
	      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
	    </tabset>
	    <tabset justified="true">
	      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
	      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tabset', function() {
	  return {
	    restrict: 'EA',
	    transclude: true,
	    replace: true,
	    scope: {},
	    controller: 'TabsetController',
	    templateUrl: 'template/tabs/tabset.html',
	    link: function(scope, element, attrs) {
	      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
	      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
	      scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';
	    }
	  };
	})

	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tab
	 * @restrict EA
	 *
	 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
	 * @param {string=} select An expression to evaluate when the tab is selected.
	 * @param {boolean=} active A binding, telling whether or not this tab is selected.
	 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
	 *
	 * @description
	 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <div ng-controller="TabsDemoCtrl">
	      <button class="btn btn-small" ng-click="items[0].active = true">
	        Select item 1, using active binding
	      </button>
	      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
	        Enable/disable item 2, using disabled binding
	      </button>
	      <br />
	      <tabset>
	        <tab heading="Tab 1">First Tab</tab>
	        <tab select="alertMe()">
	          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
	          Second Tab, with alert callback and html heading!
	        </tab>
	        <tab ng-repeat="item in items"
	          heading="{{item.title}}"
	          disabled="item.disabled"
	          active="item.active">
	          {{item.content}}
	        </tab>
	      </tabset>
	    </div>
	  </file>
	  <file name="script.js">
	    function TabsDemoCtrl($scope) {
	      $scope.items = [
	        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
	        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
	      ];

	      $scope.alertMe = function() {
	        setTimeout(function() {
	          alert("You've selected the alert tab!");
	        });
	      };
	    };
	  </file>
	</example>
	 */

	/**
	 * @ngdoc directive
	 * @name ui.bootstrap.tabs.directive:tabHeading
	 * @restrict EA
	 *
	 * @description
	 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
	 *
	 * @example
	<example module="ui.bootstrap">
	  <file name="index.html">
	    <tabset>
	      <tab>
	        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
	        And some content, too!
	      </tab>
	      <tab>
	        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
	        That's right.
	      </tab>
	    </tabset>
	  </file>
	</example>
	 */
	.directive('tab', ['$parse', function($parse) {
	  return {
	    require: '^tabset',
	    restrict: 'EA',
	    replace: true,
	    templateUrl: 'template/tabs/tab.html',
	    transclude: true,
	    scope: {
	      heading: '@',
	      onSelect: '&select', //This callback is called in contentHeadingTransclude
	                          //once it inserts the tab's content into the dom
	      onDeselect: '&deselect'
	    },
	    controller: function() {
	      //Empty controller so other directives can require being 'under' a tab
	    },
	    compile: function(elm, attrs, transclude) {
	      return function postLink(scope, elm, attrs, tabsetCtrl) {
	        var getActive, setActive;
	        if (attrs.active) {
	          getActive = $parse(attrs.active);
	          setActive = getActive.assign;
	          scope.$parent.$watch(getActive, function updateActive(value, oldVal) {
	            // Avoid re-initializing scope.active as it is already initialized
	            // below. (watcher is called async during init with value ===
	            // oldVal)
	            if (value !== oldVal) {
	              scope.active = !!value;
	            }
	          });
	          scope.active = getActive(scope.$parent);
	        } else {
	          setActive = getActive = angular.noop;
	        }

	        scope.$watch('active', function(active) {
	          // Note this watcher also initializes and assigns scope.active to the
	          // attrs.active expression.
	          setActive(scope.$parent, active);
	          if (active) {
	            tabsetCtrl.select(scope);
	            scope.onSelect();
	          } else {
	            scope.onDeselect();
	          }
	        });

	        scope.disabled = false;
	        if ( attrs.disabled ) {
	          scope.$parent.$watch($parse(attrs.disabled), function(value) {
	            scope.disabled = !! value;
	          });
	        }

	        scope.select = function() {
	          if ( ! scope.disabled ) {
	            scope.active = true;
	          }
	        };

	        tabsetCtrl.addTab(scope);
	        scope.$on('$destroy', function() {
	          tabsetCtrl.removeTab(scope);
	        });


	        //We need to transclude later, once the content container is ready.
	        //when this link happens, we're inside a tab heading.
	        scope.$transcludeFn = transclude;
	      };
	    }
	  };
	}])

	.directive('tabHeadingTransclude', [function() {
	  return {
	    restrict: 'A',
	    require: '^tab',
	    link: function(scope, elm, attrs, tabCtrl) {
	      scope.$watch('headingElement', function updateHeadingElement(heading) {
	        if (heading) {
	          elm.html('');
	          elm.append(heading);
	        }
	      });
	    }
	  };
	}])

	.directive('tabContentTransclude', function() {
	  return {
	    restrict: 'A',
	    require: '^tabset',
	    link: function(scope, elm, attrs) {
	      var tab = scope.$eval(attrs.tabContentTransclude);

	      //Now our tab is ready to be transcluded: both the tab heading area
	      //and the tab content area are loaded.  Transclude 'em both.
	      tab.$transcludeFn(tab.$parent, function(contents) {
	        angular.forEach(contents, function(node) {
	          if (isTabHeading(node)) {
	            //Let tabHeadingTransclude know.
	            tab.headingElement = node;
	          } else {
	            elm.append(node);
	          }
	        });
	      });
	    }
	  };
	  function isTabHeading(node) {
	    return node.tagName &&  (
	      node.hasAttribute('tab-heading') ||
	      node.hasAttribute('data-tab-heading') ||
	      node.tagName.toLowerCase() === 'tab-heading' ||
	      node.tagName.toLowerCase() === 'data-tab-heading'
	    );
	  }
	})

	;

	angular.module('ui.bootstrap.timepicker', [])

	.constant('timepickerConfig', {
	  hourStep: 1,
	  minuteStep: 1,
	  showMeridian: true,
	  meridians: null,
	  readonlyInput: false,
	  mousewheel: true
	})

	.directive('timepicker', ['$parse', '$log', 'timepickerConfig', '$locale', function ($parse, $log, timepickerConfig, $locale) {
	  return {
	    restrict: 'EA',
	    require:'?^ngModel',
	    replace: true,
	    scope: {},
	    templateUrl: 'template/timepicker/timepicker.html',
	    link: function(scope, element, attrs, ngModel) {
	      if ( !ngModel ) {
	        return; // do nothing if no ng-model
	      }

	      var selected = new Date(),
	          meridians = angular.isDefined(attrs.meridians) ? scope.$parent.$eval(attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

	      var hourStep = timepickerConfig.hourStep;
	      if (attrs.hourStep) {
	        scope.$parent.$watch($parse(attrs.hourStep), function(value) {
	          hourStep = parseInt(value, 10);
	        });
	      }

	      var minuteStep = timepickerConfig.minuteStep;
	      if (attrs.minuteStep) {
	        scope.$parent.$watch($parse(attrs.minuteStep), function(value) {
	          minuteStep = parseInt(value, 10);
	        });
	      }

	      // 12H / 24H mode
	      scope.showMeridian = timepickerConfig.showMeridian;
	      if (attrs.showMeridian) {
	        scope.$parent.$watch($parse(attrs.showMeridian), function(value) {
	          scope.showMeridian = !!value;

	          if ( ngModel.$error.time ) {
	            // Evaluate from template
	            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
	            if (angular.isDefined( hours ) && angular.isDefined( minutes )) {
	              selected.setHours( hours );
	              refresh();
	            }
	          } else {
	            updateTemplate();
	          }
	        });
	      }

	      // Get scope.hours in 24H mode if valid
	      function getHoursFromTemplate ( ) {
	        var hours = parseInt( scope.hours, 10 );
	        var valid = ( scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
	        if ( !valid ) {
	          return undefined;
	        }

	        if ( scope.showMeridian ) {
	          if ( hours === 12 ) {
	            hours = 0;
	          }
	          if ( scope.meridian === meridians[1] ) {
	            hours = hours + 12;
	          }
	        }
	        return hours;
	      }

	      function getMinutesFromTemplate() {
	        var minutes = parseInt(scope.minutes, 10);
	        return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;
	      }

	      function pad( value ) {
	        return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;
	      }

	      // Input elements
	      var inputs = element.find('input'), hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);

	      // Respond on mousewheel spin
	      var mousewheel = (angular.isDefined(attrs.mousewheel)) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;
	      if ( mousewheel ) {

	        var isScrollingUp = function(e) {
	          if (e.originalEvent) {
	            e = e.originalEvent;
	          }
	          //pick correct delta variable depending on event
	          var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
	          return (e.detail || delta > 0);
	        };

	        hoursInputEl.bind('mousewheel wheel', function(e) {
	          scope.$apply( (isScrollingUp(e)) ? scope.incrementHours() : scope.decrementHours() );
	          e.preventDefault();
	        });

	        minutesInputEl.bind('mousewheel wheel', function(e) {
	          scope.$apply( (isScrollingUp(e)) ? scope.incrementMinutes() : scope.decrementMinutes() );
	          e.preventDefault();
	        });
	      }

	      scope.readonlyInput = (angular.isDefined(attrs.readonlyInput)) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;
	      if ( ! scope.readonlyInput ) {

	        var invalidate = function(invalidHours, invalidMinutes) {
	          ngModel.$setViewValue( null );
	          ngModel.$setValidity('time', false);
	          if (angular.isDefined(invalidHours)) {
	            scope.invalidHours = invalidHours;
	          }
	          if (angular.isDefined(invalidMinutes)) {
	            scope.invalidMinutes = invalidMinutes;
	          }
	        };

	        scope.updateHours = function() {
	          var hours = getHoursFromTemplate();

	          if ( angular.isDefined(hours) ) {
	            selected.setHours( hours );
	            refresh( 'h' );
	          } else {
	            invalidate(true);
	          }
	        };

	        hoursInputEl.bind('blur', function(e) {
	          if ( !scope.validHours && scope.hours < 10) {
	            scope.$apply( function() {
	              scope.hours = pad( scope.hours );
	            });
	          }
	        });

	        scope.updateMinutes = function() {
	          var minutes = getMinutesFromTemplate();

	          if ( angular.isDefined(minutes) ) {
	            selected.setMinutes( minutes );
	            refresh( 'm' );
	          } else {
	            invalidate(undefined, true);
	          }
	        };

	        minutesInputEl.bind('blur', function(e) {
	          if ( !scope.invalidMinutes && scope.minutes < 10 ) {
	            scope.$apply( function() {
	              scope.minutes = pad( scope.minutes );
	            });
	          }
	        });
	      } else {
	        scope.updateHours = angular.noop;
	        scope.updateMinutes = angular.noop;
	      }

	      ngModel.$render = function() {
	        var date = ngModel.$modelValue ? new Date( ngModel.$modelValue ) : null;

	        if ( isNaN(date) ) {
	          ngModel.$setValidity('time', false);
	          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
	        } else {
	          if ( date ) {
	            selected = date;
	          }
	          makeValid();
	          updateTemplate();
	        }
	      };

	      // Call internally when we know that model is valid.
	      function refresh( keyboardChange ) {
	        makeValid();
	        ngModel.$setViewValue( new Date(selected) );
	        updateTemplate( keyboardChange );
	      }

	      function makeValid() {
	        ngModel.$setValidity('time', true);
	        scope.invalidHours = false;
	        scope.invalidMinutes = false;
	      }

	      function updateTemplate( keyboardChange ) {
	        var hours = selected.getHours(), minutes = selected.getMinutes();

	        if ( scope.showMeridian ) {
	          hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system
	        }
	        scope.hours =  keyboardChange === 'h' ? hours : pad(hours);
	        scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
	        scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
	      }

	      function addMinutes( minutes ) {
	        var dt = new Date( selected.getTime() + minutes * 60000 );
	        selected.setHours( dt.getHours(), dt.getMinutes() );
	        refresh();
	      }

	      scope.incrementHours = function() {
	        addMinutes( hourStep * 60 );
	      };
	      scope.decrementHours = function() {
	        addMinutes( - hourStep * 60 );
	      };
	      scope.incrementMinutes = function() {
	        addMinutes( minuteStep );
	      };
	      scope.decrementMinutes = function() {
	        addMinutes( - minuteStep );
	      };
	      scope.toggleMeridian = function() {
	        addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );
	      };
	    }
	  };
	}]);

	angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

	/**
	 * A helper service that can parse typeahead's syntax (string provided by users)
	 * Extracted to a separate service for ease of unit testing
	 */
	  .factory('typeaheadParser', ['$parse', function ($parse) {

	  //                      00000111000000000000022200000000000000003333333333333330000000000044000
	  var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;

	  return {
	    parse:function (input) {

	      var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
	      if (!match) {
	        throw new Error(
	          "Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" +
	            " but got '" + input + "'.");
	      }

	      return {
	        itemName:match[3],
	        source:$parse(match[4]),
	        viewMapper:$parse(match[2] || match[1]),
	        modelMapper:$parse(match[1])
	      };
	    }
	  };
	}])

	  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',
	    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

	  var HOT_KEYS = [9, 13, 27, 38, 40];

	  return {
	    require:'ngModel',
	    link:function (originalScope, element, attrs, modelCtrl) {

	      //SUPPORTED ATTRIBUTES (OPTIONS)

	      //minimal no of characters that needs to be entered before typeahead kicks-in
	      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

	      //minimal wait time after last character typed before typehead kicks-in
	      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

	      //should it restrict model values to the ones selected from the popup only?
	      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

	      //binding to a variable that indicates if matches are being retrieved asynchronously
	      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

	      //a callback executed when a match is selected
	      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

	      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

	      var appendToBody =  attrs.typeaheadAppendToBody ? $parse(attrs.typeaheadAppendToBody) : false;

	      //INTERNAL VARIABLES

	      //model setter executed upon match selection
	      var $setModelValue = $parse(attrs.ngModel).assign;

	      //expressions used by typeahead
	      var parserResult = typeaheadParser.parse(attrs.typeahead);

	      var hasFocus;

	      //pop-up element used to display matches
	      var popUpEl = angular.element('<div typeahead-popup></div>');
	      popUpEl.attr({
	        matches: 'matches',
	        active: 'activeIdx',
	        select: 'select(activeIdx)',
	        query: 'query',
	        position: 'position'
	      });
	      //custom item template
	      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
	        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
	      }

	      //create a child scope for the typeahead directive so we are not polluting original scope
	      //with typeahead-specific data (matches, query etc.)
	      var scope = originalScope.$new();
	      originalScope.$on('$destroy', function(){
	        scope.$destroy();
	      });

	      var resetMatches = function() {
	        scope.matches = [];
	        scope.activeIdx = -1;
	      };

	      var getMatchesAsync = function(inputValue) {

	        var locals = {$viewValue: inputValue};
	        isLoadingSetter(originalScope, true);
	        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {

	          //it might happen that several async queries were in progress if a user were typing fast
	          //but we are interested only in responses that correspond to the current view value
	          if (inputValue === modelCtrl.$viewValue && hasFocus) {
	            if (matches.length > 0) {

	              scope.activeIdx = 0;
	              scope.matches.length = 0;

	              //transform labels
	              for(var i=0; i<matches.length; i++) {
	                locals[parserResult.itemName] = matches[i];
	                scope.matches.push({
	                  label: parserResult.viewMapper(scope, locals),
	                  model: matches[i]
	                });
	              }

	              scope.query = inputValue;
	              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
	              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
	              //due to other elements being rendered
	              scope.position = appendToBody ? $position.offset(element) : $position.position(element);
	              scope.position.top = scope.position.top + element.prop('offsetHeight');

	            } else {
	              resetMatches();
	            }
	            isLoadingSetter(originalScope, false);
	          }
	        }, function(){
	          resetMatches();
	          isLoadingSetter(originalScope, false);
	        });
	      };

	      resetMatches();

	      //we need to propagate user's query so we can higlight matches
	      scope.query = undefined;

	      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
	      var timeoutPromise;

	      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
	      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
	      modelCtrl.$parsers.unshift(function (inputValue) {

	        hasFocus = true;

	        if (inputValue && inputValue.length >= minSearch) {
	          if (waitTime > 0) {
	            if (timeoutPromise) {
	              $timeout.cancel(timeoutPromise);//cancel previous timeout
	            }
	            timeoutPromise = $timeout(function () {
	              getMatchesAsync(inputValue);
	            }, waitTime);
	          } else {
	            getMatchesAsync(inputValue);
	          }
	        } else {
	          isLoadingSetter(originalScope, false);
	          resetMatches();
	        }

	        if (isEditable) {
	          return inputValue;
	        } else {
	          if (!inputValue) {
	            // Reset in case user had typed something previously.
	            modelCtrl.$setValidity('editable', true);
	            return inputValue;
	          } else {
	            modelCtrl.$setValidity('editable', false);
	            return undefined;
	          }
	        }
	      });

	      modelCtrl.$formatters.push(function (modelValue) {

	        var candidateViewValue, emptyViewValue;
	        var locals = {};

	        if (inputFormatter) {

	          locals['$model'] = modelValue;
	          return inputFormatter(originalScope, locals);

	        } else {

	          //it might happen that we don't have enough info to properly render input value
	          //we need to check for this situation and simply return model value if we can't apply custom formatting
	          locals[parserResult.itemName] = modelValue;
	          candidateViewValue = parserResult.viewMapper(originalScope, locals);
	          locals[parserResult.itemName] = undefined;
	          emptyViewValue = parserResult.viewMapper(originalScope, locals);

	          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
	        }
	      });

	      scope.select = function (activeIdx) {
	        //called from within the $digest() cycle
	        var locals = {};
	        var model, item;

	        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
	        model = parserResult.modelMapper(originalScope, locals);
	        $setModelValue(originalScope, model);
	        modelCtrl.$setValidity('editable', true);

	        onSelectCallback(originalScope, {
	          $item: item,
	          $model: model,
	          $label: parserResult.viewMapper(originalScope, locals)
	        });

	        resetMatches();

	        //return focus to the input element if a mach was selected via a mouse click event
	        element[0].focus();
	      };

	      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
	      element.bind('keydown', function (evt) {

	        //typeahead is open and an "interesting" key was pressed
	        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
	          return;
	        }

	        evt.preventDefault();

	        if (evt.which === 40) {
	          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
	          scope.$digest();

	        } else if (evt.which === 38) {
	          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
	          scope.$digest();

	        } else if (evt.which === 13 || evt.which === 9) {
	          scope.$apply(function () {
	            scope.select(scope.activeIdx);
	          });

	        } else if (evt.which === 27) {
	          evt.stopPropagation();

	          resetMatches();
	          scope.$digest();
	        }
	      });

	      element.bind('blur', function (evt) {
	        hasFocus = false;
	      });

	      // Keep reference to click handler to unbind it.
	      var dismissClickHandler = function (evt) {
	        if (element[0] !== evt.target) {
	          resetMatches();
	          scope.$digest();
	        }
	      };

	      $document.bind('click', dismissClickHandler);

	      originalScope.$on('$destroy', function(){
	        $document.unbind('click', dismissClickHandler);
	      });

	      var $popup = $compile(popUpEl)(scope);
	      if ( appendToBody ) {
	        $document.find('body').append($popup);
	      } else {
	        element.after($popup);
	      }
	    }
	  };

	}])

	  .directive('typeaheadPopup', function () {
	    return {
	      restrict:'EA',
	      scope:{
	        matches:'=',
	        query:'=',
	        active:'=',
	        position:'=',
	        select:'&'
	      },
	      replace:true,
	      templateUrl:'template/typeahead/typeahead-popup.html',
	      link:function (scope, element, attrs) {

	        scope.templateUrl = attrs.templateUrl;

	        scope.isOpen = function () {
	          return scope.matches.length > 0;
	        };

	        scope.isActive = function (matchIdx) {
	          return scope.active == matchIdx;
	        };

	        scope.selectActive = function (matchIdx) {
	          scope.active = matchIdx;
	        };

	        scope.selectMatch = function (activeIdx) {
	          scope.select({activeIdx:activeIdx});
	        };
	      }
	    };
	  })

	  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
	    return {
	      restrict:'EA',
	      scope:{
	        index:'=',
	        match:'=',
	        query:'='
	      },
	      link:function (scope, element, attrs) {
	        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
	        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){
	           element.replaceWith($compile(tplContent.trim())(scope));
	        });
	      }
	    };
	  }])

	  .filter('typeaheadHighlight', function() {

	    function escapeRegexp(queryToEscape) {
	      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
	    }

	    return function(matchItem, query) {
	      return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
	    };
	  });
	angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion-group.html",
	    "<div class=\"panel panel-default\">\n" +
	    "  <div class=\"panel-heading\">\n" +
	    "    <h4 class=\"panel-title\">\n" +
	    "      <a class=\"accordion-toggle\" ng-click=\"isOpen = !isOpen\" accordion-transclude=\"heading\">{{heading}}</a>\n" +
	    "    </h4>\n" +
	    "  </div>\n" +
	    "  <div class=\"panel-collapse\" collapse=\"!isOpen\">\n" +
	    "	  <div class=\"panel-body\" ng-transclude></div>\n" +
	    "  </div>\n" +
	    "</div>");
	}]);

	angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/accordion/accordion.html",
	    "<div class=\"panel-group\" ng-transclude></div>");
	}]);

	angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/alert/alert.html",
	    "<div class='alert' ng-class='\"alert-\" + (type || \"warning\")'>\n" +
	    "    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n" +
	    "    <div ng-transclude></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/carousel.html",
	    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\">\n" +
	    "    <ol class=\"carousel-indicators\" ng-show=\"slides().length > 1\">\n" +
	    "        <li ng-repeat=\"slide in slides()\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
	    "    </ol>\n" +
	    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
	    "    <a class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides().length > 1\"><span class=\"icon-prev\"></span></a>\n" +
	    "    <a class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides().length > 1\"><span class=\"icon-next\"></span></a>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/slide.html",
	    "<div ng-class=\"{\n" +
	    "    'active': leaving || (active && !entering),\n" +
	    "    'prev': (next || active) && direction=='prev',\n" +
	    "    'next': (next || active) && direction=='next',\n" +
	    "    'right': direction=='prev',\n" +
	    "    'left': direction=='next'\n" +
	    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
	    "");
	}]);

	angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/datepicker.html",
	    "<table>\n" +
	    "  <thead>\n" +
	    "    <tr>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
	    "      <th colspan=\"{{rows[0].length - 2 + showWeekNumbers}}\"><button type=\"button\" class=\"btn btn-default btn-sm btn-block\" ng-click=\"toggleMode()\"><strong>{{title}}</strong></button></th>\n" +
	    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
	    "    </tr>\n" +
	    "    <tr ng-show=\"labels.length > 0\" class=\"h6\">\n" +
	    "      <th ng-show=\"showWeekNumbers\" class=\"text-center\">#</th>\n" +
	    "      <th ng-repeat=\"label in labels\" class=\"text-center\">{{label}}</th>\n" +
	    "    </tr>\n" +
	    "  </thead>\n" +
	    "  <tbody>\n" +
	    "    <tr ng-repeat=\"row in rows\">\n" +
	    "      <td ng-show=\"showWeekNumbers\" class=\"text-center\"><em>{{ getWeekNumber(row) }}</em></td>\n" +
	    "      <td ng-repeat=\"dt in row\" class=\"text-center\">\n" +
	    "        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\"><span ng-class=\"{'text-muted': dt.secondary}\">{{dt.label}}</span></button>\n" +
	    "      </td>\n" +
	    "    </tr>\n" +
	    "  </tbody>\n" +
	    "</table>\n" +
	    "");
	}]);

	angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/datepicker/popup.html",
	    "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
	    "	<li ng-transclude></li>\n" +
	    "	<li ng-show=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
	    "		<span class=\"btn-group\">\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"today()\">{{currentText}}</button>\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-default\" ng-click=\"showWeeks = ! showWeeks\" ng-class=\"{active: showWeeks}\">{{toggleWeeksText}}</button>\n" +
	    "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"clear()\">{{clearText}}</button>\n" +
	    "		</span>\n" +
	    "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"isOpen = false\">{{closeText}}</button>\n" +
	    "	</li>\n" +
	    "</ul>\n" +
	    "");
	}]);

	angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/backdrop.html",
	    "<div class=\"modal-backdrop fade\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1040 + index*10}\"></div>");
	}]);

	angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/window.html",
	    "<div tabindex=\"-1\" class=\"modal fade {{ windowClass }}\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" +
	    "    <div class=\"modal-dialog\"><div class=\"modal-content\" ng-transclude></div></div>\n" +
	    "</div>");
	}]);

	angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pager.html",
	    "<ul class=\"pager\">\n" +
	    "  <li ng-repeat=\"page in pages\" ng-class=\"{disabled: page.disabled, previous: page.previous, next: page.next}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
	    "</ul>");
	}]);

	angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/pagination/pagination.html",
	    "<ul class=\"pagination\">\n" +
	    "  <li ng-repeat=\"page in pages\" ng-class=\"{active: page.active, disabled: page.disabled}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
	    "</ul>");
	}]);

	angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
	    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tooltip/tooltip-popup.html",
	    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
	    "  <div class=\"tooltip-arrow\"></div>\n" +
	    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/popover/popover.html",
	    "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
	    "  <div class=\"arrow\"></div>\n" +
	    "\n" +
	    "  <div class=\"popover-inner\">\n" +
	    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n" +
	    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/bar.html",
	    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" ng-transclude></div>");
	}]);

	angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progress.html",
	    "<div class=\"progress\" ng-transclude></div>");
	}]);

	angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/progressbar/progressbar.html",
	    "<div class=\"progress\"><div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" ng-transclude></div></div>");
	}]);

	angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/rating/rating.html",
	    "<span ng-mouseleave=\"reset()\">\n" +
	    "    <i ng-repeat=\"r in range\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < val && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\"></i>\n" +
	    "</span>");
	}]);

	angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tab.html",
	    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
	    "  <a ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
	    "</li>\n" +
	    "");
	}]);

	angular.module("template/tabs/tabset-titles.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tabset-titles.html",
	    "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n" +
	    "</ul>\n" +
	    "");
	}]);

	angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/tabs/tabset.html",
	    "\n" +
	    "<div class=\"tabbable\">\n" +
	    "  <ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
	    "  <div class=\"tab-content\">\n" +
	    "    <div class=\"tab-pane\" \n" +
	    "         ng-repeat=\"tab in tabs\" \n" +
	    "         ng-class=\"{active: tab.active}\"\n" +
	    "         tab-content-transclude=\"tab\">\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);

	angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/timepicker/timepicker.html",
	    "<table>\n" +
	    "	<tbody>\n" +
	    "		<tr class=\"text-center\">\n" +
	    "			<td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "			<td>&nbsp;</td>\n" +
	    "			<td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
	    "			<td ng-show=\"showMeridian\"></td>\n" +
	    "		</tr>\n" +
	    "		<tr>\n" +
	    "			<td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
	    "				<input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n" +
	    "			</td>\n" +
	    "			<td>:</td>\n" +
	    "			<td style=\"width:50px;\" class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
	    "				<input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n" +
	    "			</td>\n" +
	    "			<td ng-show=\"showMeridian\"><button type=\"button\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n" +
	    "		</tr>\n" +
	    "		<tr class=\"text-center\">\n" +
	    "			<td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "			<td>&nbsp;</td>\n" +
	    "			<td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
	    "			<td ng-show=\"showMeridian\"></td>\n" +
	    "		</tr>\n" +
	    "	</tbody>\n" +
	    "</table>\n" +
	    "");
	}]);

	angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-match.html",
	    "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>");
	}]);

	angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/typeahead/typeahead-popup.html",
	    "<ul class=\"dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
	    "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\">\n" +
	    "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
	    "    </li>\n" +
	    "</ul>");
	}]);


/***/ },
/* 884 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana').config(function ($provide) {

	    $provide.decorator('$rootScope', function ($delegate) {
	      /**
	       * Watch multiple expressions with a single callback. Along
	       * with making code simpler it also merges all of the watcher
	       * handlers within a single tick.
	       *
	       * # expression format
	       * expressions can be specified in one of the following ways:
	       * 1. string that evaluates to a value on scope. Creates a regular $watch
	       *    expression.
	       *     'someScopeValue.prop' === $scope.$watch('someScopeValue.prop', fn);
	       *
	       * 2. #1 prefixed with '[]', which uses $watchCollection rather than $watch.
	       *     '[]expr' === $scope.$watchCollection('expr', fn);
	       *
	       * 3. #1 prefixed with '=', which uses $watch with objectEquality turned on
	       *     '=expr' === $scope.$watch('expr', fn, true);
	       *
	       * 4. a function that will be called, like a normal function water
	       *
	       * 5. an object with any of the properties:
	       *   `get`: the getter called on each itteration
	       *   `deep`: a flag to turn on objectEquality in $watch
	       *   `fn`: the watch registration function ($scope.$watch or $scope.$watchCollection)
	       *
	       * @param  {array[string|function|obj]} expressions - the list of expressions to $watch
	       * @param  {Function} fn - the callback function
	       * @return {Function} - an unwatch function, just like the return value of $watch
	       */
	      $delegate.constructor.prototype.$watchMulti = function (expressions, fn) {
	        if (!_.isArray(expressions)) throw new TypeError('expected an array of expressions to watch');
	        if (!_.isFunction(fn)) throw new TypeError('expected a function that is triggered on each watch');

	        var $scope = this;
	        var vals = new Array(expressions.length);
	        var prev = new Array(expressions.length);
	        var fire = false;
	        var init = 0;
	        var neededInits = expressions.length;

	        // first, register all of the multi-watchers
	        var unwatchers = expressions.map(function (expr, i) {
	          expr = normalizeExpression($scope, expr);
	          if (!expr) return;

	          return expr.fn.call($scope, expr.get, function (newVal, oldVal) {
	            if (newVal === oldVal) {
	              init += 1;
	            }

	            vals[i] = newVal;
	            prev[i] = oldVal;
	            fire = true;
	          }, expr.deep);
	        });

	        // then, the watcher that checks to see if any of
	        // the other watchers triggered this cycle
	        var flip = false;
	        unwatchers.push($scope.$watch(function () {
	          if (init < neededInits) return init;

	          if (fire) {
	            fire = false;
	            flip = !flip;
	          }
	          return flip;
	        }, function () {
	          if (init < neededInits) return false;

	          fn(vals.slice(0), prev.slice(0));
	          vals.forEach(function (v, i) {
	            prev[i] = v;
	          });
	        }));

	        return _.partial(_.callEach, unwatchers);
	      };

	      function normalizeExpression($scope, expr) {
	        if (!expr) return;
	        var norm = {
	          fn: $scope.$watch,
	          deep: false
	        };

	        if (_.isFunction(expr)) return _.assign(norm, { get: expr });
	        if (_.isObject(expr)) return _.assign(norm, expr);
	        if (!_.isString(expr)) return;

	        if (expr.substr(0, 2) === '[]') {
	          return _.assign(norm, {
	            fn: $scope.$watchCollection,
	            get: expr.substr(2)
	          });
	        }

	        if (expr.charAt(0) === '=') {
	          return _.assign(norm, {
	            deep: true,
	            get: expr.substr(1)
	          });
	        }

	        return _.assign(norm, { get: expr });
	      }

	      return $delegate;
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 885 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(886);
	__webpack_require__(896);
	__webpack_require__(907);
	__webpack_require__(913);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function NormalizeChartDataFactory(Private) {
	    return {
	      hierarchical: Private(__webpack_require__(886)),
	      pointSeries: Private(__webpack_require__(896)),
	      tabify: Private(__webpack_require__(907)),
	      geoJson: Private(__webpack_require__(913))
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 886 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(887);
	__webpack_require__(889);
	__webpack_require__(891);
	__webpack_require__(892);
	__webpack_require__(893);
	__webpack_require__(817);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function buildHierarchicalDataProvider(Private, Notifier) {
	    var _ = __webpack_require__(192);
	    var buildSplit = Private(__webpack_require__(887));
	    var extractBuckets = __webpack_require__(889);
	    var createRawData = __webpack_require__(891);
	    var arrayToLinkedList = __webpack_require__(892);
	    var tooltipFormatter = Private(__webpack_require__(893));

	    var AggConfigResult = __webpack_require__(817);

	    var notify = new Notifier({
	      location: 'Pie chart response converter'
	    });

	    return function (vis, resp) {
	      // Create a refrenece to the buckets
	      var buckets = vis.aggs.bySchemaGroup.buckets;

	      // Find the metric so it's easier to reference.
	      // TODO: Change this to support multiple metrics.
	      var metric = vis.aggs.bySchemaGroup.metrics[0];

	      // Link each agg to the next agg. This will be
	      // to identify the next bucket aggregation
	      buckets = arrayToLinkedList(buckets);

	      // Create the raw data to be used in the spy panel
	      var raw = createRawData(vis, resp);

	      // If buckets is falsy then we should just return the aggs
	      if (!buckets) {
	        var label = 'Count';
	        var value = resp.aggregations && resp.aggregations[metric.id] && resp.aggregations[metric.id].value || resp.hits.total;
	        return {
	          hits: resp.hits.total,
	          raw: raw,
	          names: [label],
	          tooltipFormatter: tooltipFormatter(raw.columns),
	          slices: {
	            children: [{ name: label, size: value }]
	          }
	        };
	      }

	      var firstAgg = buckets[0];
	      var aggData = resp.aggregations[firstAgg.id];

	      if (!firstAgg._next && firstAgg.schema.name === 'split') {
	        notify.error('Splitting charts without splitting slices is not supported. Pretending that we are just splitting slices.');
	      }

	      // start with splitting slices
	      if (!firstAgg._next || firstAgg.schema.name === 'segment') {
	        var split = buildSplit(firstAgg, metric, aggData);
	        split.hits = resp.hits.total;
	        split.raw = raw;
	        split.tooltipFormatter = tooltipFormatter(raw.columns);
	        return split;
	      }

	      // map the split aggregations into rows.
	      var rows = _.map(extractBuckets(aggData, firstAgg), function (bucket) {
	        var agg = firstAgg._next;
	        var split = buildSplit(agg, metric, bucket[agg.id]);
	        // Since splits display labels we need to set it.
	        split.label = firstAgg.fieldFormatter()(agg.getKey(bucket));

	        var displayName = firstAgg.fieldDisplayName();
	        if (!_.isEmpty(displayName)) split.label += ': ' + displayName;

	        split.tooltipFormatter = tooltipFormatter(raw.columns);
	        var aggConfigResult = new AggConfigResult(firstAgg, null, null, firstAgg.getKey(bucket));
	        split.split = { aggConfig: firstAgg, aggConfigResult: aggConfigResult, key: bucket.key };
	        _.each(split.slices.children, function (child) {
	          child.aggConfigResult.$parent = aggConfigResult;
	        });
	        return split;
	      });

	      var result = { hits: resp.hits.total, raw: raw };
	      if (firstAgg.params.row) {
	        result.rows = rows;
	      } else {
	        result.columns = rows;
	      }

	      return result;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 887 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(888);
	__webpack_require__(890);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function biuldSplitProvider(Private) {
	    var transformer = Private(__webpack_require__(888));
	    var collectKeys = __webpack_require__(890);
	    return function (agg, metric, aggData) {
	      // Ceate the split structure
	      var split = { label: '', slices: { children: [] } };

	      // Transform the aggData into splits
	      split.slices.children = transformer(agg, metric, aggData);

	      // Collect all the keys
	      split.names = collectKeys(split.slices.children);
	      return split;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 888 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(889);
	__webpack_require__(817);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var extractBuckets = __webpack_require__(889);
	  return function transformAggregationProvider(Private) {
	    var AggConfigResult = __webpack_require__(817);
	    return function transformAggregation(agg, metric, aggData, parent) {
	      return _.map(extractBuckets(aggData, agg), function (bucket) {
	        var aggConfigResult = new AggConfigResult(agg, parent && parent.aggConfigResult, metric.getValue(bucket), agg.getKey(bucket));

	        var branch = {
	          name: agg.fieldFormatter()(bucket.key),
	          size: aggConfigResult.value,
	          aggConfig: agg,
	          aggConfigResult: aggConfigResult
	        };

	        // if the parent is defined then we need to set the parent of the branch
	        // this will be used later for filters for waking up the parent path.
	        if (parent) {
	          branch.parent = parent;
	        }

	        // If the next bucket exists and it has children the we need to
	        // transform it as well. This is where the recursion happens.
	        if (agg._next) {
	          var nextBucket = bucket[agg._next.id];
	          if (nextBucket && nextBucket.buckets) {
	            branch.children = transformAggregation(agg._next, metric, nextBucket, branch);
	          }
	        }

	        return branch;
	      });
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 889 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function (bucket, agg) {
	    if (bucket && _.isPlainObject(bucket.buckets)) {
	      return _.map(bucket.buckets, function (value, key) {
	        var item = _.cloneDeep(value);
	        item.key = agg ? agg.getKey(value, key) : key;
	        return item;
	      });
	    } else {
	      return bucket && bucket.buckets || [];
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 890 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function collectKeys(children) {
	    var nextChildren = _.pluck(children, 'children');
	    var keys = _.pluck(children, 'name');
	    return _(nextChildren).map(collectKeys).flattenDeep().union(keys).value();
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 891 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(889);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var extractBuckets = __webpack_require__(889);
	  return function (vis, resp) {

	    // Create the initial results structure
	    var results = { rows: [] };

	    // Create a reference to the buckets and metrics
	    var metrics = vis.aggs.bySchemaGroup.metrics;
	    var buckets = vis.aggs.bySchemaGroup.buckets;
	    var aggs = [];

	    if (buckets) {
	      _.each(buckets, function (bucket) {
	        aggs.push(bucket);
	        aggs.push(metrics);
	      });
	    } else {
	      aggs.push(metrics);
	    }

	    // Create the columns
	    results.columns = _(aggs).flattenDeep().map(function (agg) {
	      return {
	        categoryName: agg.schema.name,
	        id: agg.id,
	        aggConfig: agg,
	        aggType: agg.type,
	        field: agg.params.field,
	        label: agg.type.makeLabel(agg)
	      };
	    }).value();

	    // if there are no buckets then we need to just set the value and return
	    if (!buckets) {
	      var value = resp.aggregations && resp.aggregations[metrics[0].id] && resp.aggregations[metrics[0].id].value || resp.hits.total;
	      results.rows.push([value]);
	      return results;
	    }

	    /**
	     * Walk the buckets and create records for each leaf
	     * @param {aggConfig} agg The aggConfig for the current level
	     * @param {object} data The aggergation object
	     * @param {array} [record] The record that will eventually get pushed to the rows
	     * @returns {void}
	     */
	    function walkBuckets(agg, data, record) {
	      if (!_.isArray(record)) {
	        record = [];
	      }

	      // iterate through all the buckets
	      _.each(extractBuckets(data[agg.id], agg), function (bucket) {

	        var _record = _.flattenDeep([record, bucket.key]);
	        _.each(metrics, function (metric) {
	          var value = bucket.doc_count;
	          if (bucket[metric.id] && !_.isUndefined(bucket[metric.id].value)) {
	            value = bucket[metric.id].value;
	          }
	          _record.push(value);
	        });

	        // If there is another agg to call we need to check to see if it has
	        // buckets. If it does then we need to keep on walking the tree.
	        // This is where the recursion happens.
	        if (agg._next) {
	          var nextBucket = bucket[agg._next.id];
	          if (nextBucket && nextBucket.buckets) {
	            walkBuckets(agg._next, bucket, _record);
	          }
	        }
	        // if there are no more aggs to walk then  push the record to the rows.
	        else {
	            results.rows.push(_record);
	          }
	      });
	    }

	    // Start walking the buckets at the beginning of the aggregations object.
	    walkBuckets(buckets[0], resp.aggregations);

	    return results;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 892 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  return function (buckets) {
	    var previous;
	    _.each(buckets, function (bucket) {
	      if (previous) {
	        bucket._previous = previous;
	        previous._next = bucket;
	      }
	      previous = bucket;
	    });
	    return buckets;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 893 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(894);
	__webpack_require__(895);
	__webpack_require__(865);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HierarchicalTooltipFormaterProvider($rootScope, $compile, $sce) {
	    var _ = __webpack_require__(192);
	    var $ = __webpack_require__(206);
	    var $tooltip = $(__webpack_require__(894));
	    var collectBranch = __webpack_require__(895);
	    var $tooltipScope = $rootScope.$new();
	    var numeral = __webpack_require__(865);

	    $compile($tooltip)($tooltipScope);

	    return function (columns) {
	      return function (event) {
	        var datum = event.datum;

	        // Collect the current leaf and parents into an array of values
	        $tooltipScope.rows = collectBranch(datum);

	        var metricCol = $tooltipScope.metricCol = _.find(columns, { categoryName: 'metric' });

	        // Map those values to what the tooltipSource.rows format.
	        _.forEachRight($tooltipScope.rows, function (row, i, rows) {
	          row.spacer = $sce.trustAsHtml(_.repeat('&nbsp;', row.depth));

	          var percent;
	          if (row.item.percentOfGroup != null) {
	            percent = row.item.percentOfGroup;
	          }

	          row.metric = metricCol.aggConfig.fieldFormatter()(row.metric);

	          if (percent != null) {
	            row.metric += ' (' + numeral(percent).format('0.[00]%') + ')';
	          }

	          return row;
	        });

	        $tooltipScope.$apply();
	        return $tooltip[0].outerHTML;
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 894 */
/***/ function(module, exports) {

	module.exports = "<table>\n  <thead>\n    <tr>\n      <th>field</th>\n      <th>value</th>\n      <th>{{metricCol.label}}</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat=\"row in rows track by $index\">\n      <td><span ng-bind-html=\"row.spacer\"></span>{{row.field}}</td>\n      <td class=\"row-bucket\">{{row.bucket}}</td>\n      <td>{{row.metric}}</td>\n    </tr>\n  </tbody>\n</table>"

/***/ },
/* 895 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function (leaf) {
	    // walk up the branch for each parent
	    function walk(_x, _x2) {
	      var _again = true;

	      _function: while (_again) {
	        var item = _x,
	            memo = _x2;
	        depth = col = field = undefined;
	        _again = false;

	        // record the the depth
	        var depth = item.depth - 1;

	        // Using the aggConfig determine what the field name is. If the aggConfig
	        // doesn't exist (which means it's an _all agg) then use the level for
	        // the field name
	        var col = item.aggConfig;
	        var field = col && col.params && col.params.field && col.params.field.displayName || col && col.label || 'level ' + item.depth;

	        // Add the row to the tooltipScope.rows
	        memo.unshift({
	          aggConfig: col,
	          depth: depth,
	          field: field,
	          bucket: item.name,
	          metric: item.size,
	          item: item
	        });

	        // If the item has a parent and it's also a child then continue walking
	        // up the branch
	        if (item.parent && item.parent.parent) {
	          _x = item.parent;
	          _x2 = memo;
	          _again = true;
	          continue _function;
	        } else {
	          return memo;
	        }
	      }
	    }

	    return walk(leaf, []);
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 896 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(897);
	__webpack_require__(900);
	__webpack_require__(902);
	__webpack_require__(903);
	__webpack_require__(904);
	__webpack_require__(905);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesProvider(Private) {
	    var _ = __webpack_require__(192);

	    var getSeries = Private(__webpack_require__(897));
	    var getAspects = Private(__webpack_require__(900));
	    var initYAxis = Private(__webpack_require__(902));
	    var initXAxis = Private(__webpack_require__(903));
	    var setupOrderedDateXAxis = Private(__webpack_require__(904));
	    var tooltipFormatter = Private(__webpack_require__(905));

	    return function pointSeriesChartDataFromTable(vis, table) {
	      var chart = {};
	      var aspects = chart.aspects = getAspects(vis, table);

	      chart.tooltipFormatter = tooltipFormatter;

	      initXAxis(chart);
	      initYAxis(chart);

	      var datedX = aspects.x.agg.type.ordered && aspects.x.agg.type.ordered.date;
	      if (datedX) {
	        setupOrderedDateXAxis(vis, chart);
	      }

	      chart.series = getSeries(table.rows, chart);

	      delete chart.aspects;
	      return chart;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 897 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(898);
	__webpack_require__(899);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesGetSeries(Private) {
	    var _ = __webpack_require__(192);
	    var getPoint = Private(__webpack_require__(898));
	    var addToSiri = Private(__webpack_require__(899));

	    return function getSeries(rows, chart) {
	      var aspects = chart.aspects;
	      var multiY = _.isArray(aspects.y);
	      var yScale = chart.yScale;
	      var partGetPoint = _.partial(getPoint, aspects.x, aspects.series, yScale);

	      var series = _(rows).transform(function (series, row) {
	        if (!multiY) {
	          var point = partGetPoint(row, aspects.y, aspects.z);
	          if (point) addToSiri(series, point, point.series);
	          return;
	        }

	        aspects.y.forEach(function (y) {
	          var point = partGetPoint(row, y, aspects.z);
	          if (!point) return;

	          var prefix = point.series ? point.series + ': ' : '';
	          var seriesId = prefix + y.agg.id;
	          var seriesLabel = prefix + y.col.title;

	          addToSiri(series, point, seriesId, seriesLabel);
	        });
	      }, {}).values().value();

	      if (multiY) {
	        series = _.sortBy(series, function (siri) {
	          var firstVal = siri.values[0];
	          var y;

	          if (firstVal) {
	            var agg = firstVal.aggConfigResult.aggConfig;
	            y = _.find(aspects.y, function (y) {
	              return y.agg === agg;
	            });
	          }

	          return y ? y.i : series.length;
	        });
	      }

	      return series;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 898 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesGetPoint() {
	    var _ = __webpack_require__(192);
	    function unwrap(aggConfigResult, def) {
	      return aggConfigResult ? aggConfigResult.value : def;
	    }

	    return function getPoint(x, series, yScale, row, y, z) {
	      var zRow = z && row[z.i];
	      var xRow = row[x.i];

	      var point = {
	        x: unwrap(xRow, '_all'),
	        xi: xRow && xRow.$order,
	        y: unwrap(row[y.i]),
	        z: zRow && unwrap(zRow),
	        aggConfigResult: row[y.i],
	        extraMetrics: _.compact([zRow]),
	        yScale: yScale
	      };

	      if (point.y === 'NaN') {
	        // filter out NaN from stats
	        // from metrics that are not based at zero
	        return;
	      }

	      if (series) {
	        point.aggConfig = series.agg;
	        point.series = series.agg.fieldFormatter()(unwrap(row[series.i]));
	      }

	      if (yScale) {
	        point.y *= yScale;
	      }

	      return point;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 899 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesAddToSiri() {
	    return function addToSiri(series, point, id, label) {
	      id = id == null ? '' : id + '';

	      if (series[id]) {
	        series[id].values.push(point);
	        return;
	      }

	      series[id] = {
	        label: label == null ? id : label,
	        values: [point]
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 900 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(901);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesGetAspects(Private) {
	    var _ = __webpack_require__(192);
	    var fakeXAspect = Private(__webpack_require__(901));

	    var map = {
	      segment: 'x',
	      metric: 'y',
	      radius: 'z',
	      width: 'width',
	      group: 'series'
	    };

	    function columnToAspect(aspects, col, i) {
	      var schema = col.aggConfig.schema.name;

	      var name = map[schema];
	      if (!name) throw new TypeError('unknown schema name "' + schema + '"');

	      var aspect = {
	        i: i,
	        col: col,
	        agg: col.aggConfig
	      };

	      if (!aspects[name]) aspects[name] = [];
	      aspects[name].push(aspect);
	    }

	    /**
	     * Identify and group the columns based on the aspect of the pointSeries
	     * they represent.
	     *
	     * @param  {array} columns - the list of columns
	     * @return {object} - an object with a key for each aspect (see map). The values
	     *                    may be undefined, a single aspect, or an array of aspects.
	     */
	    return function getAspects(vis, table) {
	      var aspects = _(table.columns)
	      // write each column into the aspects under it's group
	      .transform(columnToAspect, {})
	      // unwrap groups that only have one value, and validate groups that have more
	      .transform(function (aspects, group, name) {
	        if (name !== 'y' && group.length > 1) {
	          throw new TypeError('Only multiple metrics are supported in point series');
	        }

	        aspects[name] = group.length > 1 ? group : group[0];
	      }).value();

	      if (!aspects.x) {
	        aspects.x = fakeXAspect(vis);
	      }

	      return aspects;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 901 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(633);
	__webpack_require__(553);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesFakeXAxis(Private) {
	    var AggConfig = Private(__webpack_require__(633));
	    var AggType = Private(__webpack_require__(553));

	    var allAgg = new AggType({
	      name: 'all',
	      title: 'All docs',
	      ordered: false,
	      hasNoDsl: true
	    });

	    return function makeFakeXAxis(vis) {
	      var fake = new AggConfig(vis, {
	        type: allAgg,
	        schema: vis.type.schemas.all.byName.segment
	      });

	      return {
	        i: -1,
	        agg: fake,
	        col: {
	          aggConfig: fake,
	          label: fake.makeLabel()
	        }
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 902 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesInitYAxis() {
	    var _ = __webpack_require__(192);

	    return function initYAxis(chart) {
	      var y = chart.aspects.y;
	      var x = chart.aspects.x;

	      if (_.isArray(y)) {
	        // TODO: vis option should allow choosing this format
	        chart.yAxisFormatter = y[0].agg.fieldFormatter();
	        chart.yAxisLabel = ''; // use the legend
	      } else {
	          chart.yAxisFormatter = y.agg.fieldFormatter();
	          chart.yAxisLabel = y.col.title;
	        }

	      var xAggOutput = x.agg.write();
	      chart.yScale = xAggOutput.metricScale || null;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 903 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	  return function PointSeriesInitX() {
	    return function initXAxis(chart) {
	      var x = chart.aspects.x;
	      chart.xAxisFormatter = x.agg ? x.agg.fieldFormatter() : String;
	      chart.xAxisLabel = x.col.title;

	      if (!x.agg || !x.agg.type.ordered) return;

	      chart.ordered = {};
	      var xAggOutput = x.agg.write();
	      if (xAggOutput.params.interval) {
	        chart.ordered.interval = xAggOutput.params.interval;
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 904 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(226);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesOrderedDateAxis(timefilter) {
	    var moment = __webpack_require__(226);

	    return function orderedDateAxis(vis, chart) {
	      var xAgg = chart.aspects.x.agg;
	      var buckets = xAgg.buckets;
	      var format = buckets.getScaledDateFormat();

	      chart.xAxisFormatter = function (val) {
	        return moment(val).format(format);
	      };

	      chart.ordered = {
	        date: true,
	        interval: buckets.getInterval()
	      };

	      var axisOnTimeField = xAgg.fieldIsTimeField();
	      var bounds = buckets.getBounds();
	      if (bounds && axisOnTimeField) {
	        chart.ordered.min = bounds.min;
	        chart.ordered.max = bounds.max;
	      } else {
	        chart.ordered.endzones = false;
	      }
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 905 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(206);
	__webpack_require__(906);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function PointSeriesTooltipFormatter($compile, $rootScope) {
	    var $ = __webpack_require__(206);

	    var $tooltipScope = $rootScope.$new();
	    var $tooltip = $(__webpack_require__(906));
	    $compile($tooltip)($tooltipScope);

	    return function tooltipFormatter(event) {
	      var datum = event.datum;
	      if (!datum || !datum.aggConfigResult) return '';

	      var details = $tooltipScope.details = [];
	      var result = { $parent: datum.aggConfigResult };

	      function addDetail(result) {
	        var agg = result.aggConfig;
	        var value = result.value;

	        var detail = {
	          value: agg.fieldFormatter()(value),
	          label: agg.makeLabel()
	        };

	        if (agg === datum.aggConfigResult.aggConfig) {
	          detail.percent = event.percent;
	          if (datum.yScale != null) {
	            detail.value = agg.fieldFormatter()(value * datum.yScale);
	          }
	        }

	        details.push(detail);
	      }

	      datum.extraMetrics.forEach(addDetail);
	      while ((result = result.$parent) && result.aggConfig) {
	        addDetail(result);
	      }

	      $tooltipScope.$apply();
	      return $tooltip[0].outerHTML;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 906 */
/***/ function(module, exports) {

	module.exports = "<table>\n  <tbody>\n    <tr ng-repeat=\"detail in details\" >\n      <td><b>{{detail.label}}</b></td>\n      <td>\n          {{detail.value}}\n          <span ng-if=\"detail.percent\"> ({{detail.percent}})</span>\n      </td>\n    </tr>\n  </tbody>\n</table>"

/***/ },
/* 907 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(633);
	__webpack_require__(908);
	__webpack_require__(912);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function tabifyAggResponseProvider(Private, Notifier) {
	    var _ = __webpack_require__(192);

	    var AggConfig = Private(__webpack_require__(633));
	    var TabbedAggResponseWriter = Private(__webpack_require__(908));
	    var Buckets = Private(__webpack_require__(912));
	    var notify = new Notifier({ location: 'agg_response/tabify' });

	    function tabifyAggResponse(vis, esResponse, respOpts) {
	      var write = new TabbedAggResponseWriter(vis, respOpts);

	      var topLevelBucket = _.assign({}, esResponse.aggregations, {
	        doc_count: esResponse.hits.total
	      });

	      collectBucket(write, topLevelBucket);

	      return write.response();
	    }

	    /**
	     * read an aggregation from a bucket, which is *might* be found at key (if
	     * the response came in object form), and will recurse down the aggregation
	     * tree and will pass the read values to the ResponseWriter.
	     *
	     * @param {object} bucket - a bucket from the aggResponse
	     * @param {undefined|string} key - the key where the bucket was found
	     * @returns {undefined}
	     */
	    function collectBucket(write, bucket, key) {
	      var agg = write.aggStack.shift();

	      switch (agg.schema.group) {
	        case 'buckets':
	          var buckets = new Buckets(bucket[agg.id]);
	          if (buckets.length) {
	            var splitting = write.canSplit && agg.schema.name === 'split';
	            if (splitting) {
	              write.split(agg, buckets, function forEachBucket(subBucket, key) {
	                collectBucket(write, subBucket, agg.getKey(subBucket), key);
	              });
	            } else {
	              buckets.forEach(function (subBucket, key) {
	                write.cell(agg, agg.getKey(subBucket, key), function () {
	                  collectBucket(write, subBucket, agg.getKey(subBucket, key));
	                });
	              });
	            }
	          } else if (write.partialRows && write.metricsForAllBuckets && write.minimalColumns) {
	            // we don't have any buckets, but we do have metrics at this
	            // level, then pass all the empty buckets and jump back in for
	            // the metrics.
	            write.aggStack.unshift(agg);
	            passEmptyBuckets(write, bucket, key);
	            write.aggStack.shift();
	          } else {
	            // we don't have any buckets, and we don't have isHierarchical
	            // data, so no metrics, just try to write the row
	            write.row();
	          }
	          break;
	        case 'metrics':
	          var value = agg.getValue(bucket);
	          write.cell(agg, value, function () {
	            if (!write.aggStack.length) {
	              // row complete
	              write.row();
	            } else {
	              // process the next agg at this same level
	              collectBucket(write, bucket, key);
	            }
	          });
	          break;
	      }

	      write.aggStack.unshift(agg);
	    }

	    // write empty values for each bucket agg, then write
	    // the metrics from the initial bucket using collectBucket()
	    function passEmptyBuckets(write, bucket, key) {
	      var agg = write.aggStack.shift();

	      switch (agg.schema.group) {
	        case 'metrics':
	          // pass control back to collectBucket()
	          write.aggStack.unshift(agg);
	          collectBucket(write, bucket, key);
	          return;

	        case 'buckets':
	          write.cell(agg, '', function () {
	            passEmptyBuckets(write, bucket, key);
	          });
	      }

	      write.aggStack.unshift(agg);
	    }

	    return notify.timed('tabify agg response', tabifyAggResponse);
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 908 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(909);
	__webpack_require__(910);
	__webpack_require__(911);
	__webpack_require__(817);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TabbedAggResponseWriterProvider(Private) {
	    var _ = __webpack_require__(192);
	    var Table = Private(__webpack_require__(909));
	    var TableGroup = Private(__webpack_require__(910));
	    var getColumns = Private(__webpack_require__(911));

	    var AggConfigResult = __webpack_require__(817);

	    _['class'](SplitAcr).inherits(AggConfigResult);
	    function SplitAcr(agg, parent, key) {
	      SplitAcr.Super.call(this, agg, parent, key, key);
	    }

	    /**
	     * Writer class that collects information about an aggregation response and
	     * produces a table, or a series of tables.
	     *
	     * @param {Vis} vis - the vis object to which the aggregation response correlates
	     */
	    function TabbedAggResponseWriter(vis, opts) {
	      this.vis = vis;
	      this.opts = opts || {};
	      this.rowBuffer = [];

	      var visIsHier = vis.isHierarchical();

	      // do the options allow for splitting? we will only split if true and
	      // tabify calls the split method.
	      this.canSplit = this.opts.canSplit !== false;

	      // should we allow partial rows to be included in the tables? if a
	      // partial row is found, it is filled with empty strings ''
	      this.partialRows = this.opts.partialRows == null ? visIsHier : this.opts.partialRows;

	      // if true, we will not place metric columns after every bucket
	      // even if the vis is hierarchical. if false, and the vis is
	      // hierarchical, then we will display metric columns after
	      // every bucket col
	      this.minimalColumns = visIsHier ? !!this.opts.minimalColumns : true;

	      // true if we can expect metrics to have been calculated
	      // for every bucket
	      this.metricsForAllBuckets = visIsHier;

	      // if true, values will be wrapped in aggConfigResult objects which link them
	      // to their aggConfig and enable the filterbar and tooltip formatters
	      this.asAggConfigResults = !!this.opts.asAggConfigResults;

	      this.columns = getColumns(vis, this.minimalColumns);
	      this.aggStack = _.pluck(this.columns, 'aggConfig');

	      this.root = new TableGroup();
	      this.acrStack = [];
	      this.splitStack = [this.root];
	    }

	    /**
	     * Create a Table of TableGroup object, link it to it's parent (if any), and determine if
	     * it's the root
	     *
	     * @param  {boolean} group - is this a TableGroup or just a normal Table
	     * @param  {AggConfig} agg - the aggregation that create this table, only applies to groups
	     * @param  {any} key - the bucketKey that this table relates to
	     * @return {Table/TableGroup} table - the created table
	     */
	    TabbedAggResponseWriter.prototype._table = function (group, agg, key) {
	      var Class = group ? TableGroup : Table;
	      var table = new Class();
	      var parent = this.splitStack[0];

	      if (group) {
	        table.aggConfig = agg;
	        table.key = key;
	        table.title = table.fieldFormatter()(key) + ': ' + agg.makeLabel();
	      }

	      // link the parent and child
	      table.$parent = parent;
	      parent.tables.push(table);

	      return table;
	    };

	    /**
	     * Enter into a split table, called for each bucket of a splitting agg. The new table
	     * is either created or located using the agg and key arguments, and then the block is
	     * executed with the table as it's this context. Within this function, you should
	     * walk into the remaining branches and end up writing some rows to the table.
	     *
	     * @param  {aggConfig} agg - the aggConfig that created this split
	     * @param  {Buckets} buckets - the buckets produces by the agg
	     * @param  {function} block - a function to execute for each sub bucket
	     */
	    TabbedAggResponseWriter.prototype.split = function (agg, buckets, block) {
	      var self = this;

	      if (!self.canSplit) {
	        throw new Error('attempted to split when splitting is disabled');
	      }

	      self._removeAggFromColumns(agg);

	      buckets.forEach(function (bucket, key) {
	        // find the existing split that we should extend
	        var tableGroup = _.find(self.splitStack[0].tables, { aggConfig: agg, key: key });
	        // create the split if it doesn't exist yet
	        if (!tableGroup) tableGroup = self._table(true, agg, key);

	        var splitAcr = false;
	        if (self.asAggConfigResults) {
	          splitAcr = self._injectParentSplit(agg, key);
	        }

	        // push the split onto the stack so that it will receive written tables
	        self.splitStack.unshift(tableGroup);

	        // call the block
	        if (_.isFunction(block)) block.call(self, bucket, key);

	        // remove the split from the stack
	        self.splitStack.shift();
	        splitAcr && _.pull(self.acrStack, splitAcr);
	      });
	    };

	    TabbedAggResponseWriter.prototype._removeAggFromColumns = function (agg) {
	      var i = _.findIndex(this.columns, function (col) {
	        return col.aggConfig === agg;
	      });

	      // we must have already removed this column
	      if (i === -1) return;

	      this.columns.splice(i, 1);

	      if (this.minimalColumns) return;

	      // hierarchical vis creats additional columns for each bucket
	      // we will remove those too
	      var mCol = this.columns.splice(i, 1).pop();
	      var mI = _.findIndex(this.aggStack, function (agg) {
	        return agg === mCol.aggConfig;
	      });

	      if (mI > -1) this.aggStack.splice(mI, 1);
	    };

	    /**
	     * When a split is found while building the aggConfigResult tree, we
	     * want to push the split into the tree at another point. Since each
	     * branch in the tree is a double-linked list we need do some special
	     * shit to pull this off.
	     *
	     * @private
	     * @param {AggConfig} - The agg which produced the split bucket
	     * @param {any} - The value which identifies the bucket
	     * @return {SplitAcr} - the AggConfigResult created for the split bucket
	     */
	    TabbedAggResponseWriter.prototype._injectParentSplit = function (agg, key) {
	      var oldList = this.acrStack;
	      var newList = this.acrStack = [];

	      // walk from right to left through the old stack
	      // and move things to the new stack
	      var injected = false;

	      if (!oldList.length) {
	        injected = new SplitAcr(agg, null, key);
	        newList.unshift(injected);
	        return injected;
	      }

	      // walk from right to left, emptying the previous list
	      while (oldList.length) {
	        var acr = oldList.pop();

	        // ignore other splits
	        if (acr instanceof SplitAcr) {
	          newList.unshift(acr);
	          continue;
	        }

	        // inject the split
	        if (!injected) {
	          injected = new SplitAcr(agg, newList[0], key);
	          newList.unshift(injected);
	        }

	        var newAcr = new AggConfigResult(acr.aggConfig, newList[0], acr.value, acr.aggConfig.getKey(acr));
	        newList.unshift(newAcr);

	        // and replace the acr in the row buffer if its there
	        var rowI = this.rowBuffer.indexOf(acr);
	        if (rowI > -1) {
	          this.rowBuffer[rowI] = newAcr;
	        }
	      }

	      return injected;
	    };

	    /**
	     * Push a value into the row, then run a block. Once the block is
	     * complete the value is pulled from the stack.
	     *
	     * @param  {any} value - the value that should be added to the row
	     * @param  {function} block - the function to run while this value is in the row
	     * @return {any} - the value that was added
	     */
	    TabbedAggResponseWriter.prototype.cell = function (agg, value, block) {
	      if (this.asAggConfigResults) {
	        value = new AggConfigResult(agg, this.acrStack[0], value, value);
	      }

	      var staskResult = this.asAggConfigResults && value.type === 'bucket';

	      this.rowBuffer.push(value);
	      if (staskResult) this.acrStack.unshift(value);

	      if (_.isFunction(block)) block.call(this);

	      this.rowBuffer.pop(value);
	      if (staskResult) this.acrStack.shift();

	      return value;
	    };

	    /**
	     * Create a new row by reading the row buffer. This will do nothing if
	     * the row is incomplete and the vis this data came from is NOT flagged as
	     * hierarchical.
	     *
	     * @param  {array} [buffer] - optional buffer to use in place of the stored rowBuffer
	     * @return {undefined}
	     */
	    TabbedAggResponseWriter.prototype.row = function (buffer) {
	      var cells = buffer || this.rowBuffer.slice(0);

	      if (!this.partialRows && cells.length < this.columns.length) {
	        return;
	      }

	      var split = this.splitStack[0];
	      var table = split.tables[0] || this._table(false);

	      while (cells.length < this.columns.length) cells.push('');
	      table.rows.push(cells);
	      return table;
	    };

	    /**
	     * Get the actual response
	     *
	     * @return {object} - the final table-tree
	     */
	    TabbedAggResponseWriter.prototype.response = function () {
	      var columns = this.columns;

	      // give the columns some metadata
	      columns.map(function (col) {
	        col.title = col.aggConfig.makeLabel();
	      });

	      // walk the tree and write the columns to each table
	      (function step(table, group) {
	        if (table.tables) table.tables.forEach(step);else table.columns = columns.slice(0);
	      })(this.root);

	      if (this.canSplit) return this.root;

	      var table = this.root.tables[0];
	      if (!table) return;

	      delete table.$parent;
	      return table;
	    };

	    return TabbedAggResponseWriter;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 909 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TableProvider() {
	    var _ = __webpack_require__(192);

	    /**
	     * Simple table class that is used to contain the rows and columns that create
	     * a table. This is usually found at the root of the response or within a TableGroup
	     */
	    function Table() {
	      this.columns = null; // written with the first row
	      this.rows = [];
	    }

	    Table.prototype.title = function () {
	      if (this.$parent) {
	        return this.$parent.title;
	      } else {
	        return '';
	      }
	    };

	    Table.prototype.aggConfig = function (col) {
	      if (!col.aggConfig) {
	        throw new TypeError('Column is missing the aggConfig property');
	      }
	      return col.aggConfig;
	    };

	    Table.prototype.field = function (col) {
	      return this.aggConfig(col).field();
	    };

	    Table.prototype.fieldFormatter = function (col) {
	      return this.aggConfig(col).fieldFormatter();
	    };

	    return Table;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 910 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TableGroupProvider() {
	    var _ = __webpack_require__(192);

	    /**
	     * Simple object that wraps multiple tables. It contains information about the aggConfig
	     * and bucket that created this group and a list of the tables within it.
	     */
	    function TableGroup() {
	      this.aggConfig = null;
	      this.key = null;
	      this.title = null;
	      this.tables = [];
	    }

	    TableGroup.prototype.field = function () {
	      if (this.aggConfig) return this.aggConfig.field();
	    };

	    TableGroup.prototype.fieldFormatter = function () {
	      if (this.aggConfig) return this.aggConfig.fieldFormatter();
	    };

	    return TableGroup;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 911 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(633);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function GetColumnsProvider(Private) {
	    var _ = __webpack_require__(192);
	    var AggConfig = Private(__webpack_require__(633));

	    return function getColumns(vis, minimal) {
	      var aggs = vis.aggs.getResponseAggs();

	      if (minimal == null) minimal = !vis.isHierarchical();

	      if (!vis.aggs.bySchemaGroup.metrics) {
	        aggs.push(new AggConfig(vis, {
	          type: 'count',
	          schema: vis.type.schemas.metrics[0].name
	        }));
	      }

	      // pick the columns
	      if (minimal) {
	        return aggs.map(function (agg) {
	          return { aggConfig: agg };
	        });
	      }

	      // supposed to be bucket,...metrics,bucket,...metrics
	      var columns = [];

	      // seperate the metrics
	      var grouped = _.groupBy(aggs, function (agg) {
	        return agg.schema.group;
	      });

	      if (!grouped.buckets) {
	        // return just the metrics, in column format
	        return grouped.metrics.map(function (agg) {
	          return { aggConfig: agg };
	        });
	      }

	      // return the buckets, and after each place all of the metrics
	      grouped.buckets.forEach(function (agg, i) {
	        columns.push({ aggConfig: agg });
	        grouped.metrics.forEach(function (metric) {
	          columns.push({ aggConfig: metric });
	        });
	      });

	      return columns;
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 912 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function AggResponseBucketsProvider() {
	    var _ = __webpack_require__(192);

	    function Buckets(aggResp) {
	      aggResp = aggResp || false;
	      this.buckets = aggResp.buckets || [];
	      this.objectMode = _.isPlainObject(this.buckets);

	      if (this.objectMode) {
	        this._keys = _.keys(this.buckets);
	        this.length = this._keys.length;
	      } else {
	        this.length = this.buckets.length;
	      }
	    }

	    Buckets.prototype.forEach = function (fn) {
	      var buckets = this.buckets;

	      if (this.objectMode) {
	        this._keys.forEach(function (key) {
	          fn(buckets[key], key);
	        });
	      } else {
	        buckets.forEach(function (bucket) {
	          fn(bucket, bucket.key);
	        });
	      }
	    };

	    return Buckets;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 913 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(914);
	__webpack_require__(916);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TileMapConverterFn(Private, timefilter, $compile, $rootScope) {
	    var _ = __webpack_require__(192);

	    var rowsToFeatures = __webpack_require__(914);
	    var tooltipFormatter = Private(__webpack_require__(916));

	    return function (vis, table) {

	      function columnIndex(schema) {
	        return _.findIndex(table.columns, function (col) {
	          return col.aggConfig.schema.name === schema;
	        });
	      }

	      var geoI = columnIndex('segment');
	      var metricI = columnIndex('metric');
	      var geoAgg = _.get(table.columns, [geoI, 'aggConfig']);
	      var metricAgg = _.get(table.columns, [metricI, 'aggConfig']);

	      var features = rowsToFeatures(table, geoI, metricI);
	      var values = features.map(function (feature) {
	        return feature.properties.value;
	      });

	      return {
	        title: table.title(),
	        valueFormatter: metricAgg && metricAgg.fieldFormatter(),
	        tooltipFormatter: tooltipFormatter,
	        geohashGridAgg: geoAgg,
	        geoJson: {
	          type: 'FeatureCollection',
	          features: features,
	          properties: {
	            min: _.min(values),
	            max: _.max(values),
	            zoom: _.get(geoAgg, 'params.mapZoom'),
	            center: _.get(geoAgg, 'params.mapCenter')
	          }
	        }
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 914 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(915);
	__webpack_require__(817);
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var decodeGeoHash = __webpack_require__(915);
	  var AggConfigResult = __webpack_require__(817);
	  var _ = __webpack_require__(192);

	  function getAcr(val) {
	    return val instanceof AggConfigResult ? val : null;
	  }

	  function unwrap(val) {
	    return getAcr(val) ? val.value : val;
	  }

	  function convertRowsToFeatures(table, geoI, metricI) {
	    return _.transform(table.rows, function (features, row) {
	      var geohash = unwrap(row[geoI]);
	      if (!geohash) return;

	      // fetch latLn of northwest and southeast corners, and center point
	      var location = decodeGeoHash(geohash);

	      var centerLatLng = [location.latitude[2], location.longitude[2]];

	      // order is nw, ne, se, sw
	      var rectangle = [[location.latitude[0], location.longitude[0]], [location.latitude[0], location.longitude[1]], [location.latitude[1], location.longitude[1]], [location.latitude[1], location.longitude[0]]];

	      // geoJson coords use LngLat, so we reverse the centerLatLng
	      // See here for details: http://geojson.org/geojson-spec.html#positions
	      features.push({
	        type: 'Feature',
	        geometry: {
	          type: 'Point',
	          coordinates: centerLatLng.slice(0).reverse()
	        },
	        properties: {
	          geohash: geohash,
	          value: unwrap(row[metricI]),
	          aggConfigResult: getAcr(row[metricI]),
	          center: centerLatLng,
	          rectangle: rectangle
	        }
	      });
	    }, []);
	  }

	  return convertRowsToFeatures;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 915 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* eslint-disable */
	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  /*
	   * Decodes geohash to object containing
	   * top-left and bottom-right corners of
	   * rectangle and center point.
	   *
	   * geohash.js
	   * Geohash library for Javascript
	   * (c) 2008 David Troy
	   * Distributed under the MIT License
	   *
	   * @method refine_interval
	   * @param interval {Array} [long, lat]
	   * @param cd {Number}
	   * @param mask {Number}
	   * @return {Object} interval
	   */
	  function decodeGeoHash(geohash) {
	    var BITS = [16, 8, 4, 2, 1];
	    var BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';
	    var is_even = 1;
	    var lat = [];
	    var lon = [];
	    lat[0] = -90.0;
	    lat[1] = 90.0;
	    lon[0] = -180.0;
	    lon[1] = 180.0;
	    var lat_err = 90.0;
	    var lon_err = 180.0;
	    for (var i = 0; i < geohash.length; i++) {
	      var c = geohash[i];
	      var cd = BASE32.indexOf(c);
	      for (var j = 0; j < 5; j++) {
	        var mask = BITS[j];
	        if (is_even) {
	          lon_err /= 2;
	          refine_interval(lon, cd, mask);
	        } else {
	          lat_err /= 2;
	          refine_interval(lat, cd, mask);
	        }
	        is_even = !is_even;
	      }
	    }
	    lat[2] = (lat[0] + lat[1]) / 2;
	    lon[2] = (lon[0] + lon[1]) / 2;
	    return { latitude: lat, longitude: lon };
	  }

	  function refine_interval(interval, cd, mask) {
	    if (cd & mask) {
	      interval[0] = (interval[0] + interval[1]) / 2;
	    } else {
	      interval[1] = (interval[0] + interval[1]) / 2;
	    }
	  }

	  return decodeGeoHash;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 916 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(206);
	__webpack_require__(192);
	__webpack_require__(443);
	__webpack_require__(917);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TileMapTooltipFormatter($compile, $rootScope, Private) {
	    var $ = __webpack_require__(206);
	    var _ = __webpack_require__(192);

	    var fieldFormats = Private(__webpack_require__(443));
	    var $tooltipScope = $rootScope.$new();
	    var $el = $('<div>').html(__webpack_require__(917));
	    $compile($el)($tooltipScope);

	    return function tooltipFormatter(feature) {
	      if (!feature) return '';

	      var value = feature.properties.value;
	      var acr = feature.properties.aggConfigResult;
	      var vis = acr.aggConfig.vis;

	      var metricAgg = acr.aggConfig;
	      var geoFormat = _.get(vis.aggs, 'byTypeName.geohash_grid[0].format');
	      if (!geoFormat) geoFormat = fieldFormats.getDefaultInstance('geo_point');

	      $tooltipScope.details = [{
	        label: metricAgg.makeLabel(),
	        value: metricAgg.fieldFormatter()(value)
	      }, {
	        label: 'Center',
	        value: geoFormat.convert({
	          lat: feature.geometry.coordinates[1],
	          lon: feature.geometry.coordinates[0]
	        })
	      }];

	      $tooltipScope.$apply();

	      return $el.html();
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 917 */
/***/ function(module, exports) {

	module.exports = "<table>\n  <tbody>\n    <tr ng-repeat=\"detail in details\" >\n      <td><b>{{detail.label}}</b></td>\n      <td>{{detail.value}}</td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ },
/* 918 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(479);
	__webpack_require__(919);
	__webpack_require__(932);
	__webpack_require__(934);
	__webpack_require__(936);
	__webpack_require__(938);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var visTypes = __webpack_require__(479);
	  visTypes.register(__webpack_require__(919));
	  visTypes.register(__webpack_require__(932));
	  visTypes.register(__webpack_require__(934));
	  visTypes.register(__webpack_require__(936));
	  visTypes.register(__webpack_require__(938));
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 919 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(920);
	__webpack_require__(634);
	__webpack_require__(931);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HistogramVisType(Private) {
	    var VislibVisType = Private(__webpack_require__(920));
	    var Schemas = Private(__webpack_require__(634));

	    return new VislibVisType({
	      name: 'histogram',
	      title: 'Vertical bar chart',
	      icon: 'fa-bar-chart',
	      description: 'The goto chart for oh-so-many needs. Great for time and non-time data. Stacked or grouped, ' + 'exact numbers or percentages. If you are not sure which chart your need, you could do worse than to start here.',
	      params: {
	        defaults: {
	          shareYAxis: true,
	          addTooltip: true,
	          addLegend: true,
	          scale: 'linear',
	          mode: 'stacked',
	          times: [],
	          addTimeMarker: false,
	          defaultYExtents: false,
	          setYExtents: false,
	          yAxis: {}
	        },
	        scales: ['linear', 'log', 'square root'],
	        modes: ['stacked', 'percentage', 'grouped'],
	        editor: __webpack_require__(931)
	      },
	      schemas: new Schemas([{
	        group: 'metrics',
	        name: 'metric',
	        title: 'Y-Axis',
	        min: 1,
	        aggFilter: '!std_dev',
	        defaults: [{ schema: 'metric', type: 'count' }]
	      }, {
	        group: 'buckets',
	        name: 'segment',
	        title: 'X-Axis',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }, {
	        group: 'buckets',
	        name: 'group',
	        title: 'Split Bars',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }, {
	        group: 'buckets',
	        name: 'split',
	        title: 'Split Chart',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }])
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 920 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(332);
	__webpack_require__(634);
	__webpack_require__(921);
	__webpack_require__(896);
	__webpack_require__(922);
	__webpack_require__(925);
	__webpack_require__(927);
	__webpack_require__(929);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function VislibVisTypeFactory(Private) {
	    var _ = __webpack_require__(192);

	    __webpack_require__(332);
	    var VisTypeSchemas = Private(__webpack_require__(634));
	    var VisType = Private(__webpack_require__(921));
	    var pointSeries = Private(__webpack_require__(896));
	    var VislibRenderbot = Private(__webpack_require__(922));

	    __webpack_require__(925);
	    __webpack_require__(927);
	    __webpack_require__(929);

	    _['class'](VislibVisType).inherits(VisType);
	    function VislibVisType(opts) {
	      opts = opts || {};

	      VislibVisType.Super.call(this, opts);

	      if (this.responseConverter == null) {
	        this.responseConverter = pointSeries;
	      }

	      this.listeners = opts.listeners || {};
	    }

	    VislibVisType.prototype.createRenderbot = function (vis, $el) {
	      return new VislibRenderbot(vis, $el);
	    };

	    return VislibVisType;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 921 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(634);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function VisTypeFactory(Private) {
	    var VisTypeSchemas = Private(__webpack_require__(634));

	    function VisType(opts) {
	      opts = opts || {};

	      this.name = opts.name;
	      this.title = opts.title;
	      this.responseConverter = opts.responseConverter;
	      this.hierarchicalData = opts.hierarchicalData || false;
	      this.icon = opts.icon;
	      this.description = opts.description;
	      this.schemas = opts.schemas || new VisTypeSchemas();
	      this.params = opts.params || {};
	      this.requiresSearch = opts.requiresSearch == null ? true : opts.requiresSearch; // Default to true unless otherwise specified
	    }

	    return VisType;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 922 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function VislibRenderbotFactory(Private) {
	  var _ = __webpack_require__(192);
	  var vislib = Private(__webpack_require__(332));
	  var Renderbot = Private(__webpack_require__(923));
	  var buildChartData = Private(__webpack_require__(924));

	  _['class'](VislibRenderbot).inherits(Renderbot);
	  function VislibRenderbot(vis, $el) {
	    VislibRenderbot.Super.call(this, vis, $el);
	    this._createVis();
	  }

	  VislibRenderbot.prototype._createVis = function () {
	    var self = this;

	    if (self.vislibVis) self.destroy();

	    self.vislibParams = self._getVislibParams();
	    self.vislibVis = new vislib.Vis(self.$el[0], self.vislibParams);

	    _.each(self.vis.listeners, function (listener, event) {
	      self.vislibVis.on(event, listener);
	    });

	    if (this.chartData) self.vislibVis.render(this.chartData);
	  };

	  VislibRenderbot.prototype._getVislibParams = function () {
	    var self = this;

	    return _.assign({}, self.vis.type.params.defaults, { type: self.vis.type.name }, self.vis.params);
	  };

	  VislibRenderbot.prototype.buildChartData = buildChartData;
	  VislibRenderbot.prototype.render = function (esResponse) {
	    this.chartData = this.buildChartData(esResponse);
	    this.vislibVis.render(this.chartData);
	  };

	  VislibRenderbot.prototype.destroy = function () {
	    var self = this;

	    var vislibVis = self.vislibVis;

	    _.forOwn(self.vis.listeners, function (listener, event) {
	      vislibVis.off(event, listener);
	    });

	    vislibVis.destroy();
	  };

	  VislibRenderbot.prototype.updateParams = function () {
	    var self = this;

	    // get full vislib params object
	    var newParams = self._getVislibParams();

	    // if there's been a change, replace the vis
	    if (!_.isEqual(newParams, self.vislibParams)) self._createVis();
	  };

	  return VislibRenderbot;
	};

/***/ },
/* 923 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function RenderbotFactory(Private) {

	    /**
	     * "Abstract" renderbot class which just defines the expected API
	     *
	     * @param {Vis} vis - the vis object that contains all configuration data required to render the vis
	     * @param {jQuery<DOMElement>} $el - a jQuery wrapped element to render into
	     */
	    function Renderbot(vis, $el) {
	      this.vis = vis;
	      this.$el = $el;
	    }

	    /**
	     * Each renderbot should implement a #render() method which
	     * should accept an elasticsearch response and update the underlying visualization
	     *
	     * @override
	     * @param {object} esResp - The raw elasticsearch response
	     * @return {undefined}
	     */
	    Renderbot.prototype.render = function (esResp) {
	      throw new Error('not implemented');
	    };

	    /**
	     * Each renderbot should implement the #destroy() method which
	     * should tear down the owned element, remove event listeners, etc.
	     *
	     * @override
	     * @return {undefined}
	     */
	    Renderbot.prototype.destroy = function () {
	      throw new Error('not implemented');
	    };

	    /**
	     * Each renderbot can optionally implement the #updateParams() method which
	     * is used to pass in new vis params. It should not re-render the vis
	     *
	     * @override
	     * @return {undefined}
	     */
	    Renderbot.prototype.updateParams = _.noop;

	    return Renderbot;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 924 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(885);
	__webpack_require__(909);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function VislibVisBuildChartData(Private) {
	    var aggResponse = Private(__webpack_require__(885));
	    var Table = Private(__webpack_require__(909));

	    return function (esResponse) {
	      var vis = this.vis;

	      if (vis.isHierarchical()) {
	        // the hierarchical converter is very self-contained (woot!)
	        return aggResponse.hierarchical(vis, esResponse);
	      }

	      var tableGroup = aggResponse.tabify(vis, esResponse, {
	        canSplit: true,
	        asAggConfigResults: true
	      });

	      var converted = convertTableGroup(vis, tableGroup);
	      if (!converted) {
	        // mimic a row of tables that doesn't have any tables
	        // https://github.com/elastic/kibana/blob/7bfb68cd24ed42b1b257682f93c50cd8d73e2520/src/kibana/components/vislib/components/zero_injection/inject_zeros.js#L32
	        converted = { rows: [] };
	      }

	      converted.hits = esResponse.hits.total;

	      return converted;
	    };

	    function convertTableGroup(vis, tableGroup) {
	      var tables = tableGroup.tables;
	      var firstChild = tables[0];
	      if (firstChild instanceof Table) {

	        var chart = convertTable(vis, firstChild);
	        // if chart is within a split, assign group title to its label
	        if (tableGroup.$parent) {
	          chart.label = tableGroup.title;
	        }
	        return chart;
	      }

	      if (!tables.length) return;
	      var out = {};
	      var outList;

	      tables.forEach(function (table) {
	        if (!outList) {
	          var aggConfig = table.aggConfig;
	          var direction = aggConfig.params.row ? 'rows' : 'columns';
	          outList = out[direction] = [];
	        }

	        var output;
	        if (output = convertTableGroup(vis, table)) {
	          outList.push(output);
	        }
	      });

	      return out;
	    }

	    function convertTable(vis, table) {
	      return vis.type.responseConverter(vis, table);
	    }
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 925 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(214);
	__webpack_require__(926);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var module = __webpack_require__(214).get('kibana');

	  module.directive('vislibBasicOptions', function ($parse, $compile) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(926),
	      replace: true
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 926 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <div class=\"vis-option-item\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"vis.params.addTooltip\">\n      Show Tooltip\n    </label>\n  </div>\n  <div class=\"vis-option-item\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"vis.params.addLegend\">\n      Show Legend\n    </label>\n  </div>\n</div>\n"

/***/ },
/* 927 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(214);
	__webpack_require__(484);
	__webpack_require__(928);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var module = __webpack_require__(214).get('kibana');
	  __webpack_require__(484);

	  module.directive('pointSeriesOptions', function ($parse, $compile) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(928),
	      replace: true
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 928 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <div class=\"vis-option-item\" ng-show=\"vis.hasSchemaAgg('segment', 'date_histogram')\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"vis.params.addTimeMarker\" ng-checked=\"vis.params.addTimeMarker\">\n      Current time marker\n    </label>\n  </div>\n  <div class=\"vis-option-item\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"vis.params.setYExtents\">\n      Set Y-Axis Extents\n    </label>\n    <div ng-if=\"vis.params.setYExtents\">\n      <label>\n        y-max\n        <input name=\"yMax\"\n               class=\"form-control\"\n               type=\"number\"\n               step=\"0.1\"\n               greater-than=\"{{vis.params.yAxis.min}}\"\n               ng-model=\"vis.params.yAxis.max\"\n               ng-required=\"vis.params.setYExtents\">\n      </label>\n      <div ng-show=\"vis.params.yAxis.min >= vis.params.yAxis.max\">\n        <span class=\"text-danger\">Max must be greater than min</span>\n      </div>\n      <label>\n        y-min\n        <input name=\"yMin\"\n               class=\"form-control\"\n               type=\"number\"\n               step=\"0.1\"\n               less-than=\"{{vis.params.yAxis.max}}\"\n               greater-than=\"{{vis.params.scale === 'log' ? 0 : ''}}\"\n               ng-model=\"vis.params.yAxis.min\"\n               ng-required=\"vis.params.setYExtents\">\n      </label>\n    </div>\n    <div ng-show=\"vis.params.setYExtents && vis.params.scale === 'log' && vis.params.yAxis.min <= 0\">\n      <span class=\"text-danger\">Min must exceed 0 when a log scale is selected</span>\n    </div>\n    <div class=\"vis-option-item\">\n      <label>\n        <input type=\"checkbox\" ng-model=\"vis.params.defaultYExtents\" ng-disabled=\"vis.params.setYExtents\">\n        Scale Y-Axis to Data Bounds\n      </label>\n    </div>\n  </div>\n</div>\n"

/***/ },
/* 929 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(206);
	__webpack_require__(214);
	__webpack_require__(930);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var $ = __webpack_require__(206);
	  var module = __webpack_require__(214).get('kibana');

	  module.directive('lineInterpolationOption', function ($parse, $compile) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(930),
	      replace: true
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 930 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <label>\n    <input type=\"checkbox\" value=\"{{smoothLines}}\" ng-model=\"vis.params.smoothLines\" name=\"smoothLines\"\n           ng-checked=\"vis.params.smoothLines\">\n    Smooth Lines\n  </label>\n</div>\n"

/***/ },
/* 931 */
/***/ function(module, exports) {

	module.exports = "<!-- vis type specific options -->\n<div class=\"vis-option-item form-group\">\n  <label>\n    Bar Mode\n  </label>\n  <select class=\"form-control\" ng-model=\"vis.params.mode\" ng-options=\"mode for mode in vis.type.params.modes\"></select>\n</div>\n<point-series-options></point-series-options>\n<vislib-basic-options></vislib-basic-options>\n"

/***/ },
/* 932 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(920);
	__webpack_require__(634);
	__webpack_require__(933);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HistogramVisType(Private) {
	    var VislibVisType = Private(__webpack_require__(920));
	    var Schemas = Private(__webpack_require__(634));

	    return new VislibVisType({
	      name: 'line',
	      title: 'Line chart',
	      icon: 'fa-line-chart',
	      description: 'Often the best chart for high density time series. Great for comparing one series to another. ' + 'Be careful with sparse sets as the connection between points can be misleading.',
	      params: {
	        defaults: {
	          shareYAxis: true,
	          addTooltip: true,
	          addLegend: true,
	          showCircles: true,
	          smoothLines: false,
	          interpolate: 'linear',
	          scale: 'linear',
	          drawLinesBetweenPoints: true,
	          radiusRatio: 9,
	          times: [],
	          addTimeMarker: false,
	          defaultYExtents: false,
	          setYExtents: false,
	          yAxis: {}
	        },
	        scales: ['linear', 'log', 'square root'],
	        editor: __webpack_require__(933)
	      },
	      schemas: new Schemas([{
	        group: 'metrics',
	        name: 'metric',
	        title: 'Y-Axis',
	        min: 1,
	        defaults: [{ schema: 'metric', type: 'count' }]
	      }, {
	        group: 'metrics',
	        name: 'radius',
	        title: 'Dot Size',
	        min: 0,
	        max: 1,
	        aggFilter: ['count', 'avg', 'sum', 'min', 'max', 'cardinality']
	      }, {
	        group: 'buckets',
	        name: 'segment',
	        title: 'X-Axis',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }, {
	        group: 'buckets',
	        name: 'group',
	        title: 'Split Lines',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }, {
	        group: 'buckets',
	        name: 'split',
	        title: 'Split Chart',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }])
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 933 */
/***/ function(module, exports) {

	module.exports = "<div>\n  <label>\n    Y-Axis Scale\n  </label>\n  <select class=\"form-control\" ng-model=\"vis.params.scale\" ng-options=\"mode for mode in vis.type.params.scales\"></select>\n<!-- vis type specific options -->\n<line-interpolation-option></line-interpolation-option>\n<div class=\"vis-option-item\">\n  <div>\n    <label>\n      <input type=\"checkbox\" value=\"{{drawLinesBetweenPoints}}\" ng-disabled=\"!vis.params.showCircles\" ng-model=\"vis.params.drawLinesBetweenPoints\" name=\"drawLinesBetweenPoints\" ng-checked=\"vis.params.drawLinesBetweenPoints\">\n      Show Connecting Lines\n    </label>\n  </div>\n  <div>\n    <label>\n      <input type=\"checkbox\" value=\"{{showCircles}}\" ng-disabled=\"!vis.params.drawLinesBetweenPoints\" ng-model=\"vis.params.showCircles\" name=\"showCircles\"  ng-checked=\"vis.params.showCircles\">\n      Show Circles\n    </label>\n  </div>\n</div>\n<point-series-options></point-series-options>\n<vislib-basic-options></vislib-basic-options>\n"

/***/ },
/* 934 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(920);
	__webpack_require__(634);
	__webpack_require__(935);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HistogramVisType(Private) {
	    var VislibVisType = Private(__webpack_require__(920));
	    var Schemas = Private(__webpack_require__(634));

	    return new VislibVisType({
	      name: 'pie',
	      title: 'Pie chart',
	      icon: 'fa-pie-chart',
	      description: 'Pie charts are ideal for displaying the parts of some whole. For example, sales percentages by department.' + 'Pro Tip: Pie charts are best used sparingly, and with no more than 7 slices per pie.',
	      params: {
	        defaults: {
	          shareYAxis: true,
	          addTooltip: true,
	          addLegend: true,
	          isDonut: false
	        },
	        editor: __webpack_require__(935)
	      },
	      responseConverter: false,
	      hierarchicalData: true,
	      schemas: new Schemas([{
	        group: 'metrics',
	        name: 'metric',
	        title: 'Slice Size',
	        min: 1,
	        max: 1,
	        aggFilter: ['sum', 'count', 'cardinality'],
	        defaults: [{ schema: 'metric', type: 'count' }]
	      }, {
	        group: 'buckets',
	        name: 'segment',
	        icon: 'fa fa-scissors',
	        title: 'Split Slices',
	        min: 0,
	        max: Infinity,
	        aggFilter: '!geohash_grid'
	      }, {
	        group: 'buckets',
	        name: 'split',
	        icon: 'fa fa-th',
	        title: 'Split Chart',
	        mustBeFirst: true,
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }])
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 935 */
/***/ function(module, exports) {

	module.exports = "<!-- vis type specific options -->\n<div>\n  <label>\n    <input type=\"checkbox\" value=\"{{isDonut}}\" ng-model=\"vis.params.isDonut\" name=\"isDonut\" ng-checked=\"vis.params.isDonut\">\n   Donut\n  </label>\n</div>\n<vislib-basic-options></vislib-basic-options>\n\n"

/***/ },
/* 936 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(920);
	__webpack_require__(634);
	__webpack_require__(937);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function HistogramVisType(Private) {
	    var VislibVisType = Private(__webpack_require__(920));
	    var Schemas = Private(__webpack_require__(634));

	    return new VislibVisType({
	      name: 'area',
	      title: 'Area chart',
	      icon: 'fa-area-chart',
	      description: 'Great for stacked timelines in which the total of all series is more important ' + 'than comparing any two or more series. Less useful for assessing the relative change of ' + 'unrelated data points as changes in a series lower down the stack will have a difficult to gauge ' + 'effect on the series above it.',
	      params: {
	        defaults: {
	          shareYAxis: true,
	          addTooltip: true,
	          addLegend: true,
	          smoothLines: false,
	          scale: 'linear',
	          interpolate: 'linear',
	          mode: 'stacked',
	          times: [],
	          addTimeMarker: false,
	          defaultYExtents: false,
	          setYExtents: false,
	          yAxis: {}
	        },
	        scales: ['linear', 'log', 'square root'],
	        modes: ['stacked', 'overlap', 'percentage', 'wiggle', 'silhouette'],
	        editor: __webpack_require__(937)
	      },
	      schemas: new Schemas([{
	        group: 'metrics',
	        name: 'metric',
	        title: 'Y-Axis',
	        min: 1,
	        aggFilter: '!std_dev',
	        defaults: [{ schema: 'metric', type: 'count' }]
	      }, {
	        group: 'buckets',
	        name: 'segment',
	        title: 'X-Axis',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }, {
	        group: 'buckets',
	        name: 'group',
	        title: 'Split Area',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }, {
	        group: 'buckets',
	        name: 'split',
	        title: 'Split Chart',
	        min: 0,
	        max: 1,
	        aggFilter: '!geohash_grid'
	      }])
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 937 */
/***/ function(module, exports) {

	module.exports = "<!-- vis type specific options -->\n<div>\n  <label>\n    Chart Mode\n    <select class=\"form-control\" ng-model=\"vis.params.mode\"\n            ng-options=\"mode for mode in vis.type.params.modes\"></select>\n  </label>\n</div>\n<line-interpolation-option></line-interpolation-option>\n<point-series-options></point-series-options>\n<vislib-basic-options></vislib-basic-options>\n"

/***/ },
/* 938 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(920);
	__webpack_require__(634);
	__webpack_require__(913);
	__webpack_require__(192);
	__webpack_require__(939);
	__webpack_require__(940);
	__webpack_require__(941);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TileMapVisType(Private, getAppState, courier, config) {
	    var VislibVisType = Private(__webpack_require__(920));
	    var Schemas = Private(__webpack_require__(634));
	    var geoJsonConverter = Private(__webpack_require__(913));
	    var _ = __webpack_require__(192);
	    var supports = __webpack_require__(939);

	    return new VislibVisType({
	      name: 'tile_map',
	      title: 'Tile map',
	      icon: 'fa-map-marker',
	      description: 'Your source for geographic maps. Requires an elasticsearch geo_point field. More specifically, a field ' + 'that is mapped as type:geo_point with latitude and longitude coordinates.',
	      params: {
	        defaults: {
	          mapType: 'Scaled Circle Markers',
	          isDesaturated: true,
	          addTooltip: true,
	          heatMaxZoom: 16,
	          heatMinOpacity: 0.1,
	          heatRadius: 25,
	          heatBlur: 15,
	          heatNormalizeData: true,
	          wms: config.get('visualization:tileMap:WMSdefaults')
	        },
	        mapTypes: ['Scaled Circle Markers', 'Shaded Circle Markers', 'Shaded Geohash Grid', 'Heatmap'],
	        canDesaturate: !!supports.cssFilters,
	        editor: __webpack_require__(940)
	      },
	      listeners: {
	        rectangle: function rectangle(event) {
	          var agg = _.get(event, 'chart.geohashGridAgg');
	          if (!agg) return;

	          var pushFilter = Private(__webpack_require__(941))(getAppState());
	          var indexPatternName = agg.vis.indexPattern.id;
	          var field = agg.fieldName();
	          var filter = { geo_bounding_box: {} };
	          filter.geo_bounding_box[field] = event.bounds;

	          pushFilter(filter, false, indexPatternName);
	        },
	        mapMoveEnd: function mapMoveEnd(event) {
	          var agg = _.get(event, 'chart.geohashGridAgg');
	          if (!agg) return;

	          agg.params.mapZoom = event.zoom;
	          agg.params.mapCenter = [event.center.lat, event.center.lng];

	          var editableVis = agg.vis.getEditableVis();
	          if (!editableVis) return;

	          var editableAgg = editableVis.aggs.byId[agg.id];
	          if (editableAgg) {
	            editableAgg.params.mapZoom = event.zoom;
	            editableAgg.params.mapCenter = [event.center.lat, event.center.lng];
	          }
	        },
	        mapZoomEnd: function mapZoomEnd(event) {
	          var agg = _.get(event, 'chart.geohashGridAgg');
	          if (!agg || !agg.params.autoPrecision) return;

	          // zoomPrecision maps event.zoom to a geohash precision value
	          // event.limit is the configurable max geohash precision
	          // default max precision is 7, configurable up to 12
	          var zoomPrecision = {
	            1: 2,
	            2: 2,
	            3: 2,
	            4: 3,
	            5: 3,
	            6: 4,
	            7: 4,
	            8: 5,
	            9: 5,
	            10: 6,
	            11: 6,
	            12: 7,
	            13: 7,
	            14: 8,
	            15: 9,
	            16: 10,
	            17: 11,
	            18: 12
	          };

	          var precision = config.get('visualization:tileMap:maxPrecision');
	          agg.params.precision = Math.min(zoomPrecision[event.zoom], precision);

	          courier.fetch();
	        }
	      },
	      responseConverter: geoJsonConverter,
	      schemas: new Schemas([{
	        group: 'metrics',
	        name: 'metric',
	        title: 'Value',
	        min: 1,
	        max: 1,
	        aggFilter: ['count', 'avg', 'sum', 'min', 'max', 'cardinality'],
	        defaults: [{ schema: 'metric', type: 'count' }]
	      }, {
	        group: 'buckets',
	        name: 'segment',
	        title: 'Geo Coordinates',
	        aggFilter: 'geohash_grid',
	        min: 1,
	        max: 1
	      }, {
	        group: 'buckets',
	        name: 'split',
	        title: 'Split Chart',
	        min: 0,
	        max: 1
	      }])
	    });
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 939 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  /**
	   * just a place to put feature detection checks
	   */
	  return {
	    cssFilters: (function () {
	      var e = document.createElement('img');
	      var rules = ['webkitFilter', 'mozFilter', 'msFilter', 'filter'];
	      var test = 'grayscale(1)';
	      rules.forEach(function (rule) {
	        e.style[rule] = test;
	      });

	      document.body.appendChild(e);
	      var styles = window.getComputedStyle(e);
	      var can = _(styles).pick(rules).includes(test);
	      document.body.removeChild(e);

	      return can;
	    })()
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 940 */
/***/ function(module, exports) {

	module.exports = "<!-- vis type specific options -->\n<div class=\"form-group\">\n  <label>Map type</label>\n    <select name=\"agg\"\n    class=\"form-control\"\n    ng-model=\"vis.params.mapType\"\n    ng-init=\"vis.params.mapType || vis.type.params.mapTypes[0]\"\n    ng-options=\"mapType as mapType for mapType in vis.type.params.mapTypes\"\n    >\n  </select>\n</div>\n\n<div ng-if=\"vis.params.mapType === 'Heatmap'\" class=\"form-group\">\n  <div>\n    <label>\n      Radius\n      &nbsp;<kbn-info placement=\"right\" info=\"Size of heatmap dots. Default: 25\"></kbn-info>\n    </label>\n    <div class=\"vis-editor-agg-form-row\">\n      <input\n        name=\"heatRadius\"\n        ng-model=\"vis.params.heatRadius\"\n        required\n        class=\"form-control\"\n        type=\"range\"\n        min=\"5\"\n        max=\"50\"\n        step=\"1\"\n        >\n      <div class=\"form-group vis-editor-agg-form-value\">\n        {{vis.params.heatRadius}}\n      </div>\n    </div>\n  </div>\n  <div>\n    <label>\n      Blur\n      &nbsp;<kbn-info placement=\"right\" info=\"Amount of blur applied to dots. Default: 15\"></kbn-info>\n    </label>\n    <div class=\"vis-editor-agg-form-row\">\n      <input\n        name=\"heatBlur\"\n        ng-model=\"vis.params.heatBlur\"\n        required\n        class=\"form-control\"\n        type=\"range\"\n        min=\"1\"\n        max=\"25\"\n        step=\"1\"\n        >\n      <div class=\"form-group vis-editor-agg-form-value\">\n        {{vis.params.heatBlur}}\n      </div>\n    </div>\n  </div>\n  <div>\n    <label>\n      Maximum zoom\n      &nbsp;<kbn-info placement=\"right\" info=\"Map zoom at which all dots are displayed at full intensity. Default: 16\"></kbn-info>\n    </label>\n    <div class=\"vis-editor-agg-form-row\">\n      <input\n        name=\"heatMaxZoom\"\n        ng-model=\"vis.params.heatMaxZoom\"\n        required\n        class=\"form-control\"\n        type=\"range\"\n        min=\"1\"\n        max=\"18\"\n        step=\"1\"\n        >\n      <div class=\"vis-editor-agg-form-value\">\n        {{vis.params.heatMaxZoom}}\n      </div>\n    </div>\n  </div>\n  <div>\n    <label>\n      Minimum opacity\n      &nbsp;<kbn-info placement=\"right\" info=\"Minimum opacity of dots. Default: 0.1\"></kbn-info>\n    </label>\n    <div class=\"vis-editor-agg-form-row\">\n      <input\n        name=\"heatMinOpacity\"\n        ng-model=\"vis.params.heatMinOpacity\"\n        required\n        class=\"form-control\"\n        type=\"range\"\n        min=\"0\"\n        max=\"1.0\"\n        step=\"0.01\"\n        >\n      <div class=\"vis-editor-agg-form-value\">\n        {{vis.params.heatMinOpacity}}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"form-group\">\n    <label>\n      <input type=\"checkbox\" ng-model=\"vis.params.addTooltip\">\n      Show Tooltip\n    </label>\n  </div>\n</div>\n\n<div class=\"vis-option-item form-group\">\n  <label>\n    <input type=\"checkbox\"\n    name=\"isDesaturated\"\n    ng-disabled=\"!vis.type.params.canDesaturate\"\n    ng-model=\"vis.params.isDesaturated\">\n\n    Desaturate map tiles\n\n    <kbn-info info=\"Reduce the vibrancy of tile colors, this does not work in any version of Internet Explorer\"></kbn-info>\n  </label>\n</div>\n\n<div class=\"vis-option-item form-group\">\n  <label>\n    <input type=\"checkbox\"\n    name=\"wms.enabled\"\n    ng-model=\"vis.params.wms.enabled\">\n\n    WMS compliant map server\n\n    <kbn-info info=\"Use WMS compliant map tile server. For advanced users only.\"></kbn-info>\n  </label>\n</div>\n\n<div ng-show=\"vis.params.wms.enabled\" class=\"well\">\n  <div class=\"vis-option-item form-group\">\n    \n    <p>\n      WMS maps are 3rd party mapping services that have not been verified to work with Kibana. \n      These should be considered expert settings.\n    </p>\n\n    <label>\n      WMS url*\n    </label>\n    <input type=\"text\" class=\"form-control\"\n      name=\"wms.url\"\n      ng-model=\"vis.params.wms.url\">    \n  </div>\n\n  <div class=\"vis-option-item form-group\">\n    <label>\n      WMS layers* <kbn-info info=\"A comma seperated list of layers to use.\"></kbn-info>\n    </label>\n    <input type=\"text\" class=\"form-control\"\n      ng-require=\"vis.params.wms.enabled\"\n      ng-model=\"vis.params.wms.options.layers\"   \n      name=\"wms.options.layers\">\n  </div>\n\n  <div class=\"vis-option-item form-group\">\n    <label>\n      WMS version* <kbn-info info=\"The version of WMS the server supports\"></kbn-info>\n    </label>\n    <input type=\"text\" class=\"form-control\"\n      name=\"wms.options.version\"\n      ng-model=\"vis.params.wms.options.version\">    \n  </div>\n\n  <div class=\"vis-option-item form-group\">\n    <label>\n      WMS format* <kbn-info info=\"Usually image/png or image/jpeg. Use png if the server will return transparent layers\"></kbn-info>\n    </label>\n    <input type=\"text\" class=\"form-control\"\n      name=\"wms.options.format\"\n      ng-model=\"vis.params.wms.options.format\">    \n  </div>\n  \n  <div class=\"vis-option-item form-group\">\n    <label>\n      WMS attribution <kbn-info info=\"Attribution string for the lower right corner<\"></kbn-info>\n    </label>\n    <input type=\"text\" class=\"form-control\"\n      name=\"wms.options.attribution\"\n      ng-model=\"vis.params.wms.options.attribution\">    \n  </div>\n\n  <div class=\"vis-option-item form-group\">\n    <label>\n      WMS styles* <kbn-info info=\"A comma seperated list of WMS server supported styles to use. Blank in most cases.\"></kbn-info>\n    </label>\n    <input type=\"text\" class=\"form-control\"\n      name=\"wms.options.styles\"\n      ng-model=\"vis.params.wms.options.styles\">    \n  </div>\n\n  <p>* if this parameter is incorrect, maps will fail to load.</p>\n\n\n</div>\n"

/***/ },
/* 941 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  return function () {
	    return function ($state) {
	      if (!_.isObject($state)) throw new Error('pushFilters requires a state object');
	      return function (filter, negate, index) {
	        // Hierarchical and tabular data set their aggConfigResult parameter
	        // differently because of how the point is rewritten between the two. So
	        // we need to check if the point.orig is set, if not use try the point.aggConfigResult
	        var filters = _.clone($state.filters || []);
	        var pendingFilter = { meta: { negate: negate, index: index } };
	        _.extend(pendingFilter, filter);
	        filters.push(pendingFilter);
	        $state.filters = filters;
	      };
	    };
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 942 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(943);
	__webpack_require__(944);
	__webpack_require__(479);
	__webpack_require__(946);
	__webpack_require__(948);
	__webpack_require__(949);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // we need to load the css ourselves
	  __webpack_require__(943);

	  // we also need to load the controller and used by the template
	  __webpack_require__(944);

	  // register the provider with the visTypes registry so that other know it exists
	  __webpack_require__(479).register(MarkdownVisProvider);

	  function MarkdownVisProvider(Private) {
	    var TemplateVisType = Private(__webpack_require__(946));

	    // return the visType object, which kibana will use to display and configure new
	    // Vis object of this type.
	    return new TemplateVisType({
	      name: 'markdown',
	      title: 'Markdown widget',
	      icon: 'fa-code',
	      description: 'Useful for displaying explanations or instructions for dashboards.',
	      template: __webpack_require__(948),
	      params: {
	        editor: __webpack_require__(949)
	      },
	      requiresSearch: false
	    });
	  }

	  // export the provider so that the visType can be required with Private()
	  return MarkdownVisProvider;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 943 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 944 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(945);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var marked = __webpack_require__(945);
	  marked.setOptions({
	    gfm: true, // Github-flavored markdown
	    sanitize: true // Sanitize HTML tags
	  });

	  var module = __webpack_require__(214).get('kibana/markdown_vis', ['kibana']);
	  module.controller('KbnMarkdownVisController', function ($scope, $sce) {
	    $scope.$watch('vis.params.markdown', function (html) {
	      if (!html) return;
	      $scope.html = $sce.trustAsHtml(marked(html));
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 945 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 */

	;(function() {

	/**
	 * Block-Level Grammar
	 */

	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
	  table: noop,
	  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
	  text: /^[^\n]+/
	};

	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = replace(block.item, 'gm')
	  (/bull/g, block.bullet)
	  ();

	block.list = replace(block.list)
	  (/bull/g, block.bullet)
	  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
	  ('def', '\\n+(?=' + block.def.source + ')')
	  ();

	block.blockquote = replace(block.blockquote)
	  ('def', block.def)
	  ();

	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

	block.html = replace(block.html)
	  ('comment', /<!--[\s\S]*?-->/)
	  ('closed', /<(tag)[\s\S]+?<\/\1>/)
	  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
	  (/tag/g, block._tag)
	  ();

	block.paragraph = replace(block.paragraph)
	  ('hr', block.hr)
	  ('heading', block.heading)
	  ('lheading', block.lheading)
	  ('blockquote', block.blockquote)
	  ('tag', '<' + block._tag)
	  ('def', block.def)
	  ();

	/**
	 * Normal Block Grammar
	 */

	block.normal = merge({}, block);

	/**
	 * GFM Block Grammar
	 */

	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
	  paragraph: /^/
	});

	block.gfm.paragraph = replace(block.paragraph)
	  ('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  ();

	/**
	 * GFM + Tables Block Grammar
	 */

	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});

	/**
	 * Block Lexer
	 */

	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;

	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}

	/**
	 * Expose Block Rules
	 */

	Lexer.rules = block;

	/**
	 * Static Lex Method
	 */

	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};

	/**
	 * Preprocessing
	 */

	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');

	  return this.token(src, true);
	};

	/**
	 * Lexing
	 */

	Lexer.prototype.token = function(src, top, bq) {
	  var src = src.replace(/^ +$/gm, '')
	    , next
	    , loose
	    , cap
	    , bull
	    , b
	    , item
	    , space
	    , i
	    , l;

	  while (src) {
	    // newline
	    if (cap = this.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this.tokens.push({
	          type: 'space'
	        });
	      }
	    }

	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this.tokens.push({
	        type: 'code',
	        text: !this.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }

	    // fences (gfm)
	    if (cap = this.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3]
	      });
	      continue;
	    }

	    // heading
	    if (cap = this.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }

	    // table no leading pipe (gfm)
	    if (top && (cap = this.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);

	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };

	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }

	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }

	      this.tokens.push(item);

	      continue;
	    }

	    // lheading
	    if (cap = this.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }

	    // hr
	    if (cap = this.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }

	    // blockquote
	    if (cap = this.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);

	      this.tokens.push({
	        type: 'blockquote_start'
	      });

	      cap = cap[0].replace(/^ *> ?/gm, '');

	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this.token(cap, top, true);

	      this.tokens.push({
	        type: 'blockquote_end'
	      });

	      continue;
	    }

	    // list
	    if (cap = this.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];

	      this.tokens.push({
	        type: 'list_start',
	        ordered: bull.length > 1
	      });

	      // Get each top-level item.
	      cap = cap[0].match(this.rules.item);

	      next = false;
	      l = cap.length;
	      i = 0;

	      for (; i < l; i++) {
	        item = cap[i];

	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }

	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }

	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }

	        this.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });

	        // Recurse.
	        this.token(item, false, bq);

	        this.tokens.push({
	          type: 'list_item_end'
	        });
	      }

	      this.tokens.push({
	        type: 'list_end'
	      });

	      continue;
	    }

	    // html
	    if (cap = this.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
	        text: cap[0]
	      });
	      continue;
	    }

	    // def
	    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.links[cap[1].toLowerCase()] = {
	        href: cap[2],
	        title: cap[3]
	      };
	      continue;
	    }

	    // table (gfm)
	    if (top && (cap = this.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);

	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };

	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }

	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }

	      this.tokens.push(item);

	      continue;
	    }

	    // top-level paragraph
	    if (top && (cap = this.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }

	    // text
	    if (cap = this.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }

	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }

	  return this.tokens;
	};

	/**
	 * Inline-Level Grammar
	 */

	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
	};

	inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

	inline.link = replace(inline.link)
	  ('inside', inline._inside)
	  ('href', inline._href)
	  ();

	inline.reflink = replace(inline.reflink)
	  ('inside', inline._inside)
	  ();

	/**
	 * Normal Inline Grammar
	 */

	inline.normal = merge({}, inline);

	/**
	 * Pedantic Inline Grammar
	 */

	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});

	/**
	 * GFM Inline Grammar
	 */

	inline.gfm = merge({}, inline.normal, {
	  escape: replace(inline.escape)('])', '~|])')(),
	  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: replace(inline.text)
	    (']|', '~]|')
	    ('|', '|https?://|')
	    ()
	});

	/**
	 * GFM + Line Breaks Inline Grammar
	 */

	inline.breaks = merge({}, inline.gfm, {
	  br: replace(inline.br)('{2,}', '*')(),
	  text: replace(inline.gfm.text)('{2,}', '*')()
	});

	/**
	 * Inline Lexer & Compiler
	 */

	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer;
	  this.renderer.options = this.options;

	  if (!this.links) {
	    throw new
	      Error('Tokens array requires a `links` property.');
	  }

	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}

	/**
	 * Expose Inline Rules
	 */

	InlineLexer.rules = inline;

	/**
	 * Static Lexing/Compiling Method
	 */

	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};

	/**
	 * Lexing/Compiling
	 */

	InlineLexer.prototype.output = function(src) {
	  var out = ''
	    , link
	    , text
	    , href
	    , cap;

	  while (src) {
	    // escape
	    if (cap = this.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }

	    // autolink
	    if (cap = this.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = cap[1].charAt(6) === ':'
	          ? this.mangle(cap[1].substring(7))
	          : this.mangle(cap[1]);
	        href = this.mangle('mailto:') + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this.renderer.link(href, null, text);
	      continue;
	    }

	    // url (gfm)
	    if (!this.inLink && (cap = this.rules.url.exec(src))) {
	      src = src.substring(cap[0].length);
	      text = escape(cap[1]);
	      href = text;
	      out += this.renderer.link(href, null, text);
	      continue;
	    }

	    // tag
	    if (cap = this.rules.tag.exec(src)) {
	      if (!this.inLink && /^<a /i.test(cap[0])) {
	        this.inLink = true;
	      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        this.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this.options.sanitize
	        ? escape(cap[0])
	        : cap[0];
	      continue;
	    }

	    // link
	    if (cap = this.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.inLink = true;
	      out += this.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this.inLink = false;
	      continue;
	    }

	    // reflink, nolink
	    if ((cap = this.rules.reflink.exec(src))
	        || (cap = this.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this.inLink = true;
	      out += this.outputLink(cap, link);
	      this.inLink = false;
	      continue;
	    }

	    // strong
	    if (cap = this.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.strong(this.output(cap[2] || cap[1]));
	      continue;
	    }

	    // em
	    if (cap = this.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.em(this.output(cap[2] || cap[1]));
	      continue;
	    }

	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.codespan(escape(cap[2], true));
	      continue;
	    }

	    // br
	    if (cap = this.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.br();
	      continue;
	    }

	    // del (gfm)
	    if (cap = this.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.del(this.output(cap[1]));
	      continue;
	    }

	    // text
	    if (cap = this.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += escape(this.smartypants(cap[0]));
	      continue;
	    }

	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }

	  return out;
	};

	/**
	 * Compile Link
	 */

	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href)
	    , title = link.title ? escape(link.title) : null;

	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};

	/**
	 * Smartypants Transformations
	 */

	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) return text;
	  return text
	    // em-dashes
	    .replace(/--/g, '\u2014')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};

	/**
	 * Mangle Links
	 */

	InlineLexer.prototype.mangle = function(text) {
	  var out = ''
	    , l = text.length
	    , i = 0
	    , ch;

	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }

	  return out;
	};

	/**
	 * Renderer
	 */

	function Renderer(options) {
	  this.options = options || {};
	}

	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }

	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }

	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};

	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};

	Renderer.prototype.html = function(html) {
	  return html;
	};

	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};

	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};

	Renderer.prototype.list = function(body, ordered) {
	  var type = ordered ? 'ol' : 'ul';
	  return '<' + type + '>\n' + body + '</' + type + '>\n';
	};

	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};

	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};

	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};

	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};

	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};

	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};

	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};

	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};

	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};

	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};

	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return '';
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
	      return '';
	    }
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};

	Renderer.prototype.image = function(href, title, text) {
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};

	/**
	 * Parsing & Compiling
	 */

	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer;
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}

	/**
	 * Static Parse Method
	 */

	Parser.parse = function(src, options, renderer) {
	  var parser = new Parser(options, renderer);
	  return parser.parse(src);
	};

	/**
	 * Parse Loop
	 */

	Parser.prototype.parse = function(src) {
	  this.inline = new InlineLexer(src.links, this.options, this.renderer);
	  this.tokens = src.reverse();

	  var out = '';
	  while (this.next()) {
	    out += this.tok();
	  }

	  return out;
	};

	/**
	 * Next Token
	 */

	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};

	/**
	 * Preview Next Token
	 */

	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};

	/**
	 * Parse Text Tokens
	 */

	Parser.prototype.parseText = function() {
	  var body = this.token.text;

	  while (this.peek().type === 'text') {
	    body += '\n' + this.next().text;
	  }

	  return this.inline.output(body);
	};

	/**
	 * Parse Current Token
	 */

	Parser.prototype.tok = function() {
	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        this.token.text);
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = ''
	        , body = ''
	        , i
	        , row
	        , cell
	        , flags
	        , j;

	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        flags = { header: true, align: this.token.align[i] };
	        cell += this.renderer.tablecell(
	          this.inline.output(this.token.header[i]),
	          { header: true, align: this.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);

	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this.token.cells[i];

	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(row[j]),
	            { header: false, align: this.token.align[j] }
	          );
	        }

	        body += this.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      var body = '';

	      while (this.next().type !== 'blockquote_end') {
	        body += this.tok();
	      }

	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      var body = ''
	        , ordered = this.token.ordered;

	      while (this.next().type !== 'list_end') {
	        body += this.tok();
	      }

	      return this.renderer.list(body, ordered);
	    }
	    case 'list_item_start': {
	      var body = '';

	      while (this.next().type !== 'list_item_end') {
	        body += this.token.type === 'text'
	          ? this.parseText()
	          : this.tok();
	      }

	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      var body = '';

	      while (this.next().type !== 'list_item_end') {
	        body += this.tok();
	      }

	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};

	/**
	 * Helpers
	 */

	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}

	function unescape(html) {
	  return html.replace(/&([#\w]+);/g, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}

	function replace(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return function self(name, val) {
	    if (!name) return new RegExp(regex, opt);
	    val = val.source || val;
	    val = val.replace(/(^|[^\[])\^/g, '$1');
	    regex = regex.replace(name, val);
	    return self;
	  };
	}

	function noop() {}
	noop.exec = noop;

	function merge(obj) {
	  var i = 1
	    , target
	    , key;

	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }

	  return obj;
	}


	/**
	 * Marked
	 */

	function marked(src, opt, callback) {
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }

	    opt = merge({}, marked.defaults, opt || {});

	    var highlight = opt.highlight
	      , tokens
	      , pending
	      , i = 0;

	    try {
	      tokens = Lexer.lex(src, opt)
	    } catch (e) {
	      return callback(e);
	    }

	    pending = tokens.length;

	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }

	      var out;

	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }

	      opt.highlight = highlight;

	      return err
	        ? callback(err)
	        : callback(null, out);
	    };

	    if (!highlight || highlight.length < 3) {
	      return done();
	    }

	    delete opt.highlight;

	    if (!pending) return done();

	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }

	    return;
	  }
	  try {
	    if (opt) opt = merge({}, marked.defaults, opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/chjj/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occured:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}

	/**
	 * Options
	 */

	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};

	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer,
	  xhtml: false
	};

	/**
	 * Expose
	 */

	marked.Parser = Parser;
	marked.parser = Parser.parse;

	marked.Renderer = Renderer;

	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;

	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;

	marked.parse = marked;

	if (true) {
	  module.exports = marked;
	} else if (typeof define === 'function' && define.amd) {
	  define(function() { return marked; });
	} else {
	  this.marked = marked;
	}

	}).call(function() {
	  return this || (typeof window !== 'undefined' ? window : global);
	}());

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 946 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(921);
	__webpack_require__(947);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TemplateVisTypeFactory(Private) {
	    var _ = __webpack_require__(192);
	    var VisType = Private(__webpack_require__(921));
	    var TemplateRenderbot = Private(__webpack_require__(947));

	    _['class'](TemplateVisType).inherits(VisType);
	    function TemplateVisType(opts) {
	      TemplateVisType.Super.call(this, opts);

	      this.template = opts.template;
	      if (!this.template) {
	        throw new Error('Missing template for TemplateVisType');
	      }
	    }

	    TemplateVisType.prototype.createRenderbot = function (vis, $el) {
	      return new TemplateRenderbot(vis, $el);
	    };

	    return TemplateVisType;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 947 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(923);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  return function TemplateRenderbotFactory(Private, $compile, $rootScope) {
	    var _ = __webpack_require__(192);
	    var Renderbot = Private(__webpack_require__(923));

	    _['class'](TemplateRenderbot).inherits(Renderbot);
	    function TemplateRenderbot(vis, $el) {
	      TemplateRenderbot.Super.call(this, vis, $el);

	      this.$scope = $rootScope.$new();
	      this.$scope.vis = vis;

	      $el.html($compile(this.vis.type.template)(this.$scope));
	    }

	    TemplateRenderbot.prototype.render = function (esResponse) {
	      this.$scope.esResponse = esResponse;
	    };

	    TemplateRenderbot.prototype.destroy = function () {
	      this.$scope.$destroy();
	    };

	    return TemplateRenderbot;
	  };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 948 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"KbnMarkdownVisController\" class=\"markdown-vis\">\n    <div ng-bind-html=\"html\"></div>\n</div>"

/***/ },
/* 949 */
/***/ function(module, exports) {

	module.exports = "<div class=\"markdown-vis-options form-group\">\n  <div>\n    <label>Markdown</label>\n    <small class=\"pull-right\"><a target=\"_window\" href=\"https://help.github.com/articles/github-flavored-markdown/\">Help <i aria-hidden=\"true\" class=\"fa fa-link\"></i></a></small>\n  </div>\n  <textarea ng-model=\"vis.params.markdown\" class=\"form-control\" rows=\"20\"></textarea>\n</div>"

/***/ },
/* 950 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(951);
	__webpack_require__(952);
	__webpack_require__(479);
	__webpack_require__(946);
	__webpack_require__(634);
	__webpack_require__(953);
	__webpack_require__(954);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // we need to load the css ourselves
	  __webpack_require__(951);

	  // we also need to load the controller and used by the template
	  __webpack_require__(952);

	  // register the provider with the visTypes registry
	  __webpack_require__(479).register(MetricVisProvider);

	  function MetricVisProvider(Private) {
	    var TemplateVisType = Private(__webpack_require__(946));
	    var Schemas = Private(__webpack_require__(634));

	    // return the visType object, which kibana will use to display and configure new
	    // Vis object of this type.
	    return new TemplateVisType({
	      name: 'metric',
	      title: 'Metric',
	      description: 'One big number for all of your one big number needs. Perfect for show ' + 'a count of hits, or the exact average a numeric field.',
	      icon: 'fa-calculator',
	      template: __webpack_require__(953),
	      params: {
	        defaults: {
	          fontSize: 60
	        },
	        editor: __webpack_require__(954)
	      },
	      schemas: new Schemas([{
	        group: 'metrics',
	        name: 'metric',
	        title: 'Metric',
	        min: 1,
	        defaults: [{ type: 'count', schema: 'metric' }]
	      }])
	    });
	  }

	  // export the provider so that the visType can be required with Private()
	  return MetricVisProvider;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 951 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 952 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(907);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // get the kibana/metric_vis module, and make sure that it requires the "kibana" module if it
	  // didn't already
	  var module = __webpack_require__(214).get('kibana/metric_vis', ['kibana']);

	  module.controller('KbnMetricVisController', function ($scope, Private) {
	    var tabifyAggResponse = Private(__webpack_require__(907));

	    var metrics = $scope.metrics = [];

	    $scope.processTableGroups = function (tableGroups) {
	      tableGroups.tables.forEach(function (table) {
	        table.columns.forEach(function (column, i) {
	          var fieldFormatter = table.aggConfig(column).fieldFormatter();
	          metrics.push({
	            label: column.title,
	            value: fieldFormatter(table.rows[0][i])
	          });
	        });
	      });
	    };

	    $scope.$watch('esResponse', function (resp) {
	      if (resp) {
	        metrics.length = 0;
	        $scope.processTableGroups(tabifyAggResponse($scope.vis, resp));
	      }
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 953 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"KbnMetricVisController\" class=\"metric-vis\">\n    <div class=\"metric-container\" ng-repeat=\"metric in metrics\">\n        <div class=\"metric-value\" ng-style=\"{'font-size': vis.params.fontSize+'pt'}\">{{metric.value}}</div>\n        <div>{{metric.label}}</div>\n    </div>\n</div>\n"

/***/ },
/* 954 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Font Size - {{ vis.params.fontSize }}pt</label>\n  <input type=\"range\" ng-model=\"vis.params.fontSize\" class=\"form-control\" min=\"12\" max=\"120\" />\n</div>"

/***/ },
/* 955 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(956);
	__webpack_require__(957);
	__webpack_require__(958);
	__webpack_require__(960);
	__webpack_require__(964);
	__webpack_require__(479);
	__webpack_require__(946);
	__webpack_require__(634);
	__webpack_require__(966);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // we need to load the css ourselves
	  __webpack_require__(956);

	  // we also need to load the controller and used by the template
	  __webpack_require__(957);

	  // our params are a bit complex so we will manage them with a directive
	  __webpack_require__(958);

	  // require the directives that we use as well
	  __webpack_require__(960);
	  __webpack_require__(964);

	  // register the provider with the visTypes registry
	  __webpack_require__(479).register(TableVisTypeProvider);

	  // define the TableVisType
	  function TableVisTypeProvider(Private) {
	    var TemplateVisType = Private(__webpack_require__(946));
	    var Schemas = Private(__webpack_require__(634));

	    // define the TableVisController which is used in the template
	    // by angular's ng-controller directive

	    // return the visType object, which kibana will use to display and configure new
	    // Vis object of this type.
	    return new TemplateVisType({
	      name: 'table',
	      title: 'Data table',
	      icon: 'fa-table',
	      description: 'The data table provides a detailed breakdown, in tabular format, of the results of a composed ' + 'aggregation. Tip, a data table is available from many other charts by clicking grey bar at the bottom of the chart.',
	      template: __webpack_require__(966),
	      params: {
	        defaults: {
	          perPage: 10,
	          showPartialRows: false,
	          showMeticsAtAllLevels: false
	        },
	        editor: '<table-vis-params></table-vis-params>'
	      },
	      hierarchicalData: function hierarchicalData(vis) {
	        return Boolean(vis.params.showPartialRows || vis.params.showMeticsAtAllLevels);
	      },
	      schemas: new Schemas([{
	        group: 'metrics',
	        name: 'metric',
	        title: 'Metric',
	        min: 1,
	        defaults: [{ type: 'count', schema: 'metric' }]
	      }, {
	        group: 'buckets',
	        name: 'bucket',
	        title: 'Split Rows'
	      }, {
	        group: 'buckets',
	        name: 'split',
	        title: 'Split Table'
	      }])
	    });
	  }

	  return TableVisTypeProvider;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 956 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 957 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(214);
	__webpack_require__(907);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  // get the kibana/table_vis module, and make sure that it requires the "kibana" module if it
	  // didn't already
	  var module = __webpack_require__(214).get('kibana/table_vis', ['kibana']);

	  // add a controller to tha module, which will transform the esResponse into a
	  // tabular format that we can pass to the table directive
	  module.controller('KbnTableVisController', function ($scope, Private) {
	    var tabifyAggResponse = Private(__webpack_require__(907));

	    $scope.$watch('esResponse', function (resp, oldResp) {
	      var tableGroups = $scope.tableGroups = null;
	      var hasSomeRows = $scope.hasSomeRows = null;

	      if (resp) {
	        var vis = $scope.vis;
	        var params = vis.params;

	        tableGroups = tabifyAggResponse(vis, resp, {
	          partialRows: params.showPartialRows,
	          minimalColumns: vis.isHierarchical() && !params.showMeticsAtAllLevels,
	          asAggConfigResults: true
	        });

	        hasSomeRows = tableGroups.tables.some(function haveRows(table) {
	          if (table.tables) return table.tables.some(haveRows);
	          return table.rows.length > 0;
	        });
	      }

	      $scope.hasSomeRows = hasSomeRows;
	      if (hasSomeRows) {
	        $scope.tableGroups = tableGroups;
	      }
	    });
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 958 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);
	__webpack_require__(959);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  __webpack_require__(214).get('kibana/table_vis').directive('tableVisParams', function () {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(959),
	      link: function link($scope) {
	        $scope.$watchMulti(['vis.params.showPartialRows', 'vis.params.showMeticsAtAllLevels'], function () {
	          if (!$scope.vis) return;

	          var params = $scope.vis.params;
	          if (params.showPartialRows || params.showMeticsAtAllLevels) {
	            $scope.metricsAtAllLevels = true;
	          } else {
	            $scope.metricsAtAllLevels = false;
	          }
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 959 */
/***/ function(module, exports) {

	module.exports = "<div class=\"form-group\">\n  <label>Per Page</label>\n  <input type=\"number\" ng-model=\"vis.params.perPage\" class=\"form-control\">\n</div>\n\n<div class=\"checkbox\">\n  <label>\n    <input type=\"checkbox\" ng-model=\"vis.params.showMeticsAtAllLevels\">\n    Show metrics for every bucket/level\n  </label>\n</div>\n\n<div class=\"checkbox\">\n  <label>\n    <input type=\"checkbox\" ng-model=\"vis.params.showPartialRows\">\n    Show partial rows\n  </label>\n</div>\n\n<div class=\"checkbox\">\n  <label>\n    <input type=\"checkbox\" ng-model=\"metricsAtAllLevels\" disabled>\n    Calculate metrics for every bucket/level\n  </label>\n</div>\n"

/***/ },
/* 960 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(752);
	__webpack_require__(961);
	__webpack_require__(962);
	__webpack_require__(214);
	__webpack_require__(192);
	__webpack_require__(963);
	__webpack_require__(795);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(752);
	  __webpack_require__(961);
	  __webpack_require__(962);

	  __webpack_require__(214).get('kibana').directive('kbnAggTable', function ($filter, config, Private, compileRecursiveDirective) {
	    var _ = __webpack_require__(192);

	    return {
	      restrict: 'E',
	      template: __webpack_require__(963),
	      scope: {
	        table: '=',
	        perPage: '=?'
	      },
	      controllerAs: 'aggTable',
	      compile: function compile($el) {
	        // Use the compile function from the RecursionHelper,
	        // And return the linking function(s) which it returns
	        return compileRecursiveDirective.compile($el);
	      },
	      controller: function controller($scope) {
	        var self = this;

	        self.sort = null;
	        self._saveAs = __webpack_require__(795).saveAs;
	        self.csv = {
	          separator: config.get('csv:separator'),
	          quoteValues: config.get('csv:quoteValues')
	        };

	        self.exportAsCsv = function (formatted) {
	          var csv = new Blob([self.toCsv(formatted)], { type: 'text/plain' });
	          self._saveAs(csv, self.csv.filename);
	        };

	        self.toCsv = function (formatted) {
	          var rows = $scope.table.rows;
	          var columns = formatted ? $scope.formattedColumns : $scope.table.columns;
	          var nonAlphaNumRE = /[^a-zA-Z0-9]/;
	          var allDoubleQuoteRE = /"/g;

	          function escape(val) {
	            if (!formatted && _.isObject(val)) val = val.valueOf();
	            val = String(val);
	            if (self.csv.quoteValues && nonAlphaNumRE.test(val)) {
	              val = '"' + val.replace(allDoubleQuoteRE, '""') + '"';
	            }
	            return val;
	          }

	          // escape each cell in each row
	          var csvRows = rows.map(function (row) {
	            return row.map(escape);
	          });

	          // add the columns to the rows
	          csvRows.unshift(columns.map(function (col) {
	            return escape(col.title);
	          }));

	          return csvRows.map(function (row) {
	            return row.join(self.csv.separator) + '\r\n';
	          }).join('');
	        };

	        $scope.$watch('table', function () {
	          var table = $scope.table;

	          if (!table) {
	            $scope.rows = null;
	            $scope.formattedColumns = null;
	            return;
	          }

	          self.csv.filename = (table.title() || 'table') + '.csv';
	          $scope.rows = table.rows;
	          $scope.formattedColumns = table.columns.map(function (col, i) {
	            var agg = $scope.table.aggConfig(col);
	            var field = agg.field();
	            var formattedColumn = {
	              title: col.title,
	              filterable: field && field.filterable && agg.schema.group === 'buckets'
	            };

	            var last = i === table.columns.length - 1;

	            if (last || agg.schema.group === 'metrics') {
	              formattedColumn['class'] = 'visualize-table-right';
	            }

	            return formattedColumn;
	          });
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 961 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(214);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);

	  /**
	   * Angular can't render directives that render themselves recursively:
	   * http://stackoverflow.com/a/18609594/296172
	   */

	  __webpack_require__(214).get('kibana').service('compileRecursiveDirective', function ($compile) {
	    return {
	      /**
	       * Manually compiles the element, fixing the recursion loop.
	       * @param element
	       * @param [link] A post-link function, or an object with function(s) registered via pre and post properties.
	       * @returns An object containing the linking functions.
	       */
	      compile: function compile(element, link) {
	        // Normalize the link parameter
	        if (_.isFunction(link)) {
	          link = {
	            post: link
	          };
	        }

	        // Break the recursion loop by removing the contents
	        var contents = element.contents().remove();
	        var compiledContents;
	        return {
	          pre: link && link.pre ? link.pre : null,
	          /**
	           * Compiles and re-adds the contents
	           */
	          post: function post(scope, element) {
	            // Compile the contents
	            if (!compiledContents) {
	              compiledContents = $compile(contents);
	            }
	            // Re-add the compiled contents to the element
	            compiledContents(scope, function (clone) {
	              element.append(clone);
	            });

	            // Call the post-linking function, if any
	            if (link && link.post) {
	              link.post.apply(null, arguments);
	            }
	          }
	        };
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 962 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 963 */
/***/ function(module, exports) {

	module.exports = "<paginated-table\n  ng-if=\"rows.length\"\n  rows=\"rows\"\n  columns=\"formattedColumns\"\n  per-page=\"perPage\">\n\n  <div class=\"agg-table-controls\">\n    <small>Export:</small>&nbsp;&nbsp;\n    <a class=\"small\" ng-click=\"aggTable.exportAsCsv(false)\">\n      Raw <i aria-hidden=\"true\" class=\"fa fa-download\"></i>\n    </a>&nbsp;&nbsp;&nbsp;\n    <a class=\"small\" ng-click=\"aggTable.exportAsCsv(true)\">\n      Formatted <i aria-hidden=\"true\" class=\"fa fa-download\"></i>\n    </a>\n    <paginate-controls></paginate-controls>\n  </div>\n</paginated-table>\n"

/***/ },
/* 964 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(961);
	__webpack_require__(960);
	__webpack_require__(214);
	__webpack_require__(965);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  __webpack_require__(961);
	  __webpack_require__(960);

	  __webpack_require__(214).get('kibana').directive('kbnAggTableGroup', function (compileRecursiveDirective) {
	    return {
	      restrict: 'E',
	      template: __webpack_require__(965),
	      scope: {
	        group: '=',
	        perPage: '=?'
	      },
	      compile: function compile($el) {
	        // Use the compile function from the RecursionHelper,
	        // And return the linking function(s) which it returns
	        return compileRecursiveDirective.compile($el, {
	          post: function post($scope) {
	            $scope.$watch('group', function (group) {
	              // clear the previous "state"
	              $scope.rows = $scope.columns = false;

	              if (!group || !group.tables.length) return;

	              var firstTable = group.tables[0];
	              var params = firstTable.aggConfig && firstTable.aggConfig.params;
	              // render groups that have Table children as if they were rows, because itteration is cleaner
	              var childLayout = params && !params.row ? 'columns' : 'rows';

	              $scope[childLayout] = group.tables;
	            });
	          }
	        });
	      }
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 965 */
/***/ function(module, exports) {

	module.exports = "<table ng-if=\"rows\" class=\"table agg-table-group\">\n  <thead ng-repeat-start=\"table in rows\">\n    <tr>\n      <th ng-if=\"table.tables\">\n        <span class=\"agg-table-group-header\">{{ table.title }}</span>\n      </th>\n    </tr>\n  </thead>\n  <tbody ng-repeat-end>\n    <tr>\n      <td>\n        <kbn-agg-table-group ng-if=\"table.tables\" group=\"table\" per-page=\"perPage\"></kbn-agg-table-group>\n        <kbn-agg-table ng-if=\"table.rows\" table=\"table\" per-page=\"perPage\"></kbn-agg-table>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<table ng-if=\"columns\" class=\"table agg-table-group\">\n  <thead>\n    <tr>\n      <th ng-repeat=\"table in columns\" ng-if=\"table.tables\">\n        <span class=\"agg-table-group-header\">{{ table.title }}</span>\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td ng-repeat=\"table in columns\">\n        <kbn-agg-table-group ng-if=\"table.tables\" group=\"table\" per-page=\"perPage\"></kbn-agg-table-group>\n        <kbn-agg-table ng-if=\"table.rows\" table=\"table\" per-page=\"perPage\"></kbn-agg-table>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"

/***/ },
/* 966 */
/***/ function(module, exports) {

	module.exports = "<div ng-controller=\"KbnTableVisController\" class=\"table-vis\">\n  <div ng-if=\"!hasSomeRows && hasSomeRows !== null\" class=\"table-vis-error\">\n    <h2 aria-hidden=\"true\"><i aria-hidden=\"true\" class=\"fa fa-meh-o\"></i></h2>\n    <h4>No results found</h4>\n  </div>\n\n  <div ng-if=\"tableGroups\" class=\"table-vis-container\">\n    <kbn-agg-table-group group=\"tableGroups\" per-page=\"vis.params.perPage\"></kbn-agg-table-group>\n  </div>\n</div>"

/***/ },
/* 967 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(795);
	__webpack_require__(907);
	__webpack_require__(960);
	__webpack_require__(968);
	__webpack_require__(476);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  function VisSpyTableProvider(Notifier, $filter, $rootScope, config, Private) {
	    var _ = __webpack_require__(192);
	    var saveAs = __webpack_require__(795).saveAs;
	    var tabifyAggResponse = Private(__webpack_require__(907));

	    var PER_PAGE_DEFAULT = 10;

	    __webpack_require__(960);

	    return {
	      name: 'table',
	      display: 'Table',
	      order: 1,
	      template: __webpack_require__(968),
	      link: function tableLinkFn($scope, $el) {
	        $rootScope.$watchMulti.call($scope, ['vis', 'esResp'], function () {
	          if (!$scope.vis || !$scope.esResp) {
	            $scope.table = null;
	          } else {
	            if (!$scope.editableVis.params.spyPerPage) {
	              $scope.editableVis.params.spyPerPage = PER_PAGE_DEFAULT;
	            }

	            $scope.table = tabifyAggResponse($scope.vis, $scope.esResp, {
	              canSplit: false,
	              asAggConfigResults: true,
	              partialRows: true
	            });
	          }
	        });
	      }
	    };
	  }

	  __webpack_require__(476).register(VisSpyTableProvider);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 968 */
/***/ function(module, exports) {

	module.exports = "<kbn-agg-table table=\"table\" per-page=\"editableVis.params.spyPerPage\"></kbn-agg-table>\n"

/***/ },
/* 969 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*** auto-preload-rjscommon-deps-loader ***/
	__webpack_require__(192);
	__webpack_require__(970);
	__webpack_require__(476);

	'use strict';

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	  var _ = __webpack_require__(192);
	  var reqRespStatsHTML = __webpack_require__(970);

	  var linkReqRespStats = function linkReqRespStats($scope, config) {
	    $scope.$bind('req', 'searchSource.history[searchSource.history.length - 1]');
	    $scope.$watchMulti(['req', 'req.started', 'req.stopped', 'searchSource'], function () {
	      if (!$scope.searchSource || !$scope.req) return;

	      var req = $scope.req;
	      var resp = $scope.req.resp;
	      var stats = $scope.stats = [];

	      if (resp && resp.took != null) stats.push(['Query Duration', resp.took + 'ms']);
	      if (req && req.ms != null) stats.push(['Request Duration', req.ms + 'ms']);
	      if (resp && resp.hits) stats.push(['Hits', resp.hits.total]);

	      if (req.fetchParams.index) stats.push(['Index', req.fetchParams.index]);
	      if (req.fetchParams.type) stats.push(['Type', req.fetchParams.type]);
	      if (req.fetchParams.id) stats.push(['Id', req.fetchParams.id]);
	    });
	  };

	  __webpack_require__(476).register(function () {
	    return {
	      name: 'request',
	      display: 'Request',
	      order: 2,
	      template: reqRespStatsHTML,
	      link: linkReqRespStats
	    };
	  }).register(function () {
	    return {
	      name: 'response',
	      display: 'Response',
	      order: 3,
	      template: reqRespStatsHTML,
	      link: linkReqRespStats
	    };
	  }).register(function () {
	    return {
	      name: 'stats',
	      display: 'Statistics',
	      order: 4,
	      template: reqRespStatsHTML,
	      link: linkReqRespStats
	    };
	  });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 970 */
/***/ function(module, exports) {

	module.exports = "<div ng-if=\"!req.stopped\" class=\"visualize-spy-loading\">\n  <div class=\"visualize-spy-loading-text\">\n    Request in progress\n    &nbsp;\n    <div class=\"spinner\"></div>\n  </div>\n</div>\n\n<div ng-if=\"req.stopped && req.success === false\" ng-init=\"console.log(req)\" class=\"alert alert-danger\">\n  <i class=\"fa fa-danger\"></i> Request Failed\n</div>\n\n<div ng-show=\"spy.mode.name === 'request'\">\n  <label>\n    Elasticsearch request body &nbsp;\n  </label>\n  <pre>{{req.fetchParams.body | json}}</pre>\n</div>\n\n<div ng-show=\"spy.mode.name === 'response'\">\n  <label>\n    Elasticsearch response body &nbsp;\n  </label>\n  <pre>{{req.resp | json}}</pre>\n</div>\n\n<div ng-show=\"spy.mode.name === 'stats'\">\n  <table class=\"table\">\n    <tr ng-repeat=\"pair in stats\">\n      <td>{{pair[0]}}</td>\n      <td>{{pair[1]}}</td>\n    </tr>\n  </table>\n</div>"

/***/ }
]);